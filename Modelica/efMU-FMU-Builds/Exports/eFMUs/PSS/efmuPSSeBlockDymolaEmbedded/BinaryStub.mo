within efmuPSSeBlockDymolaEmbedded;
block BinaryStub
  "Stub for eFMU-based co-simulation of
       [efmiPSSusecase.Components.PSSTypeIImod4efmi]
     using the static linked libraries suited for Dymola's current simulation
     platform generated for the Production Code containers
       [PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed]
       [PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c]
     as configured by eFMU generation configuration
       [efmiPSSusecase.eBlockDymolaEmbedded]
     Generated by Dymola on 2025-10-27T17:06:19Z."

  import __TuningConfiguration = efmuPSSeBlockDymolaEmbedded.TuningConfiguration;
  import __TuningBus = efmuPSSeBlockDymolaEmbedded.TuningBus;
  import __TuningBusSampler = efmuPSSeBlockDymolaEmbedded.TuningBusSampler;
  import __ProductionCodes = efmuPSSeBlockDymolaEmbedded.ProductionCodes;

  extends .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStub(
    final __sampling_period = 0.001,
    redeclare final __SampledInterface __sampled);

  /*
      Stub-interface:
    */

  // Inputs:
  input .Modelica.Blocks.Interfaces.RealInput vSI
    "PSS input signal "
    annotation (Placement(transformation(extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},{-100,20}})));

  // Outputs:
  output .Modelica.Blocks.Interfaces.RealOutput vs
    "PSS output signal"
    annotation (Placement(transformation(extent={{100,-10},{120,10}})));

  // Tuneable parameters:
  parameter Real Kw = 9.5
    "Stabilizer gain [pu/pu]";
  parameter .OpenIPSL.Types.Time T1 = 0.154
    "First stabilizer time constant";
  parameter .OpenIPSL.Types.Time T2 = 0.033
    "Second stabilizer time constant";
  parameter .OpenIPSL.Types.Time T3 = 1
    "Third stabilizer time constant";
  parameter .OpenIPSL.Types.Time T4 = 1
    "Fourth stabilizer time constant";
  parameter .OpenIPSL.Types.Time Tw = 1.41
    "Wash-out time constant";
  parameter Real vSI_start = 1.0
    "Default start value for vSI, the PSS input signal.";
  parameter .OpenIPSL.Types.PerUnit vsmax = 0.2
    "Max stabilizer output signal";
  parameter .OpenIPSL.Types.PerUnit vsmin = -0.2
    "Min stabilizer output signal";

  parameter __TuningConfiguration __tuning_configuration
    "Tuning configuration selecting the tuneable parameters to tune/recalibrate
       at runtime (i.e., throughout simulation). Only the selected tuneables are
       taken from the tuning bus; all others are set to the stub's respective
       Modelica parameters.";
  __TuningBus __tuning
    if __enable_tuning
    "Tuning bus providing the runtime values used for recalibration. Values have
       to be provided only for the parameters selected in the tuning
       configuration."
    annotation (Placement(
      iconTransformation(extent={{10,-100},{90,-20}}),
      transformation(extent={{60,-80},{80,-60}})));

  // Supported production codes:
  parameter __ProductionCodes __defining_code =
    __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
    "The production code defining the stub's results,
       i.e., whose results are propagated by the stub.";

  parameter __ProductionCodes[:] __active_codes = {
    __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
    __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c}
    "Set of production codes co-simulated. By default, all production codes
       are co-simulated. The '__defining_code' is always active, even if not
       explicitly listed in the set.";

  // Co-simulation results of each production code:
  __CosimulationResults[__ProductionCodes] __cosimulation_results
    "Vector capturing the results of all co-simulated production codes.";

protected
  /*
      Internal support facilities: 
    */

  __TuningBusSampler __tuning_sampler
    if __embedd_clock
    "Sampler used to sample all tuning bus signals in case of
       '__embedd_clock = true'.";
  __TuningBusDecoder __tuning_decoder
    "Decoder providing the sampled tuning signals of the tuning bus as
       individual output connections.";
  __TuningBusSource __tuning_mockup(
    final tuning(
      final Kw = Kw,
      final T1 = T1,
      final T2 = T2,
      final T3 = T3,
      final T4 = T4,
      final Tw = Tw,
      final vSI_start = vSI_start,
      final vsmax = vsmax,
      final vsmin = vsmin))
    if not
          (__enable_tuning)
    "Mockup tuning bus used as tuning signals source if tuning is disabled.
       It just provides the given parameterization as bus signals.";
  __Tuning __active_tuning
    "Support record holding the active calibration, i.e., the calibration
       the eFMU uses so far. Used to compare it with the currently -- by
       modifications or the tuning bus -- desired values for updating
       '__recalibrate'.";

  parameter Boolean[__ProductionCodes] __active_codes_map = {
    __defining_code == __ProductionCodes.Mockup
      or 0 < .Modelica.Math.Vectors.find(
        Integer(__ProductionCodes.Mockup),
        Integer(__active_codes)),
    __defining_code == __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      or 0 < .Modelica.Math.Vectors.find(
        Integer(__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed),
        Integer(__active_codes)),
    __defining_code == __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
      or 0 < .Modelica.Math.Vectors.find(
        Integer(__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c),
        Integer(__active_codes))}
    "Internal precomputed cache mapping production codes to their
       activation-status."
    annotation(Evaluate = true);

  /*
    Internal bindings for production code
        PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed:
    */

  class __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
    extends ExternalObject;

    function constructor
      output __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
      external "C" block_state = mei_Startup_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed()
        annotation(
          LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
    end constructor;

    function destructor
      input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
      external "C" mei_Terminate_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(block_state)
        annotation(
          LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
    end destructor;
  end __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

  function __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
    input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
    input Real Kw
      "Stabilizer gain [pu/pu]";
    input .OpenIPSL.Types.Time T1
      "First stabilizer time constant";
    input .OpenIPSL.Types.Time T2
      "Second stabilizer time constant";
    input .OpenIPSL.Types.Time T3
      "Third stabilizer time constant";
    input .OpenIPSL.Types.Time T4
      "Fourth stabilizer time constant";
    input .OpenIPSL.Types.Time Tw
      "Wash-out time constant";
    input Real vSI_start
      "Default start value for vSI, the PSS input signal.";
    input .OpenIPSL.Types.PerUnit vsmax
      "Max stabilizer output signal";
    input .OpenIPSL.Types.PerUnit vsmin
      "Min stabilizer output signal";
    output Integer error_signals;
    external "C" error_signals =
      mei_Recalibrate_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
        block_state,
        Kw,
        T1,
        T2,
        T3,
        T4,
        Tw,
        vSI_start,
        vsmax,
        vsmin);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
  end __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

  function __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
    input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
    input Real vSI
      "PSS input signal ";
    output Integer error_signals;
    output Real vs
      "PSS output signal";
    external "C" error_signals =
      mei_Reinitialize_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
        block_state,
        vSI,
        vs);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
  end __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

  function __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
    input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
    input Real vSI
      "PSS input signal ";
    output Integer error_signals;
    output Real vs
      "PSS output signal";
    external "C" error_signals =
      mei_DoStep_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
        block_state,
        vSI,
        vs);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
  end __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

  __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed =
    __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed();

  /*
    Internal bindings for production code
        PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c:
    */

  class __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
    extends ExternalObject;

    function constructor
      output __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
      external "C" block_state = mei_Startup_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c()
        annotation(
          LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
    end constructor;

    function destructor
      input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
      external "C" mei_Terminate_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(block_state)
        annotation(
          LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
    end destructor;
  end __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

  function __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
    input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
    input Real Kw
      "Stabilizer gain [pu/pu]";
    input .OpenIPSL.Types.Time T1
      "First stabilizer time constant";
    input .OpenIPSL.Types.Time T2
      "Second stabilizer time constant";
    input .OpenIPSL.Types.Time T3
      "Third stabilizer time constant";
    input .OpenIPSL.Types.Time T4
      "Fourth stabilizer time constant";
    input .OpenIPSL.Types.Time Tw
      "Wash-out time constant";
    input Real vSI_start
      "Default start value for vSI, the PSS input signal.";
    input .OpenIPSL.Types.PerUnit vsmax
      "Max stabilizer output signal";
    input .OpenIPSL.Types.PerUnit vsmin
      "Min stabilizer output signal";
    output Integer error_signals;
    external "C" error_signals =
      mei_Recalibrate_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
        block_state,
        Kw,
        T1,
        T2,
        T3,
        T4,
        Tw,
        vSI_start,
        vsmax,
        vsmin);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
  end __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

  function __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
    input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
    input Real vSI
      "PSS input signal ";
    output Integer error_signals;
    output Real vs
      "PSS output signal";
    external "C" error_signals =
      mei_Reinitialize_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
        block_state,
        vSI,
        vs);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
  end __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

  function __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
    input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
    input Real vSI
      "PSS input signal ";
    output Integer error_signals;
    output Real vs
      "PSS output signal";
    external "C" error_signals =
      mei_DoStep_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
        block_state,
        vSI,
        vs);
      annotation(
        LibraryDirectory="modelica://efmuPSSeBlockDymolaEmbedded/",
        Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
  end __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

  __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c =
    __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c();

equation
  /*
      Incorporate the sampling:
    */

  if __embedd_clock then
    // =============> Workaround Dymola bug start =============>
    connect(__clock, __embedded_clock);
    // <============= Workaround  Dymola  bug end <=============
    // In- and outputs:
    __sampled.vSI = sample(vSI, __clock);
    vs = hold(__sampled.vs);
    // Tuneables:
    if __enable_tuning then
      connect(__tuning, __tuning_sampler.ingoing);
    else
      connect(__tuning_mockup.bus, __tuning_sampler.ingoing);
    end if;
    connect(__tuning_sampler.outgoing, __tuning_decoder.__bus);
  else
    // In- and outputs:
    __sampled.vSI = vSI;
    vs = __sampled.vs;
    // Tuneables:
    if __enable_tuning then
      connect(__tuning, __tuning_decoder.__bus);
    else
      connect(__tuning_mockup.bus, __tuning_decoder.__bus);
    end if;
  end if;

  /*
      Select the tuneables either from the bus or parametrization,
      depending on their tuning configuration:
    */

  __sampled.__tuning.Kw =
    (if __tuning_configuration.Kw
     then __tuning_decoder.Kw
     else Kw);
  __sampled.__tuning.T1 =
    (if __tuning_configuration.T1
     then __tuning_decoder.T1
     else T1);
  __sampled.__tuning.T2 =
    (if __tuning_configuration.T2
     then __tuning_decoder.T2
     else T2);
  __sampled.__tuning.T3 =
    (if __tuning_configuration.T3
     then __tuning_decoder.T3
     else T3);
  __sampled.__tuning.T4 =
    (if __tuning_configuration.T4
     then __tuning_decoder.T4
     else T4);
  __sampled.__tuning.Tw =
    (if __tuning_configuration.Tw
     then __tuning_decoder.Tw
     else Tw);
  __sampled.__tuning.vSI_start =
    (if __tuning_configuration.vSI_start
     then __tuning_decoder.vSI_start
     else vSI_start);
  __sampled.__tuning.vsmax =
    (if __tuning_configuration.vsmax
     then __tuning_decoder.vsmax
     else vsmax);
  __sampled.__tuning.vsmin =
    (if __tuning_configuration.vsmin
     then __tuning_decoder.vsmin
     else vsmin);

algorithm
  when Clock() then
    /*
        Update tuning:
      */

    if not
          (__is_initialized) then
      // Initialize the active calibration with the eFMU's default calibration:
      __active_tuning.Kw := 9.5;
      __active_tuning.T1 := 0.154;
      __active_tuning.T2 := 0.033;
      __active_tuning.T3 := 1;
      __active_tuning.T4 := 1;
      __active_tuning.Tw := 1.41;
      __active_tuning.vSI_start := 1.0;
      __active_tuning.vsmax := 0.2;
      __active_tuning.vsmin := -0.2;
    end if;

    __sampled.__recalibrate := false
      or max(abs(
          __sampled.__tuning.Kw
        - __active_tuning.Kw)) > 0.0
      or max(abs(
          __sampled.__tuning.T1
        - __active_tuning.T1)) > 0.0
      or max(abs(
          __sampled.__tuning.T2
        - __active_tuning.T2)) > 0.0
      or max(abs(
          __sampled.__tuning.T3
        - __active_tuning.T3)) > 0.0
      or max(abs(
          __sampled.__tuning.T4
        - __active_tuning.T4)) > 0.0
      or max(abs(
          __sampled.__tuning.Tw
        - __active_tuning.Tw)) > 0.0
      or max(abs(
          __sampled.__tuning.vSI_start
        - __active_tuning.vSI_start)) > 0.0
      or max(abs(
          __sampled.__tuning.vsmax
        - __active_tuning.vsmax)) > 0.0
      or max(abs(
          __sampled.__tuning.vsmin
        - __active_tuning.vsmin)) > 0.0;

    if __sampled.__recalibrate then
      __active_tuning := __sampled.__tuning;
    end if;

    /*
        Cosimulate the active binaries:
      */

    __cosimulation_results[__ProductionCodes.Mockup] :=
      previous(__cosimulation_results[__ProductionCodes.Mockup]);
    __cosimulation_results[__ProductionCodes.Mockup].__production_code :=
      __ProductionCodes.Mockup;
    __cosimulation_results[__ProductionCodes.Mockup].__is_active :=
      __active_codes_map[__ProductionCodes.Mockup];
    __cosimulation_results[__ProductionCodes.Mockup].__error_signals_Recalibrate := 1;
    __cosimulation_results[__ProductionCodes.Mockup].__error_signals_Reinitialize := 1;
    __cosimulation_results[__ProductionCodes.Mockup].__error_signals_DoStep := 1;

    __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__production_code :=
      __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;
    __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__is_active :=
      __active_codes_map[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed];
    if __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__is_active then
      __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Recalibrate := 0;
      if __sampled.__recalibrate then
        __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Recalibrate :=
          __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
            __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
            __sampled.__tuning.Kw,
            __sampled.__tuning.T1,
            __sampled.__tuning.T2,
            __sampled.__tuning.T3,
            __sampled.__tuning.T4,
            __sampled.__tuning.Tw,
            __sampled.__tuning.vSI_start,
            __sampled.__tuning.vsmax,
            __sampled.__tuning.vsmin);
      end if;
      __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Reinitialize := 0;
      if __sampled.__reinitialize or not
                                        (__is_initialized) then
        ( __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Reinitialize,
          __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].vs)
          := __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
          __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
          __sampled.vSI);
      end if;
      ( __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_DoStep,
        __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].vs)
        := __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
        __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
        __sampled.vSI);
    end if;

    __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__production_code :=
      __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;
    __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__is_active :=
      __active_codes_map[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c];
    if __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__is_active then
      __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Recalibrate := 0;
      if __sampled.__recalibrate then
        __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Recalibrate :=
          __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
            __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
            __sampled.__tuning.Kw,
            __sampled.__tuning.T1,
            __sampled.__tuning.T2,
            __sampled.__tuning.T3,
            __sampled.__tuning.T4,
            __sampled.__tuning.Tw,
            __sampled.__tuning.vSI_start,
            __sampled.__tuning.vsmax,
            __sampled.__tuning.vsmin);
      end if;
      __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Reinitialize := 0;
      if __sampled.__reinitialize or not
                                        (__is_initialized) then
        ( __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Reinitialize,
          __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].vs)
          := __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
          __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
          __sampled.vSI);
      end if;
      ( __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_DoStep,
        __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].vs)
        := __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
        __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
        __sampled.vSI);
    end if;

    /*
        Stub-modification and input dependent initialization of all
        eFMU production codes certainly finished:
      */

    __is_initialized := true;

    /*
        Propagate the results of the defining production code:
      */

    __sampled.__error_signals_Recalibrate :=
      __cosimulation_results[__defining_code].__error_signals_Recalibrate;
    __sampled.__error_signals_Reinitialize :=
      __cosimulation_results[__defining_code].__error_signals_Reinitialize;
    __sampled.__error_signals_DoStep :=
      __cosimulation_results[__defining_code].__error_signals_DoStep;
    __sampled.vs :=
      __cosimulation_results[__defining_code].vs;
  end when;

  /*
      Preconfigure FMU export:
    */

  annotation (
    preferredView = "info",
    experiment(
      __Dymola_fixedstepsize = 0.001,
      __Dymola_Algorithm = "Euler"),
    __Dymola_experimentFlags(
      Advanced(
        InlineMethod = 1,
        InlineOrder = 2,
        InlineFixedStep = 0.001)));
end BinaryStub;
