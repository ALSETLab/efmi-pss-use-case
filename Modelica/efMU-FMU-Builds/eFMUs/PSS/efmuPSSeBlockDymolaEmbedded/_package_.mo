package 'efmuPSS.eFMU_SiL_Support'
  "Package supporting software in the loop (SiL) simulation of the production
   codes of the eFMU generated for the eFMU generation configuration
     [efmiPSSusecase.eBlockDymolaEmbedded]
   Generated by Dymola on 2025-10-27T17:06:19Z."

  extends .DymolaEmbedded.Icons.BinaryCodeContainer;

  block BinaryStub
    "Stub for eFMU-based co-simulation of
       [efmiPSSusecase.Components.PSSTypeIImod4efmi]
     using the static linked libraries suited for Dymola's current simulation
     platform generated for the Production Code containers
       [PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed]
       [PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c]
     as configured by eFMU generation configuration
       [efmiPSSusecase.eBlockDymolaEmbedded]
     Generated by Dymola on 2025-10-27T17:06:19Z."

    import __TuningConfiguration = 'efmuPSS.eFMU_SiL_Support'.TuningConfiguration;
    import __TuningBus = 'efmuPSS.eFMU_SiL_Support'.TuningBus;
    import __TuningBusSampler = 'efmuPSS.eFMU_SiL_Support'.TuningBusSampler;
    import __ProductionCodes = 'efmuPSS.eFMU_SiL_Support'.ProductionCodes;

    extends .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStub(
      final __sampling_period = 0.001,
      redeclare final __SampledInterface __sampled);

    /*
      Stub-interface:
    */

    // Inputs:
    input .Modelica.Blocks.Interfaces.RealInput vSI
      "PSS input signal "
      annotation (Placement(transformation(extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},{-100,20}})));

    // Outputs:
    output .Modelica.Blocks.Interfaces.RealOutput vs
      "PSS output signal"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));

    // Tuneable parameters:
    parameter Real Kw = 9.5
      "Stabilizer gain [pu/pu]";
    parameter .OpenIPSL.Types.Time T1 = 0.154
      "First stabilizer time constant";
    parameter .OpenIPSL.Types.Time T2 = 0.033
      "Second stabilizer time constant";
    parameter .OpenIPSL.Types.Time T3 = 1
      "Third stabilizer time constant";
    parameter .OpenIPSL.Types.Time T4 = 1
      "Fourth stabilizer time constant";
    parameter .OpenIPSL.Types.Time Tw = 1.41
      "Wash-out time constant";
    parameter Real vSI_start = 1.0
      "Default start value for vSI, the PSS input signal.";
    parameter .OpenIPSL.Types.PerUnit vsmax = 0.2
      "Max stabilizer output signal";
    parameter .OpenIPSL.Types.PerUnit vsmin = -0.2
      "Min stabilizer output signal";

    parameter __TuningConfiguration __tuning_configuration
      "Tuning configuration selecting the tuneable parameters to tune/recalibrate
       at runtime (i.e., throughout simulation). Only the selected tuneables are
       taken from the tuning bus; all others are set to the stub's respective
       Modelica parameters.";
    __TuningBus __tuning
      if __enable_tuning
      "Tuning bus providing the runtime values used for recalibration. Values have
       to be provided only for the parameters selected in the tuning
       configuration."
      annotation (Placement(
        iconTransformation(extent={{10,-100},{90,-20}}),
        transformation(extent={{60,-80},{80,-60}})));

    // Supported production codes:
    parameter __ProductionCodes __defining_code =
      __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      "The production code defining the stub's results,
       i.e., whose results are propagated by the stub.";

    parameter __ProductionCodes[:] __active_codes = {
      __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
      __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c}
      "Set of production codes co-simulated. By default, all production codes
       are co-simulated. The '__defining_code' is always active, even if not
       explicitly listed in the set.";

    // Co-simulation results of each production code:
    __CosimulationResults[__ProductionCodes] __cosimulation_results
      "Vector capturing the results of all co-simulated production codes.";

  protected
    /*
      Internal support facilities: 
    */

    __TuningBusSampler __tuning_sampler
      if __embedd_clock
      "Sampler used to sample all tuning bus signals in case of
       '__embedd_clock = true'.";
    __TuningBusDecoder __tuning_decoder
      "Decoder providing the sampled tuning signals of the tuning bus as
       individual output connections.";
    __TuningBusSource __tuning_mockup(
      final tuning(
        final Kw = Kw,
        final T1 = T1,
        final T2 = T2,
        final T3 = T3,
        final T4 = T4,
        final Tw = Tw,
        final vSI_start = vSI_start,
        final vsmax = vsmax,
        final vsmin = vsmin))
      if not
            (__enable_tuning)
      "Mockup tuning bus used as tuning signals source if tuning is disabled.
       It just provides the given parameterization as bus signals.";
    __Tuning __active_tuning
      "Support record holding the active calibration, i.e., the calibration
       the eFMU uses so far. Used to compare it with the currently -- by
       modifications or the tuning bus -- desired values for updating
       '__recalibrate'.";

    parameter Boolean[__ProductionCodes] __active_codes_map = {
      __defining_code == __ProductionCodes.Mockup
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes.Mockup),
          Integer(__active_codes)),
      __defining_code == __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed),
          Integer(__active_codes)),
      __defining_code == __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c),
          Integer(__active_codes))}
      "Internal precomputed cache mapping production codes to their
       activation-status."
      annotation(Evaluate = true);

    /*
    Internal bindings for production code
        PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed:
    */

    class __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      extends ExternalObject;

      function constructor
        output __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
        external "C" block_state = mei_Startup_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed()
          annotation(
            LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
            Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
      end constructor;

      function destructor
        input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
        external "C" mei_Terminate_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(block_state)
          annotation(
            LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
            Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
      end destructor;
    end __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

    function __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
      input Real Kw
        "Stabilizer gain [pu/pu]";
      input .OpenIPSL.Types.Time T1
        "First stabilizer time constant";
      input .OpenIPSL.Types.Time T2
        "Second stabilizer time constant";
      input .OpenIPSL.Types.Time T3
        "Third stabilizer time constant";
      input .OpenIPSL.Types.Time T4
        "Fourth stabilizer time constant";
      input .OpenIPSL.Types.Time Tw
        "Wash-out time constant";
      input Real vSI_start
        "Default start value for vSI, the PSS input signal.";
      input .OpenIPSL.Types.PerUnit vsmax
        "Max stabilizer output signal";
      input .OpenIPSL.Types.PerUnit vsmin
        "Min stabilizer output signal";
      output Integer error_signals;
      external "C" error_signals =
        mei_Recalibrate_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
          block_state,
          Kw,
          T1,
          T2,
          T3,
          T4,
          Tw,
          vSI_start,
          vsmax,
          vsmin);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
    end __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

    function __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_Reinitialize_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
          block_state,
          vSI,
          vs);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
    end __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

    function __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed
      input __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_DoStep_H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
          block_state,
          vSI,
          vs);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_cb4a8a449b4ada864625ee5a4355578a3aaf08ed");
    end __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;

    __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed =
      __BlockState_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed();

    /*
    Internal bindings for production code
        PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c:
    */

    class __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
      extends ExternalObject;

      function constructor
        output __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
        external "C" block_state = mei_Startup_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c()
          annotation(
            LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
            Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
      end constructor;

      function destructor
        input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
        external "C" mei_Terminate_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(block_state)
          annotation(
            LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
            Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
      end destructor;
    end __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

    function __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
      input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
      input Real Kw
        "Stabilizer gain [pu/pu]";
      input .OpenIPSL.Types.Time T1
        "First stabilizer time constant";
      input .OpenIPSL.Types.Time T2
        "Second stabilizer time constant";
      input .OpenIPSL.Types.Time T3
        "Third stabilizer time constant";
      input .OpenIPSL.Types.Time T4
        "Fourth stabilizer time constant";
      input .OpenIPSL.Types.Time Tw
        "Wash-out time constant";
      input Real vSI_start
        "Default start value for vSI, the PSS input signal.";
      input .OpenIPSL.Types.PerUnit vsmax
        "Max stabilizer output signal";
      input .OpenIPSL.Types.PerUnit vsmin
        "Min stabilizer output signal";
      output Integer error_signals;
      external "C" error_signals =
        mei_Recalibrate_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
          block_state,
          Kw,
          T1,
          T2,
          T3,
          T4,
          Tw,
          vSI_start,
          vsmax,
          vsmin);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
    end __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

    function __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
      input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_Reinitialize_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
          block_state,
          vSI,
          vs);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
    end __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

    function __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c
      input __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_DoStep_H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
          block_state,
          vSI,
          vs);
        annotation(
          LibraryDirectory = "modelica://'efmuPSS.eFMU_SiL_Support'/",
          Library = "H525b873079cf7a65f464c408f25344d5bd630cab_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c");
    end __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;

    __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c =
      __BlockState_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c();

  equation
    /*
      Incorporate the sampling:
    */

    if __embedd_clock then
      // =============> Workaround Dymola bug start =============>
      connect(__clock, __embedded_clock);
      // <============= Workaround  Dymola  bug end <=============
      // In- and outputs:
      __sampled.vSI = sample(vSI, __clock);
      vs = hold(__sampled.vs);
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_sampler.ingoing);
      else
        connect(__tuning_mockup.bus, __tuning_sampler.ingoing);
      end if;
      connect(__tuning_sampler.outgoing, __tuning_decoder.__bus);
    else
      // In- and outputs:
      __sampled.vSI = vSI;
      vs = __sampled.vs;
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_decoder.__bus);
      else
        connect(__tuning_mockup.bus, __tuning_decoder.__bus);
      end if;
    end if;

    /*
      Select the tuneables either from the bus or parametrization,
      depending on their tuning configuration:
    */

    __sampled.__tuning.Kw =
      (if __tuning_configuration.Kw
       then __tuning_decoder.Kw
       else Kw);
    __sampled.__tuning.T1 =
      (if __tuning_configuration.T1
       then __tuning_decoder.T1
       else T1);
    __sampled.__tuning.T2 =
      (if __tuning_configuration.T2
       then __tuning_decoder.T2
       else T2);
    __sampled.__tuning.T3 =
      (if __tuning_configuration.T3
       then __tuning_decoder.T3
       else T3);
    __sampled.__tuning.T4 =
      (if __tuning_configuration.T4
       then __tuning_decoder.T4
       else T4);
    __sampled.__tuning.Tw =
      (if __tuning_configuration.Tw
       then __tuning_decoder.Tw
       else Tw);
    __sampled.__tuning.vSI_start =
      (if __tuning_configuration.vSI_start
       then __tuning_decoder.vSI_start
       else vSI_start);
    __sampled.__tuning.vsmax =
      (if __tuning_configuration.vsmax
       then __tuning_decoder.vsmax
       else vsmax);
    __sampled.__tuning.vsmin =
      (if __tuning_configuration.vsmin
       then __tuning_decoder.vsmin
       else vsmin);

  algorithm
    when Clock() then
      /*
        Update tuning:
      */

      if not
            (__is_initialized) then
        // Initialize the active calibration with the eFMU's default calibration:
        __active_tuning.Kw := 9.5;
        __active_tuning.T1 := 0.154;
        __active_tuning.T2 := 0.033;
        __active_tuning.T3 := 1;
        __active_tuning.T4 := 1;
        __active_tuning.Tw := 1.41;
        __active_tuning.vSI_start := 1.0;
        __active_tuning.vsmax := 0.2;
        __active_tuning.vsmin := -0.2;
      end if;

      __sampled.__recalibrate := false
        or max(abs(
            __sampled.__tuning.Kw
          - __active_tuning.Kw)) > 0.0
        or max(abs(
            __sampled.__tuning.T1
          - __active_tuning.T1)) > 0.0
        or max(abs(
            __sampled.__tuning.T2
          - __active_tuning.T2)) > 0.0
        or max(abs(
            __sampled.__tuning.T3
          - __active_tuning.T3)) > 0.0
        or max(abs(
            __sampled.__tuning.T4
          - __active_tuning.T4)) > 0.0
        or max(abs(
            __sampled.__tuning.Tw
          - __active_tuning.Tw)) > 0.0
        or max(abs(
            __sampled.__tuning.vSI_start
          - __active_tuning.vSI_start)) > 0.0
        or max(abs(
            __sampled.__tuning.vsmax
          - __active_tuning.vsmax)) > 0.0
        or max(abs(
            __sampled.__tuning.vsmin
          - __active_tuning.vsmin)) > 0.0;

      if __sampled.__recalibrate then
        __active_tuning := __sampled.__tuning;
      end if;

      /*
        Cosimulate the active binaries:
      */

      __cosimulation_results[__ProductionCodes.Mockup] :=
        previous(__cosimulation_results[__ProductionCodes.Mockup]);
      __cosimulation_results[__ProductionCodes.Mockup].__production_code :=
        __ProductionCodes.Mockup;
      __cosimulation_results[__ProductionCodes.Mockup].__is_active :=
        __active_codes_map[__ProductionCodes.Mockup];
      __cosimulation_results[__ProductionCodes.Mockup].__error_signals_Recalibrate := 1;
      __cosimulation_results[__ProductionCodes.Mockup].__error_signals_Reinitialize := 1;
      __cosimulation_results[__ProductionCodes.Mockup].__error_signals_DoStep := 1;

      __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__production_code :=
        __ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed;
      __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__is_active :=
        __active_codes_map[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed];
      if __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__is_active then
        __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Recalibrate := 0;
        if __sampled.__recalibrate then
          __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Recalibrate :=
            __Recalibrate_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
              __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
              __sampled.__tuning.Kw,
              __sampled.__tuning.T1,
              __sampled.__tuning.T2,
              __sampled.__tuning.T3,
              __sampled.__tuning.T4,
              __sampled.__tuning.Tw,
              __sampled.__tuning.vSI_start,
              __sampled.__tuning.vsmax,
              __sampled.__tuning.vsmin);
        end if;
        __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Reinitialize := 0;
        if __sampled.__reinitialize or not
                                          (__is_initialized) then
          ( __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_Reinitialize,
            __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].vs)
            := __Reinitialize_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
            __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
            __sampled.vSI);
        end if;
        ( __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].__error_signals_DoStep,
          __cosimulation_results[__ProductionCodes.PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed].vs)
          := __DoStep_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed(
          __block_state_PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
          __sampled.vSI);
      end if;

      __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__production_code :=
        __ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c;
      __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__is_active :=
        __active_codes_map[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c];
      if __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__is_active then
        __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Recalibrate := 0;
        if __sampled.__recalibrate then
          __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Recalibrate :=
            __Recalibrate_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
              __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
              __sampled.__tuning.Kw,
              __sampled.__tuning.T1,
              __sampled.__tuning.T2,
              __sampled.__tuning.T3,
              __sampled.__tuning.T4,
              __sampled.__tuning.Tw,
              __sampled.__tuning.vSI_start,
              __sampled.__tuning.vsmax,
              __sampled.__tuning.vsmin);
        end if;
        __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Reinitialize := 0;
        if __sampled.__reinitialize or not
                                          (__is_initialized) then
          ( __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_Reinitialize,
            __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].vs)
            := __Reinitialize_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
            __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
            __sampled.vSI);
        end if;
        ( __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].__error_signals_DoStep,
          __cosimulation_results[__ProductionCodes.PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c].vs)
          := __DoStep_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c(
          __block_state_PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c,
          __sampled.vSI);
      end if;

      /*
        Stub-modification and input dependent initialization of all
        eFMU production codes certainly finished:
      */

      __is_initialized := true;

      /*
        Propagate the results of the defining production code:
      */

      __sampled.__error_signals_Recalibrate :=
        __cosimulation_results[__defining_code].__error_signals_Recalibrate;
      __sampled.__error_signals_Reinitialize :=
        __cosimulation_results[__defining_code].__error_signals_Reinitialize;
      __sampled.__error_signals_DoStep :=
        __cosimulation_results[__defining_code].__error_signals_DoStep;
      __sampled.vs :=
        __cosimulation_results[__defining_code].vs;
    end when;

    /*
      Preconfigure FMU export:
    */

    annotation (
      preferredView = "info",
      experiment(
        __Dymola_fixedstepsize = 0.001,
        __Dymola_Algorithm = "Euler"),
      __Dymola_experimentFlags(
        Advanced(
          InlineMethod = 1,
          InlineOrder = 2,
          InlineFixedStep = 0.001)));
  end BinaryStub;

  encapsulated record TuningConfiguration
    "Record type for selecting tuneable parameters to tune/recalibrate at runtime."

    extends .DymolaEmbedded.Icons.TuningBus;
    extends .DymolaEmbedded.Icons.Configuration;

    parameter Boolean Kw = false;
    parameter Boolean T1 = false;
    parameter Boolean T2 = false;
    parameter Boolean T3 = false;
    parameter Boolean T4 = false;
    parameter Boolean Tw = false;
    parameter Boolean vSI_start = false;
    parameter Boolean vsmax = false;
    parameter Boolean vsmin = false;

    annotation(preferredView = "info");
  end TuningConfiguration;

  expandable connector TuningBus
    "Expandable connector type for provisioning runtime values used for
     recalibration."

    extends .DymolaEmbedded.Icons.TuningBus;
    extends __Tuning;

    annotation(preferredView = "info");
  end TuningBus;

  model TuningBusSampler
    "Sampler for sampling a tuning bus with the clock of the clocked-partition
     the outgoing bus is part of."

    extends .DymolaEmbedded.Icons.TuningBusSampler;

    TuningBus ingoing
      annotation (
        Placement(
          transformation(extent={{-140,-50},{-40,50}}),
          iconTransformation(extent={{-140,-50},{-40,50}})));
    TuningBus outgoing
      annotation (
        Placement(
          transformation(extent={{40,-50},{140,50}}),
          iconTransformation(extent={{40,-50},{140,50}})));

  protected
    __TuningBusDecoder decoder;
    __TuningBusEncoder encoder;

  equation
    connect(ingoing, decoder.__bus);

    encoder.Kw = sample(decoder.Kw);
    encoder.T1 = sample(decoder.T1);
    encoder.T2 = sample(decoder.T2);
    encoder.T3 = sample(decoder.T3);
    encoder.T4 = sample(decoder.T4);
    encoder.Tw = sample(decoder.Tw);
    encoder.vSI_start = sample(decoder.vSI_start);
    encoder.vsmax = sample(decoder.vsmax);
    encoder.vsmin = sample(decoder.vsmin);

    connect(encoder.__bus, outgoing);

    annotation (preferredView = "info");
  end TuningBusSampler;

  // Supported production codes:
  encapsulated type ProductionCodes = enumeration(
    Mockup "non-functional mockup",
    PCode_SPE_cb4a8a449b4ada864625ee5a4355578a3aaf08ed,
    PCode_SPE_fba3e0dfa6c8985b41bcbe3594ee941ce98b740c)
    "Production codes the stub provides for co-simulation."
    annotation (
      preferredView = "info",
      Icon(
        graphics={
          Rectangle(
            extent={{-82,-80},{80,80}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={100,187,75},
            fillPattern=FillPattern.Solid,
            radius=10),
          Rectangle(
            extent={{-72,86},{-68,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,86},{-58,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,86},{-48,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,86},{-38,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,86},{-28,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,86},{-18,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,86},{-8,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,86},{2,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,86},{12,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,86},{22,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,86},{32,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,86},{42,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,86},{52,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,86},{62,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,86},{72,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-72,-76},{-68,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,-76},{-58,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,-76},{-48,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,-76},{-38,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,-76},{-28,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,-76},{-18,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,-76},{-8,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,-76},{2,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,-76},{12,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,-76},{22,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,-76},{32,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,-76},{42,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,-76},{52,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,-76},{62,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,-76},{72,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,70},
            rotation=90),
          Rectangle(
            extent={{-20,-18},{20,20}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={130,238,94},
            fillPattern=FillPattern.Solid,
            radius=10),
          Polygon(
            origin = {1.3835,-4.1418},
            rotation = 45.0,
            fillColor = {64,64,64},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
              {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
              {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
              {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
              {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
              {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
              {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
              {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin = {10.1018,5.218},
            rotation = -45.0,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
              {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
              {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
              {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
              {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
              {-20.0,82.273}})}));

  function resolve_code_configuration
    "Retrieve the original Software Production Engineering configuration used
     to build one of the stub's production codes."
    extends .Modelica.Units.Icons.Conversion;

    input ProductionCodes code
      "Production code for which to lookup its build configuration.";

    output .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration configuration
      "Software Production Engineering configuration used to build the respective
       production code.";

  algorithm
    configuration := code_configurations[code];

    annotation (preferredView = "info");
  end resolve_code_configuration;

  function resolve_code_names
    "Get names of all production codes supported by the stub."
    extends .Modelica.Units.Icons.Conversion;

    output String[ProductionCodes] names
      "Production code names.";

  algorithm
    for c in ProductionCodes loop
      names[c] := String(c);
    end for;

    annotation (preferredView = "info");
  end resolve_code_names;

  function resolve_interface
    "Retrieve the eBlock interface of the stub."
    extends .DymolaEmbedded.Icons.SourceCodeAnalysis;

    output .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent[:] interface
      "The stub's eFMI interface.";

  algorithm
    interface := {
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Input,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "Modelica.Blocks.Interfaces.RealInput",
        dimensionality = fill(0, 0),
        component_name = "vSI",
        value = "",
        description = "PSS input signal ",
        placement = "Placement(transformation(extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},{-100,20}}))"),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Output,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "Modelica.Blocks.Interfaces.RealOutput",
        dimensionality = fill(0, 0),
        component_name = "vs",
        value = "",
        description = "PSS output signal",
        placement = "Placement(transformation(extent={{100,-10},{120,10}}))"),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "Real",
        dimensionality = fill(0, 0),
        component_name = "Kw",
        value = "9.5",
        description = "Stabilizer gain [pu/pu]",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.Time",
        dimensionality = fill(0, 0),
        component_name = "T1",
        value = "0.154",
        description = "First stabilizer time constant",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.Time",
        dimensionality = fill(0, 0),
        component_name = "T2",
        value = "0.033",
        description = "Second stabilizer time constant",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.Time",
        dimensionality = fill(0, 0),
        component_name = "T3",
        value = "1",
        description = "Third stabilizer time constant",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.Time",
        dimensionality = fill(0, 0),
        component_name = "T4",
        value = "1",
        description = "Fourth stabilizer time constant",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.Time",
        dimensionality = fill(0, 0),
        component_name = "Tw",
        value = "1.41",
        description = "Wash-out time constant",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "Real",
        dimensionality = fill(0, 0),
        component_name = "vSI_start",
        value = "1.0",
        description = "Default start value for vSI, the PSS input signal.",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.PerUnit",
        dimensionality = fill(0, 0),
        component_name = "vsmax",
        value = "0.2",
        description = "Max stabilizer output signal",
        placement = ""),
      .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent(
        io_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.IOType.Parameter,
        primitive_type = .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent.PrimitiveType.Real,
        type_name = "OpenIPSL.Types.PerUnit",
        dimensionality = fill(0, 0),
        component_name = "vsmin",
        value = "-0.2",
        description = "Min stabilizer output signal",
        placement = "")};

    annotation (preferredView = "info");
  end resolve_interface;

protected
  constant .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration[3] code_configurations = {
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "Non-functional mockup.",
      active = false,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x64),
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "",
      active = true,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x32),
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "",
      active = true,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x64)}
    "Software Production Engineering configurations used to build the stub's
     production codes. Can be indexed by enumeration values of 'ProductionCodes'.";

  record __Tuning
    "Support record type compiling all tuneable parameters, each typed with
     a fitting builtin Modelica type."

    Real Kw
      "Stabilizer gain [pu/pu]";
    .OpenIPSL.Types.Time T1
      "First stabilizer time constant";
    .OpenIPSL.Types.Time T2
      "Second stabilizer time constant";
    .OpenIPSL.Types.Time T3
      "Third stabilizer time constant";
    .OpenIPSL.Types.Time T4
      "Fourth stabilizer time constant";
    .OpenIPSL.Types.Time Tw
      "Wash-out time constant";
    Real vSI_start
      "Default start value for vSI, the PSS input signal.";
    .OpenIPSL.Types.PerUnit vsmax
      "Max stabilizer output signal";
    .OpenIPSL.Types.PerUnit vsmin
      "Min stabilizer output signal";
  end __Tuning;

  class __TuningConnectors
    "Connector types for each tuneable parameter (required by tuning bus en- and
     decoders to provide respective in- and output connectors)."

    connector Kw =
      .Real;
    connector T1 =
      .OpenIPSL.Types.Time;
    connector T2 =
      .OpenIPSL.Types.Time;
    connector T3 =
      .OpenIPSL.Types.Time;
    connector T4 =
      .OpenIPSL.Types.Time;
    connector Tw =
      .OpenIPSL.Types.Time;
    connector vSI_start =
      .Real;
    connector vsmax =
      .OpenIPSL.Types.PerUnit;
    connector vsmin =
      .OpenIPSL.Types.PerUnit;
  end __TuningConnectors;

  block __TuningBusSource
    "Tuning source providing a given, fixed parameterization as bus signals."

    parameter __Tuning tuning;
    TuningBus bus;

  protected
    __TuningBusEncoder encoder;
    Source source(__tuning = tuning);

    block Source
      parameter __Tuning __tuning;
      output __TuningConnectors.Kw Kw;
      output __TuningConnectors.T1 T1;
      output __TuningConnectors.T2 T2;
      output __TuningConnectors.T3 T3;
      output __TuningConnectors.T4 T4;
      output __TuningConnectors.Tw Tw;
      output __TuningConnectors.vSI_start vSI_start;
      output __TuningConnectors.vsmax vsmax;
      output __TuningConnectors.vsmin vsmin;
    equation
      Kw = __tuning.Kw;
      T1 = __tuning.T1;
      T2 = __tuning.T2;
      T3 = __tuning.T3;
      T4 = __tuning.T4;
      Tw = __tuning.Tw;
      vSI_start = __tuning.vSI_start;
      vsmax = __tuning.vsmax;
      vsmin = __tuning.vsmin;
    end Source;

  equation
    connect(source.Kw, encoder.Kw);
    connect(source.T1, encoder.T1);
    connect(source.T2, encoder.T2);
    connect(source.T3, encoder.T3);
    connect(source.T4, encoder.T4);
    connect(source.Tw, encoder.Tw);
    connect(source.vSI_start, encoder.vSI_start);
    connect(source.vsmax, encoder.vsmax);
    connect(source.vsmin, encoder.vsmin);
    connect(encoder.__bus, bus);
  end __TuningBusSource;

  model __TuningBusDecoder
    "Decoder providing each tuning signal of a tuning bus as individually
     connectable output."

    import __TuningBus = 'efmuPSS.eFMU_SiL_Support'.TuningBus;

    __TuningBus __bus;

    output __TuningConnectors.Kw Kw;
    output __TuningConnectors.T1 T1;
    output __TuningConnectors.T2 T2;
    output __TuningConnectors.T3 T3;
    output __TuningConnectors.T4 T4;
    output __TuningConnectors.Tw Tw;
    output __TuningConnectors.vSI_start vSI_start;
    output __TuningConnectors.vsmax vsmax;
    output __TuningConnectors.vsmin vsmin;

  equation
    connect(__bus.Kw, Kw);
    connect(__bus.T1, T1);
    connect(__bus.T2, T2);
    connect(__bus.T3, T3);
    connect(__bus.T4, T4);
    connect(__bus.Tw, Tw);
    connect(__bus.vSI_start, vSI_start);
    connect(__bus.vsmax, vsmax);
    connect(__bus.vsmin, vsmin);
  end __TuningBusDecoder;

  model __TuningBusEncoder
    "Encoder setting each tuning signal of a tuning bus via an individually
     connectable input."

    import __TuningBus = 'efmuPSS.eFMU_SiL_Support'.TuningBus;

    input __TuningConnectors.Kw Kw;
    input __TuningConnectors.T1 T1;
    input __TuningConnectors.T2 T2;
    input __TuningConnectors.T3 T3;
    input __TuningConnectors.T4 T4;
    input __TuningConnectors.Tw Tw;
    input __TuningConnectors.vSI_start vSI_start;
    input __TuningConnectors.vsmax vsmax;
    input __TuningConnectors.vsmin vsmin;

    __TuningBus __bus;

  equation
    connect(Kw, __bus.Kw);
    connect(T1, __bus.T1);
    connect(T2, __bus.T2);
    connect(T3, __bus.T3);
    connect(T4, __bus.T4);
    connect(Tw, __bus.Tw);
    connect(vSI_start, __bus.vSI_start);
    connect(vsmax, __bus.vsmax);
    connect(vsmin, __bus.vsmin);
  end __TuningBusEncoder;

  record __SampledInterface
    "Refined, actual eFMU communication interface as defined and required by the
     eFMU used for co-simulation."

    extends .DymolaEmbedded.BuildUtilities.BinaryCode.DefaultSampledInterface;

    // Inputs:
    Real vSI
      "PSS input signal ";

    // Outputs:
    Real vs
      "PSS output signal";

    // Tuneable parameters:
    __Tuning __tuning;
  end __SampledInterface;

  record __CosimulationResults
    "Record compiling the results of a single co-simulated production code."

    import __ProductionCodes = 'efmuPSS.eFMU_SiL_Support'.ProductionCodes;

    // Cosimulation status:
    __ProductionCodes __production_code
      "The production code this are the results of.";
    Boolean __is_active
      "Whether the production code has been co-simulated or not.";
    Integer __error_signals_Recalibrate
      "Errors signaled by the last execution of the 'Recalibrate()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_Reinitialize
      "Errors signaled by the last execution of the 'Reinitialize()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_DoStep
      "Errors signaled by the last execution of the 'DoStep()' block-interface
       method of the production code; 0 in case of no errors (cf. the eFMI
       specification for pre-defined error signals and the encoding of such).";

    // Cosimulation outputs:
    Real vs
      "PSS output signal";
  end __CosimulationResults;

  annotation(
    preferredView = "info",
    uses(
      DymolaEmbedded(version = "1.0.5")),
    Documentation(
      info="
<html><b>Warning:</b> Do <u><i>not</i></u> edit this package (including renaming
it) or its subclasses.</html>"));
end 'efmuPSS.eFMU_SiL_Support';
