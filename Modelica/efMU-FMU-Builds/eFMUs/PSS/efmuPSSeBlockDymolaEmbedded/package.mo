package efmuPSSeBlockDymolaEmbedded "Package supporting software in the loop (SiL) simulation of the production
   codes of the eFMU generated for the eFMU generation configuration
     [efmiPSSusecase.eBlockDymolaEmbedded]
   Generated by Dymola on 2025-10-27T17:06:19Z."

  extends .DymolaEmbedded.Icons.BinaryCodeContainer;

  // Supported production codes:

protected
  constant .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration[3] code_configurations = {
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "Non-functional mockup.",
      active = false,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x64),
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "",
      active = true,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x32),
    .DymolaEmbedded.BuildUtilities.ProductionCode.SPE_Configuration(
      not_yet_supported = "",
      active = true,
      float_precision = .DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x64)}
    "Software Production Engineering configurations used to build the stub's
     production codes. Can be indexed by enumeration values of 'ProductionCodes'.";

  record __Tuning
    "Support record type compiling all tuneable parameters, each typed with
     a fitting builtin Modelica type."

    Real Kw
      "Stabilizer gain [pu/pu]";
    .OpenIPSL.Types.Time T1
      "First stabilizer time constant";
    .OpenIPSL.Types.Time T2
      "Second stabilizer time constant";
    .OpenIPSL.Types.Time T3
      "Third stabilizer time constant";
    .OpenIPSL.Types.Time T4
      "Fourth stabilizer time constant";
    .OpenIPSL.Types.Time Tw
      "Wash-out time constant";
    Real vSI_start
      "Default start value for vSI, the PSS input signal.";
    .OpenIPSL.Types.PerUnit vsmax
      "Max stabilizer output signal";
    .OpenIPSL.Types.PerUnit vsmin
      "Min stabilizer output signal";
  end __Tuning;

  class __TuningConnectors
    "Connector types for each tuneable parameter (required by tuning bus en- and
     decoders to provide respective in- and output connectors)."

    connector Kw =
      .Real;
    connector T1 =
      .OpenIPSL.Types.Time;
    connector T2 =
      .OpenIPSL.Types.Time;
    connector T3 =
      .OpenIPSL.Types.Time;
    connector T4 =
      .OpenIPSL.Types.Time;
    connector Tw =
      .OpenIPSL.Types.Time;
    connector vSI_start =
      .Real;
    connector vsmax =
      .OpenIPSL.Types.PerUnit;
    connector vsmin =
      .OpenIPSL.Types.PerUnit;
  end __TuningConnectors;

  block __TuningBusSource
    "Tuning source providing a given, fixed parameterization as bus signals."

    parameter __Tuning tuning;
    TuningBus bus;

  protected
    __TuningBusEncoder encoder;
    Source source(__tuning = tuning);

    block Source
      parameter __Tuning __tuning;
      output __TuningConnectors.Kw Kw;
      output __TuningConnectors.T1 T1;
      output __TuningConnectors.T2 T2;
      output __TuningConnectors.T3 T3;
      output __TuningConnectors.T4 T4;
      output __TuningConnectors.Tw Tw;
      output __TuningConnectors.vSI_start vSI_start;
      output __TuningConnectors.vsmax vsmax;
      output __TuningConnectors.vsmin vsmin;
    equation
      Kw = __tuning.Kw;
      T1 = __tuning.T1;
      T2 = __tuning.T2;
      T3 = __tuning.T3;
      T4 = __tuning.T4;
      Tw = __tuning.Tw;
      vSI_start = __tuning.vSI_start;
      vsmax = __tuning.vsmax;
      vsmin = __tuning.vsmin;
    end Source;

  equation
    connect(source.Kw, encoder.Kw);
    connect(source.T1, encoder.T1);
    connect(source.T2, encoder.T2);
    connect(source.T3, encoder.T3);
    connect(source.T4, encoder.T4);
    connect(source.Tw, encoder.Tw);
    connect(source.vSI_start, encoder.vSI_start);
    connect(source.vsmax, encoder.vsmax);
    connect(source.vsmin, encoder.vsmin);
    connect(encoder.__bus, bus);
  end __TuningBusSource;

  model __TuningBusDecoder
    "Decoder providing each tuning signal of a tuning bus as individually
     connectable output."

    import __TuningBus = efmuPSSeBlockDymolaEmbedded.TuningBus;

    __TuningBus __bus;

    output __TuningConnectors.Kw Kw;
    output __TuningConnectors.T1 T1;
    output __TuningConnectors.T2 T2;
    output __TuningConnectors.T3 T3;
    output __TuningConnectors.T4 T4;
    output __TuningConnectors.Tw Tw;
    output __TuningConnectors.vSI_start vSI_start;
    output __TuningConnectors.vsmax vsmax;
    output __TuningConnectors.vsmin vsmin;

  equation
    connect(__bus.Kw, Kw);
    connect(__bus.T1, T1);
    connect(__bus.T2, T2);
    connect(__bus.T3, T3);
    connect(__bus.T4, T4);
    connect(__bus.Tw, Tw);
    connect(__bus.vSI_start, vSI_start);
    connect(__bus.vsmax, vsmax);
    connect(__bus.vsmin, vsmin);
  end __TuningBusDecoder;

  model __TuningBusEncoder
    "Encoder setting each tuning signal of a tuning bus via an individually
     connectable input."

    import __TuningBus = efmuPSSeBlockDymolaEmbedded.TuningBus;

    input __TuningConnectors.Kw Kw;
    input __TuningConnectors.T1 T1;
    input __TuningConnectors.T2 T2;
    input __TuningConnectors.T3 T3;
    input __TuningConnectors.T4 T4;
    input __TuningConnectors.Tw Tw;
    input __TuningConnectors.vSI_start vSI_start;
    input __TuningConnectors.vsmax vsmax;
    input __TuningConnectors.vsmin vsmin;

    __TuningBus __bus;

  equation
    connect(Kw, __bus.Kw);
    connect(T1, __bus.T1);
    connect(T2, __bus.T2);
    connect(T3, __bus.T3);
    connect(T4, __bus.T4);
    connect(Tw, __bus.Tw);
    connect(vSI_start, __bus.vSI_start);
    connect(vsmax, __bus.vsmax);
    connect(vsmin, __bus.vsmin);
  end __TuningBusEncoder;

  record __SampledInterface
    "Refined, actual eFMU communication interface as defined and required by the
     eFMU used for co-simulation."

    extends .DymolaEmbedded.BuildUtilities.BinaryCode.DefaultSampledInterface;

    // Inputs:
    Real vSI
      "PSS input signal ";

    // Outputs:
    Real vs
      "PSS output signal";

    // Tuneable parameters:
    __Tuning __tuning;
  end __SampledInterface;

  record __CosimulationResults
    "Record compiling the results of a single co-simulated production code."

    import __ProductionCodes = efmuPSSeBlockDymolaEmbedded.ProductionCodes;

    // Cosimulation status:
    __ProductionCodes __production_code
      "The production code this are the results of.";
    Boolean __is_active
      "Whether the production code has been co-simulated or not.";
    Integer __error_signals_Recalibrate
      "Errors signaled by the last execution of the 'Recalibrate()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_Reinitialize
      "Errors signaled by the last execution of the 'Reinitialize()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_DoStep
      "Errors signaled by the last execution of the 'DoStep()' block-interface
       method of the production code; 0 in case of no errors (cf. the eFMI
       specification for pre-defined error signals and the encoding of such).";

    // Cosimulation outputs:
    Real vs
      "PSS output signal";
  end __CosimulationResults;

  annotation(
    preferredView = "info",
    uses(
      DymolaEmbedded(version = "1.0.5"),
      Modelica(version="4.0.0"),
      OpenIPSL(version="3.1.0-dev")),
    Documentation(
      info="
<html><b>Warning:</b> Do <u><i>not</i></u> edit this package (including renaming
it) or its subclasses.</html>"));
end efmuPSSeBlockDymolaEmbedded;
