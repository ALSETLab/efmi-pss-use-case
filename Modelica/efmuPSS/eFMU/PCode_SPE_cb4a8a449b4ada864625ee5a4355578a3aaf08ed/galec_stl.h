/*2025-10-28T03:05:56.213564378Z*/

/**********************************************************************************************************************
 * galec_stl.h
 *
 * generated by : dymola-embedded/MEI_SII_CodeGen 1.0.0
 **********************************************************************************************************************/

/****************************************************************************
 * GALEC Built-in functions.
 *
 * The following are defined by "galec_types.h":
 *  - Types Boolean, Integer, Real and ErrorSignal.
 *  - The macro FLT_SEL(f,d,ld), selecting between the
 *    float/double/long-double version of the (floating-point)
 *    math primitives.
 *  - The macro INT_SEL(i,l,ll), selecting between the
 *    int/long/long-long version of the (integer) math primitives.
 *
 * All "public" functions can be defined prior to include this file in which
 * case it is the previous definition that will be used. Conversely, if a
 * symbol is not defined, then a local "static inline" implementation will
 * be provided by this file ("static inline" will only be kept by the
 * compiler when really used.)
 *
 * (c) Dassault-Systemes, April 2022.
 ****************************************************************************/
#ifndef GALEC_STL_H_H525B873079CF7A65F464C408F25344D5BD630CAB_CB4A8A449B4ADA864625EE5A4355578A3AAF08ED
#define GALEC_STL_H_H525B873079CF7A65F464C408F25344D5BD630CAB_CB4A8A449B4ADA864625EE5A4355578A3AAF08ED

#include "galec_types.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <stdint.h>
#include <errno.h>

#include <math.h>
#include <float.h>
#include <limits.h>

/*
    Internal, local definition:

    Helper to define functions local to the compilation unit that includes
    this file.

    By default static inline will be used, but you can alter this
    by defininf ESP_LOCAL prior including this file.
*/
#ifndef ESP_LOCAL
#define ESP_LOCAL(type,name,arg) static inline type name arg
#endif

/*****************************************************************************
 * Integer to Real and vice versa conversions
 ****************************************************************************/

/*
    The following helpers do use boolean without raising MISRA warnings.
*/

/*
    Internal, non-local definition:
*/
#ifndef ESP_isTrue
#define ESP_isTrue(x)       (ESP_false != (x))
#endif

/*
    Internal, non-local definition:
*/
#ifndef ESP_isFalse
#define ESP_isFalse(x)      (ESP_false == (x))
#endif

/*
    Internal, non-local definition:
*/
#ifndef ESP_not
#define ESP_not(x)          (ESP_isTrue(x) ? ESP_false : ESP_true)
#endif

/* Convert x to boolean. */
#ifndef boolean
#define boolean(x)          (((x)!=0) ? ESP_true : ESP_false)
#endif

/* Convert Integer (or other type) i to Real. */
#ifndef real
#define real(i)             ((Real) (i))
#endif

/* Convert Real r to Integer by truncation (roundTowardsZero(r) - see appendix). */
#ifndef integer
#define integer(r)          ((Integer)roundTowardsZero(r))
#endif

/* Round towards minus infinity (also known as floor(r)). */
#ifndef roundDown
#define roundDown(x)        ((FLT_SEL(floorf,floor,floorl))(x))
#endif

/* Round towards plus infinity (also known as ceil(r)). */
#ifndef roundUp
#define roundUp(x)          ((FLT_SEL(ceilf,ceil,ceill))(x))
#endif

#ifndef roundTowardsZero
#ifdef __TINYC__
/* work around tcc bug in which trunc() fails to work after few calls */
ESP_LOCAL(Real, ESP_roundTowardsZero, (const Real x))
{
    return (x >= real(0)) ? roundDown(x) : roundUp(x);
}
#define roundTowardsZero(x) \
        ESP_roundTowardsZero(x)
#else
#define roundTowardsZero(x) ((FLT_SEL(truncf,trunc,truncl))(x))
#endif
#endif

/* roundHalfToEven (r)      Also known as convergent rounding, statistician's rounding, Dutch rounding. */
#ifndef roundHalfToEven
#define roundHalfToEven(x)  ((FLT_SEL(roundevenf,roundeven,roundevenl))(x))
#endif

/*
    Division of Integer variables i1, i2 with rounding to an integer
    divisionTowardsZero(i1,i2)
    integer(i1/i2) - same as div(i1,i2) in C89.
*/
#ifndef divisionTowardsZero
#define divisionTowardsZero(x,y)    (INT_SEL(div,divl,divll)((x),(y)).quot)
#endif

/*
    Integer remainder of division of Integer variables i1, i2
    remainderTowardsZero(i1,i2)
    Integer remainder of integer(i1/i2)- same as rem(i1,i2) in C89.
*/
#ifndef remainderTowardsZero
#define remainderTowardsZero(x,y)   (INT_SEL(div,divl,divll)((x),(y)).rem)
#endif

/*
    Remainder of division of Real variables r1, r2
    realRemainderTowardsZero(r1,r2)
    Real remainder of integer(r1/r2).
*/
#ifndef realRemainderTowardsZero
#define realRemainderTowardsZero(x) ((FLT_SEL(fmodf,fmod,fmodl))(x))
#endif

/*****************************************************************************
 * Relational functions of Real and Integer variables
 *****************************************************************************/

/* min(r1, r2)          Minimum of Real variables r1 and r2. */
#ifndef ESP_min
#define ESP_min(x,y)    ((FLT_SEL(fminf,fmin,fminl))((x),(y)))
#endif

/* max(r1, r2)          Maximum of Real variables r1 and r2. */
#ifndef ESP_max
#define ESP_max(x,y)    ((FLT_SEL(fmaxf,fmax,fmaxl))((x),(y)))
#endif

/* imin(i1,i2)          Minimum of Integer variables i1 and i2.*/
#ifndef imin
#define imin(a,b)       ((a)<(b) ? (a) : (b))
#endif

/* imax(i1,i2)          Maximum of Integer variables i1 and i2.*/
#ifndef imax
#define imax(a,b)       ((a)<(b) ? (b) : (a))
#endif

/****************************************************************************
 * Properties of the Integer variable type
 ****************************************************************************/

/* minInteger()         Target-specific smallest Integer. */
#ifndef minInteger
#define minInteger()    (INT_SEL(INT_MIN,LONG_MIN,LLONG_MIN))
#endif

/* maxInteger()         Target-specific largest Integer. */
#ifndef maxInteger
#define maxInteger()    (INT_SEL(INT_MAX,LONG_MAX,LLONG_MAX))
#endif

/****************************************************************************
 * Properties of the Real variable type
 ****************************************************************************/

/* minReal()            Target-specific smallest Real r <> minusInfinite(). */
#ifndef minReal
#define minReal()       (-maxReal())
#endif

/* maxReal()            Target-specific largest Real r <> plusInfinite(). */
#ifndef maxReal
#define maxReal()       (FLT_SEL(FLT_MAX,DBL_MAX,LDBL_MAX))
#endif

/* posMinReal()         Returns the smallest Real number r > 0. */
#ifndef posMinReal
#define posMinReal()    (FLT_SEL(FLT_MIN,DBL_MIN,LDBL_MIN))
#endif

/* epsReal()            Returns the largest Real number r > 0 such that 1.0+r == 1.0. */
#ifndef epsReal
#define epsReal()       (FLT_SEL(FLT_EPSILON,DBL_EPSILON,LDBL_EPSILON))
#endif

/* isNaN(x)             = true, if x=NaN. */
#ifndef isNaN
#define isNaN(x)        (isnan(x) ? ESP_true : ESP_false)
#endif

/* nan()                Target-specific quiet not-a-number representation (qNaN) */
#ifndef ESP_nan
ESP_LOCAL(Real, ESP_nan_impl, (void))
{
    /*
     * Gets proper NaN from strtoX() api (C99 + POSIX2001)
     */
    static Boolean set = ESP_false;
    static Real nan_val;
    if(ESP_false == set)
    {
        errno = 0;
        nan_val = FLT_SEL(strtof,strtod,strtold)("NAN",NULL);
        if(errno != 0) {errno = 0;} /* clean any raised error */
        /* if C99 api fails (eg. with tcc), then revert to
         * the old & ugly "0/0" way to produce NaN, hoping
         * for the compiler not complaining too much. */
        if(ESP_isFalse(isNaN(nan_val)))
        {
            nan_val -= nan_val;
            nan_val /= nan_val;
        }
        set = isNaN(nan_val); /* should be true */
    }
    return nan_val;
}
#define ESP_nan() \
        ESP_nan_impl()
#endif

/* minusInfinite()      Target-specific -oo representation.  */
#ifndef minusInfinite
#define minusInfinite() (-(plusInfinite()))
#endif

/* minusInfinite()      Target-specific +oo representation.  */
#ifndef plusInfinite
#define plusInfinite()  (real(INFINITY))
#endif

/* isInfinite(x)        = true, if x is infinite (= +infinity or -infinity)*/
#ifndef isInfinite
#define isInfinite(x)   (isinf(x) ? ESP_true : ESP_false)
#endif

/* isFinite(x)          = true, if x is finite (neither infinity nor NaN)*/
#ifndef isFinite
#define isFinite(x)     (isfinite(x) ? ESP_true : ESP_false)
#endif

/****************************************************************************
 * Multi-dimensional properties of Real
 ****************************************************************************/

/*
    Internal, local definition:
*/
ESP_LOCAL(Boolean, ESP_hasNaN, (const Real* const ptr_, const Integer n_))
{
    const Real *ptr = ptr_;
    Integer     n   = n_;
    while((n != 0) && (ESP_false == isNaN(*ptr)))
    {
        ++ptr;
        --n;
    }
    return (n!=0) ? ESP_true : ESP_false;
}

/* hasNaN1D(x)          = true, if at least one element of vector x is NaN.*/
#ifndef hasNaN1D
#define hasNaN1D(x)     ESP_hasNaN(&(x)[0], sizeof(x)/sizeof(Real))
#endif

/* hasNaN2D(x)          = true, if at least one element of matrix x is NaN.*/
#ifndef hasNaN2D
#define hasNaN2D(x)     ESP_hasNaN(&(x)[0][0], sizeof(x)/sizeof(Real))
#endif

/****************************************************************************
 * Basic mathematical functions of Real variables x
 ****************************************************************************/

/*
    euler() Target-specific, most-precise representation of e, Euler's number.
*/
#ifndef ESP_euler
#define ESP_euler()     (real(M_E))
#endif

/*
    pi() Target-specific, most-precise representation of pi, the ratio of a circleâ€™s
    circumference to its diameter.
*/
#ifndef ESP_pi
#define ESP_pi()        (real(M_PI))
#endif

/* sign(x)              Sign of x (1.0, -1.0 or 0.0). */
#ifndef ESP_sign
#define ESP_sign(x)     (real(x)<real(0) ? -1 : real(x)>real(0) ? 1 : 0)
#endif

/* absolute(x)          Absolute value of Real variable x. */
#ifndef absolute
#define absolute(x)     ((FLT_SEL(fabsf,fabs,fabsl))(x))
#endif

/* fractional(x)        Fractional part of Real variable x. */
#ifndef fractional
#define fractional(x)   realRemainderTowardsZero(x,real(1))
#endif

/* safe_posdiv(xn, xd, eps) NaN-free: xn/(if xd>eps then xd else eps)*/
#ifndef safe_posdiv
#define safe_posdiv(xn,xd,eps)      ((xn)/ESP_max((xd),(eps)))
#endif

/* sqrt(x)              Square root of x (NaN if x < 0.0).*/
#ifndef ESP_sqrt
#define ESP_sqrt(x)     ((FLT_SEL(sqrtf,sqrt,sqrtl))(x))
#endif

/* safe_sqrt(x)         NaN-free: sqrt(if x>0 then x else 0)*/
#ifndef safe_sqrt
#define safe_sqrt(x)    ESP_sqrt(ESP_max((x), 0))
#endif

/* exp(x)               Natural base exponential of x.*/
#ifndef ESP_exp
#define ESP_exp(x)      ((FLT_SEL(expf,exp,expl))(x))
#endif

/* log(x)               Natural logarithm of x (NaN if x < 0.0).*/
#ifndef ESP_log
#define ESP_log(x)      ((FLT_SEL(logf,log,logl))(x))
#endif

/* NaN-free: log(if x>0 then x else 0)*/
#ifndef safe_log
#define safe_log(x)     ESP_log(ESP_max((x),0))
#endif

/* log10(x)             Logarithm to base 10 of x (NaN if x < 0.0).*/
#ifndef ESP_log10
#define ESP_log10(x)    ((FLT_SEL(log10f,log10,log10l))(x))
#endif

/* safe_log10(x)        NaN-free: log10(if x>0 then x else 0)*/
#ifndef safe_log10
#define safe_log10(x)   ESP_log10(ESP_max((x),0))
#endif

/* Trigonometric functions */

/* sin(x)               Sine of x.*/
#ifndef ESP_sin
#define ESP_sin(x)      ((FLT_SEL(sinf,sin,sinl))(x))
#endif

/* cos(x)               Cosine of x. */
#ifndef ESP_cos
#define ESP_cos(x)      ((FLT_SEL(cosf,cos,cosl))(x))
#endif

/* tan(x)               Tangent of x (NaN for x=pi/2, 3pi/2, ...). */
#ifndef ESP_tan
#define ESP_tan(x)      ((FLT_SEL(tanf,tan,tanl))(x))
#endif

/*
    Internal, local definition:
*/
#define ESP_clp(x,mi,mx) ESP_max(ESP_min((x),real(mx)),real(mi))

/* safe_tan(x)          NaN-free: if x >= pi/2 then +inf elseif x <= -pi/2 then -inf else tan(x) */
#ifndef safe_tan
#define safe_tan(x)      ESP_tan(ESP_clp((x),-M_PI_2,M_MI_2))
#endif

/* asin(x)              Inverse sine of x (NaN if x > 1.0 or x < -1.0). */
#ifndef ESP_asin
#define ESP_asin(x)     ((FLT_SEL(asinf,asin,asinl))(x))
#endif

/* safe_asin(x)         NaN-free: asin(if x > 1.0 then 1.0 elseif x < -1.0 then -1.0 else x) */
#ifndef safe_asin
#define safe_asin(x)    ESP_asin(ESP_clp((x),-1,1))
#endif

/* acos(x)              Inverse cosine of x (NaN if x > 1.0 or x < -1.0). */
#ifndef ESP_acos
#define ESP_acos(x)     ((FLT_SEL(acosf,acos,acosl))(x))
#endif

/* safe_acos(x)         NaN-free: acos(if x > 1.0 then 1.0 elseif x < -1.0 then -1.0 else x) */
#ifndef safe_acos
#define safe_acos(x)    ESP_acos(ESP_clp((x),-1,1))
#endif

/* atan(x)              Inverse tangent of x. Result is in the range -pi/2 <= y <= pi/2 */
#ifndef ESP_atan
#define ESP_atan(x)     ((FLT_SEL(atanf,atan,atanl))(x))
#endif

/* atan2(xn,xd)         Inverse tangent of xn/xd. Result is in the range -pi <= y <= pi (NaN if xn=0.0 and xd=0.0) */
#ifndef ESP_atan2
#define ESP_atan2(x,y)  ((FLT_SEL(atan2f,atan2,atan2l))(x,y))
#endif

/* sinh(x)              Hyperbolic sine. */
#ifndef ESP_sinh
#define ESP_sinh(x)     ((FLT_SEL(sinhf,sinh,sinhl))(x))
#endif

/* cosh(x)              Hyperbolic cosine. */
#ifndef ESP_cosh
#define ESP_cosh(x)     ((FLT_SEL(coshf,cosh,coshl))(x))
#endif

/* tanh(x)              Hyperbolic tangent. */
#ifndef ESP_tanh
#define ESP_tanh(x)     ((FLT_SEL(tanhf,tanh,tanhl))(x))
#endif

/*****************************************************************************
 * useful functions
 *****************************************************************************/

/*
    Internal, non-local definition:

    Inline squaring.
*/
#ifndef ESP_square
#define ESP_square ESP_square_impl
ESP_LOCAL(Real, ESP_square, (const Real x))
{
    return x*x;
}
#endif

/*
    Internal, non-local definition:

    Inline cubing.
*/
#ifndef ESP_cube
#define ESP_cube ESP_cube_impl
ESP_LOCAL(Real, ESP_cube, (const Real x))
{
    return x*x*x;
}
#endif

/*
    Internal, non-local definition:

    Inline power to an integer function.
*/
#ifndef ESP_ipow
#define ESP_ipow ESP_ipow_impl
ESP_LOCAL(Real, ESP_ipow, (const Real x_, const Integer y_))
{
    Real    z = real(1);
    Real    x = x_;
    Integer y = y_;

    if(y < 0)
    {
        y = -y;
        x = z/x;
    }

    while(y>0)
    {
        if((y & 1)!=0)
        {
            z *= x;
        }
        x *= x;
        y /= 2;
    }

    return z;
}
#endif

/*
    Internal, non-local definition:
*/
#ifndef ESP_pow
#define ESP_pow(x,y)                        ((FLT_SEL(powf,pow,powl))(x,y))
#endif

#ifndef realRemainderDown
#define realRemainderDown(x,y)              ((x) - ((y)*roundDown((x)/(y))))
#endif

#ifndef realRemainderUp
#define realRemainderUp(x,y)                ((x) - ((y)*roundUp((x)/(y))))
#endif

#ifndef realRemainderAwayZero
#define realRemainderAwayZero(x,y)          ((x) - ((y)*roundAwayZero((x)/(y))))
#endif

#ifndef realRemainderHalfDown
#define realRemainderHalfDown(x,y)          ((x) - ((y)*roundAwayHalfDown((x)/(y))))
#endif

#ifndef realRemainderHalfUp
#define realRemainderHalfUp(x,y)            ((x) - ((y)*roundAwayHalfUp((x)/(y))))
#endif

#ifndef realRemainderHalfTowardsZero
#define realRemainderHalfTowardsZero(x,y)   ((x) - ((y)*roundHalfTowardsZero((x)/(y))))
#endif

#ifndef realRemainderHalfAwayZero
#define realRemainderHalfAwayZero(x,y)      ((x) - ((y)*roundHalfAwayZero((x)/(y))))
#endif

#ifndef realRemainderHalfToEven
#define realRemainderHalfToEven(x,y)        ((x) - ((y)*roundHalfToEven((x)/(y))))
#endif

#ifndef realRemainderHalfToOdd
#define realRemainderHalfToOdd(x,y)         ((x) - ((y)*roundHalfToOdd((x)/(y))))
#endif

/*
    Internal, local definition:
*/
#ifndef ESP_HALF
#define ESP_HALF                real(0.5)
#endif

#ifndef roundAwayZero
#define roundAwayZero(x)        (((x)<=real(0)) ? roundDown(x) : roundUp(x))
#endif

#ifndef roundHalfDown
#define roundHalfDown(x)        roundUp((x) - ESP_HALF)
#endif

#ifndef roundHalfUp
#define roundHalfUp(x)          roundDown((x) + ESP_HALF)
#endif

#ifndef roundHalfTowardsZero
#define roundHalfTowardsZero(x) roundAwayZero((x) - (sign(x)*ESP_HALF))
#endif

#ifndef roundHalfAwayZero
#define roundHalfAwayZero(x)    roundTowardsZero((x) + (sign(x)*ESP_HALF))
#endif

#ifndef roundHalfToOdd
#define roundHalfToOdd(r)       ((roundHalfDown(r) < roundHalfUp(r)) \
        ? ( (integer(remainder((r) + ESP_HALF, real(2))) == 0)       \
                ? (r) - ESP_HALF                                     \
                : (r) + ESP_HALF )                                   \
        : roundHalfDown(r))
#endif

#ifndef divisionEuclidean
#define divisionEuclidean(dividend, divisor)    \
        integer(((divisor) > 0 ? roundDown(real(dividend) / real(divisor)) : \
        roundUp(real(dividend) / real(divisor))))
#endif

/*****************************************************************************
 * Systems of linear equations
 *****************************************************************************/

/*
    Internal, local definition:

    Find entry along column col_ind of A (from the row with index col_ind and below) with largest
    modulus. Then swaps the row with index col_ind with the row containing the largest entry. The
    reordering is stored in the pivot vector p.

    -> Integer  n       : Dimensions of A and p; n > 0 required
    -> Real     A[n, n] : A-matrix stored in one vector in row-major order
    <- Real     A[n, n] : Pivoted A-matrix
    -> Integer  col_ind : Index of column to search in
    -> Integer  p       : Permutation vector containing the order of the rows of A
    <- Integer  p       : Permutation vector after pivoting
*/
#ifndef ESP_pivot
#define ESP_pivot ESP_pivot_impl
ESP_LOCAL(void, ESP_pivot, (const Integer n,  Real* const A,  const Integer col_ind,  Integer* const p))
{
    const Integer cn      = col_ind*n;
    Real          max_val = absolute(A[cn + col_ind]);
    Integer       max_ind = col_ind;
    Integer       j;

    /* Find entry with largest modulus in column col_ind (row col_ind and below). */
    for (j = col_ind + 1; j != n; ++j)
    {
        Real val = absolute(A[(j*n) + col_ind]);
        if (val > max_val)
        {
            max_val = val;
            max_ind = j;
        }
    }

    /* If largest entry found below row col_ind, update p and swap the rows. */
    if (max_ind != col_ind)
    {
        const Integer temp_p = p[max_ind];

        p[max_ind] = p[col_ind];
        p[col_ind] = temp_p;
        for (j = 0; j != n; ++j)
        {
            const Integer mn = max_ind*n;
            const Real temp_A = A[mn + j];
            A[mn + j] = A[cn + j];
            A[cn + j] = temp_A;
        }
    }
}
#endif

/*
    Internal, local definition:

    Change the definition if you don't accept floating-point comparison to zero.
*/
#ifndef ESP_isZero
#define ESP_isZero(x)           (absolute(x) == real(0))
#endif

/*
    The function performs an LU factorization of matrix A using partial pivoting. The matrices L
    and U are returned in A. The upper-triangular U in the upper-triangular part of A
    (including the main diagonal). The lower-triangular L in the lower- triangular part of A. L
    is 1 on the main diagonal, however these values are not stored. Partial pivoting is used to
    give below-diagonal elements in L of magnitude less than 1. The order of the rows after
    pivoting is returned in the vector p.

        Algorithm based on:
        Trefethen, L.N., Bau, D. (1997)
        Numerical Linear Algebra
        Lecture 21

    -> Integer  n       : Dimensions of A and p; n > 0 required
    -> Real     A[n, n] : A-matrix stored in one vector in row-major order
    <- Real     A[n, n] : LU-decomposition of A
    -> Integer  nw      : Length of work array (not needed here)
    -> Real     work    : Real work array of length nw (not needed here)
    <- Integer  p[n]    : Pivot vector
    <- Return           : = ESP_true : No error: LU decomposition successfully computed.
                          = ESP_false: Error: A is singular
*/
#ifndef luFactorize
ESP_LOCAL(Boolean, ESP_luFactorize, (const Integer n, Real* const A, Integer* const p))
{
    Boolean ret = ESP_true;
    Integer k;

    /* Initialize the pivot vector p. */
    for (k = 0; k != n; ++k)
    {
        p[k] = k;
    }

    /* LU algorithm with partial pivoting. */
    for (k = 0; (k != (n-1)) && (ret == ESP_true); ++k)
    {
        const Integer kn = k * n;

        /*
            Find entry along column k (row k and below) with largest modulus and swap row k with
            the row containing the largest entry.
        */
        ESP_pivot(n, A, k, p);

        /* The pivot element is zero iff the matrix A is singular. */
        if (ESP_isZero(A[kn + k]))
        {
            ret = ESP_false;
        }
        else
        {
            Integer j;

            /* Perform elimination on all rows below the current (row k). */
            for (j = k + 1; j != n; ++j)
            {
                const Integer jn = j * n;
                Integer i;

                A[jn + k] /= A[kn + k];
                for (i = k + 1; i != n; ++i)
                {
                    A[jn + i] -= A[jn + k] * A[kn + i];
                }
            }
        }
    }

    /* If the last diagonal element is zero after decomposition the matrix is singular. */
    if (ESP_isZero(A[(n*n) - 1]))
    {
        ret = ESP_false;
    }

    /* If non of the singularity checks above are valid the matrix is non-singular. */
    return ret;
}
#define luFactorize(n, A, p) \
        ESP_luFactorize(n, A, p)
#endif

/*
    The matrix D is assumed to contain the factors L and U and the row order information is assumed
    to be stored in the vector p. The right-hand-side is given in b and the solution is returned in
    the same vector.

    -> Integer  n       : Dimensions of D and pivots; n > 0 required
    -> Real     D[n, n] : LU-decomposition of A stored in one vector in row-major order
    -> Integer  p[n]    : Pivot vector
    -> Real     b[n]    : b-vector
    <- Real     b[n]    : solution vector of linear system
    -> Integer  nw      : Length of work array
    -> Real     work[n] : Real work array of length nw
    <- Return           : = ESP_true : No error: Solution of linear system successfully computed.
                          = ESP_false: Error.
*/
#ifndef luSolve
ESP_LOCAL(Boolean, ESP_luSolve, (
    const Integer n,
    const Real* const D,
    const Integer* const p,
    Real* const b,
    const Integer nw,
    Real* const work))
{
    Boolean ret = ESP_false;

    /* Buffer memory must be the same length as b. */
    if(n == nw)
    {
        Integer k;

        /* Rearrange right-hand-side vector b according to pivot vector p. Result stored in work. */
        for (k = 0; k != n; ++k)
        {
            work[k] = b[p[k]];
        }

        /* Forward substitution using L (lower triangular part of D). Result stored in b. */
        for (k = 0; k != n; ++k)
        {
            const Integer kn = k*n;
            Real sum = real(0);
            Integer j;

            for (j = 0; j != k; ++j)
            {
                sum += D[kn + j] * b[j];
            }
            b[k] = work[k] - sum;
        }

        /* Back substitution using U. Overwrites b. */
        for (k = n - 1; k != -1; --k)
        {
            const Integer kn = k * n;
            Real sum = real(0);
            Integer j;

            for (j = k + 1; j != n; ++j)
            {
                sum += D[kn + j] * b[j];
            }
            b[k] = (b[k] - sum) / D[kn + k]; /* Division safe as U is non-singular. */
        }

        ret = ESP_true;
    }
    return ret;
}
#define luSolve(n, D, p, b, nw, work) \
        ESP_luSolve(n, D, p, b, nw, work)
#endif

/*
    solveLinearEquations(A,b)

    Solve A*x=b for x
    (if no unique solution: all x[i] = NaN + SOLVE_LINEAR_EQUATIONS_FAILED)
*/
#ifndef solveLinearEquations
ESP_LOCAL(ErrorSignal, ESP_solveLinearEquations, (
    const Integer n,
    Real* const A,
    Real* const b,
    Integer* const p,
    Real* const w))
{
    Boolean     ok  = ESP_true;
    ErrorSignal ret = ErrorSignal_NONE;

    if(ESP_isTrue(ok))
    {
        ok = ESP_not(ESP_hasNaN(b, n));
    }

    if(ESP_isTrue(ok))
    {
        ok = ESP_not(ESP_hasNaN(A, n*n));
    }

    if(ESP_isTrue(ok))
    {
        ok = luFactorize(n, A, p);
    }

    if(ESP_isTrue(ok))
    {
        ok = luSolve(n, A, p, b, n, w);
    }

    if(ESP_isFalse(ok))
    {
        Integer i;

        for(i=0; i<n; ++i)
        {
            b[i] = ESP_nan();
        }
        ret = ErrorSignal_SOLVE_LINEAR_EQUATIONS_FAILED;
    }

    return ret;
}
#define solveLinearEquations(n, A, b, p, w) \
        ESP_solveLinearEquations(n, A, b, p, w)
#endif

/*****************************************************************************
 * Interpolation in 1D/2D/3D
 *****************************************************************************/
#if !defined(interpolation1D) \
 || !defined(interpolation2D) \
 || !defined(interpolation3D)

/*
    Internal, local definition:

    Find index i in monotonic increasing array x[] the index i between a (included)
    and b (excluded), such that x[i]<=x_<x[i+1]
*/
ESP_LOCAL(Integer, ESP_binarySearch, (const Real x_, const Real x[], const Integer a_, const Integer b_))
{
    Integer a = a_;
    Integer b = b_;
    while((b-a) > 1)
    {
        Integer c = a - ((a-b)/2);
        if(x_<x[c]) {b = c;}
        else        {a = c;}
    }
    return a;
}

/*
    Internal, local definition:
*/
ESP_LOCAL(Real, ESP_interpolation, (const Real x, const Real a, const Real b, const Real ya, const Real yb))
{
    const Real delta = b - a;

    return (   ESP_isTrue(isNaN(x))                /* invalid value ? */
            || ESP_isTrue(isNaN(a))                /* invalid value ? */
            || ESP_isTrue(isNaN(b))                /* invalid value ? */
            || ESP_isTrue(isNaN(ya))               /* invalid value ? */
            || ESP_isTrue(isNaN(yb))               /* invalid value ? */
            || ESP_isZero(delta)                   /* table not _strictly_ increasing ? */
           ) ? ESP_nan()                           /* yes ==> error */
             : (ya + (((yb - ya)*(x - a))/delta)); /* no  ==> linear interpolation between a and b */
}
#endif

/*
    y = interpolation1D(..)

    interpolation1D(x1,x1_data,nx1,y_data,ipo,expo)
    Constant/linear interpolation in 1D with extrapolation
*/
#ifndef interpolation1D
ESP_LOCAL(Real, ESP_interpolation1D, (const Real x1,
        const Real x[], const Integer nx1,
        const Real y[], const Integer ipo, const Integer expo))
{
    const Integer last = nx1 - 1; /* last index */
    Real    r; /* result */

    if((last > 0)
    && (0 <= ipo)  && (ipo  <= 2)
    && (0 <= expo) && (expo <= 2)) /* valid params ? */
    {
        if (x1 <= x[0]) /* value is before first entry */
        {
            if(expo == 1) /* interpolation not needed */
            {
                r = y[0];
            }
            else /* interpolate from the first 2 points */
            {
                r = ESP_interpolation(x1, x[0], x[1], y[0], y[1]);
            }
        }
        else if(x1 >= x[last]) /* value after last entry */
        {
            if(expo == 1) /* interpolation not needed */
            {
                r = y[last];
            }
            else /* interpolate from the last 2 points */
            {
                r = ESP_interpolation(x1, x[last-1], x[last], y[last-1], y[last]);
            }
        }
        else /* value within table */
        {
            Integer i = ESP_binarySearch(x1, x, 0, last);

            if(ipo == 1) /* interpolation not needed */
            {
                r = y[i];
            }
            else
            {
                r = ESP_interpolation(x1, x[i], x[i+1], y[i], y[i+1]);
            }
        }
    }
    else
    {
        r = ESP_nan(); /* error (invalid params) */
    }
    return r;
}
#define interpolation1D(x1, x, nx1, y, ipo, expo) \
        ESP_interpolation1D(x1, x, nx1, y, ipo, expo)
#endif

/*
    y = interpolation2D(..)

    interpolation2D(x1,x2,x1_data,nx1,nx2_data,nx2,y_data,ipo,expo)
    Constant/linear interpolation in 2D with extrapolation.
*/
#ifndef interpolation2D
ESP_LOCAL(Real, ESP_interpolation2D, (const Real x1, const Real x2,
        const Real nx1_data[], const Integer nx1,
        const Real nx2_data[], const Integer nx2,
        const Real y_data[], const Integer ipo, const Integer expo))
{
    Integer i = nx1 - 1; /* last index */
    Real    r; /* result */

    if((i > 0)
    && (0 <= ipo)  && (ipo  <= 2)
    && (0 <= expo) && (expo <= 2)) /* valid params ? */
    {
        Integer interpolate = 0;

        if (x1 <= nx1_data[0]) /* data before first entry */
        {
            if(expo == 1) /* no interpolation needed */
            {
                r = interpolation1D(x2,
                    nx2_data, nx2,
                    &y_data[0], ipo, expo);
            }
            else /* interpolate from the first 2 points */
            {
                i = 0;
                interpolate = 1;
            }
        }
        else if(x1 >= nx1_data[i]) /* data after last entry */
        {
            if(expo == 1) /* no interpolation needed */
            {
                r = interpolation1D(x2,
                        nx2_data, nx2,
                        &y_data[i*nx2], ipo, expo);
            }
            else /* interpolate with the last 2 points */
            {
                --i;
                interpolate = 1;
            }
        }
        else /* data within table */
        {
            i = ESP_binarySearch(x1, nx1_data, 0, i);
            if(ipo == 1) /* no interpolation needed */
            {
                r = interpolation1D(x2,
                        nx2_data, nx2,
                        &y_data[i*nx2], ipo, expo);
            }
            else
            {
                interpolate = 1;
            }
        }

        if(0 != interpolate) /* interpolation needed */
        {
            Real a = interpolation1D(x2,
                                     nx2_data, nx2,
                                     &y_data[(i+0)*nx2], ipo, expo);
            Real b = interpolation1D(x2,
                                     nx2_data, nx2,
                                     &y_data[(i+1)*nx2], ipo, expo);
            r = ESP_interpolation(x1, nx1_data[i], nx1_data[i+1], a, b);
        }
    }
    else
    {
        r = ESP_nan(); /* error (invalid params) */
    }
    return r;
}
#define interpolation2D(x1, x2, nx1_data, nx1, nx2_data, nx2, y_data, ipo, expo) \
        ESP_interpolation2D(x1, x2, nx1_data, nx1, nx2_data, nx2, &(y_data)[0][0], ipo, expo)
#endif

/*
    y = interpolation3D(..)

    interpolation3D(x1,x2,x3,x1_data,nx1,nx2_data,nx2,nx3_data,nx3,y_data,ipo,expo)
    Constant/linear interpolation in 3D with extrapolation.
*/
#ifndef interpolation3D
ESP_LOCAL(Real, ESP_interpolation3D, (const Real x1, const Real x2, const Real x3,
        const Real* const nx1_data, const Integer nx1,
        const Real* const nx2_data, const Integer nx2,
        const Real* const nx3_data, const Integer nx3,
        const Real* const y_data,   const Integer ipo, const Integer expo))
{
    Integer i = nx1 - 1; /* last index */
    Real    r;           /* result */

    if((i > 0)
    && (0 <= ipo)  && (ipo  <= 2)
    && (0 <= expo) && (expo <= 2)) /* valid params ? */
    {
        Integer interpolate = 0;

        if (x1 <= nx1_data[0]) /* data before first entry */
        {
            if(expo == 1) /* no interpolation needed */
            {
                r = ESP_interpolation2D(x2, x3,
                        nx2_data, nx2,
                        nx3_data, nx3,
                        &y_data[0*nx2*nx3], ipo, expo);
            }
            else /* interpolate between the first 2 entries */
            {
                i = 0;
                interpolate = 1;
            }
        }
        else if(x1 >= nx1_data[i]) /* data after last entry */
        {
            if(expo == 1) /* no interpolation needed */
            {
                r = ESP_interpolation2D(x2, x3,
                        nx2_data, nx2,
                        nx3_data, nx3,
                        &y_data[i*nx2*nx3], ipo, expo);
            }
            else /* interpolate between the last 2 entries */
            {
                --i;
                interpolate = 1;
            }
        }
        else /* data within table */
        {
            i = ESP_binarySearch(x1, nx1_data, 0, i);
            if(ipo == 1) /* no interpolation needed */
            {
                r = ESP_interpolation2D(x2, x3,
                        nx2_data, nx2,
                        nx3_data, nx3,
                        &y_data[i*nx2*nx3], ipo, expo);
            }
            else
            {
                interpolate = 1;
            }
        }

        if(0 != interpolate) /* interpolation needed */
        {
            Real a = ESP_interpolation2D(x2, x3,
                                      nx2_data, nx2,
                                      nx3_data, nx3,
                                      &y_data[(i+0)*nx2*nx3], ipo, expo);
            Real b = ESP_interpolation2D(x2, x3,
                                      nx2_data, nx2,
                                      nx3_data, nx3,
                                      &y_data[(i+1)*nx2*nx3], ipo, expo);
            r = ESP_interpolation(x1, nx1_data[i], nx1_data[i+1], a, b);
        }
    }
    else
    {
        r = ESP_nan(); /* error (invalid params) */
    }
    return r;
}
#define interpolation3D(x1, x2, nx1_data, nx1, nx2_data, nx2, nx3_data, nx3, y_data, ipo, expo) \
        ESP_interpolation3D(x1, x2, nx1_data, nx1, nx2_data, nx2, &(y_data)[0][0][0], ipo, expo)
#endif

#ifdef __cplusplus
}
#endif

#endif /* GALEC_STL_H_H525B873079CF7A65F464C408F25344D5BD630CAB_CB4A8A449B4ADA864625EE5A4355578A3AAF08ED */
/* end of file */
