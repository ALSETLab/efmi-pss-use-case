package DymolaCommands

package SimulatorAPI

function importFMU "Import an FMU"
input String fileName "The FMU file" annotation (Dialog(loadSelector(filter="FMUs(*.fmu)", caption="FMU to import")));
input Boolean includeAllVariables = true "Include other variables than inputs, outputs and parameters. Will only be used if includeVariables is an empty array.";
input Boolean integrate = true "Integrate outside the FMU, set to false for co-simulation";
input Boolean promptReplacement = false "Prompt for name and save location when importing";
input String packageName = "" "Name of package to insert FMU in";
input String includeVariables[:] = fill("", 0) "FMU variables to be included in the fmuWrapper, an empty list will include all variables";
output Boolean result "True if successful";
  external "builtin";
  annotation(__Dymola_interactive=true, Documentation(info="<html><p>Imports an FMU, i. e. unzips, XSL transforms the model description and opens the
resulting Modelica model. Note: The model description file from any previous import is replaced.
This also applies to the binary library files.</p>
<p>This built-in function corresponds to the command <b>File &GT; Import &GT; FMU&hellip;</b>.</p>
<p>For more information, please see the manual &ldquo;Dymola User Manual Volume 2&rdquo;, chapter 6
&ldquo;Other Simulation Environments&rdquo;, section &ldquo;FMI Support in Dymola&rdquo;.</p>
<p>Note: For big models it is recommended to set <code>includeAllVariables=false</code> to avoid
the Modelica wrapper becoming huge.</p>
<h4><span style=\"color:#008000\">Example in Dymola</span></h4>
<pre>importFMU(&QUOT;C:/test/Modelica_Mechanics_Rotational_Examples_CoupledClutches.fmu&QUOT;,&nbsp;true,&nbsp;true,&nbsp;false,&nbsp;&QUOT;&QUOT;);</pre></html>"));
end importFMU;

function translateModelFMU "Translate a model to an FMU"
input String modelToOpen "Model to open";
input Boolean storeResult = false "Whether to store result in mat file from within FMU";
input String modelName = "" "User-selected FMU modelIdentifier (also used as modelName)";
input String fmiVersion = "1" "FMI version, 1 or 2.";
input String fmiType = "all" "FMI type, me (model exchange), cs (co-simulation), all or csSolver (using Dymola solver).
                             Only affects modelDescription.xml; binary and source code always contain both.";
input Boolean includeSource = false "Whether to include source code in FMU";
input Integer includeImage = 0 "Whether to include the model image (0 - no image, 1 icon, 2 diagram)";
input String includeVariables[:] = fill("", 0) "Variables in model to be included in the xml, if empty all that passes selected filters will be used";
output String FMUname "FMI model identifier on success, empty string on failure";
  external "builtin";
  annotation(__Dymola_interactive=true, Documentation(info="<html><p>Translates a model to an FMU. The input string <code>model</code> defines the model to open
in the same way as the traditional <code>translateModel</code> command in Dymola.</p>
<p>The Boolean input <code>storeResult</code> is used to specify if the FMU should generate a result file
(<code>dsres.mat</code>). If <code>storeResult</code> is true, the result is saved in <code>&LT;model id&GT;</code>.mat
when the FMU is imported and simulated, where<code> &LT;model id&GT;</code> is given at FMU initialization. (If empty,
<code>&ldquo;dsres&rdquo;</code> is used instead.) This is useful when importing FMUs with parameter
<code>allVariables = false</code>, since it provides a way to still obtain the result for all variables. Simultaneous use
of result storing and source code inclusion (see below) is not supported.</p>
<p>The input string <code>modelName</code> is used to select the FMU model identifier. If the string is empty, the model
identifier will be the name of the model, adapted to the syntax of model identifier (e.g. dots will be exchanged with
underscores).The name must only contain letters, digits and underscores. It must not begin with a digit.</p>
<p>The input string <code>fmiVersion</code> controls the FMI version (<code>&QUOT;1&QUOT;</code> or <code>&QUOT;2&QUOT;</code>)
of the FMU. The default is <code>&QUOT;1&QUOT;</code>.</p>
<p>The input string <code>fmiType</code> define whether the model should be exported as</p>
<ul>
<li>Model exchange (<code>fmiType=&QUOT;me&QUOT;</code>)</li>
<li>Co-simulation using Cvode (<code>fmiType=&QUOT;cs&QUOT;</code>)</li>
<li>Both model exchange, and Co-simulation using Cvode (<code>fmiType=&QUOT;all&QUOT;</code>)</li>
<li>Co-simulation using Dymola solvers (<code>fmiType=&QUOT;csSolver&QUOT;</code>).</li>
</ul>
<p>The default setting is <code>fmiType=&QUOT;all&QUOT;</code>. This parameter primarily affects modelDescription.xml.
For the three first choices binary and source code always contains both model exchange and Co-simulation. For the last
choice the binary code only contains Co-simulation. Note &ndash; Co-simulation using Dymola solvers requires Binary Model
Export license. For this option it might also be noted that also the selected tolerance in Dymola will be used by the
co-simulation FMU, and source code generation FMU is not supported by this alternative.</p>
<p>The Boolean input <code>includeSource</code> is used to specify if source code should be included in the FMU. The default
setting is that it is not included (<code>includeSource=false</code>). Simultaneous use of result storing (see above) and
source code inclusion is not supported.</p>
<p>The function outputs a string <code>FMUName</code> containing the FMU model identifier on success, otherwise an empty string.</p>
<h4><span style=\"color:#008000\">Example in Dymola</span></h4>
<p>Translating the Modelica CoupledClutches demo model to an FMU with result file generation, is accomplished by the function call</p>
<pre>translateModelFMU(&QUOT;Modelica.Mechanics.Rotational.Examples. CoupledClutches&QUOT;, true);</pre>
<p>After successful translation, the generated FMU (with file extension .fmu) will be located in the current directory. Exporting
an FMU using the 64-bit version of Dymola will create both32-bit and 64-bit binaries if possible.</p>
<p>The <code>translateModelFMU</code> command will generate an FMU that supports both the FMI for Model Exchange specification and
the FMI for Co-Simulation interface (all functions will be present in the DLL).</p>
<p>On Linux, note that FMU export requires the Linux utility &ldquo;zip&rdquo;. If not already installed, please install using your
packaging manager (e.g. apt-get) or see e.g. http://infozip.org/Zip.html.</p>
<p>This built-in function corresponds to the commands <b>Simulation &GT; Translate &GT; FMU</b> and corresponding drop-down selections
of the <b>Translate</b> button.</p>
<p>For more information about FMI, please see the manual &ldquo;Dymola User Manual Volume 2&rdquo;, chapter 6 &ldquo;Other Simulation
Environments&rdquo;, section &ldquo;FMI Support in Dymola&rdquo;.</p></html>"));
end translateModelFMU;
end SimulatorAPI;

package Plot

function ExportPlotAsImage "Export (save) a plot window to a .png image"
input String fileName "The path to save the plot. Supported file formats are PNG and SVG.";
input Integer id = -1 "ID of the plot window to export. -1 means last plot window.";
input Boolean includeInLog = true "Include image in command log.";
input Boolean onlyActiveSubplot = true "Include all subplots or only the active subplot.";
output Boolean ok;
  external "builtin";
  annotation(__Dymola_interactive=true, Documentation(info="<html><p>Export (save) a plot window as an image. The image can only be saved in .png format. The parameter
id specifies what plot window will be saved. The default -1 means the first (lowest number) plot window in the
Dymola main window. The <code>includeInLog</code> specifies whether the plot should be included in the command log.</p>
<h4><span style=\"color:#008000\">Example in Dymola</span></h4>
<p><pre>ExportPlotAsImage(E:/MyExperiment/Plots/Plot3.png, id=3)</pre> </p>
<p>will save the plot window Plot[3] as the image Plot3.png in the folder E:\\MyExperiment\\Plots. It will also be saved in the command log.</p></html>"));
end ExportPlotAsImage;
end Plot;
  annotation (
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
      {100,100}}), graphics={
        Rectangle(
          extent={{-98,100},{92,-92}},
          lineColor={0,0,255},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid),
        Rectangle(extent={{-86,50},{74,-40}}, lineColor={255,255,255}),
        Rectangle(
          extent={{-58,-18},{54,-74}},
          lineColor={255,255,255},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid),
        Rectangle(
          extent={{-58,78},{54,22}},
          lineColor={255,255,255},
          fillColor={0,0,255},
          fillPattern=FillPattern.Solid)}),
    uses(Modelica(version="4.0.0")),
    preferredView="info",
    version="1.12",
    versionBuild=1,
    versionDate="2021-10-15",
    dateModified="2021-08-19 04:46:55",
    conversion(noneFromVersion="1.10"));
end DymolaCommands;

package Modelica_LinearSystems2
  "Modelica_LinearSystems2 (version 2.4.0) - Analysis, Synthesis and Modeling of Continuous and Discrete Linear Systems"
  extends Modelica.Icons.Package;

  operator record StateSpace
    "Continuous state space description of a linear, time invariant differential equation system (data + operations)"
    extends Modelica.Icons.Record;

    Real A[:, size(A, 1)]
      annotation (Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
    Real B[size(A, 1), :]
      annotation (Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
    Real C[:, size(A, 1)]
      annotation (Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
    Real D[size(C, 1), size(B, 2)]
      annotation (Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));

    String yNames[size(C, 1)]=fill("", size(C, 1)) "Names of the output signals"
      annotation (Dialog(group="Signal names"));
    String xNames[size(A, 1)]=fill("", size(A, 1)) "Names of the states"
      annotation (Dialog(group="Signal names"));
    String uNames[size(B, 2)]=fill("", size(B, 2)) "Names of the input signals"
      annotation (Dialog(group="Signal names"));

    encapsulated operator 'constructor'
      "Collection of operators to construct a StateSpace data record"

      import Modelica;
      import Modelica_LinearSystems2;

      function fromABCDMatrices
        "Generate a StateSpace data record from A, B, C and D matrices"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input Real A[:, size(A, 1)] "System matrix";
        input Real B[size(A, 1), :]=fill(
                0.0,
                size(A, 1),
                0) "Control matrix";
        input Real C[:, size(A, 1)]=fill(
                0.0,
                0,
                size(A, 1)) "Output matrix";
        input Real D[size(C, 1), size(B, 2)]=fill(
                0.0,
                0,
                0) "Feed-forward matrix";

        input String uNames[size(B, 2)]=fill("", size(B, 2)) "Names of the input signals";
        input String yNames[size(C, 1)]=fill("", size(C, 1)) "Names of the output signals";
        input String xNames[size(A, 2)]=fill("", size(A, 2)) "Names of the states";

        output StateSpace result(
          redeclare Real A[size(A, 1), size(A, 2)],
          redeclare Real B[size(B, 1), size(B, 2)],
          redeclare Real C[size(C, 1), size(C, 2)],
          redeclare Real D[size(D, 1), size(D, 2)],
          redeclare String uNames[size(B, 2)],
          redeclare String yNames[size(C, 1)],
          redeclare String xNames[size(A, 2)]) "State space record";

      algorithm
        result.A := A;
        result.B := B;
        result.C := C;
        result.D := D;
        result.uNames := uNames;
        result.yNames := yNames;
        result.xNames := xNames;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
ss = StateSpace.&apos;constructor&apos;.<b>fromABCDMatrices</b>(A, B, C, D)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a StateSpace record ss with
</p>
<blockquote><pre>
ss.A = A;
ss.B = B;
ss.C = C;
ss.D = D;
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Real A[1,1] = [1];
  Real B[1,1] = [1];
  Real C[1,1] = [1];
  Real D[1,1] = [0];

public
  StateSpace ss;

<b>algorithm</b>
  ss := 'constructor'.fromABCDMatrices(A, B, C, D);
  // ss.A = [1]
  // ss.B = [1]
  // ss.C = [1]
  // ss.D = [0]
</pre></blockquote>
</html>"));
      end fromABCDMatrices;

      function fromReal "Generate a StateSpace data record from a real value"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;

        input Real r "Value of real variable";
        output StateSpace ss(
          redeclare Real A[0, 0],
          redeclare Real B[0, 1],
          redeclare Real C[1, 0],
          redeclare Real D[1, 1]) "= r";

      algorithm
        ss.D[1, 1] := r;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
ss = StateSpace.&apos;constructor&apos;.<b>fromReal</b>(r)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a StateSpace record ss from a real value, i.e. a state-space system without a state and an output without dynamics:
</p>
<blockquote><pre>
y = r*u
</pre></blockquote>
<p>
Therefore, the matrices are defined by
</p>
<blockquote><pre>
ss.A = fill(0,0,0);
ss.B = fill(0,0,1);
ss.C = fill(0,1,0);
ss.D = [r];
</pre></blockquote>
</html>"));
      end fromReal;

      function fromTransferFunction =
        Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace
        "Generate a StateSpace data record from a transfer function" annotation (
          Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
ss = StateSpace.&apos;constructor&apos;.<b>fromTransferFunction</b>(tf)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a StateSpace record ss from a transfer function tf.
For the simplicity of implementation, this function directly extends from
<a href=\"Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace\">TransferFunction.Conversion.toStateSpace</a>.
</p>
</html>"));

      function fromZerosAndPoles =
        Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace
        "Generate a StateSpace data record from a zeros-and-poles system"
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
ss = StateSpace.&apos;constructor&apos;.<b>fromZerosAndPoles</b>(zp)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a StateSpace record ss from a zeros-poles-gain system zp.
For the simplicity of implementation, this function directly extends from
<a href=\"Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace\">ZerosAndPoles.Conversion.toStateSpace</a>.
</p>
</html>"));

      annotation (Documentation(info="<html>
<p>This package contains the default constructors for a data record of state space system. </p>
</html>"));
    end 'constructor';

    encapsulated operator '-'
      "Collection of operators for subtraction of state space systems"
      import Modelica;

      function subtract
        "Subtraction of two state space systems connected in parallel (= inputs are the same, outputs of the two systems are subtracted)"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss1 "State-space system 1";
        input StateSpace ss2 "State-space system 2 is subtracted from system 1";
        output StateSpace result(
          redeclare Real A[size(ss1.A, 1) + size(ss2.A, 1), size(ss1.A, 2) + size(
            ss2.A, 2)],
          redeclare Real B[size(ss1.B, 1) + size(ss2.B, 1), size(ss1.B, 2)],
          redeclare Real C[size(ss1.C, 1), size(ss1.C, 2) + size(ss2.C, 2)],
          redeclare Real D[size(ss1.D, 1), size(ss1.D, 2)]) "= ss1 - ss2";
    protected
        Integer nx1=size(ss1.A, 1);
        Integer nx2=size(ss2.A, 1);
      algorithm
        result.A := [ss1.A, zeros(nx1, nx2); zeros(nx2, nx1), ss2.A];
        result.B := [ss1.B; ss2.B];
        result.C := [ss1.C, -ss2.C];
        result.D := ss1.D - ss2.D;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.&apos;-&apos;.<b>subtract</b>(ss1, ss2)
</pre></blockquote>

<h4>Description</h4>
<p>
This operator function computes the subtraction of two state space systems connected in parallel,
i.e. the inputs are the same and the outputs of the two systems are subtracted.
Therefore, the systems must have the same number of inputs and outputs but not the same
number of states. The resulting system has an order of system_order1 + system_order2.
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
ss3 := ss1 - ss2;
</pre> </blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss1 = StateSpace(A=[-1, 0; 0, -2], B=[1; 2], C=[0, 1], D=[0]);
  StateSpace ss2 = StateSpace(A=[-3, 0; 0, -4], B=[3; 4], C=[0, 2], D=[0]);

  StateSpace ss3;

<b>algorithm</b>
  ss3 := ss1 - ss2;
// ss.A = [-1, 0, 0, 0; 0, -2, 0, 0; 0, 0, -3, 0; 0, 0, 0, -4],
// ss.B = [1; 2; 3; 4],
// ss.C = [0, 1, 0, -2],

// ss.D = [0],
</pre></blockquote>
</html>"));
      end subtract;

      function negate
        "Unary minus (state space system where the output is multiplied by a gain of -1)"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State-space system";
        output StateSpace result(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]) "= -ss";
      algorithm
        result.A := ss.A;
        result.B := ss.B;
        result.C := -ss.C;
        result.D := -ss.D;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.&apos;-&apos;.<b>negate</b>(ss1)
</pre></blockquote>

<h4>Description</h4>
<p>
This operator function negates the state space system, i.e. the output ss
is the negation ot the state space input ss1.
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
ss := -ss1;
</pre> </blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss1 = StateSpace(A=[-1, 3; 0, -2], B=[1; 2], C=[0.2, 1], D=[0.17]);

  StateSpace ss;

<b>algorithm</b>
  ss := -ss1;
// ss.A = [-1, 3; 0, -2],
// ss.B = [1; 2],
// ss.C = [-0.2, -1],
// ss.D = [-0.17],
</pre></blockquote>
</html>"));
      end negate;
      annotation (Documentation(info="<html>
<p>
This package contains operators for subtraction of state space records.
</p>
</html>"));
    end '-';

    encapsulated operator function '+'
      "Parallel connection of two state space systems (= inputs are the same, outputs of the two systems are added)"
      import Modelica_LinearSystems2.StateSpace;

      input StateSpace ss1 "State space system 1";
      input StateSpace ss2
        "State space system 2 is added in parallel to system 1";
      output StateSpace result(
        redeclare Real A[size(ss1.A, 1) + size(ss2.A, 1), size(ss1.A, 2) + size(
          ss2.A, 2)],
        redeclare Real B[size(ss1.B, 1) + size(ss2.B, 1), size(ss1.B, 2)],
        redeclare Real C[size(ss1.C, 1), size(ss1.C, 2) + size(ss2.C, 2)],
        redeclare Real D[size(ss1.D, 1), size(ss1.D, 2)]) "= ss1 + ss2";
  protected
      Integer nx1=size(ss1.A, 1);
      Integer nx2=size(ss2.A, 1);
    algorithm
      result.A := [ss1.A, zeros(nx1, nx2); zeros(nx2, nx1), ss2.A];
      result.B := [ss1.B; ss2.B];
      result.C := [ss1.C, ss2.C];
      result.D := ss1.D + ss2.D;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.<b>&apos;+&apos;</b>(ss1, ss2)
</pre></blockquote>

<h4>Description</h4>
<p>
This operator function computes the addition of two state space systems connected in parallel,
i.e. the inputs are the same and the outputs of the two systems are added.
Therefore, the systems must have the same number of inputs and outputs but not the same
number of states. The resulting system has an order of system_order1 + system_order2.
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
ss3 := ss1 + ss2;
</pre> </blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss1 = StateSpace(A=[-1, 0; 0, -2], B=[1; 2], C=[0, 1], D=[0]);
  StateSpace ss2 = StateSpace(A=[-3, 0; 0, -4], B=[3; 4], C=[0, 2], D=[0.2]);

  StateSpace ss3;

<b>algorithm</b>
  ss3 := ss1 - ss2;
// ss.A = [-1, 0, 0, 0; 0, -2, 0, 0; 0, 0, -3, 0; 0, 0, 0, -4],
// ss.B = [1; 2; 3; 4],
// ss.C = [0, 1, 0, 2],

// ss.D = [0.2],
</pre></blockquote>

</html>"));
    end '+';

    encapsulated operator function '*'
      "Series connection of two state space systems"
      import Modelica_LinearSystems2.StateSpace;

      input StateSpace ss1 "State space system 1";
      input StateSpace ss2 "State space system 2";
      output StateSpace result(
        redeclare Real A[size(ss1.A, 1) + size(ss2.A, 1), size(ss1.A, 2) + size(
          ss2.A, 2)],
        redeclare Real B[size(ss1.B, 1) + size(ss2.B, 1), size(ss2.B, 2)],
        redeclare Real C[size(ss1.C, 1), size(ss1.C, 2) + size(ss2.C, 2)],
        redeclare Real D[size(ss1.D, 1), size(ss2.D, 2)])
        "y = G(s)*u = G(ss1)*G(ss2)*u";
  protected
      Integer nx1=size(ss1.A, 1);
      Integer nx2=size(ss2.A, 1);
    algorithm
      result.A := [ss1.A, ss1.B*ss2.C; zeros(nx2, nx1), ss2.A];
      result.B := [ss1.B*ss2.D; ss2.B];
      result.C := [ss1.C, ss1.D*ss2.C];
      result.D := ss1.D*ss2.D;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.<b>&apos;*&apos;</b>(ss1, ss2)
</pre></blockquote>

<h4>Description</h4>
<p>
This operator function computes the addition of two state space systems connected in series.
<!--,
i.e. the inputs are the same and the outputs of the two systems are added.
Therefore, the systems must have the same number of inputs and outputs but not the same
number of states. The resulting system has an order of system_order1 + system_order2.
-->
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
result := ss1 * ss2;
</pre> </blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss1 = StateSpace(A=[-1, 0; 0, -2], B=[1; 2], C=[0, 1], D=[0]);
  StateSpace ss2 = StateSpace(A=[-3, 0; 0, -4], B=[3; 4], C=[0, 2], D=[0.2]);

  StateSpace ss3;

<b>algorithm</b>
  ss3 := ss1 - ss2;
// ss.A = [-1, 0, 0, 0; 0, -2, 0, 0; 0, 0, -3, 0; 0, 0, 0, -4],
// ss.B = [0.2; 0.4; 3; 4],
// ss.C = [0, 1, 0, 0],
// ss.D = [0],
</pre></blockquote>
</html>"));
    end '*';

    encapsulated operator function '=='
      "Check whether two state space systems have identical matrices"
      import Modelica.Math.Matrices.isEqual;
      import Modelica_LinearSystems2.StateSpace;

      input StateSpace ss1 "State space system 1";
      input StateSpace ss2 "State space system 2";
      input Real eps(min=0) = 0
        "Two elements e1 and e2 of the two systems are identical if abs(e1-e2) <= eps";
      output Boolean same "=true, if the two systems are identical";
    algorithm
      same := isEqual(ss1.A, ss2.A, eps) and
        isEqual(ss1.B, ss2.B, eps) and
        isEqual(ss1.C, ss2.C, eps) and
        isEqual(ss1.D, ss2.D, eps);
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
same = StateSpace.<b>&apos;==&apos;</b>(ss1, ss2)
</pre></blockquote>

<h4>Description</h4>
<p>
This operator function returns true, if all appropriate matrices of two state space systems
ss1 and ss2 are identical. False is returned in any other case.
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
same := ss1 == ss2;
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss1 = StateSpace(A=[-1, 0; 0, -2], B=[1; 2], C=[0, 1], D=[0]);
  StateSpace ss2 = StateSpace(A=[-3, 0; 0, -4], B=[3; 4], C=[0, 2], D=[0.2]);
  StateSpace ss3 = StateSpace(A=[-3, 0; 0, -4], B=[3; 4], C=[0, 2], D=[0.2]);

  ss1 == ss2;
// false

  ss2 == ss3;
// true
</pre></blockquote>
</html>"));
    end '==';

    encapsulated operator function 'String'
      "Transform state space into a String representation"
      import Modelica;
      import Modelica_LinearSystems2.StateSpace;
      import Modelica.Utilities.Strings;

      input StateSpace ss "State space system to be transformed";
      input Integer significantDigits=12
        "Number of significant digits that are shown";
      input String name="ss" "Independent variable name used for printing";
      output String s="";

  protected
      String space=Strings.repeat(5);
      String space2=Strings.repeat(3);
      String space3=Strings.repeat(8);
      Integer nx=size(ss.A, 1);
      Integer nu=size(ss.B, 2);
      Integer ny=size(ss.C, 1);
      Integer sizeD=size(ss.D, 2);
      Integer stringMaxLength;
      Boolean xNamesExist=false;
      Boolean uNamesExist=false;
      Boolean yNamesExist=false;

    algorithm
      // If system is too large, do not print the matrices
      if size(ss.A,1) > 50 or size(ss.B, 2) > 50 or size(ss.C, 1) > 50 then
        s := "System not printed since too large (only dimensions):\n" +
             "   " + name + ".A[" + String(nx) + "," + String(nx) + "]\n" +
             "   " + name + ".B[" + String(nx) + "," + String(nu) + "]\n" +
             "   " + name + ".C[" + String(ny) + "," + String(nx) + "]\n" +
             "   " + name + ".D[" + String(ny) + "," + String(nu) + "]";
        return;
      end if;

      //Checking if name arrays are empty
      for i in 1:nx loop
        xNamesExist := xNamesExist or (ss.xNames[i] <> "");
      end for;

      for i in 1:ny loop
        yNamesExist := yNamesExist or (ss.yNames[i] <> "");
      end for;

      for i in 1:nu loop
        uNamesExist := uNamesExist or (ss.uNames[i] <> "");
      end for;
      /*
    if xNamesExist then
      Modelica.Utilities.Streams.print("xNamesExist == true");
    else
      Modelica.Utilities.Streams.print("xNamesExist == false");
    end if;
*/
      stringMaxLength := max(size(ss.xNames, 1), min(size(ss.yNames, 1), 11));

      if nx == 0 and sizeD == 0 then
        s := name + ".A = []\n  " + name + ".B = []\n   " + name +
          ".C = [] \n   " + name + ".D = []";
      else
        s := "\n" + name + ".A = \n";

        //Horizontal
        // Two alternatives when printing state names
        if xNamesExist == false then
          s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
            "x1 ";
        else
          s := s + Strings.repeat(11 + significantDigits - min(Strings.length(ss.xNames[
            1]), 11)) + Strings.repeat(min(Strings.length(ss.xNames[1]), 11)) +
            " " + Strings.substring(
              ss.xNames[1],
              1,
              min(Strings.length(ss.xNames[1]), 11));
        end if;

        for i in 2:nx loop

          //Two alternatives when printing state names

          if xNamesExist == false then
            s := s + Strings.repeat(significantDigits + 11 - Strings.length("x"
               + String(i - 1))) + "x" + String(i) + " ";
          else
            s := s + " " + Strings.repeat(significantDigits + 11 - min(
              Strings.length(ss.xNames[i - 1]), 11)) + Strings.substring(
                ss.xNames[i],
                1,
                min(Strings.length(ss.xNames[i]), 11));

          end if;

          //s := s + Strings.repeat(6) + "x" + String(i);
        end for;
        s := s + "\n";

        for i in 1:nx loop
          //Vertical
          //Two alternatives when printing state names
          if xNamesExist == false then
            s := s + space + "x" + String(i) + " ";
          else
            s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
              ss.xNames[i]), 11)) + Strings.substring(
                ss.xNames[i],
                1,
                min(Strings.length(ss.xNames[i]), 11)) + " ";
          end if;

          for j in 1:nx loop
            if ss.A[i, j] >= 0 then
              s := s + " ";
            end if;
            s := s + String(ss.A[i, j], significantDigits=significantDigits) +
              Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
              ss.A[i, j]), significantDigits=significantDigits)));
          end for;
          s := s + "\n";
        end for;
        //--------------------------------------------------------------------------------------------------------------------------------------------------
        s := s + "\n" + name + ".B = \n";
        //Horizontal
        // Two alternatives when printing state names
        if uNamesExist == false then
          s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
            "u1 ";
        else
          s := s + Strings.repeat(11 + significantDigits - min(Strings.length(ss.uNames[
            1]), 11)) + Strings.repeat(min(Strings.length(ss.uNames[1]), 11)) +
            " " + Strings.substring(
              ss.uNames[1],
              1,
              min(Strings.length(ss.uNames[1]), 11));
        end if;

        for i in 2:nu loop
          //Two alternatives when printing state names
          if uNamesExist == false then
            s := s + Strings.repeat(significantDigits + 11 - Strings.length("u"
               + String(i - 1))) + "u" + String(i) + " ";
          else
            s := s + " " + Strings.repeat(significantDigits + 11 - min(
              Strings.length(ss.uNames[i - 1]), 11)) + Strings.substring(
                ss.uNames[i],
                1,
                min(Strings.length(ss.uNames[i]), 11));
          end if;
        end for;
        s := s + "\n";
        //s := s + Strings.repeat(6) + "x" + String(i);
        for i in 1:nx loop

          //Vertical
          //Two alternatives when printing state names
          if xNamesExist == false then
            s := s + space + "x" + String(i) + " ";
          else

            s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
              ss.xNames[i]), 11)) + Strings.substring(
                ss.xNames[i],
                1,
                min(Strings.length(ss.xNames[i]), 11)) + " ";
          end if;

          for j in 1:nu loop
            if ss.B[i, j] >= 0 then
              s := s + " ";
            end if;
            s := s + String(ss.B[i, j], significantDigits=significantDigits) +
              Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
              ss.B[i, j]), significantDigits=significantDigits)));
          end for;
          s := s + "\n";
        end for;

        //--------------------------------------------------------------------------------------------------------------------------------------------------
        s := s + "\n" + name + ".C = \n";
        //Horizontal
        // Two alternatives when printing state names
        if xNamesExist == false then
          s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
            "x1 ";
        else
          s := s + Strings.repeat(11 + significantDigits - min(Strings.length(ss.xNames[
            1]), 11)) + Strings.repeat(min(Strings.length(ss.xNames[1]), 11)) +
            " " + Strings.substring(
              ss.xNames[1],
              1,
              min(Strings.length(ss.xNames[1]), 11));
        end if;

        for i in 2:nx loop
          //Two alternatives when printing state names
          if xNamesExist == false then
            s := s + Strings.repeat(significantDigits + 11 - Strings.length("x"
               + String(i - 1))) + "x" + String(i) + " ";
          else
            s := s + " " + Strings.repeat(significantDigits + 11 - min(
              Strings.length(ss.xNames[i - 1]), 11)) + Strings.substring(
                ss.xNames[i],
                1,
                min(Strings.length(ss.xNames[i]), 11));
          end if;
        end for;
        s := s + "\n";
        //s := s + Strings.repeat(6) + "x" + String(i);

        for i in 1:ny loop
          //Vertical
          //Two alternatives when printing state names
          if yNamesExist == false then
            s := s + space + "y" + String(i) + " ";
          else
            s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
              ss.yNames[i]), 11)) + Strings.substring(
                ss.yNames[i],
                1,
                min(Strings.length(ss.yNames[i]), 11)) + " ";

          end if;

          for j in 1:nx loop
            if ss.C[i, j] >= 0 then
              s := s + " ";
            end if;
            s := s + String(ss.C[i, j], significantDigits=significantDigits) +
              Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
              ss.C[i, j]), significantDigits=significantDigits)));
          end for;
          s := s + "\n";
        end for;
        //--------------------------------------------------------------------------------------------------------------------------------------------------
        s := s + "\n" + name + ".D = \n";
        //Horizontal
        // Two alternatives when printing state names
        if uNamesExist == false then
          s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
            "u1 ";
        else
          s := s + Strings.repeat(11 + significantDigits - min(Strings.length(ss.uNames[
            1]), 11)) + Strings.repeat(min(Strings.length(ss.uNames[1]), 11)) +
            " " + Strings.substring(
              ss.uNames[1],
              1,
              min(Strings.length(ss.uNames[1]), 11));
        end if;

        for i in 2:nu loop
          //Two alternatives when printing state names
          if uNamesExist == false then
            s := s + Strings.repeat(significantDigits + 11 - Strings.length("u"
               + String(i - 1))) + "u" + String(i) + " ";
          else
            s := s + " " + Strings.repeat(significantDigits + 11 - min(
              Strings.length(ss.uNames[i - 1]), 11)) + Strings.substring(
                ss.uNames[i],
                1,
                min(Strings.length(ss.uNames[i]), 11));
          end if;
        end for;
        s := s + "\n";
        for i in 1:ny loop
          //Vertical
          //Two alternatives when printing state names
          if yNamesExist == false then
            s := s + space + "y" + String(i) + " ";
          else
            s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
              ss.yNames[i]), 11)) + Strings.substring(
                ss.yNames[i],
                1,
                min(Strings.length(ss.yNames[i]), 11)) + " ";
          end if;

          for j in 1:nu loop
            if ss.D[i, j] >= 0 then
              s := s + " ";
            end if;
            s := s + String(ss.D[i, j], significantDigits=significantDigits) +
              Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
              ss.D[i, j]), significantDigits=significantDigits)));
          end for;
          s := s + "\n";
        end for;

      end if;

      annotation (Documentation(info="<html>
<p>
Returns a pretty formated string representing the input state space ss.
The operator is used by writing just the following command:
</p>
<blockquote><pre>
ss;
</pre></blockquote>
</html>"));
    end 'String';

    encapsulated package Analysis
      "Collection of functions to analyse state space system represented by a StateSpace record"
      import Modelica;
      extends Modelica.Icons.Package;

      function analysis
        "Perform a system analysis based on the poles and zeros of the system"

        import Modelica;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.Eigenvalue;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;
        import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2.Utilities.Plot;
        import DymolaCommands;

        input StateSpace ss;

        input Internal.AnalyseOptions analyseOptions=
            Modelica_LinearSystems2.Internal.AnalyseOptions(
                plotEigenValues=true,
                plotInvariantZeros=true,
                plotStepResponse=true,
                plotFrequencyResponse=true,
                printSystem=true,
                printEigenValues=true,
                printEigenValueProperties=true,
                printInvariantZeros=true,
                printControllability=true,
                printObservability=true,
                headingEigenValues="Eigenvalues",
                headingInvariantzeros="Invariant zeros",
                headingStepResponse="Step response",
                headingFrequencyResponse="Frequency response",
                dB_w = false);
        input String fileName="systemReport.html"
          "Name of html-file that contains eigenvalue table";
        input String systemName=""
          "Name of system (used as heading in html file)";
        input String description="" "Description of system (used in html file)";
    protected
        String dummyFileName="dummy" + fileName;
    public
        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros());

    protected
        StateSpace ssBalanced = StateSpace.Transformation.toBalancedForm(ss);
        Complex j=Modelica_LinearSystems2.Math.Complex.j();
        Eigenvalue ev[size(ss.A, 1)];
        Integer nx=size(ss.A, 1);
        Integer window=0;
        Real eval[nx, 2];
        Real revec[nx, nx];
        Real levec[nx, nx];
        Complex cev[size(ss.A, 1)];
        Complex systemZeros[:]=
            Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros(ssBalanced);
        Boolean isStable;
        Boolean isControllable;
        Boolean isStabilizable;
        Boolean isObservable;
        Boolean isDetectable;

        Real abs_evec[nx];
        String xNames2[nx];
        String heading="Eigenvalues" "Eigen values of system";
        Eigenvalue evSorted[size(ss.A, 1)];
        Integer evIndex[size(ss.A, 1)];
        Complex zerosSorted[:];
        Integer zerosIndex[size(systemZeros, 1)];
        Integer nReal;

        Integer i;
        Integer k;
        Complex evecComplex[size(ss.A, 1), size(ss.A, 1)];
        Plot.Records.Curve curves[2];
        Plot.Records.Diagram diagram2;
        Boolean instableZeros=false;

        String filePathOnly "NOT USED: Path to fileName";
        String fileNameOnly "Name of fileName without extension and path";
        String fileExtOnly "Extension of fileName";
        String fileNameImg "General name (without extension) of file for a plot";
        String fileNameImg2="none" "Current name of file for a plot";

        Internal.AnalyseOptions analyseOptions2=analyseOptions;
      algorithm
        // ---------------------------------------------------------------------------------------------------
        // The correct HTML format generated with this function can be checked with following commands:
        //   Modelica_LinearSystems2.StateSpace.Analysis.analysis(Modelica_LinearSystems2.StateSpace(A=[2,1,1;1,1,1;1,2,2], B=[1;2.2;3], C=[2,4,6;3,8,5], D=[6;4], yNames={"y1_test","y2_test"}, xNames={"xx1","xx2","xx3"}, uNames={"u1_test"}), description="Test file in HTML format from function 'analysis'.");
        //   Modelica_LinearSystems2.StateSpace.Analysis.analysis(Modelica_LinearSystems2.StateSpace(A=[2, 1.43, 12, 3; 1, 1, 1, 43; 1, 3, 2, 2; 1, 1, 4.2, 1.2], B=[1, 2; 2.2, 3; 3, 1; 4, 0], C=[25, 1.4, 6.3, 1; 0.3, 8, 5, 1; 1, 3, 2, 2], D=[6, 4; 4, 2; 6, 5], yNames={"y1_test","y2_te","y3_"}, xNames={"xx1","x2","xxx3","xx4"}, uNames={"u1_test","u2_test"}));
        // ---------------------------------------------------------------------------------------------------

        (filePathOnly,fileNameOnly,fileExtOnly) :=
          Modelica.Utilities.Files.splitPathName(fileName);
        fileNameImg := fileNameOnly;

        // If system has no inputs and outputs, modify analyze options that do not make sense
        if size(ss.B, 2) == 0 or size(ss.C, 1) == 0 then
          analyseOptions2.plotStepResponse := false;
          analyseOptions2.plotFrequencyResponse := false;
          analyseOptions2.printControllability := false;
          analyseOptions2.printObservability := false;
        end if;

        // If system has no states, modify analyze options that do not make sense
        if nx < 1 then
           analyseOptions2.plotEigenValues          :=false;
           analyseOptions2.plotInvariantZeros       :=false;
           analyseOptions2.printEigenValues         :=false;
           analyseOptions2.printEigenValueProperties:=false;
           analyseOptions2.printInvariantZeros      :=false;
        end if;

        // If system is too large, do not print A,B,C,D matrices
        if nx > 50 or size(ss.B, 2) > 50 or size(ss.C, 1) > 50 then
           analyseOptions2.printSystem:=false;
        end if;

        // Get eigenvalues
        // ---------------
        (eval,levec,revec) := Modelica_LinearSystems2.Math.Matrices.eigenValues(
          ss.A);

        for i in 1:nx loop
          cev[i].re := eval[i, 1];
          cev[i].im := eval[i, 2];
          ev[i].ev := cev[i];
        end for;

        (evSorted,evIndex) := Modelica_LinearSystems2.Internal.sortEigenvalue(ev);

        // Build x names
        // -------------
        if size(ss.xNames, 1) <> nx or nx > 1 and ss.xNames[1]=="" then
          for i in 1:nx loop
            xNames2[i] := "x[" + String(i) + "]";
          end for;
        else
          xNames2 := ss.xNames;
        end if;

        // Whole system checks
        // ===================
        // Stability check
        isStable := true;
        for i in 1:nx loop
          isStable := isStable and ev[i].ev.re < 0;
        end for;

        if size(ss.B, 2) > 0 and size(ss.C, 1) > 0 then
          // Controllability check, stabilizability check
          isControllable := StateSpace.Analysis.isControllable(ssBalanced);
          isStabilizable := StateSpace.Analysis.isStabilizable(ssBalanced);

          // Observability check, detectability check
          isObservable := StateSpace.Analysis.isObservable(ssBalanced);
          isDetectable := StateSpace.Analysis.isDetectable(ssBalanced);
        else
          isControllable := false;
          isStabilizable := false;
          isObservable := false;
          isDetectable := false;
        end if;

        // Analysis of single eingenvalues
        ev := StateSpace.Internal.characterizeEigenvalue(ss, ev);

        // Sort eigen values according to smallest imaginary value and restore the original order
        evSorted := Modelica_LinearSystems2.Internal.sortEigenvalue(ev);

        // Analysis file
        // -------------
        Modelica.Utilities.Files.removeFile(fileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);

        // Text should be printed into new file in HTML environment
        // --------------------------------------------------------
        StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
        StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);

        if analyseOptions2.printSystem then
          printSystem(
                ss,
                fileName,
                systemName,
                description);

          printSystem(
                ss,
                dummyFileName,
                systemName,
                description);
        end if;

        printHead1(
              ss,
              isStable,
              isControllable,
              isStabilizable,
              isObservable,
              isDetectable,
              fileName,
              analyseOptions=analyseOptions2);
        printHead1(
              ss,
              isStable,
              isControllable,
              isStabilizable,
              isObservable,
              isDetectable,
              dummyFileName,
              analyseOptions=analyseOptions2);
        StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);

        Modelica.Utilities.Streams.readFile(dummyFileName);

        // Plot step response
        // ------------------
        if analyseOptions2.plotStepResponse then
          Modelica.Utilities.Files.removeFile(dummyFileName);
          print(
            "<html>\n<body>\n<p>\n<b>Step responses</b>\n</p>\n</body>\n</html>",
            dummyFileName);
          Modelica.Utilities.Streams.readFile(dummyFileName);
          StateSpace.Plot.step(ss=ssBalanced);
          fileNameImg2 := fileNameImg + "Step.png";
          DymolaCommands.Plot.ExportPlotAsImage(fileName=fileNameImg2, id=-1, includeInLog=false);
          print("<p>\n<img src=\"" + fileNameImg2 + "\">\n</p>", fileName);
        end if;

        // Plot Bode plots
        if analyseOptions2.plotFrequencyResponse then
          Modelica.Utilities.Files.removeFile(dummyFileName);
          print("<html>\n<body>\n<p>\n<b>Bode plots</b>\n</p>\n</body>\n</html>",
            dummyFileName);
          Modelica.Utilities.Streams.readFile(dummyFileName);
          StateSpace.Plot.bodeMIMO(ss=ss, Hz=not analyseOptions.dB_w, dB=analyseOptions.dB_w);
          //     fileNameImg2 := fileNameImg + "BodeMIMO1.png";
          //     ExportPlotAsImage(
          //       fileName=fileNameImg2,
          //       id=-1,
          //       includeInLog=false);
        end if;

        // Calculate the number of real eigenvalues
        nReal := Modelica_LinearSystems2.Internal.numberOfRealZeros(cev);

        // Construct complex eigenvector matrix
        i := 1;
        while i <= nx loop
          if eval[i, 2] == 0.0 then

            for jj in 1:nx loop
              evecComplex[jj, i] := revec[jj, i] + 0*j;
            end for;
            i := i + 1;
          else
            for jj in 1:nx loop
              evecComplex[jj, i] := revec[jj, i] + revec[jj, i + 1]*j;
              evecComplex[jj, i + 1] := revec[jj, i] - revec[jj, i + 1]*j;
            end for;
            i := i + 2;
          end if;
        end while;

        if analyseOptions2.printEigenValues then
          printHead2a(
                fileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal > 0));
          if nReal > 0 then
            printTab1(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  fileName,
                  analyseOptions=analyseOptions2);
          end if;

          Modelica.Utilities.Files.removeFile(dummyFileName);
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead2a(
                dummyFileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal > 0));
          if nReal > 0 then
            printTab1(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  dummyFileName,
                  analyseOptions=analyseOptions2);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
          Modelica.Utilities.Streams.readFile(dummyFileName);

          printHead2b(
                fileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal < nx));
          if nReal < nx then
            printTab2(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  fileName,
                  analyseOptions=analyseOptions2);
          end if;

          Modelica.Utilities.Files.removeFile(dummyFileName);
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead2b(
                dummyFileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal < nx));
          if nReal < nx then
            printTab2(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  dummyFileName,
                  analyseOptions=analyseOptions2);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
          Modelica.Utilities.Streams.readFile(dummyFileName);

         // Plot eigenvalues and invariant zeros
         if analyseOptions2.plotEigenValues or
            analyseOptions2.plotInvariantZeros and size(systemZeros, 1) > 0 then
            i := 0;
            if analyseOptions2.plotEigenValues then
              i := i + 1;
              curves[i] := Plot.Records.Curve(
                    x=eval[:, 1],
                    y=eval[:, 2],
                    legend="poles",
                    autoLine=false,
                    linePattern=Plot.Types.LinePattern.None,
                    lineSymbol=Plot.Types.PointSymbol.Cross);
            end if;

            // Plot invariant zeros
            if size(systemZeros, 1) > 0 and analyseOptions2.plotInvariantZeros then
              i := i + 1;
              curves[i] := Plot.Records.Curve(
                    x=systemZeros[:].re,
                    y=systemZeros[:].im,
                    legend="zeros",
                    autoLine=false,
                    linePattern=Plot.Types.LinePattern.None,
                    lineSymbol=Plot.Types.PointSymbol.Circle);
            end if;

            diagram2 := defaultDiagram;
            diagram2.curve := curves[1:i];
            Plot.diagram(diagram2, device);
          end if;

          if analyseOptions2.printEigenValueProperties then
            printHead3(fileName);
            printTab3(
                  evSorted,
                  evecComplex,
                  evIndex,
                  cev,
                  nReal,
                  xNames2,
                  fileName);

            Modelica.Utilities.Files.removeFile(dummyFileName);
            StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
            printHead3(dummyFileName);
            printTab3(
                  evSorted,
                  evecComplex,
                  evIndex,
                  cev,
                  nReal,
                  xNames2,
                  dummyFileName);
            StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
            Modelica.Utilities.Streams.readFile(dummyFileName);

          end if;
        end if;

        // ZEROS
        (zerosSorted,zerosIndex) :=
          Modelica_LinearSystems2.Math.Complex.Vectors.sortComplex(systemZeros);
        nReal := Modelica_LinearSystems2.Internal.numberOfRealZeros(zerosSorted);

        if analyseOptions2.printInvariantZeros then
          printHead4(fileName, printTable=(size(systemZeros, 1) > 0));
          if size(systemZeros, 1) > 0 then
            Modelica_LinearSystems2.StateSpace.Analysis.analysis.printTab4(
                  zerosSorted,
                  zerosIndex,
                  nReal,
                  fileName);
          end if;

          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead4(dummyFileName, printTable=(size(systemZeros, 1) > 0));
          if size(systemZeros, 1) > 0 then
            printTab4(
                  zerosSorted,
                  zerosIndex,
                  nReal,
                  dummyFileName);
          end if;
          k := 0;
          for i in 1:size(systemZeros, 1) loop
            if systemZeros[i].re > 0 then
              k := k + 1;
            end if;
          end for;
          if k > 0 then
            print("<p>\n<b>Note, that the system has " + String(k) +
              " zeros in the right complex half-plane.</b>\n</p>", fileName);
            print("<p>\n<b>Note, that the system has " + String(k) +
              " zeros in the right complex half-plane.</b>\n</p>", dummyFileName);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);

        end if;
        Modelica.Utilities.Streams.readFile(dummyFileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);

        print("\n\nAnalysis results have been written to file \"" +
          Modelica.Utilities.Files.fullPathName(fileName) + "\"");

        // Last print of HTML environment
        // --------------------------------------------------------
        StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);

        // SUB FUNCTIONS

    public
        encapsulated function printSystem
          "Print the state space system in html format on file"
          import Modelica;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;
          import Modelica_LinearSystems2;

          input StateSpace ss "State space system to analyze";
          input String fileName="systemAnalysis.html"
            "File on which the state space system is written in html format";
          input String systemName="State Space System"
            "Name of the state space system";
          input String description="" "Description of system (used in html file)";
          input String format=".6g" "Format of numbers (e.g. \"20.8e\")";

          input Boolean htmlBasics=false
            "True, if text should be printed within 'html' and 'body' environment, otherwise text printed into existing file fileName"
            annotation (Dialog(group="HTML format"));
          input Integer hSize(
            min=1,
            max=5) = 1
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));
      protected
          Integer nx=size(ss.A, 1);
          Integer nu=size(ss.B, 2);
          Integer ny=size(ss.C, 1);
          Integer c1=integer(ceil(nx/2) - 1);
          Integer c2=integer(ceil(ny/2) - 1);
          Integer dist=2;
          Boolean centered=true
            "True, if matrices columns should be centered, otherwise right aligned";

          String td_align=if centered then "  <td style=\"text-align:center\">"
               else "  <td style=\"text-align:right\">";

      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 4 then 4 else hSize;
          String heading="h" + String(hSizeOK);
          String heading2="h" + String(hSizeOK + 1);
          String heading3="h" + String(hSizeOK + 2);
          Boolean printIndices;

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(Modelica_LinearSystems2.StateSpace(A=[2,1,1;1,1,1;1,2,2], B=[1;2.2;3], C=[2,4,6;3,8,5], D=[6;4], yNames={"y1_test","y2_test"}, xNames={"xx1","xx2","xx3"}, uNames={"u1_test"}));
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(Modelica_LinearSystems2.StateSpace(A=[2, 1.43, 12, 3; 1, 1, 1, 43; 1, 3, 2, 2; 1, 1, 4.2, 1.2], B=[1, 2; 2.2, 3; 3, 1; 4, 0], C=[25, 1.4, 6.3, 1; 0.3, 8, 5, 1; 1, 3, 2, 2], D=[6, 4; 4, 2; 6, 5], yNames={"y1_test","y2_te","y3_"}, xNames={"xx1","x2","xxx3","xx4"}, uNames={"u1_test","u2_test"}));
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(ss=Modelica_LinearSystems2.StateSpace.Import.fromModel("Modelica.Mechanics.Rotational.Examples.First"), description="Test file in HTML format from function printSystem.");
          // ---------------------------------------------------------------------------------------------------

          if htmlBasics then
            // Text should be printed into new file in HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
          end if;

          print("<" + heading + ">System report</" + heading + ">", fileName);
          print("\n<" + heading2 + ">General information</" + heading2 + ">",
            fileName);
          //print("<h1>System report</h1>", fileName);
          //print("\n<h2>General information</h2>", fileName);

          if systemName == "" then
          else
            print("\n<" + heading3 + ">System name</" + heading3 + ">", fileName);
            //print("\n<h3>System name</h3>", fileName);
            print("<p>\n" + systemName + "\n</p>", fileName);
          end if;

          if description == "" then
          else
            print("\n<" + heading3 + ">Description</" + heading3 + ">", fileName);
            //print("\n<h3>Description</h3>", fileName);
            print("<p>\n" + description + "\n</p>", fileName);
          end if;

          print("\n<" + heading3 + ">Matrices</" + heading3 + ">", fileName);
          //print("\n<h3>Matrices</h3>", fileName);
          print(
            "<p>\nThe system described in the state space representation\n</p>",
            fileName);
          print(
            "<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin: 20px 0 20px 20px\" "
             + "cellpadding=\"3\" border=\"0\"> ", fileName);
          print("<tr><td>der(x) </td> <td>=</td> <td> Ax</td> <td> +</td><td> Bu</td></tr>
         <tr><td> y </td>     <td>=</td> <td> Cx</td> <td> + </td><td>Du</td></tr>",
            fileName);
          print("</table>\n<p>\nis defined by\n</p>", fileName);

          // ===============================
          // Print signal names and matrices (print row and column indices if at least one matrix has more as 5 elements)
          // ===============================
          printIndices := size(ss.A, 1) > 5 or size(ss.B, 2) > 5 or size(ss.C, 1)
             > 5;
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.uNames,
                  "uNames",
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.yNames,
                  "yNames",
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.xNames,
                  "xNames",
                  fileName=fileName,
                  printIndices=printIndices);

          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.A,
                  "A",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.B,
                  "B",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.C,
                  "C",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.D,
                  "D",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);

          if ny == 0 and nu == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has neither inputs nor outputs (and therefore matrices B, C, and D are empty matrices)!\n</p>",
              fileName);
          elseif ny == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has no outputs (and therefore matrices C and D are empty matrices)!\n</p>",
              fileName);
          elseif nu == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has no inputs (and therefore matrices B and D are empty matrices)!\n</p>",
              fileName);
          end if;

          if htmlBasics then
            // Last print of HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);
          end if;

        end printSystem;

        encapsulated function printHead1
          "Print the heading of document for characteristics in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input StateSpace ss;
          // This could be deleted sinc not used. But for reasons of beackward compatibility it is still here.
          input Boolean isStable;
          input Boolean isControllable;
          input Boolean isStabilizable;
          input Boolean isObservable;
          input Boolean isDetectable;
          input String fileName="systemHead1.html"
            "File on which the information is written in html format";

          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

          input Boolean htmlBasics=false
            "True, if text should be printed within 'html' and 'body' environment, otherwise text printed into existing file fileName"
            annotation (Dialog(group="HTML format"));
          input Integer hSize(
            min=1,
            max=5) = 2
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));

      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 5 then 5 else hSize;
          String heading="h" + String(hSizeOK);

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead1(Modelica_LinearSystems2.StateSpace(A=[2], B=[1], C=[1], D=[1]), false, false, false, true, false, htmlBasics=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          if htmlBasics then
            // Text should be printed into new file in HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
          end if;

          print("\n<" + heading + ">Characteristics</" + heading +
            ">\n<p>\nThe system\n</p>\n<p> is ", fileName);

          if analyseOptions.printControllability and analyseOptions.printObservability then
            print((if isStable then " " else "<b>not</b> ") + "stable" + "\n<br>"
               + (if isStable then if isControllable then "and it is " else
              "but it is <b>not</b> " else if isControllable then "but it is "
               else "and it is <b>not</b> ") + "controllable" + (if isStable
               then "" else "\n<br>" + (if isControllable then
              " and therefore it is " else if isStabilizable then " but it is "
               else "and is <b>not</b> ") + "stabilizable.") +
              "\n<br> The system is " + (if isObservable then " " else
              "<b>not</b> ") + "observable" + (if isStable then "" else "\n<br>"
               + (if isObservable then " and therefore it is " else if
              isDetectable then " but it is " else "and is <b>not</b> ") +
              "detectable.") + "\n<br>", fileName);
          elseif not analyseOptions.printObservability and analyseOptions.printControllability then
            print((if isStable then " " else "<b>not</b> ") + "stable" + "\n<br>"
               + (if isStable then if isControllable then "and it is " else
              "but it is <b>not</b> " else if isControllable then "but it is "
               else "and it is <b>not</b> ") + "controllable" + (if isStable
               then "" else "\n<br>" + (if isControllable then
              " and therefore it is " else if isStabilizable then " but it is "
               else "and is <b>not</b> ") + "stabilizable.") + "\n<br>", fileName);
          elseif not analyseOptions.printControllability and analyseOptions.printObservability then
            print((if isStable then " " else "<b>not</b> ") + "stable." +
              "\n<br> The system is " + (if isObservable then " " else
              "<b>not</b> ") + "observable" + (if isStable then "" else "\n<br>"
               + (if isObservable then " and therefore it is " else if
              isDetectable then " but it is " else "and is <b>not</b> ") +
              "detectable.") + "\n<br>", fileName);
          else
            print((if isStable then " " else "<b>not</b> ") + "stable." +
              "\n<br>", fileName);
          end if;

          print("</p>", fileName);

          if htmlBasics then
            // Last print of HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);
          end if;

        end printHead1;

        encapsulated function printHead2a
          "Print the heading of document for eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input String fileName="systemHead2a.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

          input Boolean printTable=true
            "True, if the system has real eigenvalues to be printed in table";
          input Integer hSize(
            min=1,
            max=5) = 3
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));
      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 5 then 5 else hSize;
          String heading="h" + String(hSizeOK);

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead2a(htmlBasics=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          print("\n<" + heading + ">Eigenvalues analysis</" + heading + ">",
            fileName);
          //print("<p>\n<b>Real eigenvalues</b>\n</p>", fileName);

          if printTable then
            print("<p>The system has the following real eigenvalues.</p>",
              fileName);
            print(
              "<table style=\"background-color:rgb(100, 100, 100); margin: 20px 0 20px 20px\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Real eigenvalues</caption>", fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> eigenvalue </td>\n  <td> T [s] </td>\n  <td> characteristics </td>",
              fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td> contribution to states</td>", fileName);
            end if;

            print("</tr>", fileName);
          else
            print("<p>\nThe system has no real eigenvalues.\n</p>", fileName);
          end if;

        end printHead2a;

        encapsulated function printHead2b
          "Print the heading of document for conjugated complex pairs in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;

          input String fileName="systemHead2b.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");
          input Boolean printTable=true
            "True, if the system has complex pairs to be printed in table";

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead2b();
          // ---------------------------------------------------------------------------------------------------

          if printTable then
            print(
              "<p>The system has the following complex conjugate pairs of eigenvalues.<br>&nbsp;</p>",
              fileName);
            print(
              "<table style=\"background-color:rgb(100, 100, 100); margin: 20px 0 20px 20px\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Complex conjugate pairs of eigenvalues</caption>",
              fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> eigenvalue </td>\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n  <td> characteristics </td>",
              fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td> contribution to states</td>", fileName);
            end if;

            print("</tr>", fileName);
          else
            print(
              "<p>\nThe system has no complex conjugate eigenvalue pairs.\n</p>",
              fileName);
          end if;

        end printHead2b;

        encapsulated function printHead3
          "Print the heading of document for description in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;

          input String fileName="systemHead3.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

        algorithm
          print(
            "<p>\nIn the tables above, the column <b>contribution to states</b> lists for each eigenvalue the states to which the"
             +
            " corresponding modal state z[i] contributes most. This information is based on the"
             +
            " two largest absolute values of the corresponding right eigenvector (if the second large value"
             +
            " is less than 5&nbsp;% of the largest contribution, it is not shown). Note"
             +
            " the <b>right eigenvector</b> v<sub>j</sub> and the <b>left eigenvector</b> u<sub>j</sub> of A satisfy the"
             +
            " following relationships with regards to <b>eigenvalue</b> &lambda;<sub>j</sub>,"
             +
            " state vector x and modal state vector z (u<sub>j</sub><sup>H</sup> denotes the conjugate transpose of u<sub>j</sub>):"
             + " </p>" +
            " <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\">" +
            " <tr><td width=\"50\"></td>" +
            "\n    <td>A * v<sub>j</sub> = &lambda;<sub>j</sub> * v<sub>j</sub>; &nbsp;&nbsp;&nbsp;&nbsp;"
             +
            "         u<sub>j</sub><sup>H</sup> * A = &lambda;<sub>j</sub> * u<sub>j</sub><sup>H</sup>; &nbsp;&nbsp;&nbsp;&nbsp;"
             +
            "               x = V * z; &nbsp;&nbsp;&nbsp;&nbsp; V = [v<sub>1</sub>, v<sub>2</sub>, ...]</td>"
             + "           </tr>" + "\n</table>" + "\n<p>" +
            "\nIn the next table, for each state in the column <b>correlation to modal states</b>, the modal"
             +
            " states z[i] which contribute most to the corresponding state are summarized, that is"
             + " the state is mostly composed of these modal states." +
            "\nThis information is based on the two largest absolute values of row i of the"
             +
            " eigenvector matrix that is associated with eigenvalue i (if the second large value"
             +
            " is less than 5&nbsp;% of the largest contribution, it is not shown). This only holds"
             +
            " if the modal states z[i] are in the same order of magnitude. Otherwise, the listed modal states"
             + " might be not the most relevant ones.</p>", fileName);

          print(
            "<table style=\"background-color:rgb(100, 100, 100); margin: 20px 0 20px 20px\" "
             + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">\n" +
            "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
             +
            "\n  <td> state </td>\n  <td> correlation to modal states </td>\n  <td> eigenvalue # </td>"
             +
            "\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n  <td> T [s] </td>\n</tr>",
            fileName);

        end printHead3;

        encapsulated function printHead4
          "Print the heading of document for invariant zeros in html format on file"
          import Modelica;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input String fileName="systemHead4.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");
          input Boolean printTable=true
            "True, if the system has complex pairs to be printed in table";

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead4(htmlEnv=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          if printTable then
            print("<p>The system has the following invariant zeros.<br>&nbsp;</p>",
              fileName);
            print(
              "\n<table style=\"background-color:rgb(100, 100, 100); margin: 20px 0 20px 20px\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Invariant zeros</caption>", fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> invariant zero </td>\n  <td> Time constant [s] </td>"
               + "\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n</tr>",
              fileName);
          else
            print("<p>\nThe system has no invariant zeros.\n</p>", fileName);
          end if;

        end printHead4;

        encapsulated function printHTMLbasics
          "Print the html preamble or ending on file"
          import Modelica.Utilities.Files;
          import Modelica.Utilities.Streams;

          input String fileName="systemReport.html"
            "File on which the html basics should be written";
          input Boolean printBegin=false
            "True, if beginning of a html file should be printed, otherwise the ending"
            annotation (choices(checkBox=true));

        algorithm
          if printBegin then
            // First print of HTML environment into new file
            Files.removeFile(fileName);
            // Following doesn't work in Dymola
            //Streams.print("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">", fileName);
            Streams.print("<html>", fileName);
            Streams.print(
              "<head>\n  <title>Analysis of a state space system from Modelica LinearSystems2</title>\n</head>",
              fileName);
            Streams.print("<style type=\"text/css\">", fileName);
            Streams.print("* { font-size: 10pt; font-family: Arial,sans-serif; }",
              fileName);
            Streams.print("</style>", fileName);
          else
            // Last print of HTML environment
            Streams.print("</html>", fileName);
          end if;
        end printHTMLbasics;

        encapsulated function printTab1
          "Print the table with real eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Integer evIndex[size(evSorted, 1)];
          input Real r_evec[size(evSorted, 1), size(evSorted, 1)];
          input Real l_evec[size(evSorted, 1), size(evSorted, 1)];
          input Integer nReal;
          input String xNames2[size(evSorted, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evSorted, 1);
          Real w;
          Real d;

          Integer i;
          Integer j;
          Integer k;
          String number;

          Real r_abs_evec[nx];
          Real l_abs_evec[nx];
          Integer r_maxIndex1;
          Integer l_maxIndex1;
          Integer r_maxIndex2;
          Integer l_maxIndex2;
          //  Complex v_normalized[size(evSorted,1)];
          Real r_abs_v_normalized;
          Real l_abs_v_normalized;
          Real r_v;
          Real l_v;
          Real r_absMax1;
          Real l_absMax1;
          Real r_absMax2;
          Real l_absMax2;
          Boolean r_two;
          Boolean l_two;
          Boolean r_first;
          Boolean l_first;

        algorithm
          i := 1;
          j := i;
          while i <= nReal loop
            // Build eigenvalue number

            number := String(
                    i,
                    minimumLength=7,
                    leftJustified=false);
            j := j + 1;

            // Determine largest value in eigenvector
            k := evIndex[i] "Index with respect to unsorted eigen values";
            r_abs_evec := abs(r_evec[:, k]);
            l_abs_evec := abs(l_evec[:, k]);

            r_first := true;
            r_two := false;
            r_absMax1 := 0;
            r_maxIndex1 := 0;
            r_absMax2 := 0;
            r_maxIndex2 := 0;
            r_abs_v_normalized := Modelica.Math.Vectors.norm(r_abs_evec, 1);

            l_first := true;
            l_two := false;
            l_absMax1 := 0;
            l_maxIndex1 := 0;
            l_absMax2 := 0;
            l_maxIndex2 := 0;
            l_abs_v_normalized := Modelica.Math.Vectors.norm(l_abs_evec, 1);
            for j in 1:nx loop
              r_v := r_abs_evec[j];
              l_v := l_abs_evec[j];

              if r_first then
                r_first := false;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif not r_two then
                r_two := true;
                if r_v < r_absMax1 then
                  r_absMax2 := r_v;
                  r_maxIndex2 := j;
                else
                  r_absMax2 := r_absMax1;
                  r_maxIndex2 := r_maxIndex1;
                  r_absMax1 := r_v;
                  r_maxIndex1 := j;
                end if;
              elseif r_v > r_absMax1 then
                r_absMax2 := r_absMax1;
                r_maxIndex2 := r_maxIndex1;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif r_v > r_absMax2 then
                r_absMax2 := r_v;
                r_maxIndex2 := j;
              end if;

              if l_first then
                l_first := false;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif not l_two then
                l_two := true;
                if l_v < l_absMax1 then
                  l_absMax2 := l_v;
                  l_maxIndex2 := j;
                else
                  l_absMax2 := l_absMax1;
                  l_maxIndex2 := l_maxIndex1;
                  l_absMax1 := l_v;
                  l_maxIndex1 := j;
                end if;
              elseif l_v > l_absMax1 then
                l_absMax2 := l_absMax1;
                l_maxIndex2 := l_maxIndex1;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif l_v > l_absMax2 then
                l_absMax2 := l_v;
                l_maxIndex2 := j;
              end if;

            end for;

            r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
            r_absMax2 := 100*r_absMax2/r_abs_v_normalized;

            if r_absMax2 < 0.05*r_absMax1 then
              r_two := false;
            end if;

            l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
            l_absMax2 := 100*l_absMax2/l_abs_v_normalized;

            if l_absMax2 < 0.05*l_absMax1 then
              l_two := false;
            end if;

            // Print data for one eigen value
            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:center\"> "
               + number + " </td>\n  <td style=\"text-align:left\"> &nbsp; " +
              String(evSorted[i].ev.re, format="14.4e") +
              " </td>\n  <td style=\"text-align:left\"> &nbsp; " + (if evSorted[i].timeConstant
               < 1e6 then String(evSorted[i].timeConstant, format="9.4f") else
              "---") + " </td>\n  <td style=\"text-align:left\"> &nbsp; " + (if
              evSorted[i].isStable then "" else "not ") + "stable, " + (if
              evSorted[i].isStable then (if evSorted[i].isControllable then ""
               else "not ") + "controllable, " else (if evSorted[i].isStabilizable
               then "" else "not ") + "stabilizable, ") + (if evSorted[i].isStable
               then (if evSorted[i].isObservable then "" else "not ") +
              "observable " else (if evSorted[i].isDetectable then "" else "not ")
               + "detectable ") + " </td>", fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td style=\"text-align:left\"> &nbsp; " + " z[" + String(i)
                 + "]" + " contributes to " + xNames2[r_maxIndex1] + " with " +
                String(r_absMax1, format=".3g") + " %<br>" + (if r_two then
                "&nbsp; " + " z[" + String(i) + "]" + " contributes to " +
                xNames2[r_maxIndex2] + " with " + String(r_absMax2, format=".3g")
                 + " %" else "") + " </td>", fileName);
            end if;

            print("</tr>", fileName);

            i := j;
          end while;

          print("</table>", fileName);
        end printTab1;

        encapsulated function printTab2
          "Print the table with complex conjugate eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Integer evIndex[size(evSorted, 1)];
          input Real r_evec[size(evSorted, 1), size(evSorted, 1)];
          input Real l_evec[size(evSorted, 1), size(evSorted, 1)];
          input Integer nReal;
          input String xNames2[size(evSorted, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evSorted, 1);

          Integer i;
          Integer k;
          String number;
          String number2;
          Integer j;

          Real r_abs_evec[nx];
          Real l_abs_evec[nx];
          Integer r_maxIndex1;
          Integer r_maxIndex2;
          Integer l_maxIndex1;
          Integer l_maxIndex2;
          Real r_abs_v_normalized;
          Real l_abs_v_normalized;
          Real r_v;
          Real l_v;
          Real r_absMax1;
          Real r_absMax2;
          Real l_absMax1;
          Real l_absMax2;
          Boolean r_two;
          Boolean l_two;
          Boolean r_first;
          Boolean l_first;

        algorithm
          i := nReal + 1;
          j := i;
          while i <= nx loop
            // Build eigenvalue number
            number := String(i) + "/" + String(i + 1);
            number2 := number;
            number := Strings.repeat(max(0, 7 - Strings.length(number))) + number;
            j := j + 2;

            // Determine largest value in eigenvector
            k := evIndex[i] "Index with respect to unsorted eigen values";

            for i2 in 1:nx loop
              r_abs_evec[i2] := sqrt(r_evec[i2, k]^2 + r_evec[i2, k + 1]^2);
              l_abs_evec[i2] := sqrt(l_evec[i2, k]^2 + l_evec[i2, k + 1]^2);
            end for;

            r_first := true;
            r_two := false;
            r_absMax1 := 0;
            r_maxIndex1 := 0;
            r_absMax2 := 0;
            r_maxIndex2 := 0;
            r_abs_v_normalized := Modelica.Math.Vectors.norm(r_abs_evec, 1);
            l_first := true;
            l_two := false;
            l_absMax1 := 0;
            l_maxIndex1 := 0;
            l_absMax2 := 0;
            l_maxIndex2 := 0;
            l_abs_v_normalized := Modelica.Math.Vectors.norm(l_abs_evec, 1);

            for j in 1:nx loop
              r_v := r_abs_evec[j];
              l_v := l_abs_evec[j];

              if r_first then
                r_first := false;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif not r_two then
                r_two := true;
                if r_v < r_absMax1 then
                  r_absMax2 := r_v;
                  r_maxIndex2 := j;
                else
                  r_absMax2 := r_absMax1;
                  r_maxIndex2 := r_maxIndex1;
                  r_absMax1 := r_v;
                  r_maxIndex1 := j;
                end if;
              elseif r_v > r_absMax1 then
                r_absMax2 := r_absMax1;
                r_maxIndex2 := r_maxIndex1;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif r_v > r_absMax2 then
                r_absMax2 := r_v;
                r_maxIndex2 := j;
              end if;

              if l_first then
                l_first := false;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif not l_two then
                l_two := true;
                if l_v < l_absMax1 then
                  l_absMax2 := l_v;
                  l_maxIndex2 := j;
                else
                  l_absMax2 := l_absMax1;
                  l_maxIndex2 := l_maxIndex1;
                  l_absMax1 := l_v;
                  l_maxIndex1 := j;
                end if;
              elseif l_v > l_absMax1 then
                l_absMax2 := l_absMax1;
                l_maxIndex2 := l_maxIndex1;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif l_v > l_absMax2 then
                l_absMax2 := l_v;
                l_maxIndex2 := j;
              end if;

            end for;
            r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
            r_absMax2 := 100*r_absMax2/r_abs_v_normalized;
            if r_absMax2 < 0.05*r_absMax1 then
              r_two := false;
            end if;

            l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
            l_absMax2 := 100*l_absMax2/l_abs_v_normalized;
            if l_absMax2 < 0.05*l_absMax1 then
              l_two := false;
            end if;

            // Print data for one eigen value
            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> "
               + number + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(evSorted[i].ev.re, format="14.4e") + " &plusmn; " +
              String(evSorted[i].ev.im, format="12.4e") + "j" + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(evSorted[i].frequency,
              format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(evSorted[i].damping,
              format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + (if evSorted[i].isStable
               then "" else "not ") + "stable, " + (if evSorted[i].isStable then
              (if evSorted[i].isControllable then "" else "not ") +
              "controllable, " else (if evSorted[i].isStabilizable then "" else
              "not ") + "stabilizable, ") + (if evSorted[i].isStable then (if
              evSorted[i].isObservable then "" else "not ") + "observable " else
              (if evSorted[i].isDetectable then "" else "not ") + "detectable ")
               + " </td>", fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td style=\"text-align:left\"> &nbsp; " + " z[" + number2
                 + "]" + " contribute to " + xNames2[r_maxIndex1] + " with " +
                String(r_absMax1, format=".3g") + " %<br>" + (if r_two then
                "&nbsp; " + " z[" + number2 + "]" + " contribute to " + xNames2[
                r_maxIndex2] + " with " + String(r_absMax2, format=".3g") + " %"
                 else "") + " </td>", fileName);
            end if;

            print("</tr>", fileName);

            i := j;
          end while;

          print("</table>", fileName);
        end printTab2;

        encapsulated function printTab3
          "Print the table with eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Complex evecComplex[:, :];
          input Integer evIndex[size(evecComplex, 1)];
          input Complex cev[size(evecComplex, 1)];
          input Integer nReal;
          input String xNames2[size(evecComplex, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evecComplex, 1);

          Integer maxIndex1;
          Integer maxIndex2;

          Complex v_normalized[size(evecComplex, 1)];
          Real abs_v_normalized;
          Real v;
          Real absMax1;
          Real absMax2;
          Boolean two;
          Boolean first;
          Integer j;
          Integer k;
          Integer iw1;
          Integer iw2;
          String number1;
          String number2;
          Real w1;
          Real w2;
          Real d1;
          Real d2;

        algorithm
          for i in 1:nx loop
            // Normalize i-th row of complex eigenvector matrix and determine two largest elements
            v_normalized := Complex.Vectors.normalize(evecComplex[i, :]);
            first := true;
            two := false;
            absMax1 := 0;
            maxIndex1 := 0;
            absMax2 := 0;
            maxIndex2 := 0;
            j := 1;
            abs_v_normalized := Complex.Vectors.norm(v_normalized, 1);
            while j <= nx loop
              if cev[j].im == 0 then
                v := abs(v_normalized[j].re);
                k := j;
                j := j + 1;
              else
                v := 2*Complex.'abs'(v_normalized[j]);
                k := j;
                j := j + 2;
              end if;

              if first then
                first := false;
                absMax1 := v;
                maxIndex1 := k;
              elseif not two then
                two := true;
                if v < absMax1 then
                  absMax2 := v;
                  maxIndex2 := k;
                else
                  absMax2 := absMax1;
                  maxIndex2 := maxIndex1;
                  absMax1 := v;
                  maxIndex1 := k;
                end if;
              elseif v > absMax1 then
                absMax2 := absMax1;
                maxIndex2 := maxIndex1;
                absMax1 := v;
                maxIndex1 := k;
              elseif v > absMax2 then
                absMax2 := v;
                maxIndex2 := k;
              end if;
            end while;

            if abs_v_normalized > 1e-30 then
              absMax1 := absMax1/abs_v_normalized;
              absMax2 := absMax2/abs_v_normalized;
            end if;

            if absMax2 < 0.05*absMax1 then
              two := false;
            end if;

            // Determine frequency and number of corresponding eigenvalue
            (w1,d1) := Complex.frequency(cev[maxIndex1]);
            iw1 := Modelica.Math.Vectors.find(maxIndex1, evIndex);
            if iw1 <= nReal then
              number1 := String(iw1);
            else
              number1 := String(iw1) + "/" + String(iw1 + 1);
            end if;

            if two then
              (w2,d2) := Complex.frequency(cev[maxIndex2]);
              iw2 := Modelica.Math.Vectors.find(maxIndex2, evIndex);
              if iw2 <= nReal then
                number2 := String(iw2);
              else
                number2 := String(iw2) + "/" + String(iw2 + 1);
              end if;
            end if;

            if two then
              print(
                "<tr style=\"background-color:white\">\n  <td rowspan=2 style=\"text-align:left\"> &nbsp; "
                 + xNames2[i] + " </td>" +
                "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax1, format="5.1f") + "% by z[" + number1 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number1 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(w1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(d1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then String(evSorted[i].timeConstant, format="9.4f") else
                "--- </td>") + "\n</tr>\n<tr style=\"background-color:white\">"
                 + "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax2, format="5.1f") + "% by z[" + number2 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number2 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw2 <= nReal
                 then "---" else String(w2, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw2 <= nReal
                 then "---" else String(d2, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if (iw2 <=
                nReal and abs(cev[maxIndex2].re) > 1e-10) then String(1/abs(cev[
                maxIndex2].re), format="9.4f") else "--- </td>\n</tr>"), fileName);
            else
              print(
                "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
                 + xNames2[i] + " </td>" +
                "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax1, format="5.1f") + "% by z[" + number1 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number1 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(w1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(d1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then String(evSorted[i].timeConstant, format="9.4f") else
                "--- </td>\n</tr>"), fileName);
            end if;
            //     print("<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; " + xNames2[i] + " </td>\n  <td style=\"text-align:left\"> &nbsp; "
            //        + " is composed of " + String(100*absMax1, format="5.1f") + "% by z[" +
            //       number1 + "]" + (if two then " <br>" + " &nbsp; " + " is composed of " +
            //       String(100*absMax2, format="5.1f") + "% by z[" + number2 + "]" else "") + " </td> <td style=\"text-align:center\"> &nbsp; "
            //        + number1 + (if two then "<br> &nbsp; " + number2 else Strings.repeat(9))
            //        + " </td> <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal then
            //             "---" else String(w1, format="9.4f")) + (if two then "<br> &nbsp; "
            //        + (if iw2 <= nReal then "---" else String(w2, format="9.4f")) else
            //       Strings.repeat(9)) + " </td>\n  <td style=\"text-align:center\"> &nbsp; " +
            //       (if iw1 <= nReal then "---" else String(d1, format="9.4f")) + (if two then
            //             "<br> &nbsp; " + (if iw2 <= nReal then "---" else String(d2,
            //       format="9.4f")) else "") + " </td>\n  <td style=\"text-align:center\"> &nbsp; "
            //        + (if (iw1 <= nReal) then String(evSorted[i].timeConstant, format="9.4f") else
            //             "---") + (if two then "<br> &nbsp; " + (if (iw2 <= nReal and abs(
            //       cev[maxIndex2].re) > 1e-10) then String(1/abs(cev[maxIndex2].re),
            //       format="9.4f") else "---") else "") + " </td>\n</tr> ", fileName);

          end for;
          print("</table>", fileName);

        end printTab3;

        encapsulated function printTab4
          "Print the table with eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Complex systemZeros[:];
          input Integer evIndex[size(systemZeros, 1)];
          input Integer nReal;
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nz=size(systemZeros, 1);

          String number;
          Real timeConstant;
          Real freq;
          Real damp;

        algorithm
          for i in 1:nReal loop
            // Build eigenvalue number

            number := String(
                    i,
                    minimumLength=7,
                    leftJustified=false);
            timeConstant := if abs(systemZeros[i].re) > 10*Modelica.Constants.eps
               then 1/abs(systemZeros[i].re) else 1/(10*Modelica.Constants.eps);

            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
               + number + " </td>" + "\n  <td> &nbsp; " + String(systemZeros[i].re,
              format="14.4e") + " </td>" + "\n  <td> &nbsp; " + String(
              timeConstant, format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>\n</tr>",
              fileName);

          end for;

          for i in nReal + 1:2:nz loop
            number := String(i) + "/" + String(i + 1);
            number := Strings.repeat(max(0, 7 - Strings.length(number))) + number;

            // Determine frequency and number of corresponding zero
            (freq,damp) := Complex.frequency(systemZeros[i]);

            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
               + number + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(systemZeros[i].re, format="14.4e") + " &plusmn; " +
              String(systemZeros[i].im, format="12.4e") + "j </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(freq, format=
              "9.4f") + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(damp, format="9.4f") + " </td>\n</tr>", fileName);

          end for;

          print("</table>\n", fileName);
        end printTab4;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Modelica_LinearSystems2.StateSpace.Analysis.<b>analysis</b>(ss);
   or
Modelica_LinearSystems2.StateSpace.Analysis.<b>analysis</b>(
  ss,
  analyseOptions=<a href=\"modelica://Modelica_LinearSystems2.Internal.AnalyseOptions\">analyseOptions</a>,
  fileName,
  systemName,
  description);
</pre></blockquote>

<h4>Description</h4>
<p>
This function analyzes a state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b> * <b>x</b> + <b>B</b> * <b>u</b>
    <b>y</b>  = <b>C</b> * <b>x</b> + <b>D</b> * <b>u</b>     <label for=\"eqn1\">(1)</label>
    <b>x</b>(t=0) = <b>x</b><sub>0</sub>
</pre></blockquote>
<p>
based on its poles, i.e. the eigenvalues, and the zeros of the system.
The system will be checked for stability, controllability and observability. In the case that the system is not stable stabilizability and detectability are examined. Furthermore, stability, controllability, observability, stabilizability, and detectability are indicated for each eigenvalue.
</p>

<h5>Stability</h5>
<p>
System (1) is stable if and only if all eigenvalues of the matrix <b>A</b> have negative real parts.
The calculation of the eigenvalues is based on the LAPACK routine dgeev.
</p>

<h5>Controllability</h5>
<p>
System (1) is said to be controllable if, starting from any initial state <b>x</b><sub>0</sub>, the system can be driven by appropriate inputs to any final state <b>x</b><sub>1</sub> within some finite time window. Equivalent is that the eigenvalues of <b>A</b>-<b>BK</b> can  arbitrarily be assigned by an appropriate choice of the matrix <b>K</b>.
</p>

<h5>Stabilizability</h5>
<p>
System (1) is said to be stabilizable if all the unstable eigenvalues, i.e. all <tt>s</tt> with Re(<tt>s</tt>)>=0, of <b>A</b> are controllable. Therefore, a controllable system is always stabilizable. An equivalent definition of stabilizability is, that a system is said to be stabilizable if there exist a matrix <b>K</b> such that <b>A</b>-<b>BK</b> is stable.
</p>

<h5>Observability</h5>
<p>
System (1) is said to be observable if the (arbitrary) initial state <b>x</b><sub>0</sub> can be uniquely determined from any state <b>x</b>(t<sub>1</sub>), t<sub>1</sub>>0, from the knowledge of the input <b>u</b>(t) and output <b>y</b>(t). With other words,  from the system's outputs it is possible to determine the behavior of the entire system. Equivalent is, that the eigenvalues of <b>A</b>-<b>LC</b> can be arbitrarily be assigned by an appropriate choice of matrix <b>L</b>.
Observability is called the dual concept of controllability, since a system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) is observable if the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) is controllable.
</p>

<h5>Detectability</h5>
<p>
System (1) is said to be detectable if all the unstable eigenvalues, i.e. all <tt>s</tt> with Re(<tt>s</tt>)>=0, of <b>A</b> are observable. Therefore, a observable system is always detectable. An equivalent definition of detectability is, that a system is said to be detectable if there exist a matrix <b>L</b> such that <b>A</b>-<b>LC</b> is stable.
Detectability is called the dual concept of stabilizability, since a system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) is detectable if the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) is stabilizable.
</p>

<h5>Algorithm to test controllability/stabilizability and observability/detectability respectively</h5>
<p>
The test of controllability and stabilizability is performed with the staircase algorithm which transforms the system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) into the controller-Hessenberg form (<b>A</b><sub>H</sub>, <b>B</b><sub>H</sub>, <b>C</b><sub>H</sub>, <b>D</b>) with <b>A</b><sub>H</sub> is a block upper Hessenberg matrix and <b>B</b><sub>H</sub>=[<b>B</b><sub>1</sub>; 0] with triangular matrix <b>B</b><sub>1</sub> with rank(<b>B</b><sub>1</sub>) = rank(<b>B</b>).
In <b>A</b><sub>H</sub>=[<b>A</b><sub>c</sub>, *,0, <b>A</b><sub>nc</sub>) the eigenvalues of the matrices <b>A</b><sub>c</sub> and <b>A</b><sub>nc</sub> are the controllable eigenvalues and uncontrollable eigenvalues of <b>A</b> respectively.
The test of observability and detectability is performed by testing the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) with respect to controllability and stabilizability.
</p>

<h5>Solution of a linear time invariant system </h5>
<p>
The solution <b>x</b>(t) of the initial value problem (1) consists of the homogeneous part (zero input response) <b>x</b><sub>h</sub>(t) and the inhomogeneous part x<sub>i</sub>(t). The zero input solution is given by
</p>
<blockquote><pre>
<b>x</b><sub>h</sub>(t) = exp(<b>A</b>*(t-t<sub>0</sub>))<b>x</b><sub>0</sub>.
</pre></blockquote>
<p>
The system can also be represented as a linear combination of the modal states <b>z</b>,
</p>
<blockquote><pre>
<b>x</b> = <b>V</b><b>z</b>
</pre></blockquote>
<p>
i.e. the states of a similar system, with
</p>
<blockquote><pre>
der(<b>z</b>) = <b>V</b><sup>-1</sup><b>AVz</b> + <b>V</b><sup>-1</sup><b>B</b><b>u</b>
</pre></blockquote>
<p>
where the system matrix <b>V</b><sup>-1</sup><b>AV</b> is the real Jordan form. For single real eigenvectors the system is decoupled, i.e. the solution of the modal states are denoted by
<blockquote><pre>
z<sub>i</sub> = exp(s<sub>i</sub> t)*z<sub>0i</sub>
</pre></blockquote>
<p>
The behavior of the modal states is determined as the solution of a linear first order differential equation for real eigenvalues. Since this behavior is well known, the behavior of the x<sub>i</sub> can at least roughly be estimated by means of the behavior of the most relevant modal states. Therefore, the contribution of the modal states to the states is computed as an indication of the original system behavior.
</p>

<h5>Contribution of the modal states to the states</h5>
<p>
Generally, as described above, the states of the system can be described as linear combination of modal states and, therefore, the states can be characterized to a certain extend by the modal states if the proportions of the combination are known. Hence, for each modal state z<sub>i</sub> of the vector <b>z</b> the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub>| of the corresponding right eigenvector <b>v</b><sub>i</sub> indicate the proportion of <b>z</b><sub>i</sub> that is contributed to the state x<sub>j</sub>.
On the other hand, the composition of xi is indicated by the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub><sup>T</sup>|, i.e. the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub><sup>T</sup>| of the corresponding row <b>v</b><sub>i</sub><sup>T</sup> of the eigenvector matrix <b>V</b> indicate the proportion of the state x<sub>i</sub> that is contributed by the modal state z<sub>j</sub>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ss=StateSpace(
    A=[-3,2,-3,4,5,6; 0,6,7,8,9,4; 0,2,3,0,78,6; 0,1,2,2,3,3; 0,13,34,0,0,1; 0,
      0,0,-17,0,0],
    B=[1,0; 0,1; 1,0; 0,1; 1,0; 0,1],
    C=[0,0,1,0,1,0; 0,1,0,0,1,1],
    D=[0,0; 0,0],
    xNames={\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\"},
    uNames={\"u1\",\"u2\"}, yNames={\"y1\",\"y2\"});

  String fileName=\"analysis.html\";
  String systemName=\"Demonstration System\";
  String description=\"System to demonstrate the usage of Modelica_LinearSystems2.StateSpace.Analysis.anlysis()\"

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Analysis.analysis(ss, fileName=fileName, systemName=systemName, description=description)
//  gives:
</pre></blockquote>

<h4>System report</h4>
<p>
The system <b>Demonstation System</b>
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b> * <b>x</b> + <b>B</b> * <b>u</b>
    <b>y</b>  = <b>C</b> * <b>x</b> + <b>D</b> * <b>u</b>
</pre></blockquote>
<p>
is defined by
</p>
<blockquote><pre>
        x1   x2   x3   x4   x5   x6            u1  u2
    x1  -3    2   -3    4    5    6         x1  1   0
    x2   0    6    7    8    9    4         x2  0   1
A = x3   0    2    3    0   78    6     B = x3  1   0
    x4   0    1    2    2    3    3         x4  0   1
    x5   0   13   34    0    0    1         x5  1   0
    x6   0    0    0  -17    0    0         x6  0   1

        x1   x2   x3   x4   x5   x6            u1  u2
C = y1   0    0    1    0    1    0     D = y1  0   0
    y2   0    1    0    0    1    1         y2  0   0
</pre></blockquote>

<h5>Description</h5>
<p>
System to demonstrate the usage of Modelica_LinearSystems2.StateSpace.Analysis.analysis()
</p>

<h5>Characteristics</h5>
<p>The system
<br> is
not stable
<br>but it is controllable
<br> and therefore it is stabilizable
<br> The system is not observable
<br> but it is detectable
</p>

<p>
<b><big>Eigenvalues analysis</big></b>
<br><br>
<b>Real eigenvalues</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin: 20px 0 20px 20px\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td><td> eigenvalue </td> <td> T [s] </td>  <td> characteristics </td><td> contribution to states</td></tr>
<tr>
 <td style=\"text-align:center\">       1 </td> <td style=\"text-align:left\"> &nbsp;   -4.9874e+001 </td> <td style=\"text-align:left\"> &nbsp;    0.0201 </td> <td style=\"text-align:left\"> &nbsp; stable, controllable, observable  </td> <td style=\"text-align:left\"> &nbsp;  z[1] contributes to x3 with 54.6 %<br>&nbsp;  z[1] contributes to x5 with 37 % </td> </tr>
<tr>
 <td style=\"text-align:center\">       2 </td> <td style=\"text-align:left\"> &nbsp;   -3.0000e+000 </td> <td style=\"text-align:left\"> &nbsp;    0.3333 </td> <td style=\"text-align:left\"> &nbsp; stable, controllable, not observable  </td> <td style=\"text-align:left\"> &nbsp;  z[2] contributes to x1 with 100 %<br> </td> </tr>
<tr>
 <td style=\"text-align:center\">       3 </td> <td style=\"text-align:left\"> &nbsp;    2.9891e+000 </td> <td style=\"text-align:left\"> &nbsp;    0.3346 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[3] contributes to x2 with 51.9 %<br>&nbsp;  z[3] contributes to x1 with 23.9 % </td> </tr>
<tr>
 <td style=\"text-align:center\">       4 </td> <td style=\"text-align:left\"> &nbsp;    5.5825e+001 </td> <td style=\"text-align:left\"> &nbsp;    0.0179 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[4] contributes to x3 with 48.4 %<br>&nbsp;  z[4] contributes to x5 with 32.5 % </td> </tr>
</table>

<p>
<b>Conjugated complex pairs of eigenvalues</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin: 20px 0 20px 20px\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td> <td> eigenvalue </td><td> freq. [Hz] </td> <td> damping </td><td> characteristics </td>  <td> contribution to states</td></tr>
<tr>
 <td style=\"text-align:left\">     5/6 </td> <td style=\"text-align:left\"> &nbsp;    1.0299e+000 &plusmn;  6.5528e+000j </td> <td style=\"text-align:left\"> &nbsp;    1.0557 </td> <td style=\"text-align:left\"> &nbsp;   -0.1553 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[    5/6] contribute to x6 with 35.9 %<br>&nbsp;  z[    5/6] contribute to x2 with 20.6 % </td> </tr>
</table>

<p>
In the table above, the column <b>contribution to states</b> lists for each eigenvalue the states
to which thecorresponding modal state contributes most. This information is based on the
two largest absolute values of the corresponding right eigenvector (if the second large value
is less than 5&nbsp;% of the largest contribution, it is not shown).
</p>

<p>
In the next table, for each state in the column <b>correlation to modal states</b>, the modal
states which contribute most to the coresponding state are summarized, i.e. the state is mostly composed of these modal states
This information is based on the two largest absolute values of row i of the
eigenvector matrix that is associated with eigenvalue i (if the second large value
is less than 5&nbsp;% of the largest contribution, it is not shown). This only holds
if the modal states are in the same order of magnitude. Otherwise, the modal states
listed in the last column might be not the most relevant one.
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin: 20px 0 20px 20px\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> state </td> <td> composition </td> <td> eigenvalue #</td> <td> freq. [Hz] </td> <td> damping </td> <td> T [s] </td></tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x1 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  42.5% by z[2] <br> &nbsp;  is composed of  35.4% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 2<br> &nbsp; 5/6 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    1.0557 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp;    0.0201<br> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x2 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  44.2% by z[3] <br> &nbsp;  is composed of  43.7% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 3<br> &nbsp; 5/6 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    1.0557 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp;    0.3333<br> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x3 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  36.9% by z[1] <br> &nbsp;  is composed of  36.3% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 1<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;    0.3346<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x4 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  88.9% by z[5/6] <br> &nbsp;  is composed of   9.8% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 5/6<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp;    1.0557<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;   -0.1553<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x5 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  45.3% by z[1] <br> &nbsp;  is composed of  44.1% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 1<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;    0.0000<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x6 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  95.7% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 5/6          </td> <td style=\"text-align:center\"> &nbsp;    1.0557          </td> <td style=\"text-align:center\"> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
</table>

<p>
<b>Invariant zeros</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin: 20px 0 20px 20px\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td> <td> invariant zero </td><td> Time constant [s] </td> <td> freq. [Hz] </td> <td> damping </td></tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;       1 </td> <td> &nbsp;   -5.4983e+001 </td> <td> &nbsp;    0.0182 </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;       2 </td> <td> &nbsp;   -3.0000e+000 </td> <td> &nbsp;    0.3333 </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;     3/4 </td> <td style=\"text-align:left\"> &nbsp;    3.2417e+000 &plusmn;  5.6548e+000j </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:left\"> &nbsp;    1.0374 </td> <td style=\"text-align:left\"> &nbsp;   -0.4973 </td> </tr>
</table>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end analysis;

      encapsulated function timeResponse
        "Calculate the time response of a state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        input TimeResponse response=TimeResponse.Step;
        extends Modelica_LinearSystems2.Internal.timeResponseMask2(redeclare Real
            y[:, size(sc.C, 1), if response == TimeResponse.Initial then 1 else
            size(sc.B, 2)], redeclare Real x_continuous[:, size(sc.A, 1), if
            response == TimeResponse.Initial then 1 else size(sc.B, 2)]);
        // Input/Output declarations of time response functions

        input Real x0[size(sc.A, 1)]=zeros(size(sc.A, 1)) "Initial state vector";

    protected
        Real dtVar;
        Real tSpanVar;
        Integer samples;
        Real u[:, size(sc.B, 2)];
        Real new_x[size(sc.A, 1), 1];
        Real x[size(sc.A, 1), 1]=zeros(size(sc.A, 1), 1);
        Modelica_LinearSystems2.DiscreteStateSpace sd(
          redeclare Real A[size(sc.A, 1), size(sc.A, 2)],
          redeclare Real B[size(sc.B, 1), size(sc.B, 2)],
          redeclare Real C[size(sc.C, 1), size(sc.C, 2)],
          redeclare Real D[size(sc.D, 1), size(sc.D, 2)],
          redeclare Real B2[size(sc.B, 1), size(sc.B, 2)]);
        Real i1;
        Real i2;

      algorithm
        // Check whether system has inputs and outputs
        assert(size(sc.B, 2) > 0,
          "\n... StateSpace system has no inputs and it is not possible to compute a time response.\n");
        assert(size(sc.C, 1) > 0,
          "\n... StateSpace system has no outputs and it is not possible to compute a time response.\n");

        // set sample time and simulation time span
        if (dt == 0 and tSpan == 0) then
          (dtVar,tSpanVar) :=
            Modelica_LinearSystems2.Internal.timeResponseSamples(sc);
        elseif (dt == 0 and tSpan <> 0) then
          dtVar := Modelica_LinearSystems2.Internal.timeResponseSamples(sc);
          tSpanVar := tSpan;
        elseif (dt <> 0 and tSpan == 0) then
          (,tSpanVar) := Modelica_LinearSystems2.Internal.timeResponseSamples(sc);
          dtVar := dt;
        else
          dtVar := dt;
          tSpanVar := tSpan;
        end if;

        samples := integer(tSpanVar/dtVar + 1);
        t := 0:dtVar:tSpanVar;
        u := zeros(samples, size(sc.B, 2));
        y := if response == TimeResponse.Initial then zeros(
              samples,
              size(sc.C, 1),
              1) else zeros(
              samples,
              size(sc.C, 1),
              size(sc.B, 2));
        x_continuous := if response == TimeResponse.Initial then zeros(
              samples,
              size(sc.A, 1),
              1) else zeros(
              samples,
              size(sc.A, 1),
              size(sc.B, 2));

        if response == TimeResponse.Initial then
          sd :=Modelica_LinearSystems2.DiscreteStateSpace(
                sc,
                dtVar,
                Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal);
          (y[:, :, 1],x_continuous[:, :, 1]) :=
            Modelica_LinearSystems2.DiscreteStateSpace.initialResponse(
                sd,
                x0,
                samples);
        else

          for i1 in 1:size(sc.B, 2) loop
            // Loop over inputs

            // time response to plot
            if response == TimeResponse.Impulse then
              u[1, :] := zeros(size(sc.B, 2));
              u[1, i1] := 1;
              sd :=Modelica_LinearSystems2.DiscreteStateSpace(
                    sc,
                    dtVar,
                    Modelica_LinearSystems2.Utilities.Types.Method.ImpulseExact);
            elseif response == TimeResponse.Step then
              u[:, :] := zeros(samples, size(sc.B, 2));
              u[:, i1] := ones(samples);
              sd :=Modelica_LinearSystems2.DiscreteStateSpace(
                    sc,
                    dtVar,
                    Modelica_LinearSystems2.Utilities.Types.Method.StepExact);
            elseif response == TimeResponse.Ramp then
              u[:, :] := zeros(samples, size(sc.B, 2));
              u[:, i1] := 0:dtVar:tSpanVar;
              sd :=Modelica_LinearSystems2.DiscreteStateSpace(
                    sc,
                    dtVar,
                    Modelica_LinearSystems2.Utilities.Types.Method.RampExact);
              //    elseif response == TimeResponse.Initial then
              //      u[:, :] := zeros(samples, size(sc.B, 2));
              //      sd := Modelica_LinearSystems2.DiscreteStateSpace(
              //          sc,
              //          dtVar,
              //          Modelica_LinearSystems2.Types.Method.Trapezoidal);
            else
              assert(false, "Argument response (= " + String(response) +
                ") of \"Time response to plot\" is wrong.");
            end if;

            (y[:, :, i1],x_continuous[:, :, i1]) :=
              Modelica_LinearSystems2.DiscreteStateSpace.timeResponse(
                  sd,
                  u,
                  x0);
          end for;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = StateSpace.Analysis.<b>timeResponse</b>(ss, dt, tSpan, responseType, x0)
</pre> </blockquote>

<h4>Description</h4>
<p>
This function calculates the time responses of a state space system. The type of the time response is defined by the input <code>responseType</code>, i.e.
</p>
<blockquote><pre>
Impulse &quot;Impulse response&quot;,
Step &quot;Step response&quot;,
Ramp &quot;Ramp response&quot;,
Initial &quot;Initial condition response&quot;
</pre></blockquote>
<p>
The state space system is transformed to a appropriate discrete state space system and,
starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y and x are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[2],
    D=[0]);
  Real Ts = 0.1;
  Real tSpan = 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response = Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[1] = {0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x) := Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(ss,Ts,tSpan,response,x0);
  // y[:,1,1] = {0, 0.19, 0.3625, 0.518, 0.659}
  //        t = {0, 0.1, 0.2, 0.3, 0.4}
  // x[:,1,1] = {0, 0.0952, 0.1813, 0.2592, 0.33}
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse
        "Calculate the impulse time response of a state space system"

        import Modelica;
        import Modelica_LinearSystems2;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(
              sc=sc,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
              x0=zeros(size(sc.A, 1)));

        annotation (__Dymola_interactive=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = StateSpace.Analysis.<b>impulseResponse</b>(ss, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the time response of a state space system for impulse imput. The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
StateSpace.Analysis.impulseResponse(ss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
StateSpace.Analysis.timeResponse(ss, dt, tSpan, response=Types.TimeResponse.Impulse, x0=fill(0,size(ss.A,1))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[2],
    D=[0]);
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x) := StateSpace.Analysis.impulseResponse(ss,Ts,tSpan);
  // y[:,1,1] = {2, 1.8097, 1.6375, 1.4816, 1.3406}
  //        t = {0, 0.1, 0.2, 0.3, 0.4}
  // x[:,1,1] = {1, 0.9048, 0.8187, 0.7408, 0.6703}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.timeResponse\">StateSpace.Analysis.timeResponse</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse
        "Calculate the step time response of a state space system"

        import Modelica;
        import Modelica_LinearSystems2;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(
              sc=sc,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(size(sc.A, 1)));

        annotation (__Dymola_interactive=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = StateSpace.Analysis.<b>stepResponse</b>(ss, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>stepResponse</b> calculates the step response of a state space system.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
StateSpace.Analysis.stepResponse(ss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
StateSpace.Analysis.timeResponse(ss, dt, tSpan, response=Types.TimeResponse.Step, x0=fill(0,size(ss.A,1))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[2],
    D=[0]);
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=StateSpace.Analysis.stepResponse(ss,Ts,tSpan);
//  y[:,1,1]={0, 0.19, 0.3625, 0.518, 0.659}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0952, 0.1813, 0.2592, 0.33}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.timeResponse\">StateSpace.Analysis.timeResponse</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end stepResponse;

      encapsulated function rampResponse
        "Calculate the ramp time response of a state space system"

        import Modelica;
        import Modelica_LinearSystems2;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(
              sc=sc,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
              x0=zeros(size(sc.A, 1)));

        annotation (__Dymola_interactive=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = StateSpace.Analysis.<b>rampResponse</b>(ss, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rampResponse</b> calculates the time response of a state space system for ramp imput u = t.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
StateSpace.Analysis.rampResponse(ss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
StateSpace.Analysis.timeResponse(ss, dt, tSpan, response=Types.TimeResponse.Ramp, x0=fill(0,size(ss.A,1))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1],
      B=[1],
      C=[2],
      D=[0]);
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=StateSpace.Analysis.rampResponse(ss,Ts,tSpan);
//  y[:,1,1]={0, 0.00967, 0.03746, 0.08164, 0.14064}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.00484, 0.018734, 0.04082, 0.07032}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.timeResponse\">StateSpace.Analysis.timeResponse</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the time response of a state space system for given initial condition and zero inputs"

        import Modelica;
        import Modelica_LinearSystems2;

        input Real x0[:]=fill(0, 0) "Initial state vector";

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2(redeclare Real
            y[:, size(sc.C, 1), 1], redeclare Real x_continuous[:, size(sc.A, 1),
            1]);

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(
              sc=sc,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
              x0=x0);

        annotation (__Dymola_interactive=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = StateSpace.Analysis.<b>initialResponse</b>(ss, dt, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>initialResponse</b> calculates the time response of a state space system for given initial condition and zero inputs.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
StateSpace.Analysis.initialResponse(x0,ss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
StateSpace.Analysis.timeResponse(ss, dt, tSpan, response=Types.TimeResponse.Initial, x0=x0).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1],
      B=[1],
      C=[2],
      D=[0]);
  Real Ts=0.1;
  Real tSpan= 0.4;
  Real x0[2] = {1};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=StateSpace.Analysis.initialResponse(x0,ss,Ts,tSpan);
//  y[:,1,1]={2, 1.809, 1.637, 1.4812, 1.3402}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={1, 0.9048, 0.8186, 0.7406, 0.6701}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.timeResponse\">StateSpace.Analysis.timeResponse</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end initialResponse;

      encapsulated function numeratorDegree
        "Return numerator degree of the corresponding transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input Modelica_LinearSystems2.StateSpace ss;
        output Integer result;

    protected
        Modelica_LinearSystems2.TransferFunction tf=if StateSpace.Internal.isSISO(
            ss) then StateSpace.Conversion.toTransferFunction(ss) else
            TransferFunction(1);

      algorithm
        assert(StateSpace.Internal.isSISO(ss), "System must be SISO but is " +
          String(size(ss.B, 2)) + "-by-" + String(size(ss.C, 1)) + " system");
        result := size(tf.n, 1) - 1;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = StateSpace.Analysis.<b>numeratorDegree</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>numeratorDegree</b> calculates the degree of the numerator polynomial of the corresponding transfer function.
The state space system is converted to the transfer function G(s)=N(s)/D(s) with the polynomial N(s) as numerator.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[1],
    D=[1]);

  Real nDegree;

<b>algorithm</b>
  nDegree := StateSpace.Analysis.numeratorDegree(Modelica_LinearSystems2.StateSpace(ss);
//  nDegree = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction\">StateSpace.Conversion.toTransferFunction</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.denominatorDegree\">StateSpace.Analysis.denominatorDegree</a>
</p>
</html>"));
      end numeratorDegree;

      encapsulated function denominatorDegree
        "Return denominator degree of the corresponding transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input Modelica_LinearSystems2.StateSpace ss;
        output Integer result;
    protected
        Modelica_LinearSystems2.TransferFunction tf=if StateSpace.Internal.isSISO(
            ss) then StateSpace.Conversion.toTransferFunction(ss) else
            TransferFunction(1);

      algorithm
        assert(StateSpace.Internal.isSISO(ss), "System must be SISO but is " +
          String(size(ss.B, 2)) + "-by-" + String(size(ss.C, 1)) + " system");
        result := size(tf.d, 1) - 1;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = StateSpace.Analysis.<b>denominatorDegree</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>denominatorDegree</b> calculates the degree of the denominator polynomial of the corresponding transfer function.
The state space system is converted to the transfer function G(s)=N(s)/D(s) with the polynomial D(s) as denominator.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[1],
    D=[1]);

  Real dDegree;

<b>algorithm</b>
  dDegree := StateSpace.Analysis.denominatorDegree(Modelica_LinearSystems2.StateSpace(ss);
//  nDegree = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction\">StateSpace.Conversion.toTransferFunction</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.numeratorDegree\">StateSpace.Analysis.numeratorDegree</a>
</p>
</html>"));
      end denominatorDegree;

      encapsulated function evaluate
        "Evaluate the corresponding transfer function at a given (complex) value of s"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;
        input Complex s "Value of s where tf shall be evaluated";
        input Real den_min=0 "|denominator(s)| is limited by den_min";
        output Complex result "= tf(s)";

    protected
        Boolean issiso=StateSpace.Internal.isSISO(ss);
        TransferFunction tf=if issiso then
            StateSpace.Conversion.toTransferFunction(ss) else TransferFunction(1);
        Complex j=Modelica_LinearSystems2.Math.Complex.j();
        Complex den=Polynomial.evaluateComplex(Polynomial(tf.d), s);
        Real abs_den=Complex.'abs'(den);
      algorithm
        assert(issiso, "System must be SISO but is " + String(size(ss.B, 2)) +
          "-by-" + String(size(ss.C, 1)) + " system");
        den := if abs_den >= den_min then den else -abs_den + 0*j;
        result := Polynomial.evaluateComplex(Polynomial(tf.n), s)/den;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = StateSpace.Analysis.<b>evaluate</b>(ss,s)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>evaluate</b> evaluates the corresponding transfer function of the state space system at a given (complex) value of s.
The state space system is converted to the transfer function G(s)=N(s)/D(s), which is evaluated by calculating the numerator polynomial N(s) and the denominator polynomial D(s).
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[1],
    D=[0]);
  Complex s=Complex(1,1);

  Complex result;

<b>algorithm</b>
  result := Modelica_LinearSystems2.StateSpace.Analysis.evaluate(ss, s);
//  result = 0.4 - 0.2j
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction\">StateSpace.Conversion.toTransferFunction</a>,
<a href=\"Modelica://Modelica_LinearSystems2.Math.Polynomial.evaluateComplex\">Math.Polynomial.evaluateComplex</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end evaluate;

      encapsulated function zerosAndPoles
        "Calculate zeros and poles of the TransferFunction corresponding to a state space representation"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;

        output Complex z[:] "Zeros (Complex vector of numerator zeros)";
        output Complex p[:] "Poles (Complex vector of denominator zeros)";
        output Real k
          "Constant multiplied with transfer function that is factorized with zeros and poles";

    protected
        TransferFunction tf=StateSpace.Conversion.toTransferFunction(ss);
        Polynomial pn;
        Polynomial pd;
        TransferFunction tf2;
        Real r;
        Complex s;
        Complex y1;
        Complex y2;
      algorithm

        z := Polynomial.roots(Polynomial(tf.n));
        p := Polynomial.roots(Polynomial(tf.d));
        pn := Polynomial(z);
        pd := Polynomial(p);
        tf2 := TransferFunction(pn, pd);
        // Determine an s-value that is neither a zero nor a pole
        r := 1.0;
        for i in 1:size(z, 1) loop
          r := max(r, abs(z[i].re));
        end for;
        for i in 1:size(p, 1) loop
          r := max(r, abs(p[i].re));
        end for;
        r := 2*r;
        s := Complex(r, 0);

        // Evaluate both tf and tf2 and determine k from the quotient
        y1 := TransferFunction.Analysis.evaluate(tf, s);
        y2 := TransferFunction.Analysis.evaluate(tf2, s);
        k := y1.re/y2.re;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(z,p,k) = StateSpace.Analysis.<b>zerosAndPoles</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the zeros, poles and gain of the corresponding transfer function of a state space system.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[1],
    D=[1]);

  Complex z;
  Complex p;
  Real k;

<b>algorithm</b>
  (z,p,k)=Modelica_LinearSystems2.StateSpace.Analysis.zerosAndPoles(ss);
//  z = {-2}
//  p = {-1}
//  k = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction\">StateSpace.Conversion.toTransferFunction</a>,
<a href=\"Modelica://Modelica_LinearSystems2.TransferFunction.Analysis.zerosAndPoles\">TransferFunction.Analysis.zerosAndPoles</a>
</p>
</html>"));
      end zerosAndPoles;

      encapsulated function eigenValues
        "Calculate the eigenvalues of a linear state space system and write them in a complex vector"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "state space system";
        output Complex eigvalues[size(ss.A, 1)]=Complex.eigenValues(ss.A)
          "eigen values of the system";
      algorithm

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
eigenvalues = StateSpace.Analysis.<b>eigenValues</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvalues of a state space system, i.e. the eigenvalues of the system matrix <b>A</b> of a state space system. The output is a complex vector containing the eigenvalues.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1,1;-1,-1],
    B=[1;1],
    C=[1,1],
    D=[0]);

  Complex eigenvalues[2];

<b>algorithm</b>
  eigenvalues = Modelica_LinearSystems2.StateSpace.Analysis.eigenValues(ss);
// eigenvalues = {-1 + 1j, -1 - 1j}
</pre></blockquote>
</html>"));
      end eigenValues;

      encapsulated function eigenVectors
        "Calculate the rigth eigenvectors of a linear state space system and write them columnwise in a matrix. Optionally, the eigenvalues are computed"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica.Math.Matrices.LAPACK;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "state space system";
        input Boolean onlyEigenvectors=true;
        output Real eigvec[size(ss.A, 1), size(ss.A, 2)]
          "eigen values of the system";
        output Complex eigval[size(ss.A, 1)]=fill(Complex(0), size(ss.A, 1))
          "eigen values of the system";
    protected
        Integer info;
        Real eigvalRe[size(ss.A, 1)]=fill(0, size(ss.A, 1));
        Real eigvalIm[size(ss.A, 1)]=fill(0, size(ss.A, 1));

      algorithm
        if size(ss.A, 1) > 0 then
          if onlyEigenvectors then
            (,,eigvec,info) := LAPACK.dgeev(ss.A);
          else
            (eigvalRe,eigvalIm,eigvec,info) := LAPACK.dgeev(ss.A);
            for i in 1:size(ss.A, 1) loop
              eigval[i].re := eigvalRe[i];
              eigval[i].im := eigvalIm[i];
            end for;
          end if;

          assert(info == 0, "Calculating the eigen values with function
\"StateSpace.Analysis.eigenVectors\" is not possible, since the
numerical algorithm does not converge.");
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(eigenvectors, eigenvalues) = StateSpace.Analysis.<b>eigenVectors</b>(ss, onlyEigenvectors)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvectors and optionally (onlyEigenvectors=false) the eigenvalues of a state space system. The output <tt>eigenvectors</tt> is a matrix with the same dimension as matrix <b>ss.A</b>. Just like in <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Modelica.Math.Matrices.eigenValues</a>, if the i-th eigenvalue has an imaginary part, then <tt>eigenvectors</tt>[:,i] is the real and <tt>eigenvectors</tt>[:,i+1] is the imaginary part of the eigenvector of the i-th eigenvalue.<br>
The eigenvalues are returned as a complex vector <tt>eigenvalues</tt>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1,1;-1,-1],
    B=[1;1],
    C=[1,1],
    D=[0]);

  Real eigenvectors[2,2];
  Complex eigenvalues[2];

<b>algorithm</b>
  (eigenvectors, eigenvalues) = Modelica_LinearSystems2.StateSpace.Analysis.eigenVectors(ss, true);
// eigenvectors = [0.707, 0; 0, 0.707]
// eigenvalues = {-1 + 1j, -1 - 1j}

          |0.707 |         | 0.707 |
i.e. v1 = |      |,   v2 = |       |
          |0.707i|         |-0.707i|
</pre></blockquote>
</html>"));
      end eigenVectors;

      encapsulated function invariantZeros
        "Compute invariant zeros of linear state space system"

        import Modelica;
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        import Complex;

        input StateSpace ss "Linear system in state space form";

        output Complex Zeros[:]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";

    protected
        Integer n=10;
        Integer m;
        Integer p;
        Real Ar[:, :];
        Real Br[:, :];
        Real Cr[:, :];
        Real Dr[:, :];

        Real Af[:, :];
        Real Bf[:, :];
        Real AfBf[:, :];

        Real V2[:, :];
        Real Vf[:, :];
        Real R[:, :];

        Integer na;
        Real alphaReal[:];
        Real alphaImag[:];
        Real beta[:];
        Integer info;
        Real zerosMax;
        Real absZero;

        Integer j;
      algorithm
        if min(size(ss.B)) == 0 or min(size(ss.C)) == 0 then
          Zeros := fill(Complex(0), 0);
        else
          (Ar,Br,Cr,Dr,n,m,p) := StateSpace.Internal.reduceRosenbrock(
                ss.A,
                ss.B,
                ss.C,
                ss.D);
          if n > 0 then
            (Ar,Br,Cr,Dr,n,m,p) := StateSpace.Internal.reduceRosenbrock(
                  transpose(Ar),
                  transpose(Cr),
                  transpose(Br),
                  transpose(Dr));
          end if;
          if n == 0 then
            Zeros := fill(Complex(0), 0);
          else
            (,R,,V2) := Matrices.QR(MatricesMSL.flipLeftRight(transpose([Cr, Dr])));
            Vf := MatricesMSL.flipLeftRight(V2);
            AfBf := [Ar, Br]*Vf;
            Af := AfBf[:, 1:size(Ar, 2)];
            Bf := Vf[1:size(Ar, 1), 1:size(Ar, 2)];

            (alphaReal,alphaImag,beta,,,info) := LAPACK.dggev(
                  Af,
                  Bf,
                  n);
            assert(info == 0,
              "Failed to compute invariant zeros with function invariantZeros(..)");

            Zeros := fill(Complex(0), size(beta, 1));

            /* The pencil (Af,Bf) has n eigenvalues, since the transformation to this
             form is done so that Bf is regular. Therefore, the generalized eigenvalues
             represented by alpha[i]/beta[i] have the property that beta[i] cannot be zero
             and a division by beta[i] is uncritical.

             |alpha| / beta <= zerosMax
             if |alpha| <= beta*zerosMax then
                zero is used
             else
                assumed that zero is at infinity (i.e. it is ignored)
          */
            j := 0;
            zerosMax := 1.0e4*MatricesMSL.norm([Af, Bf], p=1);
            for i in 1:size(beta, 1) loop
               absZero := Modelica_LinearSystems2.Math.Complex.'abs'(Complex(alphaReal[i], alphaImag[i]));
               if absZero <= beta[i]*zerosMax then
                  j := j + 1;
                  Zeros[j].re := alphaReal[i]/beta[i];
                  Zeros[j].im := alphaImag[i]/beta[i];
               end if;
            end for;

            if j == 0 then
               Zeros := fill(Complex(0), 0);
            else
               Zeros := Zeros[1:j];
            end if;
          end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zeros = StateSpace.Analysis.<b>invariantZeros</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
     <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre></blockquote>
<p>
The invariant zeros of this system are defined as the variables
s  that make the Rosenbrock matrix of the system
</p>
<pre>
    | s<b>I-A</b>   <b>-B</b> |
    |           |
    | <b>C</b>       <b>D</b> |
</pre>
<p>
singular.
</p>
<p>
This function applies the algorithm described in [1] where the system (<b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) is reduced to a new system (<b>A</b>r, <b>B</b>r <b>C</b>r, <b>D</b>r) with the same zeros and with <b>D</b>r of full rank.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[1, 1, 1;0, 1, 1;0,0,1],
    B=[1;0;1],
    C=[0,1,1],
    D=[0]);

  Complex zeros[:];

<b>algorithm</b>
  zeros := Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros(ss);
// zeros = {1, 0}
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Emami-Naeini, A. and Van Dooren, P. (1982):</dt>
<dd> <b>Computation of Zeros of Linear Multivariable Systems</b>.
     Automatica, 18, pp. 415-430.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end invariantZeros;

      encapsulated function dcGain
        "Return steady state gain matrix K (for a stable system: K[i,j] = value of y[i] at infinite time for a step input of u[j])"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "Linear system in state space form";

        output Real K[size(ss.C, 1), size(ss.B, 2)]
          "DC gain matrix K (= G(s=0) = D - C*inv(A)*B)";
        output Boolean finite
          "True, if K is finite, otherwise K is infinite (K=fill(Modelica.Constants.inf,..) returned)";

    protected
        Integer nx=size(ss.A, 1);
        Integer nu=size(ss.B, 2);
        Integer ny=size(ss.C, 1);
        Real X[nx, nu];
        Integer rank;
      algorithm
        finite := true;
        if nu == 0 or ny == 0 then
          K := fill(
                0.0,
                ny,
                nu);
        else
          (X,rank) := Modelica.Math.Matrices.leastSquares2(ss.A,
            ss.B);
          // Determine whether A*X-B=0 is not fulfilled (since no unique solution)
          if rank < nx then
            if Modelica.Math.Matrices.norm(ss.A*X - ss.B, p=Modelica.Constants.inf)
                 >= 1000*Modelica.Constants.eps then
              finite := false;
            end if;
          end if;

          if finite then
            // A*X - B = 0:
            K := ss.D - ss.C*X;
          else
            // The least squares solution does not fulfill A*X - B = 0
            K := fill(
                  Modelica.Constants.inf,
                  ny,
                  nu);
          end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
          K = <b>dcGain</b>(ss);
(K, finite) = <b>dcGain</b>(ss);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the steady state gain <b>K</b> of a state space system.
<b>K</b> is defined in the following way:
</p>
<p>
The linear state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
     <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre></blockquote>
<p>
is solved for <b>y</b> under steady state conditions, i.e.,
</p>
<blockquote><pre>
   der(<b>x</b>) = <b>0</b>
</pre></blockquote>
<p>
resulting in
</p>
<blockquote><pre>
    <b>y</b> = ( <b>D</b> + <b>C</b>*inv(<b>A</b>)*<b>B</b> )*<b>u</b>
      = <b>K</b>*<b>u</b>
</pre></blockquote>

<p>
Interpretations of matrix <b>K</b>:
</p>

<ul>
<li> <b>K</b> is the value of the transfer function G(s) at s=0</li>
<li> For a stable state space system, a step input u[j] results in
     the output y[i](t->t<sub>&infin;</sub>) = K[i,j].</li>
</ul>

<p>
If <b>A</b> is singular (e.g. due to a zero eigenvalue), then a unique inverse
of <b>A</b> does not exist. If there are non-unique solutions of the
equation \"<b>A</b>*<b>X</b>=<b>B</b>\", the one with the smallest norm
in <b>X</b> is used to compute <b>K</b>. If no solution of this equation exists,
<b>K</b> cannot be computed. In this case, output argument
<b>finite</b> = <b>false</b> and all elements of
<b>K</b> are set to Modelica.Constants.inf (when <b>K</b> could be computed,
<b>finite</b> = <b>true</b>).
</p>
</html>"));
      end dcGain;

      encapsulated function isControllable
        "Check controllability of a state space system"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean controllable;
      algorithm

        controllable := if StateSpace.Internal.isSISO(ss) then
          StateSpace.Internal.isControllableSISO(ss) else
          StateSpace.Internal.isControllableMIMO(ss, method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
controllable = StateSpace.Analysis.<b>isControllable</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function StateSpace.Analysis.<b>isControllable</b> checks the controllability of a state space system. Therefore, the system is transformed into staircase form, i.e. the system matrix <b>H</b> of the transformed system has block upper Hessenberg form:
</p>
<blockquote><pre>
     | H11    H12     H13    ...     H1k |
     | H21    H22     H23    ...     H2k |
 <b>H</b> = |  0     H32     ...    ...     ... |
     | ...    ...     ...    ...     ... |
     |  0     ...      0    Hk,k-1   Hkk |
</pre></blockquote>
<p>
where, if <b>H</b>k,k-1 has full rank, indicating whether the system is controllable or not.
</p>
<p>
For single input systems the staircase form is a usual upper Hessenberg form, i.e. th blocks are of dimension one.<br>
The boolean input <b>method</b> defines for multi output systems the method to generate the staircase form of the system, whereas Types.StaircaseMethod.QR and Types.StaircaseMethod.SVD denotes QR-factorization and singular value decomposition respectively. Since staircase algorithm contains rank decisions QR-factorization should be restricted to well conditioned systems of lower order (&lt;5). Default is SVD.
</p>
<p>
Since controllability is dual to observability of the dual system (A', C', B', D'), proof of <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isObservable\">observability</a> is referred to proof of controllability of the dual system.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1, 1;0, -1, 1;0,0,-1],
    B=[0;0;1],
    C=[0,1,0],
    D=[0]);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean controllable;

<b>algorithm</b>
  controllable := Modelica_LinearSystems2.StateSpace.Analysis.isControllable(ss, method);
// controllable = true
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end isControllable;

      encapsulated function isObservable
        "Check observability of a state space system"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean observable;
      algorithm

        observable := if StateSpace.Internal.isSISO(ss) then
          StateSpace.Internal.isObservableSISO(ss) else
          StateSpace.Internal.isObservableMIMO(ss, method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
observable = StateSpace.Analysis.<b>isObservable</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function StateSpace.Analysis.<b>isObservable</b> checks the observability of a state space system. Since observability is dual to controllability of the dual system (A', C', B', D'), proof of observability is referred to proof of <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isControllable\">controllability</a> of the dual system.<br>
The boolean input <b>method</b> defines for multi output systems the method to generate the staircase form of the system, whereas Types.StaircaseMethod.QR and Types.StaircaseMethod.SVD denotes QR-factorization and singular value decomposition respectively. Since staircase algorithm contains rank decisions QR-factorization should be restricted to  well conditioned systems of lower order (&lt;5). Default is SVD.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1, 1;0, -1, 1;0,0,-1],
    B=[0;0;1],
    C=[0,1,0],
    D=[0]);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean observable;

<b>algorithm</b>
  observable := Modelica_LinearSystems2.StateSpace.Analysis.isObservable(ss, method);
// observable = false
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end isObservable;

      encapsulated function isStabilizable
        "Check stabilizability of a state space system"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;

        output Boolean stabilizable;

      algorithm
        if StateSpace.Internal.isSISO(ss) then
          stabilizable := StateSpace.Internal.isStabilizableSISO(ss);
        else
          stabilizable := StateSpace.Internal.isStabilizableMIMO(ss);
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
stabilizable = StateSpace.Analysis.<b>isStabilizable</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function checks whether a state space system is stabilizable or not.<br>
A system is stabilizable for the continuous-time case if all of the uncontrollable eigenvalues have negative real part.
Therefore, a controllable system is always stabilizable.
</p>
<p>
To check stabilizability, staircase algorithm is used to separate the controllable subspace from the uncontrollable subspace.
Then, the uncontrollable poles are checked to be stable, i.e. to have negative real parts.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[1, 1, 1;0, 1, 1;0, 0, 1],
    B=[0; 0; 1],
    C=[0, 1, 0],
    D=[0]);

  Boolean stabilizable;

<b>algorithm</b>
   stabilizable := Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable(ss);
// stabilizable = true
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end isStabilizable;

      encapsulated function isDetectable
        "Check detectability of a state space system"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;

        output Boolean detectable;

      algorithm
        if StateSpace.Internal.isSISO(ss) then
          detectable := StateSpace.Internal.isDetectableSISO(ss);
        else
          detectable := StateSpace.Internal.isDetectableMIMO(ss);
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
detectable = StateSpace.Analysis.<b>isDetectable</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function checks whether a state space system is detectable or not.<br>
A system is detectable for the continuous-time case if all of the unobservable eigenvalues have negative real part.
Therefore, a observable system is always detectable.
</p>
<p>
To check detectability, staircase algorithm is used to separate the observable subspace from the unobservable subspace.
Then, the unobservable poles are checked to be stable, i.e. to have negative real parts.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1, 1;0, 1, 1;0,0,1],
    B=[0;0;1],
    C=[0,1,0],
    D=[0]);

  Boolean detectable;

<b>algorithm</b>
  detectable := Modelica_LinearSystems2.StateSpace.Analysis.isDetectable(ss);
// detectable = true
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end isDetectable;

      encapsulated function controllabilityMatrix
        "Calculate the controllability matrix [B, A*B, ..., A^(n-1)*B] of a state space system"

        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;
        output Real cm[size(ss.B, 1), size(ss.A, 2)*size(ss.B, 2)];

      algorithm
        if size(ss.A, 2) == 0 then
          cm := fill(
                0,
                size(ss.B, 1),
                0);
        else
          cm[:, 1:size(ss.B, 2)] := ss.B;

          for i in 2:size(ss.A, 1) loop
            cm[:, ((i - 1)*size(ss.B, 2) + 1):(i*size(ss.B, 2))] := ss.A*cm[:, ((
              i - 2)*size(ss.B, 2) + 1):((i - 1)*size(ss.B, 2))];
          end for;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = StateSpace.Analysis.<b>controllabilityMatrix</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the controllability matrix
</p>
<blockquote>
  <b>Q</b> = [<b>B</b>, <b>A</b>*<b>B</b>, ..., <b>A</b>^(n-1)*<b>B</b>]
</blockquote>
<p>
of the system corresponding to state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[1, 1, 1;0, 1, 1;0, 0, 1],
    B=[0; 0; 1],
    C=[0, 1, 0],
    D=[0]);

  Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.StateSpace.Analysis.controllabilityMatrix(ss);
// Q = [0, 1, 3; 0, 1, 2; 1, 1, 1]
</pre></blockquote>
</html>"));
      end controllabilityMatrix;

      encapsulated function observabilityMatrix
        "Calculate the observability matrix of a state space system"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss;
        output Real om[size(ss.A, 1)*size(ss.C, 1), size(ss.C, 2)];

      algorithm
        if size(ss.A, 1) == 0 then
          om := fill(
                0,
                0,
                size(ss.C, 2));
        else
          om[1:size(ss.C, 1), :] := ss.C;

          for i in 2:size(ss.A, 1) loop
            om[((i - 1)*size(ss.C, 1) + 1):(i*size(ss.C, 1)), :] := om[((i - 2)*
              size(ss.C, 1) + 1):((i - 1)*size(ss.C, 1)), :]*ss.A;
          end for;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = StateSpace.Analysis.<b>observabilityMatrix</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the observability matrix
</p>
<blockquote>
  <b>Q</b> = [<b>C</b>; <b>C</b>*<b>A</b>; ...; <b>C</b>*<b>A</b>^(n-1)]
</blockquote>
<p>
of the system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1, 1;0, 1, 1;0, 0, 1],
    B=[0; 0; 1],
    C=[0, 1, 0],
    D=[0]);

  Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.StateSpace.Analysis.observabilityMatrix(ss);
// Q = [0, 1, 0; 0, 1, 1; 1, 1, 2]
</pre></blockquote>
</html>"));
      end observabilityMatrix;

      function analysis2
        "Perform a system analysis based on the poles and zeros of the system"

        import Modelica;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.Eigenvalue;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;
        import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2.Utilities.Plot;
        import DymolaCommands;

        input StateSpace ss;

        input Internal.AnalyseOptions analyseOptions=
            Modelica_LinearSystems2.Internal.AnalyseOptions(
                plotEigenValues=true,
                plotInvariantZeros=true,
                plotStepResponse=true,
                plotFrequencyResponse=true,
                printSystem=true,
                printEigenValues=true,
                printEigenValueProperties=true,
                printInvariantZeros=true,
                printControllability=true,
                printObservability=true,
                headingEigenValues="Eigenvalues",
                headingInvariantzeros="Invariant zeros",
                headingStepResponse="Step response",
                headingFrequencyResponse="Frequency response",
                dB_w = false);
        input String fileName="systemReport.html"
          "Name of html-file that contains eigenvalue table";
        input String systemName=""
          "Name of system (used as heading in html file)";
        input String description="" "Description of system (used in html file)";
    protected
        String dummyFileName="dummy" + fileName;
    public
        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros());

    protected
        StateSpace ssBalanced = StateSpace.Transformation.toBalancedForm(ss);
        Complex j=Modelica_LinearSystems2.Math.Complex.j();
        Eigenvalue ev[size(ss.A, 1)];
        Integer nx=size(ss.A, 1);
        Integer window=0;
        Real eval[nx, 2];
        Real revec[nx, nx];
        Real levec[nx, nx];
        Complex cev[size(ss.A, 1)];
        Complex systemZeros[:]=
            Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros(ssBalanced);
        Boolean isStable;
        Boolean isControllable;
        Boolean isStabilizable;
        Boolean isObservable;
        Boolean isDetectable;

        Real abs_evec[nx];
        String xNames2[nx];
        String heading="Eigenvalues" "Eigen values of system";
        Eigenvalue evSorted[size(ss.A, 1)];
        Integer evIndex[size(ss.A, 1)];
        Complex zerosSorted[:];
        Integer zerosIndex[size(systemZeros, 1)];
        Integer nReal;

        Integer i;
        Integer k;
        Complex evecComplex[size(ss.A, 1), size(ss.A, 1)];
        Plot.Records.Curve curves[2];
        Plot.Records.Diagram diagram2;
        Boolean instableZeros=false;

        String filePathOnly "NOT USED: Path to fileName";
        String fileNameOnly "Name of fileName without extension and path";
        String fileExtOnly "Extension of fileName";
        String fileNameImg "General name (without extension) of file for a plot";
        String fileNameImg2="none" "Current name of file for a plot";

        Internal.AnalyseOptions analyseOptions2=analyseOptions;
      algorithm
        // ---------------------------------------------------------------------------------------------------
        // The correct HTML format generated with this function can be checked with following commands:
        //   Modelica_LinearSystems2.StateSpace.Analysis.analysis(Modelica_LinearSystems2.StateSpace(A=[2,1,1;1,1,1;1,2,2], B=[1;2.2;3], C=[2,4,6;3,8,5], D=[6;4], yNames={"y1_test","y2_test"}, xNames={"xx1","xx2","xx3"}, uNames={"u1_test"}), description="Test file in HTML format from function 'analysis'.");
        //   Modelica_LinearSystems2.StateSpace.Analysis.analysis(Modelica_LinearSystems2.StateSpace(A=[2, 1.43, 12, 3; 1, 1, 1, 43; 1, 3, 2, 2; 1, 1, 4.2, 1.2], B=[1, 2; 2.2, 3; 3, 1; 4, 0], C=[25, 1.4, 6.3, 1; 0.3, 8, 5, 1; 1, 3, 2, 2], D=[6, 4; 4, 2; 6, 5], yNames={"y1_test","y2_te","y3_"}, xNames={"xx1","x2","xxx3","xx4"}, uNames={"u1_test","u2_test"}));
        // ---------------------------------------------------------------------------------------------------

        (filePathOnly,fileNameOnly,fileExtOnly) :=
          Modelica.Utilities.Files.splitPathName(fileName);
        fileNameImg := fileNameOnly;

        // If system has no inputs and outputs, modify analyze options that do not make sense
        if size(ss.B, 2) == 0 or size(ss.C, 1) == 0 then
          analyseOptions2.plotStepResponse := false;
          analyseOptions2.plotFrequencyResponse := false;
          analyseOptions2.printControllability := false;
          analyseOptions2.printObservability := false;
        end if;

        // If system has no states, modify analyze options that do not make sense
        if nx < 1 then
           analyseOptions2.plotEigenValues          :=false;
           analyseOptions2.plotInvariantZeros       :=false;
           analyseOptions2.printEigenValues         :=false;
           analyseOptions2.printEigenValueProperties:=false;
           analyseOptions2.printInvariantZeros      :=false;
        end if;

        // If system is too large, do not print A,B,C,D matrices
        if nx > 50 or size(ss.B, 2) > 50 or size(ss.C, 1) > 50 then
           analyseOptions2.printSystem:=false;
        end if;

        // Get eigenvalues
        // ---------------
        (eval,levec,revec) := Modelica_LinearSystems2.Math.Matrices.eigenValues(
          ss.A);

        for i in 1:nx loop
          cev[i].re := eval[i, 1];
          cev[i].im := eval[i, 2];
          ev[i].ev := cev[i];
        end for;

        (evSorted,evIndex) := Modelica_LinearSystems2.Internal.sortEigenvalue(ev);

        // Build x names
        // -------------
        if size(ss.xNames, 1) <> nx or nx > 1 and ss.xNames[1]=="" then
          for i in 1:nx loop
            xNames2[i] := "x[" + String(i) + "]";
          end for;
        else
          xNames2 := ss.xNames;
        end if;

        // Whole system checks
        // ===================
        // Stability check
        isStable := true;
        for i in 1:nx loop
          isStable := isStable and ev[i].ev.re < 0;
        end for;

        if size(ss.B, 2) > 0 and size(ss.C, 1) > 0 then
          // Controllability check, stabilizability check
          isControllable := StateSpace.Analysis.isControllable(ssBalanced);
          isStabilizable := StateSpace.Analysis.isStabilizable(ssBalanced);

          // Observability check, detectability check
          isObservable := StateSpace.Analysis.isObservable(ssBalanced);
          isDetectable := StateSpace.Analysis.isDetectable(ssBalanced);
        else
          isControllable := false;
          isStabilizable := false;
          isObservable := false;
          isDetectable := false;
        end if;

        // Analysis of single eingenvalues
        ev := StateSpace.Internal.characterizeEigenvalue(ss, ev);

        // Sort eigen values according to smallest imaginary value and restore the original order
        evSorted := Modelica_LinearSystems2.Internal.sortEigenvalue(ev);

        // Analysis file
        // -------------
        Modelica.Utilities.Files.removeFile(fileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);

        // Text should be printed into new file in HTML environment
        // --------------------------------------------------------
        StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
        StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);

        if analyseOptions2.printSystem then
          printSystem(
                ss,
                fileName,
                systemName,
                description);

          printSystem(
                ss,
                dummyFileName,
                systemName,
                description);
        end if;

        printHead1(
              ss,
              isStable,
              isControllable,
              isStabilizable,
              isObservable,
              isDetectable,
              fileName,
              analyseOptions=analyseOptions2);
        printHead1(
              ss,
              isStable,
              isControllable,
              isStabilizable,
              isObservable,
              isDetectable,
              dummyFileName,
              analyseOptions=analyseOptions2);
        StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);

        Modelica.Utilities.Streams.readFile(dummyFileName);

        // Plot step response
        // ------------------
        if analyseOptions2.plotStepResponse then
          Modelica.Utilities.Files.removeFile(dummyFileName);
          print(
            "<html>\n<body>\n<p>\n<b>Step responses</b>\n</p>\n</body>\n</html>",
            dummyFileName);
          Modelica.Utilities.Streams.readFile(dummyFileName);
          StateSpace.Plot.step(ss=ssBalanced);
          fileNameImg2 := fileNameImg + "Step.png";
          DymolaCommands.Plot.ExportPlotAsImage(fileName=fileNameImg2, id=-1, includeInLog=false);
          print("<p>\n<img src=\"" + fileNameImg2 + "\">\n</p>", fileName);
        end if;

        // Plot Bode plots
        if analyseOptions2.plotFrequencyResponse then
          Modelica.Utilities.Files.removeFile(dummyFileName);
          print("<html>\n<body>\n<p>\n<b>Bode plots</b>\n</p>\n</body>\n</html>",
            dummyFileName);
          Modelica.Utilities.Streams.readFile(dummyFileName);
          StateSpace.Plot.bodeMIMO(ss=ss, Hz=not analyseOptions.dB_w, dB=analyseOptions.dB_w);
          //     fileNameImg2 := fileNameImg + "BodeMIMO1.png";
          //     ExportPlotAsImage(
          //       fileName=fileNameImg2,
          //       id=-1,
          //       includeInLog=false);
        end if;

        // Calculate the number of real eigenvalues
        nReal := Modelica_LinearSystems2.Internal.numberOfRealZeros(cev);

        // Construct complex eigenvector matrix
        i := 1;
        while i <= nx loop
          if eval[i, 2] == 0.0 then

            for jj in 1:nx loop
              evecComplex[jj, i] := revec[jj, i] + 0*j;
            end for;
            i := i + 1;
          else
            for jj in 1:nx loop
              evecComplex[jj, i] := revec[jj, i] + revec[jj, i + 1]*j;
              evecComplex[jj, i + 1] := revec[jj, i] - revec[jj, i + 1]*j;
            end for;
            i := i + 2;
          end if;
        end while;

        if analyseOptions2.printEigenValues then
          printHead2a(
                fileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal > 0));
          if nReal > 0 then
            printTab1(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  fileName,
                  analyseOptions=analyseOptions2);
          end if;

          Modelica.Utilities.Files.removeFile(dummyFileName);
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead2a(
                dummyFileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal > 0));
          if nReal > 0 then
            printTab1(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  dummyFileName,
                  analyseOptions=analyseOptions2);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
          Modelica.Utilities.Streams.readFile(dummyFileName);

          printHead2b(
                fileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal < nx));
          if nReal < nx then
            printTab2(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  fileName,
                  analyseOptions=analyseOptions2);
          end if;

          Modelica.Utilities.Files.removeFile(dummyFileName);
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead2b(
                dummyFileName,
                analyseOptions=analyseOptions2,
                printTable=(nReal < nx));
          if nReal < nx then
            printTab2(
                  evSorted,
                  evIndex,
                  revec,
                  levec,
                  nReal,
                  xNames2,
                  dummyFileName,
                  analyseOptions=analyseOptions2);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
          Modelica.Utilities.Streams.readFile(dummyFileName);

         // Plot eigenvalues and invariant zeros
         if analyseOptions2.plotEigenValues or
            analyseOptions2.plotInvariantZeros and size(systemZeros, 1) > 0 then
            i := 0;
            if analyseOptions2.plotEigenValues then
              i := i + 1;
              curves[i] := Plot.Records.Curve(
                    x=eval[:, 1],
                    y=eval[:, 2],
                    legend="poles",
                    autoLine=false,
                    linePattern=Plot.Types.LinePattern.None,
                    lineSymbol=Plot.Types.PointSymbol.Cross);
            end if;

            // Plot invariant zeros
            if size(systemZeros, 1) > 0 and analyseOptions2.plotInvariantZeros then
              i := i + 1;
              curves[i] := Plot.Records.Curve(
                    x=systemZeros[:].re,
                    y=systemZeros[:].im,
                    legend="zeros",
                    autoLine=false,
                    linePattern=Plot.Types.LinePattern.None,
                    lineSymbol=Plot.Types.PointSymbol.Circle);
            end if;

            diagram2 := defaultDiagram;
            diagram2.curve := curves[1:i];
            Plot.diagram(diagram2, device);
          end if;

          if analyseOptions2.printEigenValueProperties then
            printHead3(fileName);
            printTab3(
                  evSorted,
                  evecComplex,
                  evIndex,
                  cev,
                  nReal,
                  xNames2,
                  fileName);

            Modelica.Utilities.Files.removeFile(dummyFileName);
            StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
            printHead3(dummyFileName);
            printTab3(
                  evSorted,
                  evecComplex,
                  evIndex,
                  cev,
                  nReal,
                  xNames2,
                  dummyFileName);
            StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);
            Modelica.Utilities.Streams.readFile(dummyFileName);

          end if;
        end if;

        // ZEROS
        (zerosSorted,zerosIndex) :=
          Modelica_LinearSystems2.Math.Complex.Vectors.sortComplex(systemZeros);
        nReal := Modelica_LinearSystems2.Internal.numberOfRealZeros(zerosSorted);

        if analyseOptions2.printInvariantZeros then
          printHead4(fileName, printTable=(size(systemZeros, 1) > 0));
          if size(systemZeros, 1) > 0 then
            Modelica_LinearSystems2.StateSpace.Analysis.analysis.printTab4(
                  zerosSorted,
                  zerosIndex,
                  nReal,
                  fileName);
          end if;

          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, true);
          printHead4(dummyFileName, printTable=(size(systemZeros, 1) > 0));
          if size(systemZeros, 1) > 0 then
            printTab4(
                  zerosSorted,
                  zerosIndex,
                  nReal,
                  dummyFileName);
          end if;
          k := 0;
          for i in 1:size(systemZeros, 1) loop
            if systemZeros[i].re > 0 then
              k := k + 1;
            end if;
          end for;
          if k > 0 then
            print("<p>\n<b>Note, that the system has " + String(k) +
              " zeros in the right complex half-plane.</b>\n</p>", fileName);
            print("<p>\n<b>Note, that the system has " + String(k) +
              " zeros in the right complex half-plane.</b>\n</p>", dummyFileName);
          end if;
          StateSpace.Analysis.analysis.printHTMLbasics(dummyFileName, false);

        end if;
        Modelica.Utilities.Streams.readFile(dummyFileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);

        print("\n\nAnalysis results have been written to file \"" +
          Modelica.Utilities.Files.fullPathName(fileName) + "\"");

        // Last print of HTML environment
        // --------------------------------------------------------
        StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);

        // SUB FUNCTIONS

    public
        encapsulated function printSystem
          "Print the state space system in html format on file"
          import Modelica;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;
          import Modelica_LinearSystems2;

          input StateSpace ss "State space system to analyze";
          input String fileName="systemAnalysis.html"
            "File on which the state space system is written in html format";
          input String systemName="State Space System"
            "Name of the state space system";
          input String description="" "Description of system (used in html file)";
          input String format=".6g" "Format of numbers (e.g. \"20.8e\")";

          input Boolean htmlBasics=false
            "True, if text should be printed within 'html' and 'body' environment, otherwise text printed into existing file fileName"
            annotation (Dialog(group="HTML format"));
          input Integer hSize(
            min=1,
            max=5) = 1
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));
      protected
          Integer nx=size(ss.A, 1);
          Integer nu=size(ss.B, 2);
          Integer ny=size(ss.C, 1);
          Integer c1=integer(ceil(nx/2) - 1);
          Integer c2=integer(ceil(ny/2) - 1);
          Integer dist=2;
          Boolean centered=true
            "True, if matrices columns should be centered, otherwise right aligned";

          String td_align=if centered then "  <td style=\"text-align:center\">"
               else "  <td style=\"text-align:right\">";

      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 4 then 4 else hSize;
          String heading="h" + String(hSizeOK);
          String heading2="h" + String(hSizeOK + 1);
          String heading3="h" + String(hSizeOK + 2);
          Boolean printIndices;

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(Modelica_LinearSystems2.StateSpace(A=[2,1,1;1,1,1;1,2,2], B=[1;2.2;3], C=[2,4,6;3,8,5], D=[6;4], yNames={"y1_test","y2_test"}, xNames={"xx1","xx2","xx3"}, uNames={"u1_test"}));
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(Modelica_LinearSystems2.StateSpace(A=[2, 1.43, 12, 3; 1, 1, 1, 43; 1, 3, 2, 2; 1, 1, 4.2, 1.2], B=[1, 2; 2.2, 3; 3, 1; 4, 0], C=[25, 1.4, 6.3, 1; 0.3, 8, 5, 1; 1, 3, 2, 2], D=[6, 4; 4, 2; 6, 5], yNames={"y1_test","y2_te","y3_"}, xNames={"xx1","x2","xxx3","xx4"}, uNames={"u1_test","u2_test"}));
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printSystem(ss=Modelica_LinearSystems2.StateSpace.Import.fromModel("Modelica.Mechanics.Rotational.Examples.First"), description="Test file in HTML format from function printSystem.");
          // ---------------------------------------------------------------------------------------------------

          if htmlBasics then
            // Text should be printed into new file in HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
          end if;

          print("<" + heading + ">System report</" + heading + ">", fileName);
          print("\n<" + heading2 + ">General information</" + heading2 + ">",
            fileName);
          //print("<h1>System report</h1>", fileName);
          //print("\n<h2>General information</h2>", fileName);

          if systemName == "" then
          else
            print("\n<" + heading3 + ">System name</" + heading3 + ">", fileName);
            //print("\n<h3>System name</h3>", fileName);
            print("<p>\n" + systemName + "\n</p>", fileName);
          end if;

          if description == "" then
          else
            print("\n<" + heading3 + ">Description</" + heading3 + ">", fileName);
            //print("\n<h3>Description</h3>", fileName);
            print("<p>\n" + description + "\n</p>", fileName);
          end if;

          print("\n<" + heading3 + ">Matrices</" + heading3 + ">", fileName);
          //print("\n<h3>Matrices</h3>", fileName);
          print(
            "<p>\nThe system described in the state space representation\n</p>",
            fileName);
          print(
            "<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin:20px 0 20px 20px;\" "
             + "cellpadding=\"3\" border=\"0\"> ", fileName);
          print("<tr><td>der(x) </td> <td>=</td> <td> Ax</td> <td> +</td><td> Bu</td></tr>
         <tr><td> y </td>     <td>=</td> <td> Cx</td> <td> + </td><td>Du</td></tr>",
            fileName);
          print("</table>\n<p>\nis defined by\n</p>", fileName);

          // ===============================
          // Print signal names and matrices (print row and column indices if at least one matrix has more as 5 elements)
          // ===============================
          printIndices := size(ss.A, 1) > 5 or size(ss.B, 2) > 5 or size(ss.C, 1)
             > 5;
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.uNames,
                  "uNames",
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.yNames,
                  "yNames",
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Vectors.printStringVectorInHtml(
                  ss.xNames,
                  "xNames",
                  fileName=fileName,
                  printIndices=printIndices);

          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.A,
                  "A",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.B,
                  "B",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.C,
                  "C",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);
          Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml(
                  ss.D,
                  "D",
                  format=format,
                  fileName=fileName,
                  printIndices=printIndices);

          if ny == 0 and nu == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has neither inputs nor outputs (and therefore matrices B, C, and D are empty matrices)!\n</p>",
              fileName);
          elseif ny == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has no outputs (and therefore matrices C and D are empty matrices)!\n</p>",
              fileName);
          elseif nu == 0 then
            print(
              "<p>\n<b>Note</b>, that the system has no inputs (and therefore matrices B and D are empty matrices)!\n</p>",
              fileName);
          end if;

          if htmlBasics then
            // Last print of HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);
          end if;

        end printSystem;

        encapsulated function printHead1
          "Print the heading of document for characteristics in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input StateSpace ss;
          // This could be deleted sinc not used. But for reasons of beackward compatibility it is still here.
          input Boolean isStable;
          input Boolean isControllable;
          input Boolean isStabilizable;
          input Boolean isObservable;
          input Boolean isDetectable;
          input String fileName="systemHead1.html"
            "File on which the information is written in html format";

          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

          input Boolean htmlBasics=false
            "True, if text should be printed within 'html' and 'body' environment, otherwise text printed into existing file fileName"
            annotation (Dialog(group="HTML format"));
          input Integer hSize(
            min=1,
            max=5) = 2
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));

      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 5 then 5 else hSize;
          String heading="h" + String(hSizeOK);

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead1(Modelica_LinearSystems2.StateSpace(A=[2], B=[1], C=[1], D=[1]), false, false, false, true, false, htmlBasics=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          if htmlBasics then
            // Text should be printed into new file in HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, true);
          end if;

          print("\n<" + heading + ">Characteristics</" + heading +
            ">\n<p>\nThe system\n</p>\n<p> is ", fileName);

          if analyseOptions.printControllability and analyseOptions.printObservability then
            print((if isStable then " " else "<b>not</b> ") + "stable" + "\n<br>"
               + (if isStable then if isControllable then "and it is " else
              "but it is <b>not</b> " else if isControllable then "but it is "
               else "and it is <b>not</b> ") + "controllable" + (if isStable
               then "" else "\n<br>" + (if isControllable then
              " and therefore it is " else if isStabilizable then " but it is "
               else "and is <b>not</b> ") + "stabilizable.") +
              "\n<br> The system is " + (if isObservable then " " else
              "<b>not</b> ") + "observable" + (if isStable then "" else "\n<br>"
               + (if isObservable then " and therefore it is " else if
              isDetectable then " but it is " else "and is <b>not</b> ") +
              "detectable.") + "\n<br>", fileName);
          elseif not analyseOptions.printObservability and analyseOptions.printControllability then
            print((if isStable then " " else "<b>not</b> ") + "stable" + "\n<br>"
               + (if isStable then if isControllable then "and it is " else
              "but it is <b>not</b> " else if isControllable then "but it is "
               else "and it is <b>not</b> ") + "controllable" + (if isStable
               then "" else "\n<br>" + (if isControllable then
              " and therefore it is " else if isStabilizable then " but it is "
               else "and is <b>not</b> ") + "stabilizable.") + "\n<br>", fileName);
          elseif not analyseOptions.printControllability and analyseOptions.printObservability then
            print((if isStable then " " else "<b>not</b> ") + "stable." +
              "\n<br> The system is " + (if isObservable then " " else
              "<b>not</b> ") + "observable" + (if isStable then "" else "\n<br>"
               + (if isObservable then " and therefore it is " else if
              isDetectable then " but it is " else "and is <b>not</b> ") +
              "detectable.") + "\n<br>", fileName);
          else
            print((if isStable then " " else "<b>not</b> ") + "stable." +
              "\n<br>", fileName);
          end if;

          print("</p>", fileName);

          if htmlBasics then
            // Last print of HTML environment
            // --------------------------------------------------------
            StateSpace.Analysis.analysis.printHTMLbasics(fileName, false);
          end if;

        end printHead1;

        encapsulated function printHead2a
          "Print the heading of document for eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input String fileName="systemHead2a.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

          input Boolean printTable=true
            "True, if the system has real eigenvalues to be printed in table";
          input Integer hSize(
            min=1,
            max=5) = 3
            "Size of heading of printed document (=1: Title, =2: Chapter, etc.)"
            annotation (Dialog(group="HTML format"));
      protected
          Integer hSizeOK=if hSize < 1 then 1 else if hSize > 5 then 5 else hSize;
          String heading="h" + String(hSizeOK);

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead2a(htmlBasics=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          print("\n<" + heading + ">Eigenvalues analysis</" + heading + ">",
            fileName);
          //print("<p>\n<b>Real eigenvalues</b>\n</p>", fileName);

          if printTable then
            print("<p>\nThe system has the following real eigenvalues.\n</p>",
              fileName);
            print(
              "<table style=\"background-color:rgb(100, 100, 100);margin:20px 0 20px 20px;\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Real eigenvalues</caption>", fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> eigenvalue </td>\n  <td> T [s] </td>\n  <td> characteristics </td>",
              fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td> contribution to states</td>", fileName);
            end if;

            print("</tr>", fileName);
          else
            print("<p>\nThe system has no real eigenvalues.\n</p>", fileName);
          end if;

        end printHead2a;

        encapsulated function printHead2b
          "Print the heading of document for conjugated complex pairs in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;

          input String fileName="systemHead2b.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");
          input Boolean printTable=true
            "True, if the system has complex pairs to be printed in table";

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead2b();
          // ---------------------------------------------------------------------------------------------------

          if printTable then
            print(
              "<p>\nThe system has the following complex conjugate pairs of eigenvalues.\n</p>",
              fileName);
            print(
              "<table style=\"background-color:rgb(100, 100, 100);margin:20px 0 20px 20px;\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Complex conjugate pairs of eigenvalues</caption>",
              fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> eigenvalue </td>\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n  <td> characteristics </td>",
              fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td> contribution to states</td>", fileName);
            end if;

            print("</tr>", fileName);
          else
            print(
              "<p>\nThe system has no complex conjugate eigenvalue pairs.\n</p>",
              fileName);
          end if;

        end printHead2b;

        encapsulated function printHead3
          "Print the heading of document for description in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;

          input String fileName="systemHead3.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

        algorithm
          print(
            "<p>\nIn the tables above, the column <b>contribution to states</b> lists for each eigenvalue the states to which the"
             +
            " corresponding modal state z[i] contributes most. This information is based on the"
             +
            " two largest absolute values of the corresponding right eigenvector (if the second large value"
             +
            " is less than 5&nbsp;% of the largest contribution, it is not shown). Note"
             +
            " the <b>right eigenvector</b> v<sub>j</sub> and the <b>left eigenvector</b> u<sub>j</sub> of A satisfy the"
             +
            " following relationships with regards to <b>eigenvalue</b> &lambda;<sub>j</sub>,"
             +
            " state vector x and modal state vector z (u<sub>j</sub><sup>H</sup> denotes the conjugate transpose of u<sub>j</sub>):"
             + " </p>" +
            " <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\">" +
            " <tr><td width=\"50\"></td>" +
            "\n    <td>A * v<sub>j</sub> = &lambda;<sub>j</sub> * v<sub>j</sub>; &nbsp;&nbsp;&nbsp;&nbsp;"
             +
            "         u<sub>j</sub><sup>H</sup> * A = &lambda;<sub>j</sub> * u<sub>j</sub><sup>H</sup>; &nbsp;&nbsp;&nbsp;&nbsp;"
             +
            "               x = V * z; &nbsp;&nbsp;&nbsp;&nbsp; V = [v<sub>1</sub>, v<sub>2</sub>, ...]</td>"
             + "           </tr>" + "\n</table>" + "\n<p>" +
            "\nIn the next table, for each state in the column <b>correlation to modal states</b>, the modal"
             +
            " states z[i] which contribute most to the corresponding state are summarized, that is"
             + " the state is mostly composed of these modal states." +
            "\nThis information is based on the two largest absolute values of row i of the"
             +
            " eigenvector matrix that is associated with eigenvalue i (if the second large value"
             +
            " is less than 5&nbsp;% of the largest contribution, it is not shown). This only holds"
             +
            " if the modal states z[i] are in the same order of magnitude. Otherwise, the listed modal states"
             + " might be not the most relevant ones.</p>", fileName);

          print(
            "<table style=\"background-color:rgb(100, 100, 100); margin:20px 0 20px 20px;\" "
             + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">\n" +
            "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
             +
            "\n  <td> state </td>\n  <td> correlation to modal states </td>\n  <td> eigenvalue # </td>"
             +
            "\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n  <td> T [s] </td>\n</tr>",
            fileName);

        end printHead3;

        encapsulated function printHead4
          "Print the heading of document for invariant zeros in html format on file"
          import Modelica;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.StateSpace;

          input String fileName="systemHead4.html"
            "File on which the information is written in html format";
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");
          input Boolean printTable=true
            "True, if the system has complex pairs to be printed in table";

        algorithm
          // ---------------------------------------------------------------------------------------------------
          // The correct HTML format generated with this function can be checked with following commands:
          //   Modelica_LinearSystems2.StateSpace.Analysis.analysis.printHead4(htmlEnv=true, hSize=3);
          // ---------------------------------------------------------------------------------------------------

          if printTable then
            print("<p>\nThe system has the following invariant zeros.\n</p>",
              fileName);
            print(
              "\n<table style=\"background-color:rgb(100, 100, 100); margin:20px 0 20px 20px;\" "
               + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", fileName);
            print("<caption>Invariant zeros</caption>", fileName);
            print(
              "<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
               +
              "\n  <td> number </td>\n  <td> invariant zero </td>\n  <td> Time constant [s] </td>"
               + "\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n</tr>",
              fileName);
          else
            print("<p>\nThe system has no invariant zeros.\n</p>", fileName);
          end if;

        end printHead4;

        encapsulated function printHTMLbasics
          "Print the html preamble or ending on file"
          import Modelica.Utilities.Files;
          import Modelica.Utilities.Streams;

          input String fileName="systemReport.html"
            "File on which the html basics should be written";
          input Boolean printBegin=false
            "True, if beginning of a html file should be printed, otherwise the ending"
            annotation (choices(checkBox=true));

        algorithm
          if printBegin then
            // First print of HTML environment into new file
            Files.removeFile(fileName);
            // Following doesn't work in Dymola
            //Streams.print("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">", fileName);
            Streams.print("<html>", fileName);
            Streams.print(
              "<head>\n  <title>Analysis of a state space system from Modelica LinearSystems2</title>\n</head>",
              fileName);
            Streams.print("<style type=\"text/css\">", fileName);
            Streams.print("* { font-size: 10pt; font-family: Arial,sans-serif; }",
              fileName);
            Streams.print("</style>", fileName);
          else
            // Last print of HTML environment
            Streams.print("</html>", fileName);
          end if;
        end printHTMLbasics;

        encapsulated function printTab1
          "Print the table with real eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Integer evIndex[size(evSorted, 1)];
          input Real r_evec[size(evSorted, 1), size(evSorted, 1)];
          input Real l_evec[size(evSorted, 1), size(evSorted, 1)];
          input Integer nReal;
          input String xNames2[size(evSorted, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evSorted, 1);
          Real w;
          Real d;

          Integer i;
          Integer j;
          Integer k;
          String number;

          Real r_abs_evec[nx];
          Real l_abs_evec[nx];
          Integer r_maxIndex1;
          Integer l_maxIndex1;
          Integer r_maxIndex2;
          Integer l_maxIndex2;
          //  Complex v_normalized[size(evSorted,1)];
          Real r_abs_v_normalized;
          Real l_abs_v_normalized;
          Real r_v;
          Real l_v;
          Real r_absMax1;
          Real l_absMax1;
          Real r_absMax2;
          Real l_absMax2;
          Boolean r_two;
          Boolean l_two;
          Boolean r_first;
          Boolean l_first;

        algorithm
          i := 1;
          j := i;
          while i <= nReal loop
            // Build eigenvalue number

            number := String(
                    i,
                    minimumLength=7,
                    leftJustified=false);
            j := j + 1;

            // Determine largest value in eigenvector
            k := evIndex[i] "Index with respect to unsorted eigen values";
            r_abs_evec := abs(r_evec[:, k]);
            l_abs_evec := abs(l_evec[:, k]);

            r_first := true;
            r_two := false;
            r_absMax1 := 0;
            r_maxIndex1 := 0;
            r_absMax2 := 0;
            r_maxIndex2 := 0;
            r_abs_v_normalized := Modelica.Math.Vectors.norm(r_abs_evec, 1);

            l_first := true;
            l_two := false;
            l_absMax1 := 0;
            l_maxIndex1 := 0;
            l_absMax2 := 0;
            l_maxIndex2 := 0;
            l_abs_v_normalized := Modelica.Math.Vectors.norm(l_abs_evec, 1);
            for j in 1:nx loop
              r_v := r_abs_evec[j];
              l_v := l_abs_evec[j];

              if r_first then
                r_first := false;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif not r_two then
                r_two := true;
                if r_v < r_absMax1 then
                  r_absMax2 := r_v;
                  r_maxIndex2 := j;
                else
                  r_absMax2 := r_absMax1;
                  r_maxIndex2 := r_maxIndex1;
                  r_absMax1 := r_v;
                  r_maxIndex1 := j;
                end if;
              elseif r_v > r_absMax1 then
                r_absMax2 := r_absMax1;
                r_maxIndex2 := r_maxIndex1;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif r_v > r_absMax2 then
                r_absMax2 := r_v;
                r_maxIndex2 := j;
              end if;

              if l_first then
                l_first := false;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif not l_two then
                l_two := true;
                if l_v < l_absMax1 then
                  l_absMax2 := l_v;
                  l_maxIndex2 := j;
                else
                  l_absMax2 := l_absMax1;
                  l_maxIndex2 := l_maxIndex1;
                  l_absMax1 := l_v;
                  l_maxIndex1 := j;
                end if;
              elseif l_v > l_absMax1 then
                l_absMax2 := l_absMax1;
                l_maxIndex2 := l_maxIndex1;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif l_v > l_absMax2 then
                l_absMax2 := l_v;
                l_maxIndex2 := j;
              end if;

            end for;

            r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
            r_absMax2 := 100*r_absMax2/r_abs_v_normalized;

            if r_absMax2 < 0.05*r_absMax1 then
              r_two := false;
            end if;

            l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
            l_absMax2 := 100*l_absMax2/l_abs_v_normalized;

            if l_absMax2 < 0.05*l_absMax1 then
              l_two := false;
            end if;

            // Print data for one eigen value
            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:center\"> "
               + number + " </td>\n  <td style=\"text-align:left\"> &nbsp; " +
              String(evSorted[i].ev.re, format="14.4e") +
              " </td>\n  <td style=\"text-align:left\"> &nbsp; " + (if evSorted[i].timeConstant
               < 1e6 then String(evSorted[i].timeConstant, format="9.4f") else
              "---") + " </td>\n  <td style=\"text-align:left\"> &nbsp; " + (if
              evSorted[i].isStable then "" else "not ") + "stable, " + (if
              evSorted[i].isStable then (if evSorted[i].isControllable then ""
               else "not ") + "controllable, " else (if evSorted[i].isStabilizable
               then "" else "not ") + "stabilizable, ") + (if evSorted[i].isStable
               then (if evSorted[i].isObservable then "" else "not ") +
              "observable " else (if evSorted[i].isDetectable then "" else "not ")
               + "detectable ") + " </td>", fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td style=\"text-align:left\"> &nbsp; " + " z[" + String(i)
                 + "]" + " contributes to " + xNames2[r_maxIndex1] + " with " +
                String(r_absMax1, format=".3g") + " %<br>" + (if r_two then
                "&nbsp; " + " z[" + String(i) + "]" + " contributes to " +
                xNames2[r_maxIndex2] + " with " + String(r_absMax2, format=".3g")
                 + " %" else "") + " </td>", fileName);
            end if;

            print("</tr>", fileName);

            i := j;
          end while;

          print("</table>", fileName);
        end printTab1;

        encapsulated function printTab2
          "Print the table with complex conjugate eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Integer evIndex[size(evSorted, 1)];
          input Real r_evec[size(evSorted, 1), size(evSorted, 1)];
          input Real l_evec[size(evSorted, 1), size(evSorted, 1)];
          input Integer nReal;
          input String xNames2[size(evSorted, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evSorted, 1);

          Integer i;
          Integer k;
          String number;
          String number2;
          Integer j;

          Real r_abs_evec[nx];
          Real l_abs_evec[nx];
          Integer r_maxIndex1;
          Integer r_maxIndex2;
          Integer l_maxIndex1;
          Integer l_maxIndex2;
          Real r_abs_v_normalized;
          Real l_abs_v_normalized;
          Real r_v;
          Real l_v;
          Real r_absMax1;
          Real r_absMax2;
          Real l_absMax1;
          Real l_absMax2;
          Boolean r_two;
          Boolean l_two;
          Boolean r_first;
          Boolean l_first;

        algorithm
          i := nReal + 1;
          j := i;
          while i <= nx loop
            // Build eigenvalue number
            number := String(i) + "/" + String(i + 1);
            number2 := number;
            number := Strings.repeat(max(0, 7 - Strings.length(number))) + number;
            j := j + 2;

            // Determine largest value in eigenvector
            k := evIndex[i] "Index with respect to unsorted eigen values";

            for i2 in 1:nx loop
              r_abs_evec[i2] := sqrt(r_evec[i2, k]^2 + r_evec[i2, k + 1]^2);
              l_abs_evec[i2] := sqrt(l_evec[i2, k]^2 + l_evec[i2, k + 1]^2);
            end for;

            r_first := true;
            r_two := false;
            r_absMax1 := 0;
            r_maxIndex1 := 0;
            r_absMax2 := 0;
            r_maxIndex2 := 0;
            r_abs_v_normalized := Modelica.Math.Vectors.norm(r_abs_evec, 1);
            l_first := true;
            l_two := false;
            l_absMax1 := 0;
            l_maxIndex1 := 0;
            l_absMax2 := 0;
            l_maxIndex2 := 0;
            l_abs_v_normalized := Modelica.Math.Vectors.norm(l_abs_evec, 1);

            for j in 1:nx loop
              r_v := r_abs_evec[j];
              l_v := l_abs_evec[j];

              if r_first then
                r_first := false;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif not r_two then
                r_two := true;
                if r_v < r_absMax1 then
                  r_absMax2 := r_v;
                  r_maxIndex2 := j;
                else
                  r_absMax2 := r_absMax1;
                  r_maxIndex2 := r_maxIndex1;
                  r_absMax1 := r_v;
                  r_maxIndex1 := j;
                end if;
              elseif r_v > r_absMax1 then
                r_absMax2 := r_absMax1;
                r_maxIndex2 := r_maxIndex1;
                r_absMax1 := r_v;
                r_maxIndex1 := j;
              elseif r_v > r_absMax2 then
                r_absMax2 := r_v;
                r_maxIndex2 := j;
              end if;

              if l_first then
                l_first := false;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif not l_two then
                l_two := true;
                if l_v < l_absMax1 then
                  l_absMax2 := l_v;
                  l_maxIndex2 := j;
                else
                  l_absMax2 := l_absMax1;
                  l_maxIndex2 := l_maxIndex1;
                  l_absMax1 := l_v;
                  l_maxIndex1 := j;
                end if;
              elseif l_v > l_absMax1 then
                l_absMax2 := l_absMax1;
                l_maxIndex2 := l_maxIndex1;
                l_absMax1 := l_v;
                l_maxIndex1 := j;
              elseif l_v > l_absMax2 then
                l_absMax2 := l_v;
                l_maxIndex2 := j;
              end if;

            end for;
            r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
            r_absMax2 := 100*r_absMax2/r_abs_v_normalized;
            if r_absMax2 < 0.05*r_absMax1 then
              r_two := false;
            end if;

            l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
            l_absMax2 := 100*l_absMax2/l_abs_v_normalized;
            if l_absMax2 < 0.05*l_absMax1 then
              l_two := false;
            end if;

            // Print data for one eigen value
            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> "
               + number + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(evSorted[i].ev.re, format="14.4e") + " &plusmn; " +
              String(evSorted[i].ev.im, format="12.4e") + "j" + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(evSorted[i].frequency,
              format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(evSorted[i].damping,
              format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + (if evSorted[i].isStable
               then "" else "not ") + "stable, " + (if evSorted[i].isStable then
              (if evSorted[i].isControllable then "" else "not ") +
              "controllable, " else (if evSorted[i].isStabilizable then "" else
              "not ") + "stabilizable, ") + (if evSorted[i].isStable then (if
              evSorted[i].isObservable then "" else "not ") + "observable " else
              (if evSorted[i].isDetectable then "" else "not ") + "detectable ")
               + " </td>", fileName);

            if analyseOptions.printEigenValueProperties then
              print("  <td style=\"text-align:left\"> &nbsp; " + " z[" + number2
                 + "]" + " contribute to " + xNames2[r_maxIndex1] + " with " +
                String(r_absMax1, format=".3g") + " %<br>" + (if r_two then
                "&nbsp; " + " z[" + number2 + "]" + " contribute to " + xNames2[
                r_maxIndex2] + " with " + String(r_absMax2, format=".3g") + " %"
                 else "") + " </td>", fileName);
            end if;

            print("</tr>", fileName);

            i := j;
          end while;

          print("</table>", fileName);
        end printTab2;

        encapsulated function printTab3
          "Print the table with eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Eigenvalue evSorted[:];
          input Complex evecComplex[:, :];
          input Integer evIndex[size(evecComplex, 1)];
          input Complex cev[size(evecComplex, 1)];
          input Integer nReal;
          input String xNames2[size(evecComplex, 1)];
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nx=size(evecComplex, 1);

          Integer maxIndex1;
          Integer maxIndex2;

          Complex v_normalized[size(evecComplex, 1)];
          Real abs_v_normalized;
          Real v;
          Real absMax1;
          Real absMax2;
          Boolean two;
          Boolean first;
          Integer j;
          Integer k;
          Integer iw1;
          Integer iw2;
          String number1;
          String number2;
          Real w1;
          Real w2;
          Real d1;
          Real d2;

        algorithm
          for i in 1:nx loop
            // Normalize i-th row of complex eigenvector matrix and determine two largest elements
            v_normalized := Complex.Vectors.normalize(evecComplex[i, :]);
            first := true;
            two := false;
            absMax1 := 0;
            maxIndex1 := 0;
            absMax2 := 0;
            maxIndex2 := 0;
            j := 1;
            abs_v_normalized := Complex.Vectors.norm(v_normalized, 1);
            while j <= nx loop
              if cev[j].im == 0 then
                v := abs(v_normalized[j].re);
                k := j;
                j := j + 1;
              else
                v := 2*Complex.'abs'(v_normalized[j]);
                k := j;
                j := j + 2;
              end if;

              if first then
                first := false;
                absMax1 := v;
                maxIndex1 := k;
              elseif not two then
                two := true;
                if v < absMax1 then
                  absMax2 := v;
                  maxIndex2 := k;
                else
                  absMax2 := absMax1;
                  maxIndex2 := maxIndex1;
                  absMax1 := v;
                  maxIndex1 := k;
                end if;
              elseif v > absMax1 then
                absMax2 := absMax1;
                maxIndex2 := maxIndex1;
                absMax1 := v;
                maxIndex1 := k;
              elseif v > absMax2 then
                absMax2 := v;
                maxIndex2 := k;
              end if;
            end while;

            if abs_v_normalized > 1e-30 then
              absMax1 := absMax1/abs_v_normalized;
              absMax2 := absMax2/abs_v_normalized;
            end if;

            if absMax2 < 0.05*absMax1 then
              two := false;
            end if;

            // Determine frequency and number of corresponding eigenvalue
            (w1,d1) := Complex.frequency(cev[maxIndex1]);
            iw1 := Modelica.Math.Vectors.find(maxIndex1, evIndex);
            if iw1 <= nReal then
              number1 := String(iw1);
            else
              number1 := String(iw1) + "/" + String(iw1 + 1);
            end if;

            if two then
              (w2,d2) := Complex.frequency(cev[maxIndex2]);
              iw2 := Modelica.Math.Vectors.find(maxIndex2, evIndex);
              if iw2 <= nReal then
                number2 := String(iw2);
              else
                number2 := String(iw2) + "/" + String(iw2 + 1);
              end if;
            end if;

            if two then
              print(
                "<tr style=\"background-color:white\">\n  <td rowspan=2 style=\"text-align:left\"> &nbsp; "
                 + xNames2[i] + " </td>" +
                "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax1, format="5.1f") + "% by z[" + number1 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number1 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(w1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(d1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then String(evSorted[i].timeConstant, format="9.4f") else
                "--- </td>") + "\n</tr>\n<tr style=\"background-color:white\">"
                 + "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax2, format="5.1f") + "% by z[" + number2 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number2 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw2 <= nReal
                 then "---" else String(w2, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw2 <= nReal
                 then "---" else String(d2, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if (iw2 <=
                nReal and abs(cev[maxIndex2].re) > 1e-10) then String(1/abs(cev[
                maxIndex2].re), format="9.4f") else "--- </td>\n</tr>"), fileName);
            else
              print(
                "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
                 + xNames2[i] + " </td>" +
                "\n  <td style=\"text-align:left\"> &nbsp; is composed of " +
                String(100*absMax1, format="5.1f") + "% by z[" + number1 +
                "]</td>" + "\n  <td style=\"text-align:center\"> &nbsp; " +
                number1 + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(w1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then "---" else String(d1, format="9.4f")) + "</td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal
                 then String(evSorted[i].timeConstant, format="9.4f") else
                "--- </td>\n</tr>"), fileName);
            end if;
            //     print("<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; " + xNames2[i] + " </td>\n  <td style=\"text-align:left\"> &nbsp; "
            //        + " is composed of " + String(100*absMax1, format="5.1f") + "% by z[" +
            //       number1 + "]" + (if two then " <br>" + " &nbsp; " + " is composed of " +
            //       String(100*absMax2, format="5.1f") + "% by z[" + number2 + "]" else "") + " </td> <td style=\"text-align:center\"> &nbsp; "
            //        + number1 + (if two then "<br> &nbsp; " + number2 else Strings.repeat(9))
            //        + " </td> <td style=\"text-align:center\"> &nbsp; " + (if iw1 <= nReal then
            //             "---" else String(w1, format="9.4f")) + (if two then "<br> &nbsp; "
            //        + (if iw2 <= nReal then "---" else String(w2, format="9.4f")) else
            //       Strings.repeat(9)) + " </td>\n  <td style=\"text-align:center\"> &nbsp; " +
            //       (if iw1 <= nReal then "---" else String(d1, format="9.4f")) + (if two then
            //             "<br> &nbsp; " + (if iw2 <= nReal then "---" else String(d2,
            //       format="9.4f")) else "") + " </td>\n  <td style=\"text-align:center\"> &nbsp; "
            //        + (if (iw1 <= nReal) then String(evSorted[i].timeConstant, format="9.4f") else
            //             "---") + (if two then "<br> &nbsp; " + (if (iw2 <= nReal and abs(
            //       cev[maxIndex2].re) > 1e-10) then String(1/abs(cev[maxIndex2].re),
            //       format="9.4f") else "---") else "") + " </td>\n</tr> ", fileName);

          end for;
          print("</table>", fileName);

        end printTab3;

        encapsulated function printTab4
          "Print the table with eigenvalues in html format on file"
          import Modelica;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Internal.Eigenvalue;
          import Modelica_LinearSystems2.Math.Complex;

          input Complex systemZeros[:];
          input Integer evIndex[size(systemZeros, 1)];
          input Integer nReal;
          input String fileName;
          input Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
              Modelica_LinearSystems2.Internal.AnalyseOptions(
                    plotEigenValues=true,
                    plotInvariantZeros=true,
                    plotStepResponse=true,
                    plotFrequencyResponse=true,
                    printEigenValues=true,
                    printEigenValueProperties=true,
                    printInvariantZeros=true,
                    printControllability=true,
                    printObservability=true,
                    headingEigenValues="Eigenvalues",
                    headingInvariantzeros="Invariant zeros",
                    headingStepResponse="Step response",
                    headingFrequencyResponse="Frequency response");

      protected
          Integer nz=size(systemZeros, 1);

          String number;
          Real timeConstant;
          Real freq;
          Real damp;

        algorithm
          for i in 1:nReal loop
            // Build eigenvalue number

            number := String(
                    i,
                    minimumLength=7,
                    leftJustified=false);
            timeConstant := if abs(systemZeros[i].re) > 10*Modelica.Constants.eps
               then 1/abs(systemZeros[i].re) else 1/(10*Modelica.Constants.eps);

            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
               + number + " </td>" + "\n  <td> &nbsp; " + String(systemZeros[i].re,
              format="14.4e") + " </td>" + "\n  <td> &nbsp; " + String(
              timeConstant, format="9.4f") + " </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>\n</tr>",
              fileName);

          end for;

          for i in nReal + 1:2:nz loop
            number := String(i) + "/" + String(i + 1);
            number := Strings.repeat(max(0, 7 - Strings.length(number))) + number;

            // Determine frequency and number of corresponding zero
            (freq,damp) := Complex.frequency(systemZeros[i]);

            print(
              "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
               + number + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(systemZeros[i].re, format="14.4e") + " &plusmn; " +
              String(systemZeros[i].im, format="12.4e") + "j </td>" +
              "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
              "\n  <td style=\"text-align:left\"> &nbsp; " + String(freq, format=
              "9.4f") + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
               + String(damp, format="9.4f") + " </td>\n</tr>", fileName);

          end for;

          print("</table>\n", fileName);
        end printTab4;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Modelica_LinearSystems2.StateSpace.Analysis.<b>analysis</b>(ss);
   or
Modelica_LinearSystems2.StateSpace.Analysis.<b>analysis</b>(
  ss,
  analyseOptions=<a href=\"modelica://Modelica_LinearSystems2.Internal.AnalyseOptions\">analyseOptions</a>,
  fileName,
  systemName,
  description);
</pre></blockquote>

<h4>Description</h4>
<p>
This function analyzes a state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b> * <b>x</b> + <b>B</b> * <b>u</b>
    <b>y</b>  = <b>C</b> * <b>x</b> + <b>D</b> * <b>u</b>     <label for=\"eqn1\">(1)</label>
    <b>x</b>(t=0) = <b>x</b><sub>0</sub>
</pre></blockquote>
<p>
based on its poles, i.e. the eigenvalues, and the zeros of the system.
The system will be checked for stability, controllability and observability. In the case that the system is not stable stabilizability and detectability are examined. Furthermore, stability, controllability, observability, stabilizability, and detectability are indicated for each eigenvalue.
</p>

<h5>Stability</h5>
<p>
System (1) is stable if and only if all eigenvalues of the matrix <b>A</b> have negative real parts.
The calculation of the eigenvalues is based on the LAPACK routine dgeev.
</p>

<h5>Controllability</h5>
<p>
System (1) is said to be controllable if, starting from any initial state <b>x</b><sub>0</sub>, the system can be driven by appropriate inputs to any final state <b>x</b><sub>1</sub> within some finite time window. Equivalent is that the eigenvalues of <b>A</b>-<b>BK</b> can  arbitrarily be assigned by an appropriate choice of the matrix <b>K</b>.
</p>

<h5>Stabilizability</h5>
<p>
System (1) is said to be stabilizable if all the unstable eigenvalues, i.e. all <tt>s</tt> with Re(<tt>s</tt>)>=0, of <b>A</b> are controllable. Therefore, a controllable system is always stabilizable. An equivalent definition of stabilizability is, that a system is said to be stabilizable if there exist a matrix <b>K</b> such that <b>A</b>-<b>BK</b> is stable.
</p>

<h5>Observability</h5>
<p>
System (1) is said to be observable if the (arbitrary) initial state <b>x</b><sub>0</sub> can be uniquely determined from any state <b>x</b>(t<sub>1</sub>), t<sub>1</sub>>0, from the knowledge of the input <b>u</b>(t) and output <b>y</b>(t). With other words,  from the system's outputs it is possible to determine the behavior of the entire system. Equivalent is, that the eigenvalues of <b>A</b>-<b>LC</b> can be arbitrarily be assigned by an appropriate choice of matrix <b>L</b>.
Observability is called the dual concept of controllability, since a system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) is observable if the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) is controllable.
</p>

<h5>Detectability</h5>
<p>
System (1) is said to be detectable if all the unstable eigenvalues, i.e. all <tt>s</tt> with Re(<tt>s</tt>)>=0, of <b>A</b> are observable. Therefore, a observable system is always detectable. An equivalent definition of detectability is, that a system is said to be detectable if there exist a matrix <b>L</b> such that <b>A</b>-<b>LC</b> is stable.
Detectability is called the dual concept of stabilizability, since a system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) is detectable if the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) is stabilizable.
</p>

<h5>Algorithm to test controllability/stabilizability and observability/detectability respectively</h5>
<p>
The test of controllability and stabilizability is performed with the staircase algorithm which transforms the system (<b>A</b>,<b>B</b>,<b>C</b>,<b>D</b>) into the controller-Hessenberg form (<b>A</b><sub>H</sub>, <b>B</b><sub>H</sub>, <b>C</b><sub>H</sub>, <b>D</b>) with <b>A</b><sub>H</sub> is a block upper Hessenberg matrix and <b>B</b><sub>H</sub>=[<b>B</b><sub>1</sub>; 0] with triangular matrix <b>B</b><sub>1</sub> with rank(<b>B</b><sub>1</sub>) = rank(<b>B</b>).
In <b>A</b><sub>H</sub>=[<b>A</b><sub>c</sub>, *,0, <b>A</b><sub>nc</sub>) the eigenvalues of the matrices <b>A</b><sub>c</sub> and <b>A</b><sub>nc</sub> are the controllable eigenvalues and uncontrollable eigenvalues of <b>A</b> respectively.
The test of observability and detectability is performed by testing the system (<b>A</b><sup>T</sup>, <b>C</b><sup>T</sup>, <b>B</b><sup>T</sup>, <b>D</b><sup>T</sup>) with respect to controllability and stabilizability.
</p>

<h5>Solution of a linear time invariant system </h5>
<p>
The solution <b>x</b>(t) of the initial value problem (1) consists of the homogeneous part (zero input response) <b>x</b><sub>h</sub>(t) and the inhomogeneous part x<sub>i</sub>(t). The zero input solution is given by
</p>
<blockquote><pre>
<b>x</b><sub>h</sub>(t) = exp(<b>A</b>*(t-t<sub>0</sub>))<b>x</b><sub>0</sub>.
</pre></blockquote>
<p>
The system can also be represented as a linear combination of the modal states <b>z</b>,
</p>
<blockquote><pre>
<b>x</b> = <b>V</b><b>z</b>
</pre></blockquote>
<p>
i.e. the states of a similar system, with
</p>
<blockquote><pre>
der(<b>z</b>) = <b>V</b><sup>-1</sup><b>AVz</b> + <b>V</b><sup>-1</sup><b>B</b><b>u</b>
</pre></blockquote>
<p>
where the system matrix <b>V</b><sup>-1</sup><b>AV</b> is the real Jordan form. For single real eigenvectors the system is decoupled, i.e. the solution of the modal states are denoted by
<blockquote><pre>
z<sub>i</sub> = exp(s<sub>i</sub> t)*z<sub>0i</sub>
</pre></blockquote>
<p>
The behavior of the modal states is determined as the solution of a linear first order differential equation for real eigenvalues. Since this behavior is well known, the behavior of the x<sub>i</sub> can at least roughly be estimated by means of the behavior of the most relevant modal states. Therefore, the contribution of the modal states to the states is computed as an indication of the original system behavior.
</p>

<h5>Contribution of the modal states to the states</h5>
<p>
Generally, as described above, the states of the system can be described as linear combination of modal states and, therefore, the states can be characterized to a certain extend by the modal states if the proportions of the combination are known. Hence, for each modal state z<sub>i</sub> of the vector <b>z</b> the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub>| of the corresponding right eigenvector <b>v</b><sub>i</sub> indicate the proportion of <b>z</b><sub>i</sub> that is contributed to the state x<sub>j</sub>.
On the other hand, the composition of xi is indicated by the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub><sup>T</sup>|, i.e. the elements |v<sub>i,j</sub>|/|<b>v</b><sub>i</sub><sup>T</sup>| of the corresponding row <b>v</b><sub>i</sub><sup>T</sup> of the eigenvector matrix <b>V</b> indicate the proportion of the state x<sub>i</sub> that is contributed by the modal state z<sub>j</sub>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ss=StateSpace(
    A=[-3,2,-3,4,5,6; 0,6,7,8,9,4; 0,2,3,0,78,6; 0,1,2,2,3,3; 0,13,34,0,0,1; 0,
      0,0,-17,0,0],
    B=[1,0; 0,1; 1,0; 0,1; 1,0; 0,1],
    C=[0,0,1,0,1,0; 0,1,0,0,1,1],
    D=[0,0; 0,0],
    xNames={\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\"},
    uNames={\"u1\",\"u2\"}, yNames={\"y1\",\"y2\"});

  String fileName=\"analysis.html\";
  String systemName=\"Demonstration System\";
  String description=\"System to demonstrate the usage of Modelica_LinearSystems2.StateSpace.Analysis.anlysis()\"

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Analysis.analysis(ss, fileName=fileName, systemName=systemName, description=description)
//  gives:
</pre></blockquote>

<h4>System report</h4>
<p>
The system <b>Demonstation System</b>
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b> * <b>x</b> + <b>B</b> * <b>u</b>
    <b>y</b>  = <b>C</b> * <b>x</b> + <b>D</b> * <b>u</b>
</pre></blockquote>
<p>
is defined by
</p>
<blockquote><pre>
        x1   x2   x3   x4   x5   x6            u1  u2
    x1  -3    2   -3    4    5    6         x1  1   0
    x2   0    6    7    8    9    4         x2  0   1
A = x3   0    2    3    0   78    6     B = x3  1   0
    x4   0    1    2    2    3    3         x4  0   1
    x5   0   13   34    0    0    1         x5  1   0
    x6   0    0    0  -17    0    0         x6  0   1

        x1   x2   x3   x4   x5   x6            u1  u2
C = y1   0    0    1    0    1    0     D = y1  0   0
    y2   0    1    0    0    1    1         y2  0   0
</pre></blockquote>

<h5>Description</h5>
<p>
System to demonstrate the usage of Modelica_LinearSystems2.StateSpace.Analysis.analysis()
</p>

<h5>Characteristics</h5>
<p>The system
<br> is
not stable
<br>but it is controllable
<br> and therefore it is stabilizable
<br> The system is not observable
<br> but it is detectable
</p>

<p>
<b><big>Eigenvalues analysis</big></b>
<br><br>
<b>Real eigenvalues</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin:20px 0 20px 20px;\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td><td> eigenvalue </td> <td> T [s] </td>  <td> characteristics </td><td> contribution to states</td></tr>
<tr>
 <td style=\"text-align:center\">       1 </td> <td style=\"text-align:left\"> &nbsp;   -4.9874e+001 </td> <td style=\"text-align:left\"> &nbsp;    0.0201 </td> <td style=\"text-align:left\"> &nbsp; stable, controllable, observable  </td> <td style=\"text-align:left\"> &nbsp;  z[1] contributes to x3 with 54.6 %<br>&nbsp;  z[1] contributes to x5 with 37 % </td> </tr>
<tr>
 <td style=\"text-align:center\">       2 </td> <td style=\"text-align:left\"> &nbsp;   -3.0000e+000 </td> <td style=\"text-align:left\"> &nbsp;    0.3333 </td> <td style=\"text-align:left\"> &nbsp; stable, controllable, not observable  </td> <td style=\"text-align:left\"> &nbsp;  z[2] contributes to x1 with 100 %<br> </td> </tr>
<tr>
 <td style=\"text-align:center\">       3 </td> <td style=\"text-align:left\"> &nbsp;    2.9891e+000 </td> <td style=\"text-align:left\"> &nbsp;    0.3346 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[3] contributes to x2 with 51.9 %<br>&nbsp;  z[3] contributes to x1 with 23.9 % </td> </tr>
<tr>
 <td style=\"text-align:center\">       4 </td> <td style=\"text-align:left\"> &nbsp;    5.5825e+001 </td> <td style=\"text-align:left\"> &nbsp;    0.0179 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[4] contributes to x3 with 48.4 %<br>&nbsp;  z[4] contributes to x5 with 32.5 % </td> </tr>
</table>

<p>
<b>Conjugated complex pairs of eigenvalues</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin:20px 0 20px 20px;\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td> <td> eigenvalue </td><td> freq. [Hz] </td> <td> damping </td><td> characteristics </td>  <td> contribution to states</td></tr>
<tr>
 <td style=\"text-align:left\">     5/6 </td> <td style=\"text-align:left\"> &nbsp;    1.0299e+000 &plusmn;  6.5528e+000j </td> <td style=\"text-align:left\"> &nbsp;    1.0557 </td> <td style=\"text-align:left\"> &nbsp;   -0.1553 </td> <td style=\"text-align:left\"> &nbsp; not stable, stabilizable, detectable  </td> <td style=\"text-align:left\"> &nbsp;  z[    5/6] contribute to x6 with 35.9 %<br>&nbsp;  z[    5/6] contribute to x2 with 20.6 % </td> </tr>
</table>

<p>
In the table above, the column <b>contribution to states</b> lists for each eigenvalue the states
to which thecorresponding modal state contributes most. This information is based on the
two largest absolute values of the corresponding right eigenvector (if the second large value
is less than 5&nbsp;% of the largest contribution, it is not shown).
</p>

<p>
In the next table, for each state in the column <b>correlation to modal states</b>, the modal
states which contribute most to the coresponding state are summarized, i.e. the state is mostly composed of these modal states
This information is based on the two largest absolute values of row i of the
eigenvector matrix that is associated with eigenvalue i (if the second large value
is less than 5&nbsp;% of the largest contribution, it is not shown). This only holds
if the modal states are in the same order of magnitude. Otherwise, the modal states
listed in the last column might be not the most relevant one.
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin:20px 0 20px 20px;\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> state </td> <td> composition </td> <td> eigenvalue #</td> <td> freq. [Hz] </td> <td> damping </td> <td> T [s] </td></tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x1 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  42.5% by z[2] <br> &nbsp;  is composed of  35.4% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 2<br> &nbsp; 5/6 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    1.0557 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp;    0.0201<br> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x2 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  44.2% by z[3] <br> &nbsp;  is composed of  43.7% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 3<br> &nbsp; 5/6 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    1.0557 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp;    0.3333<br> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x3 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  36.9% by z[1] <br> &nbsp;  is composed of  36.3% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 1<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;    0.3346<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x4 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  88.9% by z[5/6] <br> &nbsp;  is composed of   9.8% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 5/6<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp;    1.0557<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;   -0.1553<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x5 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  45.3% by z[1] <br> &nbsp;  is composed of  44.1% by z[4] </td> <td style=\"text-align:center\"> &nbsp; 1<br> &nbsp; 4 </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; ---<br> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp;    0.0000<br> &nbsp;    0.0179 </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp; x6 </td> <td style=\"text-align:left\"> &nbsp;  is composed of  95.7% by z[5/6] </td> <td style=\"text-align:center\"> &nbsp; 5/6          </td> <td style=\"text-align:center\"> &nbsp;    1.0557          </td> <td style=\"text-align:center\"> &nbsp;   -0.1553 </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
</table>

<p>
<b>Invariant zeros</b>
</p>
<table style=\"font-size:10pt; font-family:Arial; border-collapse:collapse; margin:20px 0 20px 20px;\" cellpadding=\"3\" border=\"1\" cellspacing=\"0\">
<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\"><td> number </td> <td> invariant zero </td><td> Time constant [s] </td> <td> freq. [Hz] </td> <td> damping </td></tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;       1 </td> <td> &nbsp;   -5.4983e+001 </td> <td> &nbsp;    0.0182 </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;       2 </td> <td> &nbsp;   -3.0000e+000 </td> <td> &nbsp;    0.3333 </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:center\"> &nbsp; --- </td> </tr>
<tr>
 <td style=\"text-align:left\"> &nbsp;     3/4 </td> <td style=\"text-align:left\"> &nbsp;    3.2417e+000 &plusmn;  5.6548e+000j </td> <td style=\"text-align:center\"> &nbsp; --- </td> <td style=\"text-align:left\"> &nbsp;    1.0374 </td> <td style=\"text-align:left\"> &nbsp;   -0.4973 </td> </tr>
</table>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end analysis2;
      annotation (Documentation(info="<html>
<p>
This package collects functions used for common analyses on a state space system
represented by a StateSpace record.
</p>
</html>"));
    end Analysis;

    encapsulated package Design
      "Package of functions to design state space controllers and observers"
      import Modelica;
      extends Modelica.Icons.Package;
      encapsulated function assignPolesSI
        "Pole placement for single input systems using Ackermann's formula."

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Modelica_LinearSystems2.Math.Complex p[size(ss.A, 1)]
          "Vector of desired poles";
        output Real k[size(ss.A, 1)] "Feedback gain matrix";

    protected
        Real cm[size(ss.B, 1), size(ss.A, 1)*size(ss.B, 2)];
        Modelica_LinearSystems2.Math.Polynomial poly;
        Real Y[size(ss.A, 1), size(ss.A, 2)];
        Real X[:, :];
        Modelica_LinearSystems2.Math.Complex p_actual[size(p, 1)];
        Modelica_LinearSystems2.Math.Complex p_sorted[size(p, 1)];
        Real poleError;
        Modelica_LinearSystems2.Math.Complex smaller;
      algorithm
        assert(size(ss.B, 2) == 1, "System must be SI but has " + String(size(ss.B,
          2)) + " inputs");
        cm := StateSpace.Analysis.controllabilityMatrix(ss);
        assert(Modelica.Math.Matrices.rank(cm) == size(cm, 1) or
          Modelica.Math.Matrices.rank(cm) == size(cm, 2),
          "Controllability matrix has not full rank. System is not controllable!");
        poly := Modelica_LinearSystems2.Math.Polynomial(p);
        Y := Modelica_LinearSystems2.Math.Polynomial.evaluateMatrix(poly, ss.A);
        X := zeros(size(cm, 2), size(Y, 2));
        for j in 1:size(Y, 2) loop
          X[:, j] := Modelica.Math.Matrices.leastSquares(cm, vector(Y[:, j]));
        end for;
        k := X[size(ss.A, 1), :];

        // Check results
        // sort p
        p_sorted := p;
        for i1 in 1:size(p_sorted, 1) loop
          for i2 in (1 + i1):size(p_sorted, 1) loop
            if Modelica_LinearSystems2.Math.Complex.'abs'(p_sorted[i1]) >
                Modelica_LinearSystems2.Math.Complex.'abs'(p_sorted[i2]) then
              smaller := p_sorted[i2];
              p_sorted[i2] := p_sorted[i1];
              p_sorted[i1] := smaller;
            end if;
          end for;
        end for;

        p_actual := Modelica_LinearSystems2.Math.Complex.eigenValues(ss.A - ss.B*
          transpose(matrix(k)));
        // sort actual eigenvalues
        for i1 in 1:size(p_actual, 1) loop
          for i2 in (1 + i1):size(p_actual, 1) loop
            if Modelica_LinearSystems2.Math.Complex.'abs'(p_actual[i1]) >
                Modelica_LinearSystems2.Math.Complex.'abs'(p_actual[i2]) then
              smaller := p_actual[i2];
              p_actual[i2] := p_actual[i1];
              p_actual[i1] := smaller;
            end if;
          end for;
        end for;

        // check for poles that have an error of more than 10%
        for i in 1:size(p_sorted, 1) loop
          if (Modelica_LinearSystems2.Math.Complex.'abs'(p_sorted[i]) <> 0) then
            poleError := Modelica_LinearSystems2.Math.Complex.'abs'((p_sorted[i]
               - p_actual[i]))/Modelica_LinearSystems2.Math.Complex.'abs'(
              p_sorted[i]);

            if poleError > 0.1 then
              Modelica.Utilities.Streams.print("Warning: Pole location of pole "
                 + String(p_sorted[i]) + " has an error of " + String(100*
                poleError) + "%. (Is " + String(p_actual[i]) + ")");

            end if;
          end if;
        end for;

        annotation (Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end assignPolesSI;

      encapsulated function assignPolesMI
        "Pole assignment design algorithm for multi input systems"

        import Modelica;
        //  import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Matrices;

        input StateSpace ss "State space system";

        input Complex gamma[:]=fill(Complex(0), 0) "Designed Poles";
        //  input Integer np=size(gamma, 1) "number of given eigenvalues to assign";
        input Real alpha=-1e10
          "Maximum admissible value for real parts of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm";
        input Real tolerance=Modelica.Math.Matrices.norm(ss.A, 1)*1e-12
          "Tolerance to be used in determining the controllability of (A,B)";
        input Boolean calculateEigenvectors=false
          "Calculate the eigenvectors X of the closed loop system when true";

        output Real K[size(ss.B, 2), size(ss.A, 1)]
          "State feedback matrix assigning the desired poles";
        output Real S[:, :] "Closed loop System matrix";
        output Complex po[size(ss.A, 1)] "poles of the closed loop system";
        output Integer nfp
          "number of eigenvalues that are not modified with respect to alpha";
        output Integer nap "number of assigned eigenvalues";
        output Integer nup "number of uncontrollable eigenvalues";
        output Complex X[size(ss.A, 1), size(ss.A, 1)]
          "eigenvectors of the closed loop system";

    protected
        Real A_rsf[size(ss.A, 1), size(ss.A, 2)];
        Real B_rsf[size(ss.B, 1), size(ss.B, 2)];
        Real Q[size(ss.A, 1), size(ss.A, 1)];
        Real Ks1[:, :];
        Real Ks2[:, :];
        Real Q2[:, :];
        Real A_rsf_1[:, :];
        Real Q1[:, :];
        Boolean select[:];
        Boolean rselectA[:];
        Real Z[:, :] "orthogonal transformation matrix";
        Real ZT[:, :] "orthogonal transformation matrix";
        Complex pf[:];
        Complex gammaReordered[:]=gamma;
        Integer info;
        Real wr[size(gamma, 1)];
        Real wi[size(gamma, 1)];
        Boolean imag=false;
        Integer i;
        Integer ii;
        Integer iii;
        Integer counter;
        Integer counter2;
        Integer n=size(ss.A, 1);
        Integer nccA "number of conjugated complex pole pairs of openloop system";
        Integer nccg "number of conjugated complex pole pairs of gamma";
        Integer rpg "number of real poles in gamma";
        Integer rpA "number of real poles of open loop system";
        Integer ncc "Min(nccA, nccg)";
        Integer rp "Min(rpg, rpA)";
        Integer ng=size(gamma, 1);
        Integer nr "Differenz between rpA and rpg; Sign(rpA-rpg)*(rpA-rpg)";

        Real alphaReal[size(ss.A, 1)]
          "Real part of eigenvalue=alphaReal+i*alphaImag";
        Real alphaImag[size(ss.A, 1)]
          "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";

        Complex SS[:, :];
        Complex Xj[:, :];
        Complex h;

        Real dist;
        Real evImag;

      algorithm
        assert(size(gamma, 1) <= size(ss.A, 1),
          "At most n (order of ss) eigenvalues can be assigned");

        /* Extraction of Poles (Variable conversation) and pole sequence check */
        for i in 1:size(gamma, 1) loop
          wr[i] := gamma[i].re;
          wi[i] := gamma[i].im;
          if imag then
            assert(wi[i - 1] == -wi[i] and wr[i - 1] == wr[i],
              "Poles are in wrong sequence");
            imag := false;
          elseif wi[i] <> 0 then
            imag := true;
          end if;
        end for;

        // put matrix ss.A to real Schur form A <- QAQ' and compute B <- QB
        (A_rsf,Z,alphaReal,alphaImag) := Modelica.Math.Matrices.realSchur(ss.A);
        ZT := transpose(Z);

        // reorder real Schur form according to alpha
        (A_rsf,Z,alphaReal,alphaImag) := Matrices.Internal.reorderRSFc(
              A_rsf,
              identity(size(A_rsf, 1)),
              alphaReal,
              alphaImag,
              alpha);
        ZT := transpose(Z)*ZT;
        B_rsf := ZT*ss.B;

        // determine number of poles not to be assigned according to alpha
        nfp := 0;
        for i in 1:n loop
          if alphaReal[i] < alpha then
            nfp := nfp + 1;
          end if;
        end for;
        nap := n - nfp;

        assert(size(gamma, 1) >= nap, String(nap) +
          " poles should be modified, therefore gamma should contain at at least "
           + String(nap) + " assigned eigenvalues");

        // second reorder (reorderRSF3) according to conjugated complex pairs in A and p
        // count numbre of conjugated complex pole pairs = max(number_ccpp(eig(A), number_ccpp(gamma))
        nccA := 0;
        //mark the real poles of original system
        rselectA := fill(true, nap);
        ii := 1;
        for i in nfp + 1:n loop
          if abs(alphaImag[i]) > 0 then
            nccA := nccA + 1;
          else
            rselectA[ii] := false;

          end if;
          ii := ii + 1;
        end for;
        rpA := n - nccA;
        nccA := div(nccA, 2);

        // reorder gamma and A_rsf
        (gammaReordered,rpg) := Modelica_LinearSystems2.Internal.reorderZeros(
          gamma);
        gammaReordered := Complex.Vectors.reverse(gammaReordered);
        nccg := div(size(gammaReordered, 1) - rpg, 2);
        ncc := min(nccA, nccg);
        rp := min(rpA, rpg);
        if nccA > 0 then
          (A_rsf[nfp + 1:n, nfp + 1:n],Q2) := Matrices.LAPACK.dtrsen(
                "E",
                "V",
                rselectA,
                A_rsf[nfp + 1:n, nfp + 1:n],
                identity(n - nfp));
          //The Schur vector matrix is identity, since A_rsf already has Schur form

          A_rsf[1:nfp, nfp + 1:n] := A_rsf[1:nfp, nfp + 1:n]*Q2;
          B_rsf[nfp + 1:n, :] := transpose(Q2)*B_rsf[nfp + 1:n, :];
          ZT[nfp + 1:n, :] := transpose(Q2)*ZT[nfp + 1:n, :];
        end if;

        // main algorithm
        K := zeros(size(ss.B, 2), size(ss.A, 1));
        counter := nfp + 1;
        counter2 := 1;

        for i in 1:rp loop
          // 1x1 blocks; real system pole and real assigned poles; take the next eigenvalue in the
          // diagonal of the Schur form and search the nearest pole in the set of the real poles to assign
          dist := Modelica.Constants.inf;
          for ii in i:rpg loop
            // looking for nearest pole and reorder gamma
            if abs(A_rsf[n, n] - gammaReordered[ng - ii + 1].re) < dist then
              iii := ng - ii + 1;
              dist := abs(A_rsf[n, n] - gammaReordered[ng - ii + 1].re);
            end if;
          end for;
          h := gammaReordered[ng - i + 1];
          gammaReordered[ng - i + 1] := gammaReordered[iii];
          gammaReordered[iii] := h;

          Ks1 := StateSpace.Internal.assignOneOrTwoPoles(
                matrix(A_rsf[n, n]),
                transpose(matrix(B_rsf[n, :])),
                {gammaReordered[ng - i + 1]},
                tolerance);
          K := K + [zeros(size(Ks1, 1), size(K, 2) - 1), Ks1]*ZT;
          A_rsf := A_rsf - B_rsf*[zeros(size(Ks1, 1), size(K, 2) - 1), Ks1];
          select := fill(false, n - counter + 1);
          select[n - counter + 1] := true;

          (A_rsf[counter:n, counter:n],Q1) := Matrices.LAPACK.dtrsen(
                "E",
                "V",
                select,
                A_rsf[counter:n, counter:n],
                identity(n - counter + 1));
          //The Schur vector matrix is identity, since A_rsf already has Schur form

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q1;
          B_rsf[counter:n, :] := transpose(Q1)*B_rsf[counter:n, :];
          ZT[counter:n, :] := transpose(Q1)*ZT[counter:n, :];
          counter := counter + 1;
          counter2 := counter2 + 1;
        end for;

        if counter2 < rpg and counter2 > rpA then
          //System has less real eigenvalues than real assigned poles
          for i in 1:div(rpg - rpA, 2) loop
            // 2x2 blocks; complex pair of system poles and 2 real assigned poles; take the next complex pair
            // (Schur bump) in the diagonal of the Schur form and search the two nearest poles in the set of the
            // remaining real assigned poles
            dist := Modelica.Constants.inf;
            evImag := sqrt(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);
            //positive imaginary part of the complex system pole pair
            for ii in 2*(i - 1) + 1:2:rpg - rpA loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag
                   < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) +
                  evImag;
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*(i - 1)];
            gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
            gammaReordered[iii] := h;
            dist := Modelica.Constants.inf;
            for ii in 2*(i - 1) + 1:2:rpg - rpA loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag
                   < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) +
                  evImag;
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*i + 1];
            gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii];
            gammaReordered[iii] := h;

            Ks2 := StateSpace.Internal.assignOneOrTwoPoles(
                  A_rsf[n - 1:n, n - 1:n],
                  matrix(B_rsf[n - 1:n, :]),
                  gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
                  tolerance);

            K := K + [zeros(size(Ks2, 1), size(K, 2) - 2), Ks2]*ZT;
            A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2), Ks2];
            select := fill(false, n - counter + 1);
            select[n - counter:n - counter + 1] := {true,true};

            (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
                  "E",
                  "V",
                  select,
                  A_rsf[counter:n, counter:n],
                  identity(n - counter + 1));
            //The Schur vector matrix is identity, since A_rsf already has Schur form

            A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
            B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
            ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
            counter := counter + 2;
            counter2 := counter2 + 2;
          end for;
        end if;

        if counter2 > rpg and counter2 < rpA then
          //System has more real eigenvalues than real assigned poles
          for i in 1:div(rpA - rpg, 2) loop
            // 2x2 blocks; 2 real system poles and a pair of complex assigned poles; take the next two real
            // eigenvalues in the diagonal of the Schur form and search the complex pole pair of the assigned poles
            // which is nearest to the two real poles
            dist := Modelica.Constants.inf;
            for ii in 2*(i - 1) + 1:2:rpA - rpg loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + abs(
                  gammaReordered[ng - rp - ii + 1].im) + abs(A_rsf[n - 1, n - 1]
                   - gammaReordered[ng - rp - ii + 1].re) + abs(gammaReordered[ng
                   - rp - ii + 1].im) < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) +
                  abs(gammaReordered[ng - rp - ii + 1].im) + abs(A_rsf[n - 1, n
                   - 1] - gammaReordered[ng - rp - ii + 1].re) + abs(
                  gammaReordered[ng - rp - ii + 1].im);
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*(i - 1)];
            gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
            gammaReordered[iii] := h;
            h := gammaReordered[ng - rp - 2*i + 1];
            gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii - 1];
            gammaReordered[iii - 1] := h;

            Ks2 := StateSpace.Internal.assignOneOrTwoPoles(
                  A_rsf[n - 1:n, n - 1:n],
                  matrix(B_rsf[n - 1:n, :]),
                  gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
                  tolerance);

            K := K + [zeros(size(Ks2, 1), size(K, 2) - 2), Ks2]*ZT;
            A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2), Ks2];
            select := fill(false, n - counter + 1);
            select[n - counter:n - counter + 1] := {true,true};

            (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
                  "E",
                  "V",
                  select,
                  A_rsf[counter:n, counter:n],
                  identity(n - counter + 1));
            //The Schur vector matrix is identity, since A_rsf already has Schur form

            A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
            B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
            ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
            counter := counter + 2;
            counter2 := counter2 + 2;
            //      Modelica.Utilities.Streams.print("counter2Case3 = " + String(counter2));
          end for;
        end if;

        for i in 1:ncc loop
          // 2x2 blocks; 2 complex system poles and two complex assigned poles; take the next complex
          // system pole pair (next Schur bump) in the diagonal of the Schur form and search the complex
          //  assigned pole pair which is nearest
          dist := Modelica.Constants.inf;
          evImag := sqrt(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);
          //positive imaginary part of the complex system pole pair
          for ii in 2*(i - 1) + 1:2:2*ncc loop
            if abs(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + abs(evImag
                 - abs(gammaReordered[2*ncc - ii + 1].im)) < dist then
              iii := 2*ncc - ii + 1;
              dist := abs(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + abs(
                evImag - abs(gammaReordered[2*ncc - ii + 1].im));
            end if;
          end for;
          h := gammaReordered[2*ncc - 2*(i - 1)];
          gammaReordered[2*ncc - 2*(i - 1)] := gammaReordered[iii];
          gammaReordered[iii] := h;
          h := gammaReordered[2*ncc - 2*i + 1];
          gammaReordered[2*ncc - 2*i + 1] := gammaReordered[iii - 1];
          gammaReordered[iii - 1] := h;

          Ks2 := StateSpace.Internal.assignOneOrTwoPoles(
                A_rsf[n - 1:n, n - 1:n],
                matrix(B_rsf[n - 1:n, :]),
                gammaReordered[2*ncc - 2*i + 1:2*ncc - 2*(i - 1)],
                tolerance);
          K := K + [zeros(size(Ks2, 1), size(K, 2) - 2), Ks2]*ZT;
          A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2), Ks2];
          select := fill(false, n - counter + 1);
          select[n - counter:n - counter + 1] := {true,true};

          (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
                "E",
                "V",
                select,
                A_rsf[counter:n, counter:n],
                identity(n - counter + 1));
          //The Schur vector matrix is identity, since A_rsf already has Schur form

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
          B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
          ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
          counter := counter + 2;
          counter2 := counter2 + 2;
        end for;

        S := ss.A - ss.B*K;
        po := Complex.eigenValues(S);

        if calculateEigenvectors then
          //     X := fill(Complex(0), n, n);
          //     for i in 1:n loop
          //       SS := Complex(1)*S;
          //       for ii in 1:n loop
          //         SS[ii, ii] := SS[ii, ii] - po[i];
          //       end for;
          //       Xj := Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace(
          //                                  SS);
          //       for ii in 1:n loop
          //         X[ii, i] := Xj[ii, 1];
          //       end for;
          //     end for;
          //      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,"X1");
          X := Complex.eigenVectors(S);
          //      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,"X2");

        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(K, S, po, nfp, nap, nup) = StateSpace.Design.<b>assignPolesMI</b>(ss, gamma, np, tol, calculateEigenvectors)
</pre></blockquote>

<h4>Description</h4>
<p>
The purpose of this function is to determine the state feedback matrix <b>K</b> for a
given time invariant multi input state system (<b>A</b>,<b>B</b>) such that the
closed-loop state matrix <b>A</b>-<b>B</b>*<b>K</b> has specified eigenvalues. The
feedback matrix <b>K</b> is calculated by factorization following [1]. The algorithm
modifies the eigenvalues sequentially and also allows partial eigenvalue assignment.
</p>
<p>
At the beginning of the algorithm, the feedback matrix <b>K</b> is set to zero (<b>K</b> = <b>0</b>) and the matrix <b>A</b> is
reduced to an ordered real Schur form by separating its spectrum in two parts
</p>
<blockquote><pre>
             | <b>F</b>1  <b>F</b>3|
<b>F</b> = <b>Q</b>*<b>A</b>*<b>Q</b>' = |       |
             | <b>0</b>   <b>F</b>2|
</pre></blockquote>
<p>
in such a way, that <b>F</b>1 contains the eigenvalues that will be
retained and <b>F</b>3 contains the eigenvalues going to be modified. On the suggestion
of [1] the eigenvalues <i>evr</i> to be retained are chosen as
</p>
<blockquote><pre>
evr = {s in C: Re(s) &lt; -alpha, alpha &gt;= 0}
</pre> </blockquote>
<p>
but other specification are conceivable of course.
</p>
<p>
Let
</p>
<blockquote><pre>
<b>G</b> = [<b>G</b>1;<b>G</b>2] = <b>Q</b>*<b>B</b>
</pre> </blockquote>
<p>
with an appropriate partition according to <b>F</b>2. (<b>F</b>2, <b>G</b>2) has to be
controllable.
</p>
<p>
If the feedback matrix <b>K</b> is taken in a form
</p>
<blockquote><pre>
<b>K</b> = [0, <b>K</b>2]
</pre></blockquote>
<p>
the special structure of <b>F</b> and <b>K</b> results in a closed loop state
matrix
</p>
<blockquote><pre>
          |<b>F</b>1 <b>F</b>3 - <b>G</b>1*<b>K</b>2|
<b>F</b> - <b>G</b>*<b>K</b> = |             |
          |0  <b>F</b>2 - <b>G</b>2*<b>K</b>2|
</pre></blockquote>
<p>
with only the eigenvalues of <b>F</b>2 are modified. This approach to modify
separated eigenvalues is used to sequentially shift one real eigenvalue ore two
complex conjugated eigenvalues stepwise until all assigned eigenvalues are placed.
Therefore, at each step i always the (two) lower right eigenvalue(s) are modified by an
appropriate feedback matrix <b>K</b>i. The matrix <b>F</b> - <b>G</b>*<b>K</b>i remains in real Schur form. The
assigned eigenvalue(s) is (are) then moved to another diagonal position of the real Schur
form using reordering techniques <b>F</b> &lt; -- <b>Q</b>i*<b>F</b>*<b>Q</b>i'  and a new block is transferred to the
lower right diagonal position. The transformations are accumulated in <b>Q</b>i and are also
applicated to the matrices
</p>
<blockquote><pre>
<b>G</b> &lt; - <b>Q</b>i*<b>G</b> <b>Q</b> &lt; - <b>Q</b>i*<b>Q</b>
</pre></blockquote>
<p>
The eigenvalue(s) to be assigned at  each step is (are) chosen such that the norm of each <b>K</b>i is minimized [1].
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1,1; 0,-2],
    B=[0; 1],
    C=[1,0; 0,1],
    D=[0; 0]);

  Complex p[:]={Complex(-3,0),Complex(-4,0)};

<b>algorithm</b>
  (K, S, newPoles) := Modelica_LinearSystems2.StateSpace.Design.assignPolesMI(ss, p);

 // K = [6.0, 4.0]
 // S = [-1.0, 1.0; -6.0, -6.0]
 // newPoles = {-3, -4}
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga A. (1981):</dt>
<dd> <b>A Schur method for pole assignment</b>.
     IEEE Trans. Autom. Control, Vol. AC-26, pp. 517-519.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end assignPolesMI;

      function kalmanFilter "Design of a Kalman estimator matrix"
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "Time-continuous system in state space form";
        input Real Q[size(ss.A, 1), size(ss.A, 1)]
          "Covariance Matrix of state noise (n x n), n number of states";
        input Real R[size(ss.C, 1), size(ss.C, 1)]
          "Covariance Matrix of output noise (m x m), m number of inputs";

    public
        output Real L[:, :] "Kalman filter matrix";
        output StateSpace kss(
          redeclare Real A[size(ss.A, 1), size(ss.A, 1)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2) + size(ss.C, 1)],
          redeclare Real C[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real D[size(ss.A, 1), size(ss.B, 2) + size(ss.C, 1)])
          "kalman system";

    protected
        Real AR[:, :]=transpose(ss.A);
        Real BR[:, :]=transpose(ss.C);
        Real CR[:, :]=zeros(1, size(AR, 1));
        Real DR[:, :]=zeros(1, size(BR, 2));
        StateSpace rss=StateSpace(
                AR,
                BR,
                CR,
                DR) "System to calculate the Kalman estimator with lqr algorithm";

        Real AK[size(ss.A, 1), size(ss.A, 1)];
        Real BK[size(ss.B, 1), size(ss.B, 2) + size(ss.C, 1)];
        Real CK[size(ss.A, 1), size(ss.A, 2)];
        Real DK[size(ss.A, 1), size(ss.B, 2) + size(ss.C, 1)];
        // matrices of the kalman system kss

      algorithm
        (L) := StateSpace.Design.lqr(
              rss,
              Q,
              R);
        L := transpose(L);

        AK := ss.A - L*ss.C;
        BK[:, 1:size(ss.B, 2)] := ss.B - L*ss.D;
        BK[:, size(ss.B, 2) + 1:size(BK, 2)] := L;
        CK := identity(size(ss.A, 1));
        DK := zeros(size(ss.A, 1), size(ss.B, 2) + size(ss.C, 1));

        kss := StateSpace(
              AK,
              BK,
              CK,
              DK);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(L, kss) = StateSpace.Design.<b>kalmanFilter</b>(ss, Q, R)
</pre></blockquote>

<h4>Description</h4>
<p>
This functions designs the kalman-bucy filter, that reconstructs
plant states and system output without noise.
As input it uses the plant input and output.
</p>
<p>
Noise affects the plant states via q(t)
</p>
<blockquote>d
x/dt = Ax + Bu + q(t)
</blockquote>
<p>
The plant output is affected by r(t)
</p>
<blockquote>
y = Cx + Du + r(t)
</blockquote>
<p>
The covariance matrices of q and r have to be given via Q and R, respectively.
</p>
<p>
The filter uses an observer that tries to reconstruct the original behaviour. Its states and outputs are trailed with a hat (^)<br>
The observer is controlled by feedback of the output difference y - y^ (y^= Cx^+ Du)
over a Matrix L, such that x^
</p>
<blockquote>
dx^/dt = (A - LC) x^ + (B - LD)u + Ly
</blockquote>
<p>
follows the plant state x. L is designed to minimize noise in states and inputs.
L is calculated from a Riccati Equation
</p>
<blockquote><pre>
    -1
SC'R  CS - SA' - AS - Q = 0
        -1
L = SC'R
</pre></blockquote>

<p>
The representation of the estimation model would be as follows:
</p>
<blockquote><pre>
.                            |u|
x^  = [A-LC] x^ + [B-LD , L] | |
                             |y|
                    |u|
y^ = [C] x^ + [D 0] | |
                    |y|
</pre></blockquote>
<p>
Since the controller approach was made to provide the estimated states, the representation of the ooutput kss is such that
</p>
<blockquote><pre>
y^ = x^
</pre></blockquote>
<p>
i.e., kss:
</p>
<blockquote><pre>
.                            |u|
x^  = [A-LC] x^ + [B-LD , L] | |
                             |y|
            |u|
y^ = Ix^ + 0| |
            |y|
</pre></blockquote>
<p>
i.e.
</p>
<blockquote><pre>
C^ = I,   D^ = 0   with appropriate sizes, i.e. size(C^) = {nx,nx},  size(D^) = {nx, nu+ny}.
</pre></blockquote>

<p>
Since the calculation of a Kalman filter is the dual problem of lqr calculation function
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Design.lqr\">Modelica_LinearSystems2.StateSpace.Design.lqr</a>
is used to solve the Riccati euation.<br>
The algebraic Riccati equation is solved by using the Schur algorithm
<a href=\"modelica://Modelica_LinearSystems2.Math.Matrices.care\">care</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  import Modelica_LinearSystems2.StateSpace;
  import Modelica_LinearSystems2.TransferFunction;
  StateSpace css = StateSpace(TransferFunction.constructor({1},{1,2,3,4}));
  Real Q[:,:] = identity(3);
  Real R[:,:] = [1];

  Real L[:,:];
  StateSpace kss(
            redeclare Real A[size(css.A,1),size(css.A,1)],
            redeclare Real B[size(css.B,1),size(css.B,2)+size(css.C,1)],
            redeclare Real C[size(css.C,1)+size(css.A,1),size(css.C,2)],
            redeclare Real D[size(css.C,1)+size(css.A,1),size(css.B,2)+size(css.C,1)]);

<b>algorithm</b>
  ( L, kss) := StateSpace.Design.kalmanFilter(css, Q, R);
//  L = [0.9928;
       (-0.0072);
       (-1.4868)]
// kss = StateSpace(
          A = [-0.993,     1,     0;
                0.007,     0,     1;
               -2.513,     3,    -2],

          B = [ 0,         0.993;
                0,        -0.0072;
                1,        -1.4868],

          C = [ 1,     0,     0;
                0,     1,     0;
                0,     0,     1],

          D = [ 0,     0;
                0,     0;
                0,     0])
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end kalmanFilter;

      encapsulated function lqr "LQR design algorithm"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math;

        input StateSpace ss "Open loop system in state space form";
        input Real Q[size(ss.A, 1), size(ss.A, 2)]=identity(size(ss.A, 1))
          "State weighting matrix";
        input Real R[size(ss.B, 2), size(ss.B, 2)]=identity(size(ss.B, 2))
          "Input weighting matrix";
    protected
        Boolean iscontinuousSystem=true;
    public
        output Real K[size(ss.B, 2), size(ss.A, 1)] "Feedback gain matrix";
        output StateSpace sslqr(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]) "closed loop system";

        output Real S[size(ss.A, 1), size(ss.A, 1)]
          "solution of the Riccati equation";

        output Math.Complex ev[:];

      algorithm
        if min(size(ss.A, 1), size(ss.A, 2)) > 0 then
          assert(StateSpace.Analysis.isControllable(ss),
            "System in function \"Modelica_LinearSystems2.StateSpace.Design.lqr\" has to be controllable");
          if iscontinuousSystem then
            (S,ev) := Math.Matrices.care(
                  ss.A,
                  ss.B,
                  R,
                  Q);
            K := Modelica.Math.Matrices.solve2(R, transpose(ss.B)*S);
          else
            (S,ev) := Math.Matrices.dare(
                  ss.A,
                  ss.B,
                  R,
                  Q);
            K := Modelica.Math.Matrices.solve2(R + transpose(ss.B)*S*ss.B, transpose(ss.B)
              *S*ss.A);
          end if;

          sslqr.A := ss.A - ss.B*K;
          sslqr.B := ss.B;
          sslqr.C := ss.C - ss.D*K;
          sslqr.D := ss.D;

        else
          K := fill(
                0,
                size(ss.B, 2),
                size(ss.A, 1));
          ev := fill(Modelica_LinearSystems2.Math.Complex(0), 0);
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(K, sslqr, X, ev) = StateSpace.<b>lqr</b>(ss, Q, R, true)
</pre></blockquote>

<h4>Description</h4>
<p>
The optimal and stabilizing gain matrix <b>K</b> for a state-feedback law <b>u</b> = -<b>K</b>*<b>x</b>
is designed such that the cost function
</p>
<blockquote><pre>
J = Integral {<b>x</b>'*<b>Q</b>*<b>x</b> + <b>u</b>'*<b>R</b>*<b>u</b>} dt
</pre></blockquote>
<p>
of the continuous time case or
</p>
<blockquote><pre>
Jd = Sum {<b>x</b>'k*<b>Q</b>*<b>x</b>k + <b>u</b>'k*<b>R</b>*<b>u</b>k}
</pre></blockquote>
<p>
of the discrete time case is minimized. The cases are chosen by the input <b>iscontinuousSystem</b> This is done by solving
the continuous-time algebraic Riccati equation (CARE)
</p>
<blockquote><pre>
<b>Q</b> + <b>A</b>'*<b>X</b> + <b>X</b>*<b>A</b> - <b>X</b>*<b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b> = <b>0</b>
</pre></blockquote>
<p>
or the discrete-time algebraic Riccati equation (DARE)
</p>
<blockquote><pre>
<b>X</b> - <b>A</b>'*<b>X</b>*<b>A</b> + <b>A</b>'*<b>X</b>*<b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>*<b>B</b>'*<b>X</b>*<b>A</b> - <b>Q</b> = <b>0</b>
</pre>
</blockquote>
<p>
for <b>X</b> using the Schur vector approach. See <a href=\"modelica://Modelica_LinearSystems2.Math.Matrices.care\">care</a> and <a href=\"Modelica://Modelica_LinearSystems2.Math.Matrices.dare\">dare</a> respectively for more details.
</p>
<p>
The gain matrix <b>K</b> of the continuous-time case is calculated from
</p>
<blockquote><pre>
<b>K</b> = <b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b>
</pre></blockquote>
<p>
or from
</p>
<blockquote><pre>
<b>K</b> = (<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>*<b>B</b>'*<b>X</b>*<b>A</b>
</pre></blockquote>
<p>
for the discrete-time case.
The output state space system sslqr represents the closed loop system
</p>
<blockquote><pre>
  .
  <b>x</b> = [<b>A</b> - <b>BK</b>] <b>x</b> + <b>Bu</b>

  <b>y</b> = [<b>C</b> - <b>DK</b>] <b>x</b> + <b>Du</b>

</pre></blockquote>
<p>
The output S is the solution of the Riccati equation
</p>
<p>
The eigenvalues of the closed loop system <b>A</b> - <b>B</b>*<b>K</b> are computed as complex output ev.
</p>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss=StateSpace(
    A=[0, 1, 0, 0; 0, 0, 39.2, 0; 0, 0, 0, 1; 0, 0, 49, 0],
    B=[0; 1; 0; 1],
    C=[1, 0, 0, 0],
    D=[0]);
  Real Q[:,:]=identity(4);
  Real R[:,:]=identity(1);
  Real K[size(ss.B, 2),size(ss.A, 1)];

<b>algorithm</b>
  K := StateSpace.Design.lqr(ss, Q, R);

// K = [-1, -3.63271, 108.763, 18.3815]
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end lqr;

      encapsulated function lqg "LQG design algorithm"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math;

        input StateSpace ss "Open loop system in state space form";
        input Real Q[size(ss.A, 1), size(ss.A, 2)]=identity(size(ss.A, 1))
          "State weighting matrix";
        input Real R[size(ss.B, 2), size(ss.B, 2)]=identity(size(ss.B, 2))
          "Input weighting matrix";
        input Real V[size(ss.C, 1), size(ss.C, 1)]=identity(size(ss.C, 1))
          "Covariance output noise matrix";
        input Real W[size(ss.A, 1), size(ss.A, 1)]=identity(size(ss.A, 1))
          "Covariance state noise matrix";

        input Boolean iscontinuousSystem=true
          "True, if state space system is continuous";

        output Real Kc[size(ss.B, 2), size(ss.A, 1)]
          "Controller feedback gain matrix";
        output Real Kf[size(ss.A, 1), size(ss.C, 1)]
          "Kalman feedback gain matrix";

        output StateSpace sslqg(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.C, 1)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.C, 1), size(ss.C, 1)]) "Closed loop system";

    protected
        Real AR[:, :]=transpose(ss.A);
        Real BR[:, :]=transpose(ss.C);
        Real CR[:, :]=zeros(1, size(AR, 1));
        Real DR[:, :]=zeros(1, size(BR, 2));
        // System for lqr
        StateSpace rss=StateSpace(
                AR,
                BR,
                CR,
                DR);
        Real Sc[size(ss.A, 1), size(ss.A, 1)]
          "Solution of the Riccati equation, controller";
        Real Sf[size(ss.A, 1), size(ss.A, 1)]
          "Solution of the Riccati equation, filter";

      algorithm
        if min(size(ss.A, 1), size(ss.A, 2)) > 0 then
          assert(StateSpace.Analysis.isControllable(ss),
            "System in function \"Modelica_LinearSystems2.StateSpace.Design.lqg\" has to be controllable");

          if iscontinuousSystem then
            (Sc,) := Math.Matrices.care(
                  ss.A,
                  ss.B,
                  R,
                  Q);
            Kc := Modelica.Math.Matrices.solve2(R, transpose(ss.B)*Sc);
          else
            (Sc,) := Math.Matrices.dare(
                  ss.A,
                  ss.B,
                  R,
                  Q);
            Kc := Modelica.Math.Matrices.solve2(R + transpose(ss.B)*Sc*ss.B, transpose(ss.B)
              *Sc*ss.A);
          end if;

          assert(StateSpace.Analysis.isObservable(ss),
            "System in function \"Modelica_LinearSystems2.StateSpace.Design.lqg\" has to be observable");
          if iscontinuousSystem then
            (Sf,) := Math.Matrices.care(
                  rss.A,
                  rss.B,
                  V,
                  W);
            Kf := transpose(Modelica.Math.Matrices.solve2(V, ss.C*Sf));
          else
            (Sf,) := Math.Matrices.dare(
                  rss.A,
                  rss.B,
                  V,
                  W);
            Kf := transpose(Modelica.Math.Matrices.solve2(V + rss.C*Sf*rss.B, rss.C*Sf*rss.A));
          end if;

        else
          Kc := fill(
                0,
                size(ss.B, 2),
                size(ss.A, 1));
          Kf := fill(
                0,
                size(ss.C, 1),
                size(ss.A, 1));

        end if;

        sslqg.A := ss.A - Kf*ss.C - ss.B*Kc + Kf*ss.D*Kc;
        sslqg.B := Kf;
        sslqg.C := ss.C - ss.D*Kc;
        sslqg.D := zeros(size(ss.C, 1), size(ss.C, 1));

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(Kc, Kf, sslqg) = StateSpace.<b>lqg</b>(ss, Q, R, V, W)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates matrices <b>K</b>c and <b>K</b>f for linear quadratic gaussian problem (LQG), i.e. the minimization of the expected value of a cost function in consideration of stochastically disturbed states and outputs of the system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b><b>x</b> + <b>B</b><b>u</b> + <b>w</b>
     <b>y</b> = <b>C</b><b>x</b> + <b>D</b><b>u</b> + <b>v</b>
</pre></blockquote>
<p>
The noise <b>w</b>(t) and <b>v</b>(t) are supposed to be both white, Gaussian zero-mean, stationary stochastic processes with positive semidefinte covariance matrix <b>W</b>
</p>
<blockquote><pre>
E[<b>w</b>(t)*<b>w</b>'(tau)] = <b>W</b>*delta(t-tau)
</pre></blockquote>
<p>
and positive covariance matrix <b>V</b>
</p>
<blockquote><pre>
E[<b>v</b>(t)*<b>v</b>'(tau)] = <b>V</b>*delta(t-tau).
</pre></blockquote>
<p>
E[s] denotes the expected value of a signal s.
</p>
<p>
The LQG approach combines the deterministic <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Design.lqr\">LQR</a> approach and <a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Design.kalmanFilter\">Kalman filter</a> principle to estimate stochastically disturbed systems, such that input <b>u</b>(t) is given by
</p>
<blockquote><pre>
<b>u</b>(t) = -<b>K</b>c<b>x</b>^(t)
</pre></blockquote>
<p>
where <b>K</b>c is a lqr feedback matrix and x^(t) the reconstructed state vector estimated by a Kalman filter.
</p>
<p>
Since, the considered problem is stochastic, the objective function to minimize is an expected value
</p>
<blockquote><pre>
           1      T
J = lim   ---- E[Integral (<b>x</b>'*<b>Q</b>*<b>x</b> + <b>u</b>'*<b>R</b>*<b>u</b>)dt],
  (T->inf) 2T    -T
</pre></blockquote>
<p>
where the weighting matrices <b>Q</b> and <b>R</b> are, respectively, symmetric positive semidefinite and positive definite.
</p>
<p>
The feedback matrix Kc is calculated by
</p>
<blockquote><pre>
<b>K</b>c = <b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b>c,
</pre></blockquote>
<p>
where <b>X</b>c satisfying the continuous-time algebraic Riccati equation (<a href=\"modelica://Modelica_LinearSystems2.Math.Matrices.care\">care</a>)
</p>
<blockquote><pre>
<b>Q</b> + <b>A</b>'*<b>X</b>c + <b>X</b>c*<b>A</b> - <b>X</b>c*<b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b>c = <b>0</b>.
</pre></blockquote>
<p>
The matrix <b>K</b>f of the filter problem to generate the estimated state vector <b>x</b>^(t) is given by
</p>
<blockquote><pre>
<b>K</b>f = <b>X</b>f*<b>C</b>T*<b>V</b>-1,
</pre></blockquote>
<p>
where <b>X</b>f is satisfying the continuous-time algebraic Riccati equation
</p>
<blockquote><pre>
<b>W</b> + <b>A</b>*<b>X</b>f + <b>X</b>f*<b>A</b>' - <b>X</b>f*<b>C</b>'*<b>V</b><sup>-1</sup>*<b>C</b>*<b>X</b>f = <b>0</b>.
</pre></blockquote>
<p>
The vector <b>x</b>^(t) satisfies the differential equation
</p>
<blockquote><pre>
.
<b>x</b>^(t) = (<b>A</b> - <b>K</b>f<b>C</b>)<b>x</b>^(t) + (<b>B</b> - <b>K</b>f<b>D</b>)<b>u</b>(t) + <b>K</b>f<b>y</b>(t)
</pre></blockquote>
<p>
Combining the equation state feedback and state estimation, the state vector <b>x</b>(t) and the estimated state vector <b>x</b>^(t) are given by
</p>
<blockquote><pre>
 .
|<b>x</b> |   | <b>A</b>         -<b>B</b><b>K</b>c      |  |<b>x</b> |   | <b>I</b>   <b>0</b> |  | <b>w</b> |
|  | = |                     |  |  | + |       |  |   |
|<b>x</b>^|   | <b>K</b>f<b>C</b>   <b>A</b> - <b>B</b><b>K</b>c - <b>K</b>f<b>C</b> |  |<b>x</b>^|   | <b>0</b>  <b>K</b>f |  | <b>v</b> |.
</pre></blockquote>
<p>
Finally, the output sslqg represents the estimated system with <b>y</b>(t), the output of the real system, as the input
</p>
<blockquote><pre>
.
<b>x</b>^ = [<b>A</b> - <b>K</b>f<b>C</b> - <b>B</b><b>K</b>c + <b>K</b>f<b>D</b><b>K</b>c]*<b>x</b>^ + <b>K</b>f*<b>y</b>

<b>y</b>^ = [<b>C</b> - <b>D</b><b>K</b>c] <b>x</b>^
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss=StateSpace(
    A=[-0.02, 0.005, 2.4,  -32; -0.14,  0.44,  -1.3,  -30; 0,  0.018,  -1.6,  1.2; 0, 0, 1, 0],
    B=[0.14,  -0.12; 0.36, -8.6; 0.35, 0.009; 0, 0],
    C=[0, 1, 0, 0; 0, 0, 0, 57.3],
    D=[0,0; 0,0]);

   Real Q[:,:] = transpose(ss.C)*ss.C \" state weighting matrix\";
   Real R[:,:] = identity(2) \" input weighting matrix\";
   Real V[:,:] = identity(2) \" covariance output noise matrix\";
   Real W[:,:] = ss.B*transpose(ss.B) \" covariance state noise matrix\";
   Real Kc[size(ss.B, 2),size(ss.A, 1)] \"Controller feedback gain matrix\";
   Real Kf[size(ss.A, 1),size(ss.C, 1)] \"Kalman feedback gain matrix\";

<b>algorithm</b>
  (Kc, Kf) := StateSpace.Design.lqg(ss, Q, R, V, W);

// Kc = [-0.0033,     0.04719,      14.6421,        60.8894;
          0.0171,    -1.05154,       0.29273,        3.2468]

// Kf = [0.015,     -0.2405;
         9.066,     -0.1761;
         0.009,      0.2289;
        -0.003,      0.08934]
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end lqg;

    end Design;

    encapsulated package Plot
      "Package of functions to plot state space system responses"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function polesAndZeros
        "Plot poles (i.e. eigenvalues) and/or invariant zeros of a state space system"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "Linear system in state space form"
          annotation (Dialog);
        input Boolean poles=true
          "= true, to plot the poles (i.e. the eigenvalues) of ss"
          annotation (choices(checkBox=true));
        input Boolean zeros=true "= true, to plot the (invariant) zeros of ss "
          annotation (choices(checkBox=true));

        input Boolean print=true
          "= true, to print the selection to the output window"
          annotation (choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=if poles and zeros then
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros()
               else if poles then
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
              heading="Eigenvalues (x)") else
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
              heading="Invariant zeros (o)"));
    protected
        Integer nx=size(ss.A, 1);
        Real EigReal[:, 2];
        Real InvZerosReal[:,2];
        Complex invZeros[:];
        Complex eig[:];
        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2;
        Real Ab[size(ss.A,1),size(ss.A,1)];
        Real Bb[size(ss.A,1),size(ss.B,2)];
        Real Cb[size(ss.C,1),size(ss.A,1)];
      algorithm
        if poles and size(ss.A, 1) > 0 then
          EigReal := Modelica_LinearSystems2.Math.Matrices.eigenValuesAsRealMatrix(ss.A);
        else
          EigReal := fill(0.0,0,2);
        end if;

        if zeros and size(ss.A,1) > 0 and size(ss.B,2) > 0 and size(ss.C,1) > 0 then
          (,Ab,Bb,Cb) :=Modelica_LinearSystems2.Internal.balanceABC(
            ss.A,
            ss.B,
            ss.C);
          InvZerosReal := Modelica_LinearSystems2.StateSpace.Internal.invariantZerosWithRealMatrix(Ab,Bb,Cb,ss.D);
        else
          InvZerosReal :=fill(0.0,  0, 2);
        end if;

        i := 0;
        if poles then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=EigReal[:, 1],
                y=EigReal[:, 2],
                legend="Eigenvalues",
                lineColor={0,0,255},
                autoLine=false,
                linePattern=Plot.Types.LinePattern.None,
                lineSymbol=Plot.Types.PointSymbol.Cross);
        end if;
        if zeros then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=InvZerosReal[:,1],
                y=InvZerosReal[:,2],
                legend="invariant zeros",
                lineColor={255,0,0},
                autoLine=false,
                linePattern=Plot.Types.LinePattern.None,
                lineSymbol=Plot.Types.PointSymbol.Circle);
        end if;

        diagram2 := defaultDiagram;
        diagram2.curve := curves[1:i];
        Plot.diagram(diagram2, device);

        if print then
           if poles then
              eig :=fill(Complex(0), size(EigReal, 1));
              for i in 1:size(eig,1) loop
                 eig[i].re :=EigReal[i, 1];
                 eig[i].im :=EigReal[i, 2];
              end for;
              Modelica_LinearSystems2.Math.Complex.Vectors.printHTML(eig,heading="Eigenvalues", name="eigenvalue");
           end if;

           if zeros then
              invZeros :=fill(Complex(0), size(InvZerosReal, 1));
              for i in 1:size(invZeros,1) loop
                 invZeros[i].re :=InvZerosReal[i, 1];
                 invZeros[i].im :=InvZerosReal[i, 2];
              end for;
              Modelica_LinearSystems2.Math.Complex.Vectors.printHTML(invZeros,heading="Invariant zeros", name="invariant zero");
           end if;
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>polesAndZeros</b>(ss);
   or
StateSpace.Plot.<b>polesAndZeros</b>(
  ss,
  poles=true,
  zeros=true,
  plot=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>());
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots a pole-zero-map of the poles and transmission zeros of a state space system.
The poles are the eigenvalues of the system matrix (eigenvalues(ss.A)). The Boolean inputs
\"poles\" and \"zeros\" define what to plot. If Boolean input \"plot = true\", the pole-zero-map
is plotted. If false, only the diagram is generated and returned as output argument.
The records \"defaultDiagram\" and \"device\" allow to set various layout options and the
size and location of the diagram on the screen.
</p>

<h4>Example</h4>
<p>
The example <a href=\"modelica://Modelica_LinearSystems2.Examples.StateSpace.plotPolesAndZeros\">
Modelica_LinearSystems2.Examples.StateSpace.plotPolesAndZeros</a>
is defined as
</p>
<pre>
  Plot.polesAndZeros(ss = Modelica_LinearSystems2.StateSpace(
    A=[-3, 2,-3,  4, 5,6;
        0, 6, 7,  8, 9,4;
        0, 2, 3,  0,78,6;
        0, 1, 2,  2, 3,3;
        0,13,34,  0, 0,1;
        0, 0, 0,-17, 0,0],
    B=[1,0;
       0,1;
       1,0;
       0,1;
       1,0;
       0,1],
    C=[0,0,1,0,1,0;
       0,1,0,0,1,1],
    D=[0,0;
       0,0]));
</pre>

<p>
and results in
</p>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/polesAndZerosSS.png\"/>
</blockquote>
</html>"));
      end polesAndZeros;

      encapsulated function bodeSISO
        "Plot bode plot of the corresponding transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Internal;

        input StateSpace ss "State space system";
        input Integer iu=1 "Index of input";
        input Integer iy=1 "Index of output";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "= true, if abszissa range is automatically determined";
        input Modelica.Units.SI.Frequency f_min=0.1
          "Minimum frequency value, if autoRange = false";
        input Modelica.Units.SI.Frequency f_max=10
          "Maximum frequency value, if autoRange = false";

        input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot());

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));
        input Boolean onFile=false
          "= true, if frequency response is stored on file as matrix [f,a,phi]" annotation(choices(checkBox=true));
        input String fileName="frequencyResponse.mat"
          "If onFile=true, file on which the frequency response will be stored" annotation(Dialog(enable=onFile));
        input String matrixName=if Hz and not dB then "fHz_a_phiDeg" elseif
                                   Hz and dB then "fHz_adB_phiDeg" elseif
                                   not Hz and dB then "f_adB_phiDeg" else "f_a_phiDeg"
          "If onFile=true, Name of matrix on file" annotation(Dialog(enable=onFile));

    protected
        Real A[size(ss.A, 1), size(ss.A, 2)];
        Real B[size(ss.B, 1), 1];
        Real C[1, size(ss.C, 2)];
        Real D[1, 1];

        Real Eig[size(ss.A,1), 2];
        Real InvZeros[:,2];
        Real f[nPoints];
        Real a[nPoints] "Absolute value (magnitude)";
        Real phi[nPoints];
        Real gain;

        Real fap[nPoints,if onFile then 3 else 0];
        Boolean success;
      algorithm
        // Check that system has inputs and outputs
        if size(ss.B, 2) == 0 then
          Modelica.Utilities.Streams.print(
            "\n... Not possible to plot transfer function because system has no inputs."
             + "\n... Call of Plot.bodeSISO is ignored.\n");
          return;
        elseif size(ss.C, 1) == 0 then
          Modelica.Utilities.Streams.print(
            "\n... Not possible to plot transfer function because system has no outputs."
             + "\n... Call of Plot.bodeSISO is ignored.\n");
          return;
        end if;

        // Extract desired SISO system
        assert(iu <= size(ss.B, 2) and iu > 0, "index for input is " + String(iu)
           + " which is not in [1, " + String(size(ss.B, 2)) + "].");
        assert(iy <= size(ss.C, 1) and iy > 0, "index for output is " + String(iy)
           + " which is not in [1, " + String(size(ss.C, 1)) + "].");

        // Extract SISO system and balance it
        (,A,B,C) :=Internal.balanceABC(A=ss.A, B=matrix(ss.B[:, iu]),
                                       C=transpose(matrix(ss.C[iy, :])));
        D :=matrix(ss.D[iy, iu]);

        // Compute eigenvalues and invariant zeros (as Real Matrices)
        Eig := Math.Matrices.eigenValuesAsRealMatrix(A,balance=false);
        InvZeros := StateSpace.Internal.invariantZerosWithRealMatrix(A,B,C,D);
        gain := Internal.frequencyResponseGain(A,B,C,D,InvZeros,Eig);

        // Compute frequency response values
        (f,a,phi) :=Modelica_LinearSystems2.Internal.frequencyResponse(gain,
                       InvZeros, Eig, nPoints, autoRange, f_min, f_max,
                       Hz, dB, defaultDiagram.logX);

        // Bode plot
        Internal.frequencyResponsePlot(f,a,phi,autoRange,f_min,f_max,magnitude,
                                       phase,Hz,dB,defaultDiagram,device);

        // Store frequency response values on file
        if onFile then
           fap :=[f,a,phi];
           Modelica.Utilities.Files.removeFile(fileName);
           success:=writeMatrix(fileName,matrixName,fap,append=false);
           if success then
              Modelica.Utilities.Streams.print("... Frequency response stored on file \"" +
                       Modelica.Utilities.Files.fullPathName(fileName) + "\"");
           end if;
        end if;
        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>bodeSISO</b>(ss)
   or
StateSpace.Plot.<b>bodeSISO</b>(
  ss,
  iu,
  iy,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a transfer function corresponding
to the behavior of the state space system from iu'th element of the input
vector <b>u</b> to the iy'th element of the output vector <b>y</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,0.0; 0.0,0.0,-3.0],
    B=[0.0,1.0; 1.0,1.0; -1.0,0.0],
    C=[0.0,1.0,1.0; 1.0,1.0,1.0],
    D=[1.0,0.0; 0.0,1.0])

  Integer iu=1;
  Integer iy=1;

<b>algorithm</b>
   Modelica_LinearSystems2.StateSpace.Plot.plotBodeSISO(ss, iu, iy)
//  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</p>
</html>"));
      end bodeSISO;

      encapsulated function bodeMIMO
        "Plot bode plot of all transfer functions, corresponding to the state space system"
        import Modelica;
        import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Plot;
        import Modelica_LinearSystems2.Math;
        import Modelica_LinearSystems2.Internal;

        input StateSpace ss "State space system";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange[:, :] = fill(
            true,
            size(ss.C, 1),
            size(ss.B, 2)) "True, if abszissa range is automatically determined";
        input Modelica.Units.SI.Frequency f_min[:,:]=fill(
                0.1,
                size(ss.C, 1),
                size(ss.B, 2)) "Minimum frequency value, if autoRange = false";
        input Modelica.Units.SI.Frequency f_max[:,:]=fill(
                10,
                size(ss.C, 1),
                size(ss.B, 2)) "Maximum frequency value, if autoRange = false";

        input Boolean magnitude = true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase = true "= true, to plot phase" annotation(choices(checkBox=true));

        input Real tol = 1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot());

        input Boolean Hz = true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB = false
          "= true, to plot magnitude in [-], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));

        input Boolean onFile = false
          "= true, if frequency response is stored on file as matrix [f,a,phi]" annotation(choices(checkBox=true));
        input String fileName = "frequencyResponse.mat"
          "If onFile=true, file on which the frequency response will be stored" annotation(Dialog(enable=onFile));
        input String matrixName = if Hz and not dB then "fHz_a_phiDeg" elseif
                                     Hz and dB then "fHz_adB_phiDeg" elseif
                                     not Hz and dB then "f_adB_phiDeg" else "f_a_phiDeg"
          "If onFile=true, prefix name of matrix on file" annotation(Dialog(enable=onFile));

    protected
        Real A[    size(ss.A, 1), size(ss.A, 2)];
        Real Bfull[size(ss.B, 1), size(ss.B, 2)];
        Real Cfull[size(ss.C, 1), size(ss.C, 2)];

        Real B[size(ss.B, 1), 1];
        Real C[1, size(ss.C, 2)];
        Real D[1,1];

        Real Eig[size(ss.A,1), 2];
        Real InvZeros[:,2];
        Real f[nPoints] "Frequency";
        Real a[nPoints] "Absolute value (magnitude)";
        Real phi[nPoints] "Phase";
        Real gain;

        Real fap[nPoints,if onFile then 3 else 0];
        Boolean success;

        String yNames[size(ss.C, 1)];
        String uNames[size(ss.B, 2)];

        Plot.Records.Diagram diagram2 = defaultDiagram;
      algorithm
        // Check that system has inputs and outputs
        if size(ss.B, 2) == 0 then
          print("\n... Not possible to plot transfer function because system has no inputs."
             + "\n... Call of Plot.bodeMIMO is ignored.\n");
          return;
        elseif size(ss.C, 1) == 0 then
          print("\n... Not possible to plot transfer function because system has no outputs."
             + "\n... Call of Plot.bodeMIMO is ignored.\n");
          return;
        end if;

        // generate headings
        for i1 in 1:size(ss.B, 2) loop
          uNames[i1] := if ss.uNames[i1] == "" then "u" + String(i1) else ss.uNames[i1];
        end for;
        for i1 in 1:size(ss.C, 1) loop
          yNames[i1] := if ss.yNames[i1] == "" then "y" + String(i1) else ss.yNames[i1];
        end for;

        // Balance system
        (,A,Bfull,Cfull) := Internal.balanceABC(A=ss.A, B=ss.B, C=ss.C);

        // Compute eigen values (matrix A balanced already)
        Eig := Math.Matrices.eigenValuesAsRealMatrix(A,balance=false);

        // Remove output file, if onFile=true
        if onFile then
           Modelica.Utilities.Files.removeFile(fileName);
        end if;

        // Perform computation from every input to every output
        for i1 in 1:size(ss.C, 1) loop
          for i2 in 1:size(ss.B, 2) loop
            // Compute zeros
            B := matrix(Bfull[:, i2]);
            C := transpose(matrix(Cfull[i1, :]));
            D := matrix(ss.D[i1, i2]);
            InvZeros := StateSpace.Internal.invariantZerosWithRealMatrix(A,B,C,D);
            gain := Internal.frequencyResponseGain(A,B,C,D,InvZeros,Eig);

            // Compute frequency response values
            (f,a,phi) := Modelica_LinearSystems2.Internal.frequencyResponse(
                           gain, InvZeros, Eig, nPoints, autoRange[i1, i2],
                           f_min[i1, i2], f_max[i1, i2], Hz, dB, defaultDiagram.logX);

            // Bode plot
            diagram2.heading := defaultDiagram.heading + "  " + uNames[i2] + " -> " + yNames[i1];
            Internal.frequencyResponsePlot(f,a,phi,autoRange[i1, i2],
                                           f_min[i1, i2], f_max[i1, i2],magnitude,
                                           phase,Hz,dB,diagram=diagram2,
                                           device=device);

            // Store result optionally on file
            if onFile then
              fap := [f,a,phi];
              success := Modelica.Utilities.Streams.writeRealMatrix(
                fileName, matrixName + "_" + uNames[i2] + "_" + yNames[i1], fap, append=true);
            end if;
          end for;
        end for;

        if onFile and success then
          print("... Frequency response stored on file \"" +
            Modelica.Utilities.Files.fullPathName(fileName) + "\"");
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>bodeMIMO</b>(ss)
   or
StateSpace.Plot.<b>bodeMIMO</b>(
  ss,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude,
  phase,
  tol,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>(),
  Hz,
  dB,
  onFile,
  fileName,
  matrixName)
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,0.0; 0.0,0.0,-3.0],
    B=[0.0,1.0; 1.0,1.0; -1.0,0.0],
    C=[0.0,1.0,1.0],
    D=[1.0,0.0])

<b>algorithm</b>
   Modelica_LinearSystems2.StateSpace.Plot.plotBodeMIMO(ss)
//  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</p>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude2.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase2.png\">
</p>
</html>"));
      end bodeMIMO;

      encapsulated function timeResponse
        "Plot the time response of the system. The response type is selectable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Modelica.Units.SI.Time dt=0 "Sample time";
        input Modelica.Units.SI.Time tSpan=0 "Simulation time span";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step;

        input Real x0[size(ss.A, 1)]=zeros(size(ss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation (Dialog, choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Time response"));

    protected
        Plot.Records.Curve curve;
        Integer i1;
        Integer i2;
        Plot.Records.Diagram diagram2[size(ss.C, 1)];

        Real y[:, size(ss.C, 1), if response == TimeResponse.Initial then 1 else
          size(ss.B, 2)]
          "Output response: (number of samples) x (number of outputs) x (number of inputs)";
        Real t[:] "Time vector: (number of samples)";
        Real x[:, size(ss.A, 1), if response == TimeResponse.Initial then 1 else
          size(ss.B, 2)]
          "State trajectories: (number of samples) x (number of states) x (number of inputs)";
        String yNames[size(ss.C, 1)];
        String uNames[size(ss.B, 2)];
        Integer loops=if response == TimeResponse.Initial then 1 else size(ss.B,
            2);

      algorithm
        (y,t,x) := Modelica_LinearSystems2.StateSpace.Analysis.timeResponse(
              sc=ss,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0);

        // generate headings
        for i1 in 1:size(ss.B, 2) loop
          uNames[i1] := if ss.uNames[i1] == "" then "u" + String(i1) else ss.uNames[
            i1];
        end for;
        for i1 in 1:size(ss.C, 1) loop
          yNames[i1] := if ss.yNames[i1] == "" then "y" + String(i1) else ss.yNames[
            i1];
        end for;

        for i2 in 1:loops loop
          for i1 in 1:size(ss.C, 1) loop
            curve := Plot.Records.Curve(
                  x=t,
                  y=y[:, i1, i2],
                  autoLine=true);

            diagram2[i1] := defaultDiagram;
            diagram2[i1].curve := {curve};
            diagram2[i1].heading := if response == TimeResponse.Initial then
              defaultDiagram.heading + " " + yNames[i1] else defaultDiagram.heading
               + "  " + uNames[i2] + " -> " + yNames[i1];
            diagram2[i1].yLabel := yNames[i1];

          end for;

          if subPlots then
            Plot.diagramVector(diagram2, device);
          else
            for i1 in 1:size(ss.C, 1) loop
              Plot.diagram(diagram2[i1], device);
            end for;
          end if;
        end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>timeResponse</b>(ss);
   or
StateSpace.Plot.<b>timeResponse</b>(
  ss,
  dt,
  tSpan,
  response,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the time response of a state space system. The character of the time response if defined by the input <tt>response</tt>, i.e. Impulse, Step, Ramp or Initial.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Plot.timeResponse(ss, response=response)
// gives:
</pre></blockquote>
<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/timeResponseSS.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.initialResponse\">initial</a>
</p>
</html>"));
      end timeResponse;

      encapsulated function impulse "Impulse response plot"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Modelica.Units.SI.Time dt=0 "Sample time";
        input Modelica.Units.SI.Time tSpan=0 "Simulation time span";
        input Real x0[size(ss.A, 1)]=zeros(size(ss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation (Dialog, choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Impulse response"));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse "type of time response";
      algorithm

        Modelica_LinearSystems2.StateSpace.Plot.timeResponse(
              ss=ss,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>impulse</b>(ss);
   or
StateSpace.Plot.<b>impulse</b>(
  ss,
  dt,
  tSpan,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the impulse responses of a state space system
for each system corresponding to the transition matrix. It is based on <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Plot.impulse(ss)
// gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/impulseResponseSS.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end impulse;

      encapsulated function step "Step response plot"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Modelica.Units.SI.Time dt=0 "Sample time";
        input Modelica.Units.SI.Time tSpan=0 "Simulation time span";
        input Real x0[size(ss.A, 1)]=zeros(size(ss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation (Dialog, choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Step response"));

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";

      algorithm
        Modelica_LinearSystems2.StateSpace.Plot.timeResponse(
              ss=ss,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>step</b>(ss);
   or
StateSpace.Plot.<b>step</b>(
  ss,
  dt,
  tSpan,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the step responses of a state space system for each system corresponding to the transition matrix. It is based on <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Plot.step(ss, tSpan=3)
// gives:
</pre></blockquote>
<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/stepResponseSS.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end step;

      encapsulated function ramp "Ramp response plot"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Modelica.Units.SI.Time dt=0 "Sample time";
        input Modelica.Units.SI.Time tSpan=0 "Simulation time span";
        input Real x0[size(ss.A, 1)]=zeros(size(ss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation (Dialog, choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Ramp response"));

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";

      algorithm
        Modelica_LinearSystems2.StateSpace.Plot.timeResponse(
              ss=ss,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>ramp</b>(ss);
   or
StateSpace.Plot.<b>ramp</b>(
  ss,
  dt,
  tSpan,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the ramp responses of a state space system for each system corresponding to the transition matrix. It is based on <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[1.0,1.0,1.0],
    D=[0.0])

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Plot.ramp(ss)
// gives:
</pre></blockquote>
<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/rampResponseSS.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end ramp;

      encapsulated function initialResponse "Initial condition response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Modelica.Units.SI.Time dt=0 "Sample time";
        input Modelica.Units.SI.Time tSpan=0 "Simulation time span";
        input Real x0[size(ss.A, 1)]=zeros(size(ss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation (Dialog, choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Initial response"));

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";
      algorithm

        Modelica_LinearSystems2.StateSpace.Plot.timeResponse(
              ss=ss,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>initial</b>(ss);
   or
StateSpace.Plot.<b>initial</b>(
  ss,
  dt,
  tSpan,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the initial responses of a state space system for the initial state vector x0 for each system corresponding to the transition matrix. It is based on <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Real x0={1,0.5,0.5};

<b>algorithm</b>
  Modelica_LinearSystems2.StateSpace.Plot.initial(ss, x0=x0)
// gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/initialResponseSS.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Plot.ramp\">ramp</a>
</p>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of StateSpace data record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function toZerosAndPoles
        "Generate a zeros-and-poles representation from a SISO state space representation"
        import Modelica.Utilities.Streams.print;

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        //protected
        //  input Boolean cancel=true "false to hinder cancellation";// is not fully realized
    public
        output ZerosAndPoles zp;

    protected
        StateSpace ssm=if size(ss.A, 1) > 0 then
            StateSpace.Transformation.toIrreducibleForm(ss, tol) else StateSpace(
            ss.D[1, 1]);
        Complex Poles[:];
        Complex Zeros[:];

        Real gain;

        Complex frequency;
        Complex Gs;
        Real As[:, :];
        Real pk;
        Integer i;
        Integer k;
        Boolean h;
        Real v;

        function getReOutsidePolesZeros
          "Get p on the real axis so that there is a minimum distance to all poles and zeros"
          input Complex Poles[:];
          input Complex Zeros[:];
          input Real minimumDistance=0.1;
          output Real p
            "Value on real axis > 0.0, so that poles.re and zeros.re have a minimumDistance to it";
          /* Most systems have no or only a few unstable poles or zeros.
    Searching for a suitable p is therefore fastest when searching
    only in the unstable region, that is p > 0.0
    */
      protected
          Integer nVec=size(Poles, 1) + size(Zeros, 1);
          Real vec[:];
          Real vecSorted[:];
          Integer i;
          Integer iMax;
          Real small = minimumDistance*1e-6;
        algorithm
          i := 0;
          vec := zeros(nVec);
          for j in 1:size(Poles, 1) loop
            if Poles[j].re > small then
              i := i + 1;
              vec[i] := Poles[j].re;
            end if;
          end for;
          for j in 1:size(Zeros, 1) loop
            if Zeros[j].re > small then
              i := i + 1;
              vec[i] := Zeros[j].re;
            end if;
          end for;
          iMax := i;
          if iMax == 0 then
            p := minimumDistance;
            return;
          end if;

          vec := vec[1:iMax];
          vecSorted := Modelica.Math.Vectors.sort(vec);

          // Find p, so that vecSorted[i+1] - vecSorted[i] > 2*minimumDistance
          if vecSorted[1] >= 2*minimumDistance then
             p := minimumDistance;
             return;
          end if;

          i :=1;
          while i <= iMax loop
            if i == iMax then
              p := vecSorted[i] + minimumDistance;
              break;
            elseif vecSorted[i + 1] - vecSorted[i] > 2*minimumDistance then
              p := vecSorted[i] + minimumDistance;
              break;
            else
              i := i + 1;
            end if;
          end while;
        end getReOutsidePolesZeros;

      algorithm
        if Modelica.Math.Vectors.length(ssm.B[:, 1]) > 0 and
            Modelica.Math.Vectors.length(ssm.C[1, :]) > 0 then
          Poles := Complex.Internal.eigenValues_dhseqr(ssm.A);
          //ssm.A is of upper Hessenberg form
          Zeros := StateSpace.Analysis.invariantZeros(ssm);

          if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
            assert(size(ss.B, 2) == 1,
              " function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is "
               + String(size(ss.B, 2)) + " instead of 1");
            assert(size(ss.C, 1) == 1,
              " function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is "
               + String(size(ss.C, 1)) + " instead of 1");
          end if;
          zp := ZerosAndPoles(
                z=Zeros,
                p=Poles,
                k=1);

          v := getReOutsidePolesZeros(Poles, Zeros);
          frequency := Complex(v);
          Gs := ZerosAndPoles.Analysis.evaluate(zp, frequency);
          As := -ssm.A;
          for i in 1:size(As, 1) loop
            As[i, i] := As[i, i] + frequency.re;
          end for;

          pk := StateSpace.Internal.partialGain(As, ssm.B[:, 1]);
          gain := (ssm.C[1, size(As, 1)]*pk + ss.D[1, 1])/Gs.re;
          zp := ZerosAndPoles(
                z=Zeros,
                p=Poles,
                k=gain);
        else
          zp := ZerosAndPoles(
                z=fill(Complex(0), 0),
                p=fill(Complex(0), 0),
                k=scalar(ss.D));

        end if;
        zp.uName := ss.uNames[1];
        zp.yName := ss.yNames[1];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = StateSpace.Conversion.<b>toZerosAndPoles</b>(ss)
</pre> </blockquote>

<h4>Description</h4>
<p>
Computes a ZerosAndPoles record
</p>
<blockquote><pre>
          product(s + n1[i]) * product(s^2 + n2[i,1]*s + n2[i,2])
zp = k * ---------------------------------------------------------
          product(s + d1[i]) * product(s^2 + d2[i,1]*s + d2[i,2])
</pre></blockquote>
<p>
of a system from state space representation using the transformation algorithm described in [1].
The uncontrollable and unobservable parts are isolated and the eigenvalues and invariant zeros of the controllable and observable sub system are calculated.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-1.0, 0.0, 0.0;
          0.0,-2.0, 0.0;
          0.0, 0.0,-3.0],
    B = [1.0;
         1.0;
         0.0],
    C = [1.0,1.0,1.0],
    D = [0.0]);

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles(ss);
//                s + 1.5
//   zp = 2 -----------------
             (s + 1)*(s + 2)
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2011-07-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Improved frequency calculation</td>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toZerosAndPoles;

      function toTransferFunction
        "Generate a transfer function from a SISO state space representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        output TransferFunction tf;

    protected
        ZerosAndPoles zp;

      algorithm
        zp := toZerosAndPoles(ss, tol);
        tf := ZerosAndPoles.Conversion.toTransferFunction(zp);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tf = StateSpace.Conversion.<b>toTransferFunction</b>(ss)
</pre> </blockquote>

<h4>Description</h4>
<p>
Computes a TransferFunction record
</p>
<blockquote><pre>
      n(s)     b0 + b1*s + ... + bn*s^n
tf = ------ = --------------------------
      d(s)     a0 + a1*s + ... + an*s^n
</pre></blockquote>
<p>
The algorithm uses <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles\">StateSpace.Conversion.toZerosAndPoles</a> to convert the state space system into a zeros and poles representation first and after that <a href=\"Modelica://Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunction\">ZerosAndPoles.Conversion.toTransferFunction</a> to generate the transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-1.0, 0.0, 0.0;
          0.0,-2.0, 0.0;
          0.0, 0.0,-3.0],
    B = [1.0;
         1.0;
         0.0],
    C = [1.0,1.0,1.0],
    D = [0.0]);

<b>algorithm</b>
  tf:=Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles(ss);
//             2*s + 3
//   tf =  -----------------
             s^2 + 3*s + 2
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toTransferFunction;

      encapsulated function toZerosAndPolesMIMO
        "Generate a zeros-and-poles representation from a MIMO state space representation"
        import Modelica.Utilities.Streams.print;
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        output ZerosAndPoles zp[size(ss.C, 1), size(ss.B, 2)];

    protected
        StateSpace ss_siso(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), 1],
          redeclare Real C[1, size(ss.C, 2)],
          redeclare Real D[1, 1]);

        Integer ny=size(ss.C, 1);
        Integer nu=size(ss.B, 2);

      algorithm
        for ic in 1:ny loop
          for ib in 1:nu loop
            ss_siso := StateSpace(
                  A=ss.A,
                  B=matrix(ss.B[:, ib]),
                  C=transpose(matrix(ss.C[ic, :])),
                  D=matrix(ss.D[ic, ib]));
            zp[ic, ib] := StateSpace.Conversion.toZerosAndPoles(ss_siso, tol);
          end for;
        end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = StateSpace.Conversion.<b>toZerosAndPolesMIMO</b>(ss)
</pre> </blockquote>

<h4>Description</h4>
<p>
Computes a matrix of ZerosAndPoles records
</p>
<blockquote><pre>
          product(s + n1[i]) * product(s^2 + n2[i,1]*s + n2[i,2])
zp = k * ---------------------------------------------------------
          product(s + d1[i]) * product(s^2 + d2[i,1]*s + d2[i,2])
</pre></blockquote>
<p>
of a system from state space representation, i.e. isolating the uncontrollable and unobservable parts and the eigenvalues and invariant zeros of the controllable and observable sub systems are calculated. The algorithm applies the method described in [1] for each input-output pair.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-1.0, 0.0, 0.0;
          0.0,-2.0, 0.0;
          0.0, 0.0,-3.0],
    B = [0.0, 1.0;
         1.0, 1.0;
        -1.0, 0.0],
    C = [0.0, 1.0, 1.0;
         1.0, 1.0, 1.0],
    D = [1.0, 0.0;
         0.0, 1.0]);

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles(ss);

// zp = [(s^2 + 5*s + 7)/( (s + 2)*(s + 3) ), 1/(s + 2);
         1/( (s + 2)*(s + 3) ), 1*(s + 1.38197)*(s + 3.61803)/( (s + 1)*(s + 2) )]
</pre></blockquote>
<p>
i.e.
</p>
<blockquote><pre>
         |                                                   |
         |    (s^2+5*s+7)                    1               |
         | -----------------               -----             |
         |  (s + 2)*(s + 3)                (s+2)             |
  tf  =  |                                                   |
         |        1             (s + 1.38197)*(s + 3.61803)  |
         | -------------       ----------------------------- |
         | (s + 2)*(s + 3)            (s + 1)*(s + 2)        |
         |                                                   |
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toZerosAndPolesMIMO;

      function toTransferFunctionMIMO
        "Generate a transfer function of a MIMO system from state space representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        output TransferFunction tf[size(ss.C, 1), size(ss.B, 2)]
          "Matrix of transfer function objects";

    protected
        ZerosAndPoles zp[:, :];
        parameter Integer m=size(ss.B, 2);
        parameter Integer p=size(ss.C, 1);

      algorithm
        zp := StateSpace.Conversion.toZerosAndPolesMIMO(ss, tol);
        for i1 in 1:m loop
          for i2 in 1:p loop
            tf[i2, i1] := ZerosAndPoles.Conversion.toTransferFunction(zp[i2, i1]);
          end for;
        end for;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tf = StateSpace.Conversion.<b>toTransferFunctionMIMO</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a matrix of TransferFunction records
</p>
<blockquote><pre>
        n_i(s)     b0_i + b1_i*s + ... + bn_i*s^n
tf_i = -------- = --------------------------------
        d_i(s)     a0_i + a1_i*s + ... + an_i*s^n
</pre></blockquote>
<p>
with repetitive application of <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction\">Conversion.toTransferFunction</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-1.0, 0.0, 0.0;
          0.0,-2.0, 0.0;
          0.0, 0.0,-3.0],
    B = [0.0, 1.0;
         1.0, 1.0;
        -1.0, 0.0],
    C = [0.0, 1.0, 1.0;
         1.0, 1.0, 1.0],
    D = [1.0, 0.0;
         0.0, 1.0]);

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles(ss);

// zp = [(s^2 + 5*s + 7)/(s^2 + 5*s + 6), 1/(s + 2);
         1/(s^2 + 5*s + 6), (1*s^2 + 5*s + 5)/(s^2 + 3*s + 2)]
</pre></blockquote>
<p>
i.e.
</p>
<blockquote><pre>
         |                                                   |
         |    (s^2+5*s+7)                    1               |
         | -----------------               -----             |
         |  (s + 2)*(s + 3)                (s+2)             |
  tf  =  |                                                   |
         |        1             (s + 1.38197)*(s + 3.61803)  |
         | -------------       ----------------------------- |
         | (s + 2)*(s + 3)            (s + 1)*(s + 2)        |
         |                                                   |
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toTransferFunctionMIMO;

    end Conversion;

    encapsulated package Transformation
      "Package of functions for state space similarity transformations"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function toSimilarForm
        "Perform the similarity transformation z = Tx (or x = inv(T)z) which leads to Az=T*A*inv(T), Bz=T*B, Cz=C*inv(T), Dz=D (or Az=inv(T)*A*T, Bz=inv(T)B, Cz=C*T, Dz=D)"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "State space system";
        input Real T[size(ss.A, 2), size(ss.A, 1)]=identity(size(ss.A, 1))
          "Transformation matrix";
        input Boolean inverted=false
          "Is false (default) for transformation z = Tx, true for x = Tz"
          annotation (choices(checkBox=true));

        output StateSpace tss(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);

      algorithm
        if inverted then
          tss.A := Matrices.solve2(T, ss.A*T);
          tss.B := Matrices.solve2(T, ss.B);
          tss.C := ss.C*T;
          tss.D := ss.D;
        else
          tss.A := transpose(LAPACK.dgesvx(T, transpose(T*ss.A)));
          tss.B := T*ss.B;
          tss.C := transpose(LAPACK.dgesvx(T, transpose(ss.C)));
          tss.D := ss.D;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tss = StateSpace.Transformation.<b>toSimilarForm</b>(ss, T, inverted)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates a similar state space system, i.e.
</p>
<blockquote><pre>
der(z) = T*A*inv(T)*z + T*B*u
     y = C*T*z + D*u
</pre></blockquote>
<p>
if inverted==false and
</p>
<blockquote><pre>
der(z) = inv(T)*A*T*z + inv(T)*B*u
     y = C*inv(T)*z + D*u
</pre></blockquote>
<p>
if inverted=true. Matrix T has to be invertible. The transformed system has the same eigenvalues.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
     A=[-1, 1; 0, -2],
     B=[1; 0],
     C=[0, 1],
     D=[0]);

  Real T[2,2]=[1, 1;0, sqrt(2)];

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.toSimilarForm(ss, T, false);
//  tss=StateSpace(
      A=[-1, 0; 0, -2],
      B=[1; 0],
      C=[0, 1/sqrt82)],
      D=[0])
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.analysis\">State space analysis</a>
</p>
</html>"));
      end toSimilarForm;

      encapsulated function toObservabilityForm
        "Perform the similarity transformation to the obervabillity canonical form"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.Streams;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "State space system";
        output StateSpace tss(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);

    protected
        Real V[size(ss.A, 1), size(ss.A, 1)]
          "Matrix of the right eigenvectors of the matrix ss.A";

        Integer nx=size(ss.A, 1);

      algorithm
        assert(size(ss.C, 1) == 1 and size(ss.B, 2) == 1,
          "Calculation of controllable form fails for systems with more than 1 inputs or outputs");
        assert(Modelica_LinearSystems2.StateSpace.Analysis.isObservable(ss),
          "transformation ist not realizable since the system ist not obersvable");

        V[:, 1] := Modelica.Math.Matrices.solve(
          StateSpace.Analysis.observabilityMatrix(ss), vector([fill(
              0,
              1,
              nx - 1), 1]));

        for i in 2:nx loop
          V[:, i] := ss.A*V[:, i - 1];
        end for;

        tss := StateSpace.Transformation.toSimilarForm(
              ss,
              V,
              inverted=true);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tss = StateSpace.Transformation.<b>toObservabilityForm</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the observability form of a SISO state space system, i.e.
</p>
<blockquote><pre>
tss:
der(z) = inv(T)*A*T*z + inv(T)*B*u
     y = C*inv(T)*z + D*u
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
T = [C; C*A; ...; C*A^(n-1)]
</pre></blockquote>
<p>
is the observability matrix of the original state space system.
In comparison to the corresponding transfer function
</p>
<blockquote><pre>
        b0 + b1*s + ... + bn*s^n
G(s) = --------------------------
        a0 + a1*s + ... + an*s^n
</pre></blockquote>
<p>
the canonical observability form is
</p>
<blockquote><pre>
    | 0   0   ...   0   -a0   |        | b0   - a0*bn   |
    | 1   0   ...   0   -a1   |        | b1   - a1*bn   |
A = | 0   1   ...   0   -a2   |,   B = |     ...        |
    |... ...  ...  ...  -a3   |        | bn-2 - an-2*bn |
    | 0  ...  ...   1   -an-1 |        | bn-1 - an-1*bn |

C = [0, 0, ..., 1],                D = [bn]
</pre></blockquote>
<p>
Matrix <code>T</code> has to be invertible, i.e. the system has to be observable.
The transformed system has the same eigenvalues.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1; 1, -2],
    B=[1; 0],
    C=[1, 1],
    D=[2]);

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.toObservabilityForm(ss);
//  tss=StateSpace(
      A=[0, -1; 1, -3],
      B=[3; 1],
      C=[0, 1],
      D=[2])
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Transformation.toSimilarForm\">toSimilarForm</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Transformation.toControllabilityForm\">toControllabilityForm</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toObservabilityForm;

      encapsulated function toControllabilityForm
        "Perform the similarity transformation to the controllability canonical form"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.Streams;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "State space system";
        output StateSpace tss(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);

    protected
        Real V[size(ss.A, 1), size(ss.A, 1)]
          "Matrix of the right eigenvectors of the matrix ss.A";

        Integer nx=size(ss.A, 1);

      algorithm
        assert(size(ss.C, 1) == 1 and size(ss.B, 2) == 1,
          "Calculation of controllable form fails for systems with more than 1 inputs or outputs");
        assert(Modelica_LinearSystems2.StateSpace.Analysis.isControllable(ss),
          "transformation ist not realizable since the system ist not controllable");

        V[1, :] := Modelica.Math.Matrices.solve(transpose(
          StateSpace.Analysis.controllabilityMatrix(ss)), vector([fill(
              0,
              nx - 1,
              1); 1]));

        for i in 2:nx loop
          V[i, :] := V[i - 1, :]*ss.A;
        end for;

        tss := StateSpace.Transformation.toSimilarForm(ss, V);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tss = StateSpace.Transformation.<b>toControllabilityForm</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the controllability form of a SISO state space system, i.e.
</p>
<blockquote><pre>
tss:
der(z) = T*A*inv(T)*z + T*B*u
     y = C*T*z + D*u
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
T = [B, A*B,..., A^(n-1)*B]
</pre></blockquote>
<p>
is the observability matrix of the original state space system.
In comparison to the corresponding transfer function
</p>
<blockquote><pre>
        b0 + b1*s + ... + bn*s^n
G(s) = --------------------------
        a0 + a1*s + ... + an*s^n
</pre></blockquote>
<p>
the canonical observability form is
</p>
<blockquote><pre>
    | 0   1   0   ...   0     0   |                        | 0 |
    |  0     0     0    0     0   |                        | 0 |
A = | ...   ...   ...  ...   ...  |,                   B = |...|
    |  0     0     0    0     0   |                        | 0 |
    | -a0   -a1   -a2  ...  -an-1 |                        | 1 |

C = [ b0 - bn*a0, b1 - bn*a1, ..., bn-1 - bn*an-1],    D = [bn]
</pre></blockquote>
<p>
Matrix T has to be invertible, i.e. the system has to be controllable. The transformed system has the same eigenvalues.
</p>

<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1, 1; 1, -2],
      B=[1; 0],
      C=[1, 1],
      D=[2]);

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.toControllabilityForm(ss);
//  tss=StateSpace(
      A=[0, 1; -1, -3],
      B=[0; 1],
      C=[3, 1],
      D=[2])
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Transformation.toSimilarForm\">toSimilarForm</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Transformation.toObservabilityForm\">toObservabilityForm</a>
</p>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toControllabilityForm;

      encapsulated function toDiagonalForm
        "Perform the similarity transformation with the (real) inverse right eigenvector matrix of the system, that lead to the Jordan canonical form for single eigenvalues"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "State space system";
        output StateSpace tss(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);

    protected
        Real V[size(ss.A, 1), size(ss.A, 1)]
          "Matrix of the right eigenvectors of the matrix ss.A";

      algorithm
        (,,,V,) := LAPACK.dgeev(ss.A);

        tss := StateSpace.Transformation.toSimilarForm(
              ss,
              V,
              inverted=true);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tss = StateSpace.Transformation.<b>toDiagonalForm</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the diagonal form of a SISO state space system, i.e.
</p>
<blockquote><pre>
tss:
der(z) = inv(T)*A*T*z + inv(T)*B*u
     y = C*inv(T)*z + D*u
</pre></blockquote>
<p>
Matrix T has to be diagonalizable, i.e. the algebraic and geometric multiplicities of an eigenvalue must coincide. The diagonal entries of the new system matrix tss.<b>A</b> are the eigenvalues off the systemmatrix ss.<b>A</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1, 1; 0, -2],
      B=[1; 0],
      C=[1, 1],
      D=[2]);

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.toDiagonalForm(ss);
//  tss=StateSpace(
      A=[-1, 0; 0, -2],
      B=[1; 0],
      C=[1, 0],
      D=[0])
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Transformation.toSimilarForm\">toSimilarForm</a>
</p>
</html>"));
      end toDiagonalForm;

      encapsulated function toBalancedForm
        "Perform the similarity transformation to a balanced form (to make further numerical computations on the StateSpace system more reliable)"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        output StateSpace ssBalanced(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]) "Balanced ss";
      algorithm
        (,ssBalanced.A, ssBalanced.B, ssBalanced.C) :=
          Modelica_LinearSystems2.Internal.balanceABC(
              ss.A,
              ss.B,
              ss.C);
        ssBalanced.D :=ss.D;
        ssBalanced.uNames := ss.uNames;
        ssBalanced.yNames := ss.yNames;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ssBalanced = StateSpace.Transformation.<b>toBalancedForm</b>(ss);
</pre></blockquote>

<h4>Description</h4>

<p>
Balancing a linear dynamic system in state space form ss means to find a
state transformation x_new = T*x = diagonal(scale)*x
so that the transformed system is better suited for numerical algorithms.
In more detail:
</p>

<p>
This function performs a similarity transformation with T=diagonal(scale) such that S_scale
</p>

<pre>             |inv(T)*ss.A*T, inv(T)*ss.B|
   S_scale = |                          |
             |       ss.C*T,     0      |
</pre>

<p>
has a better condition as system matrix S
</p>

<pre>       |ss.A, ss.B|
   S = |          |
       |ss.C, 0   |
</pre>
that is, conditionNumber(S_scale) &le; conditionNumber(S). The elements of vector scale
are multiples of 2 which means that this function does not introduce round-off errors.
</p>


<h4>Example</h4>

<blockquote>
<pre>import Modelica.Math.Matrices.norm;
ss = Modelica_LinearSystems2.StateSpace(A=[1, -10,  1000; 0.01,  0,  10; 0.005,  -0.01,  10],
                                        B=[100, 10; 1,0; -0.003, 1],
                                        C=[-0.5, 1, 100],
                                        D=[0,0]);
sb = Modelica_LinearSystems2.StateSpace.Transformation.toBalancedForm(ss);

-> Results in:
norm(ss.A) = 1000.15, norm(ss.B) = 100.504, norm(ss.C) = 100.006
norm(sb.A) = 10.8738, norm(sb.B) = 16.0136, norm(sb.C) = 10.2011
</pre>
</blockquote>

<p>
The algorithm is taken from
</p>
<dl>
<dt>H. D. Joos, G. Gr&uuml;bel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
<p>
which is based on the <code>balance</code> function from EISPACK.
</p>
</html>"));
      end toBalancedForm;

      encapsulated function toIrreducibleForm
        "Calculate a minimal controllable and observable block Hessenberg realization of a given SISO state-space representation "

        // test of SISO has to be added
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssm1=
            StateSpace.Internal.reducedCtrSystem(ss, tol);
        Integer nx=size(ss.A, 1);
        Integer rankQ=ssm1.r;
        StateSpace ss2=StateSpace(
                A=transpose(ssm1.A[nx - rankQ + 1:nx, nx - rankQ + 1:nx]),
                B=transpose(ssm1.C[:, nx - rankQ + 1:nx]),
                C=transpose(ssm1.B[nx - rankQ + 1:nx, :]),
                D=ssm1.D);
        Integer nx2=ssm1.r;
        Modelica_LinearSystems2.Internal.StateSpaceR ssm2=
            StateSpace.Internal.reducedCtrSystem(ss2, tol);
        Integer rankQ2=ssm2.r;
    public
        output StateSpace ssm3(
          redeclare Real A[rankQ2, rankQ2],
          redeclare Real B[rankQ2, size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), rankQ2],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);
      algorithm
        ssm3 := StateSpace(
              A=transpose(ssm2.A[nx2 - rankQ2 + 1:nx2, nx2 - rankQ2 + 1:nx2]),
              B=transpose(ssm2.C[:, nx2 - rankQ2 + 1:nx2]),
              C=transpose(ssm2.B[nx2 - rankQ2 + 1:nx2, :]),
              D=(ssm2.D));

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tss = StateSpace.Transformation.<b>toIrreducibleForm</b>(ss)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates a minimal controllable and observable block Hessenberg realization for a given state-space representation.
Therefore, all uncontrollable and unobservable modes are removed by performing orthogonal similarity transformations as described in [1].
</p>
<p>
This function is called to compute transfer functions of state space representations as described in [1]. Look at [1] for further details
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-4.5,  1.5,   4.0;
         -4.0,  1.0,   4.0;
         -1.5, -0.5,   1.0],
    B = [  1; 0; 1 ],
    C = [1,  0,  0],
    D = [0]);

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.toIrreducibleForm(ss);
//  tss=StateSpace(
      A=[-0.5],
      B=[-sqrt(0.5)],
      C=[-1/sqrt(0.5)1],
      D=[0])
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toIrreducibleForm;

      encapsulated function toStaircaseForm
        "Transforms a state space system to upper staircase form"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD "Method for staircase algorithm";

        output StateSpace ss_sc(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)]);

      algorithm
        if method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD then
          (,ss_sc) := StateSpace.Internal.staircaseSVD(ss);
        else
          (,ss_sc) := Modelica_LinearSystems2.StateSpace.Internal.staircaseQR(ss);
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss_sc = StateSpace.Transformation.<b>toStaircaseForm</b>(ss, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the upper staircase form state space system.
</p>

<h4>Example</h4>
<blockquote><pre>
Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
   A=[17.0,   24.0,    1.0,    8.0,   15.0;
      23.0,    5.0,    7.0,   14.0,   16.0;
       4.0,    6.0,   13.0,   20.0,   22.0;
      10.0,   12.0,   19.0,   21.0,    3.0;
      11.0,   18.0,   25.0,    2.0,    9.0],
   B=[-1.0,   -4.0;
       4.0,    9.0;
      -9.0,  -16.0;
      16.0,   25.0;
     -25.0,  -36.0],
   C=[1, 0, 1, 0, 0;
      0, 1, 0, 1, 1],
   D=[0, 0;
      0, 0]);

<b>algorithm</b>
  ss_sc:=Modelica_LinearSystems2.StateSpace.Transformation.toStaircaseForm(ss);
  ss_sc=StateSpace(
    A=[-1, 0; 0, -2],
    B=[1; 0],
    C=[1, 0],
    D=[0])
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toStaircaseForm;

      encapsulated function extract
        "Extract input/output related subsystems from state space system record"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Integer outputIndex[:]={1} "Vector of subsystem outputs indices";
        input Integer inputIndex[:]={1} "Vector of subsystem inputs indices";
        output StateSpace subSc(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(inputIndex, 1)],
          redeclare Real C[size(outputIndex, 1), size(ss.C, 2)],
          redeclare Real D[size(outputIndex, 1), size(inputIndex, 1)])
          "Subsystem state space record";

      algorithm
        subSc.A := ss.A;
        subSc.B := ss.B[:, inputIndex];
        subSc.C := ss.C[outputIndex, :];
        subSc.D := ss.D[outputIndex, inputIndex];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
subsystem = StateSpace.Transformation.<b>extract</b>(ss, outputIndex, inputIndex)
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the subsystem of a state space system corresponding to the indices in outputIndex and inputIndex, i.e.
</p>
<blockquote><pre>
subsystem.A = ss.A;
subsystem.B = ss.B[:, inputIndex];
subsystem.C = ss.C[outputIndex, :];
subsystem.D = ss.D[outputIndex, inputIndex];
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1, 1, 2; 0, -2, 3;-3, 2, 1],
    B=[1, 0; 0, 1; 1, 0],
    C=[1, 1, 0; 0, 1, 1],
    D=[0, 0; 0,0]);

  Integer outputIndex={1, 2};
  Integer inputIndex={2}

<b>algorithm</b>
  tss:=Modelica_LinearSystems2.StateSpace.Transformation.extract(ss, outputIndex, inputIndex);
//  tss=StateSpace(
      A=[-1, 1, 2; 0, -2, 3;-3, 2, 1],
      B=[0; 1; 0],
      C=[1, 1, 0; 0, 1, 1],
      D=[0; 0])
</pre></blockquote>
</html>"));
      end extract;

    end Transformation;

    encapsulated package Import
      "Package of functions to generate a StateSpace data record from imported data"
      extends Modelica.Icons.Package;
      import Modelica;

      encapsulated function fromFile
        "Read a StateSpace data record from mat-file"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input String fileName="dslin.mat"
          "Name of the state space system data file" annotation (Dialog(
              loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption=
                  "State space system data file")));
        input String matrixName="ABCD"
          "Name of the state space system matrix (default is \"ABCD\") in the fileName"
          annotation (Dialog);
    protected
        Integer xuy[3]=StateSpace.Internal.readSystemDimension(fileName, matrixName) annotation(__Dymola_allowForSize=true);
        Integer nx=xuy[1] annotation(__Dymola_allowForSize=true);
        Integer nu=xuy[2] annotation(__Dymola_allowForSize=true);
        Integer ny=xuy[3] annotation(__Dymola_allowForSize=true);

    public
        output StateSpace result(
          redeclare Real A[nx, nx],
          redeclare Real B[nx, nu],
          redeclare Real C[ny, nx],
          redeclare Real D[ny, nu]) "Outputs model read from file";

    protected
        Real ABCD[nx + ny, nx + nu]=
            Modelica_LinearSystems2.Internal.Streams.readMatrixInternal(
                fileName,
                matrixName,
                nx + ny,
                nx + nu);

      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        Modelica.Utilities.Streams.print(
          "State space record loaded from file: \"" + Modelica.Utilities.Files.fullPathName(fileName) + "\"");

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.Import.<b>fromFile</b>(fileName, matrixName)
</pre></blockquote>

<h4>Description</h4>
<p>
Reads and loads a state space system from a mat-file <tt>fileName</tt>. The file must contain the matrix [A, B; C, D] named matrixName and the integer nx representing the order of the system, i.e. the number of rows of the square matrix A.
</p>

<h4>Example</h4>
<blockquote><pre>

<b>algorithm</b>
  ss:=Modelica_LinearSystems2.StateSpace.Import.fromFile(\"stateSpace.mat\", \"ABCD\");
//  ss=StateSpace(
      A=[-1, 0, 0; 0, -2, 0; 0, 0, -3],
      B=[1; 1; 0],
      C=[1, 1, 1],
      D=[0])
</pre></blockquote>
</html>"));
      end fromFile;

      function fromModel
        "Generate a StateSpace data record by linearization of a model"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;

        input String modelName "Name of the model"
         annotation(Dialog(__Dymola_translatedModel(translate=true)));
        input Real T_linearize=0
          "Simulate until T_linearize and then linearize the model";
        input String fileName="dslin" "Name of the result file";
        input String method="Dassl" "Integration method";

    protected
        String fileName2=fileName + ".mat"
          "Name of the result file with extension";
        Boolean OK1=simulateModel(
                problem=modelName,
                startTime=0,
                stopTime=T_linearize,
                method=method);
        Boolean OK2=importInitial("dsfinal.txt");
        Boolean OK3=linearizeModel(
                problem=modelName,
                resultFile=fileName,
                startTime=T_linearize,
                stopTime=T_linearize + 1,
                method=method);

        Real nxMat[1, 1]=readMatrix(
                fileName2,
                "nx",
                1,
                1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny, nx + nu]=readMatrix(
                fileName2,
                "ABCD",
                nx + ny,
                nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(
                fileName2,
                "xuyName",
                nx + nu + ny);
    public
        output StateSpace result(
          redeclare Real A[nx, nx],
          redeclare Real B[nx, nu],
          redeclare Real C[ny, nx],
          redeclare Real D[ny, nu]) "= model linearized at initial point";

      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        result.uNames := xuyName[nx + 1:nx + nu];
        result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        result.xNames := xuyName[1:nx];

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.Import.<b>fromModel</b>(modelName, T_linearize, fileName)
</pre></blockquote>

<h4>Description</h4>
<p>
Generate a StateSpace data record by linearization of a model defined by modelName. The linearization is performed at time T_linearize of the simulation. The result of linearization is transformed into a StateSpace record.
</p>
<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;

<b>algorithm</b>
  ss = Modelica_LinearSystems2.StateSpace.Import.fromModel(modelName, T_linearize);

// ss.A = [ 0.0,   1.0,    0.0,            0.0,      0.0,     0.0;
            0.0,   0.0,          -2.26,    0.08,     1.95,   -0.45;
            0.0,   0.0,           0.0,            1.0,      0.0,     0.0;
            0.0,   0.0,          -3.09,   -1.38,     7.70,   -3.01;
            0.0,   0.0,           0.0,            0.0,      0.0,     1.0;
            0.0,   0.0,          -6.47,    1.637,   -2.90,    1.29],

// ss.B=[0.0; 0.13; 0.0; -0.014; 0.0; -0.1],
// ss.C=identity(6),
// ss.D=[0; 0; 0; 0; 0; 0]
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end fromModel;

      annotation (Documentation(info="<html>
</html>"));
    end Import;

    encapsulated package Internal
      "Package of internal material of record StateSpace (for advanced users only)"
      import Modelica;
      import Modelica_LinearSystems2;
      extends Modelica.Icons.Package;

      encapsulated function assignOneOrTwoPoles
        "Algorithm to assign p (p = 1 or 2) eigenvalues"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Vectors;

        input Real F[:, size(F, 1)] "System matrix of order p=1 or p=2";
        input Real G[size(F, 1), :] "Control input matrix p rows";
        input Complex gamma[size(F, 1)];
        input Real tolerance=Modelica.Constants.eps;
        output Real K[:, size(F, 1)] "Feedback matrix p columns";

    protected
        Real Gamma[:, :];
        Integer rankGs;
        Real Fs[size(F, 1), size(F, 2)];
        Real Gs[size(G, 1), size(G, 2)];
        Real Gst[:, :]=transpose(G);
        Real Ks[:, size(F, 1)];
        Real c;
        Real s;
        Real r;
        Integer p=size(F, 1);
        Real sigmaG[:];

        Real V[size(G, 2), size(G, 2)];
        Real U[size(F, 1), size(F, 2)];

        Real u1[:];
        Real u2[:];
        Integer i;
        Complex system_ev[:];

      algorithm
        assert(size(F, 1) >= size(gamma, 1),
          "\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size ["
           + String(size(F, 1)) + "," + String(size(F, 1)) + "] and " + String(
          size(F, 1)) + " demanded assigned poles are expected. However, " +
          String(size(gamma, 1)) + " poles are given");
        //assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),"A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix ");
        if size(gamma, 1) == 1 then
          assert(gamma[1].im == 0,
            "\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size ["
             + String(size(F, 1)) + "," + String(size(F, 1)) +
            "], therefore, the demanded assigned pole must be real. However, the imaginary part is "
             + String(gamma[1].im));
        elseif abs(gamma[1].im) > 0 or abs(gamma[2].im) > 0 then
          assert(gamma[1].re == gamma[2].re and gamma[1].im == -gamma[2].im,
            "\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = "
             + String(gamma[1]) + "\npole2 = " + String(gamma[2]) +
            ". \nTry\npole1 = " + String(gamma[1]) + "\npole2 = " + String(
            Complex.conj(gamma[1])) + "\ninstead");
        end if;

        if not Modelica.Math.Matrices.isEqual(
                G,
                zeros(size(G, 1), size(G, 2)),
                tolerance) then
          if size(G, 2) == 1 then
            V := [1];
            if size(G, 1) == 1 then
              U := [1];
            else
              // Givens
              r := sqrt(G[1, 1]^2 + G[2, 1]^2);
              c := G[1, 1]/r;
              s := G[2, 1]/r;
              U := [c, s; -s, c];
            end if;
            Gs := U*G;

            rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;
          else
            // size(G, 2)>1

            if size(G, 1) == 1 then
              // U=I, compute V by just one Householder transformation
              U := [1];
              u1 := cat(1, Vectors.householderVector(Gst[:, 1], cat(
                    1,
                    {1},
                    zeros(size(G, 2) - 1))));
              // Householder vector
              Gst := Modelica_LinearSystems2.Math.Matrices.householderReflexion(
                Gst, u1);

              V := identity(size(G, 2)) - 2*matrix(u1)*transpose(matrix(u1))/(u1*
                u1);
              Gs := transpose(Gst);
              rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;

            else
              // systems with p==2 and m>1 are transformed by svd
              (sigmaG,U,V) := Modelica.Math.Matrices.singularValues(G);
              rankGs := 0;
              i := size(sigmaG, 1);
              while i > 0 loop
                if sigmaG[i] > 1e-10 then
                  rankGs := i;
                  i := 0;
                end if;
                i := i - 1;
              end while;
              Gs := zeros(p, size(G, 2));
              for i in 1:rankGs loop
                Gs[i, i] := sigmaG[i];
              end for;

            end if;
            V := transpose(V);
          end if;

          // check controllability
          assert(not Modelica.Math.Matrices.isEqual(
                Gs,
                zeros(size(Gs, 1), size(Gs, 2)),
                tolerance),
            "A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable");

          Ks := fill(
                0,
                rankGs,
                size(F, 1));
          Fs := U*F*transpose(U);

          if size(F, 1) == 1 then
            Ks := matrix((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
          else
            if rankGs == size(F, 1) then

              // Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];
              //  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);
              //        Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,2],
              //        (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] - gamma[2].re)/Gs[1, 1]/Gs[2, 2];
              //        (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2] - gamma[2].re)/Gs[2, 2]];

              // since G1 is diagonal because of svd, Gs[1, 2] is zero

              Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1], (Fs[1, 2] + (gamma[1].im)
                ^2)/Gs[1, 1]; (Fs[2, 1] - 1)/Gs[2, 2], (Fs[2, 2] - gamma[2].re)/
                Gs[2, 2]];
            else

              Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1,
                1];
              Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1,
                2]*Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))
                /Fs[2, 1]/Gs[1, 1];
              Ks := -Ks;
            end if;
          end if;

          K := V[:, 1:size(Ks, 1)]*Ks*U;

        else
          if p == 1 then
            Modelica.Utilities.Streams.print("\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, "   + String(F[1, 1]) + " remains and " + String(gamma[1].re) +
              " cannot be realized");
          else
            system_ev := Complex.eigenValues(F);
            Modelica.Utilities.Streams.print("\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, "   + String(system_ev[1].re) + (if abs(system_ev[1].im) > 0 then
              " + " else " - ") + String(system_ev[1].im) + "j and " + String(
              system_ev[2].re) + (if abs(system_ev[2].im) > 0 then " + " else
              " - ") + String(system_ev[2].im) + "j remain and " + String(gamma[1].re)
               + (if abs(gamma[1].im) > 0 then (if gamma[1].im > 0 then " + "
               else " - " + String(gamma[1].im) + "j") else "" + " and ") +
              String(gamma[2].re) + (if abs(gamma[2].im) > 0 then (if gamma[2].im
               > 0 then " + " else " - " + String(gamma[2].im) + "j") else "") +
              " cannot be realized");
          end if;
          K := zeros(size(G, 2), size(F, 1));
        end if;

      end assignOneOrTwoPoles;

      encapsulated function assignOneOrTwoPoles_alpha
        "Algorithm to assign p (p = 1 or 2) eigenvalues"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Vectors;

        input Real F[:, size(F, 1)] "System matrix of order p=1 or p=2";
        input Real G[size(F, 1), :] "Control input matrix p rows";
        input Complex gamma[size(F, 1)];
        input Real tolerance=Modelica.Constants.eps;
        output Real K[:, size(F, 1)] "Feedback matrix p columns";

    protected
        Real Gamma[:, :];
        Integer rankGs;
        Real Fs[size(F, 1), size(F, 2)];
        Real Gs[size(G, 1), size(G, 2)];
        Real Gst[:, :]=transpose(G);
        Real Ks[:, size(F, 1)];
        Real c;
        Real s;
        Real r;

        Real V1[size(G, 2), size(G, 2)];
        Real V2[size(G, 2), size(G, 2)];
        Real V[size(G, 2), size(G, 2)];
        Real U[size(F, 1), size(F, 2)];

        Real u1[:];
        Real u2[:];

      algorithm
        assert(size(F, 1) >= size(gamma, 1),
          "\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size ["
           + String(size(F, 1)) + "," + String(size(F, 1)) + "] and " + String(
          size(F, 1)) + " demanded assigned poles are expected. However, " +
          String(size(gamma, 1)) + " poles are given");
        //assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),"A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix ");
        if size(gamma, 1) == 1 then
          assert(gamma[1].im == 0,
            "\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size ["
             + String(size(F, 1)) + "," + String(size(F, 1)) +
            "], therefore, the demanded assigned pole must be real. However, the imaginary part is "
             + String(gamma[1].im));
        elseif abs(gamma[1].im) > 0 or abs(gamma[2].im) > 0 then
          assert(gamma[1].re == gamma[2].re and gamma[1].im == -gamma[2].im,
            "\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = "
             + String(gamma[1]) + "\npole2 = " + String(gamma[2]) +
            ". \nTry\npole1 = " + String(gamma[1]) + "\npole2 = " + String(
            Complex.conj(gamma[1])) + "\ninstead");
        end if;

        if not Modelica.Math.Matrices.isEqual(
                G,
                zeros(size(G, 1), size(G, 2)),
                tolerance) then
          if size(G, 2) == 1 then
            V := [1];
            if size(G, 1) == 1 then
              U := [1];
            else
              // Givens
              r := sqrt(G[1, 1]^2 + G[2, 1]^2);
              c := G[1, 1]/r;
              s := G[2, 1]/r;
              U := [c, s; -s, c];
            end if;
            Gs := U*G;

            rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;
          else
            // size(G, 2)>1

            if size(G, 1) == 1 then
              // U=I, compute V by just one Householder transformation
              U := [1];
              u1 := cat(1, Vectors.householderVector(Gst[:, 1], cat(
                    1,
                    {1},
                    zeros(size(G, 2) - 1))));
              // Householder vector
              Gst := Modelica_LinearSystems2.Math.Matrices.householderReflexion(
                Gst, u1);

              V := identity(size(G, 2)) - 2*matrix(u1)*transpose(matrix(u1))/(u1*
                u1);
              Gs := transpose(Gst);
              rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;

            else
              //2xHH + Givens
              u1 := cat(1, Vectors.householderVector(Gst[:, 1], cat(
                    1,
                    {1},
                    zeros(size(G, 2) - 1))));
              // Householder vector1
              Gst := Modelica_LinearSystems2.Math.Matrices.householderReflexion(
                Gst, u1);
              V1 := identity(size(G, 2)) - 2*matrix(u1)*transpose(matrix(u1))/(u1
                *u1);

              // if rank of G of a multi input system is equal to 1
              if Modelica.Math.Vectors.isEqual(
                      Gst[:, 2],
                      zeros(size(G, 2)),
                      tolerance) or Modelica.Math.Matrices.isEqual(
                      Gst[2:size(Gst, 1), :],
                      zeros(size(Gst, 1) - 1, size(Gst, 2)),
                      tolerance) then
                V := V1;
                rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;
              else

                u2 := cat(
                      1,
                      zeros(1),
                      Vectors.householderVector(Gst[2:size(G, 2), 2], cat(
                        1,
                        {1},
                        zeros(size(G, 2) - 2))));
                // Householder vector2
                Gst := Modelica_LinearSystems2.Math.Matrices.householderReflexion(
                  Gst, u2);

                V2 := identity(size(G, 2)) - 2*matrix(u2)*transpose(matrix(u2))/(
                  u1*u1);
                V := V2*V1;

              end if;

              Gs := transpose(Gst);

              rankGs := 0;
              for i in 1:2 loop
                if abs(Gs[i, i]) > tolerance then
                  rankGs := rankGs + 1;
                end if;
              end for;
              // Givens rotation to transfotm Gs[1:2,1:2] to right upper triangle
              r := sqrt(Gs[1, 1]^2 + Gs[2, 1]^2);
              c := Gs[1, 1]/r;
              s := Gs[2, 1]/r;
              U := [c, s; -s, c];
              Gs := U*Gs;

            end if;
          end if;

          // check controllability
          assert(not Modelica.Math.Matrices.isEqual(
                Gs,
                zeros(size(Gs, 1), size(Gs, 2)),
                tolerance),
            "A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable");

          Ks := fill(
                0,
                rankGs,
                size(F, 1));
          Fs := U*F*transpose(U);

          if size(F, 1) == 1 then
            Ks := matrix((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
          else
            if rankGs == size(F, 1) then

              // Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];
              //  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);
              Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/
                Gs[1, 1]/Gs[2, 2], (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1,
                2]*(Fs[2, 2] - gamma[2].re)/Gs[1, 1]/Gs[2, 2]; (Fs[2, 1] - 1)/Gs[
                2, 2], (Fs[2, 2] - gamma[2].re)/Gs[2, 2]];
            else

              Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1,
                1];
              Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1,
                2]*Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))
                /Fs[2, 1]/Gs[1, 1];
              Ks := -Ks;
            end if;
          end if;

          //    K := transpose(V)*[Ks; zeros(size(G, 2) - rankGs, size(Ks, 2))]*(U);
          K := transpose(V[1:size(Ks, 1), :])*Ks*U;

        else
          Modelica.Utilities.Streams.print(
            "\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained");
          K := zeros(size(G, 2), size(F, 1));
        end if;

      end assignOneOrTwoPoles_alpha;

      function characterizeEigenvalue
        "Check stability, stabilizability, controllability, observability nad detectability of the single poles"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.Eigenvalue;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;

        input StateSpace ss=Modelica_LinearSystems2.StateSpace(
                A=fill(
                  0,
                  0,
                  0),
                B=fill(
                  0,
                  0,
                  0),
                C=fill(
                  0,
                  0,
                  0),
                D=fill(
                  0,
                  0,
                  0)) "State space system";
        input Eigenvalue evin[:]
          "Eigenvalues or a pairs of conjugated complex pair";
        output Eigenvalue ev[size(ss.A, 1)];

    protected
        Real cPoles[:, 2] "Controllable poles";
        Real ncPoles[:, 2] "Uncontrollable poles";
        Real poles[size(ss.A, 1), 2] "Controllable and uncontrollable poles";
        Integer n_c;
        Integer nx=size(ss.A, 1);

        Eigenvalue cdummy[size(ss.A, 1)];
        Eigenvalue odummy[size(ss.A, 1)];
        StateSpace sst=StateSpace(
                A=transpose(ss.A),
                B=transpose(ss.C),
                C=transpose(ss.B),
                D=transpose(ss.D));
        Boolean equal;
        Integer ii;

        Real eps=1e-16*Modelica.Math.Matrices.norm(A=ss.A, p=1);
        Real factor_eps=1;
        Real absVector[nx];
        Integer indices[:];
        Integer indexMin;
        Real indexVector[:];
        Integer vv[:];
        Complex j=Modelica_LinearSystems2.Math.Complex.j();

      algorithm
        for i in 1:nx loop
          ev[i].ev := evin[i].ev;
        end for;

        (cPoles,ncPoles,poles) := StateSpace.Internal.controllablePoles(ss);
        n_c := size(cPoles, 1);
        for i in 1:n_c loop
          cdummy[i].ev := cPoles[i, 1] + cPoles[i, 2]*j;
          cdummy[i].isControllable := true;
        end for;
        for i in 1:size(ncPoles, 1) loop
          cdummy[n_c + i].ev := ncPoles[i, 1] + ncPoles[i, 2]*j;
          cdummy[n_c + i].isControllable := false;
        end for;

        // controllable poles of the trnasposed system are the observable poles
        (cPoles,ncPoles,poles) := StateSpace.Internal.controllablePoles(sst);
        n_c := size(cPoles, 1);
        for i in 1:n_c loop
          odummy[i].ev := cPoles[i, 1] + cPoles[i, 2]*j;
          odummy[i].isObservable := true;
        end for;
        for i in 1:size(ncPoles, 1) loop
          odummy[n_c + i].ev := ncPoles[i, 1] + ncPoles[i, 2]*j;
          odummy[n_c + i].isObservable := false;
        end for;

        // using ev.imag as an flag to mark the eigenvalues
        for i in 1:nx loop
          absVector := fill(1e50, nx);
          for ii in 1:nx loop
            if not odummy[ii].imag then
              absVector[ii] := Complex.'abs'(ev[i].ev - odummy[ii].ev);
            end if;
          end for;
          (absVector,indices) := Modelica.Math.Vectors.sort(absVector);
          indexMin := indices[1];
          ev[i].isObservable := odummy[indexMin].isObservable;
          odummy[indexMin].imag := true;
        end for;

        for i in 1:nx loop
          absVector := fill(1e50, nx);
          for ii in 1:nx loop
            if not cdummy[ii].imag then
              absVector[ii] := Complex.'abs'(ev[i].ev - cdummy[ii].ev);
            end if;
          end for;
          (absVector,indices) := Modelica.Math.Vectors.sort(absVector);
          indexMin := indices[1];
          ev[i].isControllable := cdummy[indexMin].isControllable;
          cdummy[indexMin].imag := true;
        end for;

        for i in 1:nx loop
          ev[i] := Eigenvalue(
                ev[i].ev,
                ev[i].isControllable,
                ev[i].isObservable);
        end for;

      end characterizeEigenvalue;

      encapsulated function cntrHessenberg
        "Calculate the controllable part of a SISO system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";

        output Modelica_LinearSystems2.Internal.StateSpaceR ssm1(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), 1],
          redeclare Real C[1, size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "controllable state space system";

    protected
        Integer nx=size(ss.A, 1);
        Real Ah1[nx, nx];
        Real bh1[nx];
        Real ch1[nx];
        Real u[:] "householder vector";
        Real Q[nx, nx];
        Real V[size(ss.A, 1), size(ss.A, 2)];
        Real tau[max(0,nx - 1)];
        Real Qc[:, :];
        Real svd[:];
        Real normA=Modelica.Math.Matrices.norm(A=ss.A, p=1);
        Integer rankMinSys;
        Boolean isZero=false;

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        Ah1 := ss.A;
        bh1 := ss.B[:, 1];
        ch1 := ss.C[1, :];

        if Modelica.Math.Vectors.length(bh1) > 0 then

          if nx > 1 then

            // transform b->Qb = {*,0,...,0} and c->cQ, A->QAQ
            u := Vectors.householderVector(bh1, cat(
                  1,
                  {1},
                  fill(0, nx - 1)));
            //householder vector to compute a housholder reflector S = I - 2*u*u'/u'*u
            Ah1 := Matrices.householderSimilarityTransformation(Ah1, u);
            bh1 := Vectors.householderReflexion_e1(bh1, u);
            ch1 := Vectors.householderReflexion(ch1, u);

            (Ah1,V,tau) := Modelica.Math.Matrices.Utilities.toUpperHessenberg(
                  Ah1,
                  1,
                  nx);
            Q := Matrices.orthogonalQ(
                  V,
                  tau,
                  1,
                  nx);
            ch1 := ch1*Q;

          end if;

          rankMinSys := 1;
          while rankMinSys < nx and not isZero loop
            isZero := abs(Ah1[rankMinSys + 1, rankMinSys]) < normA*1e-10;
            rankMinSys := rankMinSys + 1;
          end while;

          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=Ah1,
                B=matrix(bh1),
                C=transpose(matrix(ch1)),
                D=ss.D,
                r=if isZero then rankMinSys - 1 else rankMinSys);

        end if;

        //equation

        //algorithm
      end cntrHessenberg;

      encapsulated function complexPoles
        "Generate a zeros-and-poles representation from state space representation"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        output Complex poles2[:]=fill(Complex(0, 0),
            StateSpace.Internal.numberOfPoles(ss));

    protected
        Integer nx=size(ss.A, 2);

        Complex zeros[:]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";
        Complex zeros2[:];
        Complex poles[:] "eigenvalues of ss";
        Real eval[nx, 2];
        Real evec[nx, nx];

        Integer index[:]=fill(0, nx) "indices of zeros which are equal to poles";
        Integer i;
        Integer j;
        Integer k;
        Boolean h;
        Integer nzero;

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            " function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        h := false;
        zeros := StateSpace.Analysis.invariantZeros(ss);
        zeros2 := zeros;

        poles := Modelica_LinearSystems2.Math.Complex.eigenValues(ss.A);

        for i in 1:size(zeros, 1) loop
          for j in 1:size(poles, 1) loop
            if zeros[i] == poles[j] then
              h := false;
              k := 1;
              while ((k < i) and (not h)) loop
                h := if (j == index[k]) then true else false;
                k := k + 1;
              end while;
              index[i] := if h then 0 else j;
            end if;
          end for;
        end for;

        j := 0;
        for i in 1:size(zeros, 1) loop
          if index[i] == 0 then
            j := j + 1;
            zeros2[j] := zeros[i];
          end if;
        end for;
        nzero := j;
        j := 0;
        for i in 1:size(poles, 1) loop
          h := false;
          k := 1;
          while (k <= size(zeros, 1) and (not h)) loop
            h := if i == index[k] then true else false;
            k := k + 1;
          end while;
          if not h then
            j := j + 1;
            poles2[j] := poles[i];

          end if;
        end for;

      end complexPoles;

      encapsulated function complexZeros
        "Calculate the zeros of the related transfer function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        output Complex zeros2[:]=fill(Complex(0, 0),
            StateSpace.Internal.numberOfZeros(ss));

    protected
        Integer nx=size(ss.A, 2);

        Complex zeros[:];
        Complex poles[:];
        Real eval[nx, 2];
        Real evec[nx, nx];

        Integer index[:]=fill(0, nx) "Indices of zeros which are equal to poles";
        Integer i;
        Integer j;
        Integer k;
        Boolean h;
        Integer nzero;

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "Function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            "Function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        zeros := StateSpace.Analysis.invariantZeros(ss);

        poles := Modelica_LinearSystems2.Math.Complex.eigenValues(ss.A);

        for i in 1:size(zeros, 1) loop
          for j in 1:size(poles, 1) loop
            if zeros[i] == poles[j] then
              h := false;
              k := 1;
              while ((k < i) and (not h)) loop
                h := if (j == index[k]) then true else false;
                k := k + 1;
              end while;
              index[i] := if h then 0 else j;
            end if;
          end for;
        end for;

        j := 0;
        for i in 1:size(zeros, 1) loop
          if index[i] == 0 then
            j := j + 1;
            zeros2[j] := zeros[i];
          end if;
        end for;

      end complexZeros;

      encapsulated function controllablePoles
        "Compute the controllable and uncontrollable poles of a state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal;

        input StateSpace ss=StateSpace(
                A=[-1],
                B=[1],
                C=[0],
                D=[0]) "State space system";

        output Real cPoles[:, 2] "controllable poles";
        output Real ncPoles[:, 2] "uncontrollable poles";
        output Real poles[size(ss.A, 1), 2]
          "controllable and uncontrollable poles";
    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssch(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "upper block controller Hessenberg form state space system";
        Boolean isControllable;

      algorithm
        if size(ss.B, 2) == 0 then
          poles := Modelica.Math.Matrices.eigenValues(ss.A);
          ncPoles := poles;
          cPoles := fill(
                0,
                0,
                2);
        else
          // build upper Hessenberg staircase to decomposite controllable/uncontrollable subspaces
          // The controllable part of A is in A[1:ssch.r, 1:ssch.r]
          (isControllable,ssch) := StateSpace.Internal.staircaseSVD(ss);
          if isControllable then
            poles := Modelica.Math.Matrices.eigenValues(ss.A);
            cPoles := poles;
            ncPoles := fill(
                  0,
                  0,
                  2);
          else
            cPoles := Modelica.Math.Matrices.eigenValues(ssch.A[1:ssch.r, 1:ssch.r]);
            ncPoles := Modelica.Math.Matrices.eigenValues(ssch.A[ssch.r + 1:size(
              ss.A, 1), ssch.r + 1:size(ss.A, 1)]);
            poles := [cPoles; ncPoles];
          end if;
        end if;

        annotation (Documentation(info="<html>
The function uses the SVD based staircase algorithm to transform the state space representation into a similar state space
to separate the uncontrollable poles from the controllable poles.
</html>"));
      end controllablePoles;

      function damping "Frequencies and damping of state space system"
        extends Modelica.Icons.Function;

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";
        output Complex eigenvalues[size(ss.A, 1)];
        output Real damp[size(ss.A, 1)];
        output Real frequency[size(ss.A, 1)];

    protected
        Integer n=size(ss.A, 1);
        Real pi=Modelica.Constants.pi;

      algorithm
        eigenvalues := StateSpace.Analysis.eigenValues(ss);
        for i in 1:n loop
          (frequency[i],damp[i]) := Complex.frequency(eigenvalues[i]);
          frequency[i] := 2*pi*frequency[i];
        end for;

      end damping;

      encapsulated function dgreeOfRedSys
        "Calculate the controllable and observable part of a state space system"

        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2;

        input StateSpace ss;
        output Integer degree_rs;

    protected
        StateSpace ssm1=
            Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem(ss);

        StateSpace ss2=StateSpace(
                A=transpose(ssm1.A),
                B=transpose(ssm1.C),
                C=transpose(ssm1.B),
                D=ssm1.D);

        StateSpace ssm2=
            Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem(ss2);

      algorithm
        degree_rs := size(ssm2.A, 1);

      end dgreeOfRedSys;

      encapsulated function householder "Householder transformation"
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;

        input StateSpace ss;
        input Real v[size(ss.A, 1)];

        output StateSpace ssh;

    protected
        Real Ah[size(ss.A, 1), size(ss.A, 2)];
        Real Bh[size(ss.B, 1), size(ss.B, 2)];
        Real Ch[size(ss.C, 1), size(ss.C, 2)];
      algorithm
        Ah := Matrices.householderSimilarityTransformation(ss.A, v);
        Bh := Matrices.householderReflexion(ss.B, v);
        Ch := transpose(Matrices.householderReflexion(transpose(ss.C), v));

        ssh := StateSpace(
              A=Ah,
              B=Bh,
              C=Ch,
              D=ss.D);

      end householder;

      encapsulated function invariantZerosWithRealMatrix
        "Compute invariant zeros of linear state space system (system given by A,B,C,D matrices)"
        import Modelica;
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        import Complex;

        input Real A[:,size(A,1)] "A-matrix of linear state space system";
        input Real B[size(A,1),:] "B-matrix of linear state space system";
        input Real C[:,size(A,1)] "C-matrix of linear state space system";
        input Real D[size(C,1),size(B,2)] "D-matrix of linear state space system";

        output Real InvariantZeros[:,2]
          "Finite, invariant zeros of linear state space system; size(Zeros,1) <= size(A,1); Zeros[:,1]: Real part, Zeros[:,2]: Imaginary part";

    protected
        Integer n;
        Integer m;
        Integer p;
        Real Ar[:, :];
        Real Br[:, :];
        Real Cr[:, :];
        Real Dr[:, :];

        Real Af[:, :];
        Real Bf[:, :];
        Real AfBf[:, :];

        Real V2[:, :];
        Real Vf[:, :];
        Real R[:, :];

        Integer na;
        Real alphaReal[:];
        Real alphaImag[:];
        Real beta[:];
        Integer info;
        Real zerosMax;
        Real absZero[:];

        Integer j;
      algorithm
        if min(size(B)) == 0 or min(size(C)) == 0 then
          // no inputs or no outputs
          InvariantZeros := fill(0.0,0,2);
        else
          // Reduce system
          (Ar,Br,Cr,Dr,n,m,p) := StateSpace.Internal.reduceRosenbrock(A,B,C,D);
          if n > 0 then
            (Ar,Br,Cr,Dr,n,m,p) := StateSpace.Internal.reduceRosenbrock(
                  transpose(Ar),
                  transpose(Cr),
                  transpose(Br),
                  transpose(Dr));
          end if;
          if n == 0 then
             InvariantZeros := fill(0.0,0,2);
          else
            (,R,,V2) := Matrices.QR(MatricesMSL.flipLeftRight(transpose([Cr, Dr])));
            Vf := MatricesMSL.flipLeftRight(V2);
            AfBf := [Ar, Br]*Vf;
            Af := AfBf[:, 1:size(Ar, 2)];
            Bf := Vf[1:size(Ar, 1), 1:size(Ar, 2)];

            (alphaReal,alphaImag,beta,info) :=
               Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev_eigenValues(Af,Bf);
            assert(info == 0,
              "Failed to compute invariant zeros with function invariantZerosWithRealMatrix(..)");

            InvariantZeros := fill(0.0, size(beta, 1),2);

            /* The pencil (Af,Bf) has n eigenvalues, since the transformation to this
             form is done so that Bf is regular. Therefore, the generalized eigenvalues
             represented by alpha[i]/beta[i] have the property that beta[i] cannot be zero
             and a division by beta[i] is uncritical.

             |alpha| / beta <= zerosMax
             if |alpha| <= beta*zerosMax then
                zero is used
             else
                assumed that zero is at infinity (i.e. it is ignored)
          */
            j := 0;
            zerosMax := 1.0e4*MatricesMSL.norm([Af, Bf], p=1);
            absZero := Modelica_LinearSystems2.StateSpace.Internal.absComplexVector(alphaReal, alphaImag);
            for i in 1:size(beta, 1) loop
               if absZero[i] <= beta[i]*zerosMax then
                  j := j + 1;
                  InvariantZeros[j,1] := alphaReal[i]/beta[i];
                  InvariantZeros[j,2] := alphaImag[i]/beta[i];
               end if;
            end for;

            if j == 0 then
               InvariantZeros := fill(0.0, 0,2);
            else
               InvariantZeros := InvariantZeros[1:j,:];
            end if;
          end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
InvariantZeros = StateSpace.Internal.<b>invariantZerosWithRealMatrix</b>(A,B,C,D)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
     <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre></blockquote>
<p>
The invariant zeros of this system are defined as the variables
s  that make the Rosenbrock matrix of the system
</p>
<pre>
    | s<b>I-A</b>   <b>-B</b> |
    |           |
    | <b>C</b>       <b>D</b> |
</pre>
<p>
singular.
</p>
<p>
This function applies the algorithm described in [1] where the system (<b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) is reduced to a new system (<b>A</b>r, <b>B</b>r <b>C</b>r, <b>D</b>r) with the same zeros and with <b>D</b>r of full rank.
</p>

<p>
The zeros are returned as a matrix InvariantZeros[:,2] where InvariantZeros[i,1] is the real and InvariantZeros[i,2] is the imaginary part
of the complex zero i.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[1, 1, 1;0, 1, 1;0,0,1],
    B=[1;0;1],
    C=[0,1,1],
    D=[0]);

  Complex zeros[:];

<b>algorithm</b>
  zeros := Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros(ss);
// zeros = {1, 0}
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Emami-Naeini, A. and Van Dooren, P. (1982):</dt>
<dd> <b>Computation of Zeros of Linear Multivariable Systems</b>.
     Automatica, 18, pp. 415-430.<br>&nbsp;</dd>
</dl>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end invariantZerosWithRealMatrix;

      encapsulated function invariantZeros2
        "Compute invariant zeros of linear SISO state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "Linear system in state space form";
        output Complex Zeros[:]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";

    protected
        Integer nx=size(ss.A, 1) "Number of states";
        Integer nu=size(ss.B, 2) "Number of inputs";
        Integer ny=size(ss.C, 1) "Number of outputs";
        Integer na=nx + nu;
        Real A[nx + ny, nx + nu]=[ss.A, ss.B; ss.C, ss.D];
        Real B[nx + ny, nx + nu]=[identity(nx), zeros(nx, nu); zeros(ny, nx + nu)];
        Real alphaReal[na];
        Real alphaImag[na];
        Real beta[na];
        Integer info;
        Real beta_small=100*Modelica.Constants.eps;
        Integer nZeros;
        Complex z[size(ss.A, 1)];
        Integer j;
        Real normB=max(beta_small,Modelica.Math.Matrices.norm(ss.B, p=1));
      algorithm
        assert(nu == ny, "Function invariantZeros requires currently that the number of
inputs (= "   + String(nu) + ") = number of outputs (= " + String(ny) + ")
This condition is however not fulfilled");

        // Compute zeros

        (alphaReal,alphaImag,beta,info) :=
          Matrices.generalizedEigenvaluesTriangular(A, B);

        assert(info == 0,
          "Failed to compute invariant zeros with function invariantZeros(..)");

        // If beta[i] is zero, then zero i is infinite.
        j := 1;
        for i in 1:na loop

          if beta[i] >= normB*1e-10 then
            // finite eigenvalue
            z[j].re := if abs(alphaReal[i]) >= normB*1e-12 then alphaReal[i]/beta[
              i] else 0;
            z[j].im := if abs(alphaImag[i]) >= normB*1e-12 then alphaImag[i]/beta[
              i] else 0;
            j := j + 1;
          end if;
        end for;
        nZeros := j - 1;
        Zeros := z[1:nZeros];
        annotation (Documentation(info="<html>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<pre>
   der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
        <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre>
<p>
The invariant zeros of this system are defined as the variables
z that make the following matrix singular:
</p>
<pre>
    | <b>A</b> <b>B</b> |     | <b>I</b> <b>0</b> |
    |     | - z*|     |
    | <b>C</b> <b>D</b> |     | <b>0</b> <b>0</b> |
</pre>
<p>
where <b>I</b> is the identity matrix of the same size as <b>A</b>
and <b>0</b> are zero matrices of appropriate dimensions.
</p>
<p>
Unlike to function StateSpace.Analysis.invariantZeros for general systems, it is
assumned in StateSpace.Analysis.invariantZeros that the generalized system matrix
[<b>A</b>, <b>B</b>; <b>C</b>, <b>D</b>] has upper Hessenberg form. Especially for SISO system this is
achieved when <b>A</b> is of upper Hessenberg form and [1, n] matrix <b>C</b> is of form
<b>C</b> = k*[0, 0, ..., 0, 1].
<p>
The function uses the LAPACK routine DHGEQZ. Look at <b>Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz</b> for details.
<p>
The advantage of this function in comparison to the general invariantZeros function
is the lower computatioal effort bacause systems with arbitrary system functions are first transformed
into an upper Hessenberg form system.
<p>
This function is used in fromStateSpace transformation functions which use Hessenberg form systems anyway.
</p>
<p>
Currently, there is the restriction that the number of
inputs and the number of outputs must be identical. Other systems
have to be treated like p*q SISO systems where p is the number of putputs and q the number of inputs of the MIMO system.
</p>
</html>"));
      end invariantZeros2;

      encapsulated function invariantZerosHessenberg
        "Fast version to calculate the system zeros of a SISO system with D=[0] and A has upper Hessenberg form, delivered by StateSpace.reduceSystem"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "Linear system in state space form";
        output Complex Zeros[:]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";

    protected
        Integer nx=size(ss.A, 1) "Number of states";
        Integer nu=size(ss.B, 2) "Number of inputs";
        Integer ny=size(ss.C, 1) "Number of outputs";
        Real Ah[nx, nx]=ss.A;
        Real eps=100*Modelica.Constants.eps;
        Integer k;
        Boolean h;

      algorithm
        assert(nu == 1, "Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of inputs is nu = "
           + String(nu));
        assert(ny == 1, "Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of outputs is ny = "
           + String(ny));

        h := true;
        k := nx + 1;

        if size(ss.B, 2) > 0 then
          while k >= 1 and h loop
            k := k - 1;
            if abs(ss.B[k, 1]) >= eps then

              h := false;
            end if;

          end while;

          Zeros := fill(Complex(0), k - 1);

          if k > 1 then
            Ah[:, k - 1] := ss.A[:, k - 1] - ss.A[k, k - 1]/ss.B[k, 1]*ss.B[:, 1];

            //    Zeros := Complex.eigenValues(Ah[1:k - 1, 1:k - 1]);
            Zeros := Complex.Internal.eigenValues_dhseqr(Ah[1:k - 1, 1:k - 1]);

            for i in 1:k - 1 loop
              if Complex.'abs'(Zeros[i]) < Modelica.Math.Matrices.norm(Ah[1:k - 1,
                  1:k - 1], p=1)*1e-12 then
                Zeros[i] := Complex(0);
              end if;

            end for;

          end if;
        else
          Zeros := fill(Complex(0, 0), 0);
        end if;

        annotation (Documentation(info="<html>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<pre>
   der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
        <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre>
<p>
The invariant zeros of this system are defined as the variables
z that make the following matrix singular:
</p>
<pre>
    | <b>A</b> <b>B</b> |     | <b>I</b> <b>0</b> |
    |     | - z*|     |
    | <b>C</b> <b>D</b> |     | <b>0</b> <b>0</b> |
</pre>
<p>
where <b>I</b> is the identity matrix of the same size as <b>A</b>
and <b>0</b> are zero matrices of appropriate dimensions.
</p>
<p>
Currently, there is the restriction that the number of
inputs and the number of outputs must be identical.
</p>
</html>"));
      end invariantZerosHessenberg;

      encapsulated function isSISO
        "To check a state space system to be SISO (or not)"

        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

        output Boolean isSISO "True, if state space system is SISO";
      algorithm
        isSISO := size(ss.B, 2) == 1 and size(ss.C, 1) == 1;
        annotation (Documentation(info="<html>
</html>"));
      end isSISO;

      encapsulated function isControllableAndObservableSISO
        "To check whether a SISO system is controllable and observable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssm1=
            StateSpace.Internal.reducedCtrSystem(ss);
        Integer nx=size(ss.A, 1);
        Integer rankQ=ssm1.r;
        StateSpace ss2=StateSpace(
                A=transpose(ssm1.A[nx - rankQ + 1:nx, nx - rankQ + 1:nx]),
                B=transpose(ssm1.C[:, nx - rankQ + 1:nx]),
                C=transpose(ssm1.B[nx - rankQ + 1:nx, :]),
                D=ssm1.D);
        Integer nx2=ssm1.r;
        Modelica_LinearSystems2.Internal.StateSpaceR ssm2=
            StateSpace.Internal.reducedCtrSystem(ss2);
    public
        output Boolean controllableAndObservable;
      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;
        controllableAndObservable := size(ss.A, 1) == ssm2.r;

      end isControllableAndObservableSISO;

      encapsulated function isControllableSISO
        "To check a SISO system whether it is controllable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssm=
            StateSpace.Internal.reducedCtrSystem(ss);

    public
        output Boolean controllable;
      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;
        controllable := size(ss.A, 1) == ssm.r;

        annotation (Documentation(info="<html>
This function is to calculate whether a SISO state space system is controllable or not. Therefore,
it is transformed to lower controller Hessenberg form
<blockquote><pre>
               | *    *     0   ...  0 |               | 0 |
               | .    .     .    .   . |               | . |
 <b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | *   ...   ...   *   0 |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
               | *   ...   ...   *   * |               | 0 |
               | *   ...   ...   *   * |               | * |

</pre>
</blockquote>
Note, that
<blockquote><pre>
                   n-1                        n-1
rank(<b>b</b>, <b>A</b>*<b>b</b>, ..., <b>A</b>  *<b>b</b>) = rank(<b>q</b>, <b>H</b>*<b>q</b>, ..., <b>H  </b>*<b>q</b>)
</pre>
</blockquote>
and that
<blockquote><pre>
                 n-1
 (<b>q</b>, <b>H</b>*<b>q</b>, ..., <b>H</b>  *<b>q</b>)
</pre>
</blockquote>
is a lower triangular matrix and has full rank if and only if none of the elements in the diagonal is zero. That is, that neither qn or hi,i+1,   i = 1,..., n-1   may be zero.
</html>"));
      end isControllableSISO;

      encapsulated function isControllableMIMO
        "To check a MIMO system whether it is controllable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean controllable;
      algorithm
        assert(method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD or method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.QR, "\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore,
the variable \"method\" in \"Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\" has to be qr or svd but is method = "   + String(method));
        if min(size(ss.B)) == 0 then
          controllable := false;
        else
          if method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.QR then
            controllable := StateSpace.Internal.staircaseQR(ss);
          else
            controllable := StateSpace.Internal.staircaseSVD(ss);
          end if;
        end if;
        annotation (Documentation(info="<html>
</html>"));
      end isControllableMIMO;

      encapsulated function isDetectableSISO
        "To check whether a SISO system is detectable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";
        output Boolean detectable;
    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssm=
            StateSpace.Internal.cntrHessenberg(
            StateSpace.Internal.transposeStateSpace(ss));
        Complex evd[:]=fill(Complex(0), size(ss.A, 1) - ssm.r);
      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        detectable := true;
        if size(ss.A, 1) > ssm.r then
          evd := Complex.eigenValues(ssm.A[ssm.r + 1:size(ss.A, 1), ssm.r + 1:
            size(ss.A, 1)]);
          for i1 in 1:size(evd, 1) loop
            detectable := detectable and evd[i1].re < 0;
          end for;
        end if;

        annotation (Documentation(info="<html>
<p>
This function checks whether a SISO state space system is detectable or not.
</p>
<p>
A system is detectable for the continuous-time case if all of the unobservable eigenvalues have neagtive real part
or for the discrete-time case if all of the unobservable eigenvalues are in the complex unit circle respectively.
Hence, a oberservable system is always detectable of course.
</p>
<p>
As observability is a dual concept of controllability, the concept of detectability is dual to stabilizability, that is,
a system is detectable if the pair (<b>A</b>', <b>C</b>') is stabilizable. Therefore, the same algorithm to check stabilizability
are applied to the dual pair (<b>A</b>', <b>C</b>') of the system:
</p>
<p>
To check stabilizability (see Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable) , ths system is transformed to to upper controller Hessenberg form
</p>
<blockquote><pre>
              | *   *   ...   ...    * |               | * |
              | *   *   ...   ...    * |               | 0 |
<b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
              | .   .    .     .     . |               | . |
              | 0  ...   0     *     * |               | 0 |
</pre>
</blockquote>
<p>
The system can be partitioned to
</p>
<blockquote><pre>
<b>H</b>=[<b>H</b>11,<b>H</b>12; <b>H</b>21, <b>H</b>22], <b>q</b>=[<b>q</b>1;<b>0</b>],
</pre></blockquote>
<p>
where the pair (<b>H</b>11, <b>q</b>1) contains the controllable part of the system, that is, rank(<b>H</b>) = rank(<b>H</b>11). For
stabilizability the <b>H</b>22 has to be stable.
</p>
</html>"));
      end isDetectableSISO;

      encapsulated function isDetectableMIMO
        "Check whether a MIMO system is detectable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";

        output Boolean detectable;

    protected
        StateSpace sst=StateSpace.Internal.transposeStateSpace(ss);

        Complex evnd[:] "complex vector of uncontrollable poles";
        Real dPoles[:, 2] "controllable poles";
        Real ndPoles[:, 2] "uncontrollable poles";
        Real poles[size(ss.A, 1), 2] "controllable and uncontrollable poles";
        Complex j=Modelica_LinearSystems2.Math.Complex.j();

      algorithm
        (dPoles,ndPoles,poles) := StateSpace.Internal.controllablePoles(sst);
        evnd := fill(Complex(0), size(ndPoles, 1));
        for i1 in 1:size(ndPoles, 1) loop
          evnd[i1] := ndPoles[i1, 1] + j*ndPoles[i1, 2];
        end for;

        detectable := true;

        if size(sst.A, 1) == size(dPoles, 1) then
          detectable := true;
        else
          for i1 in 1:size(ndPoles, 1) loop
            detectable := detectable and ndPoles[i1, 1] < 0;
          end for;
        end if;

        annotation (Documentation(info="<html>
This function checks whether a MIMO state space system is detectable or not.
<p>
A system is detectable for the continuous-time case if all of the unobservable eigenvalues have negative real part
or for the discrete-time case if all of the unobservable eigenvalues are in the complex unit circle respectively.
Hence, a observable system is always detectable of course.
<p>
To check detectability, staircase algorithm is used to separate the observable subspace from the unobservable subspace.
The unobservable poles are checked to be stable.
</html>"));
      end isDetectableMIMO;

      encapsulated function isObservableSISO
        "To check whether a SISO system is observable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

    protected
        StateSpace ss2=StateSpace.Internal.transposeStateSpace(ss);

        Modelica_LinearSystems2.Internal.StateSpaceR ssm2=
            StateSpace.Internal.reducedCtrSystem(ss2);
    public
        output Boolean observable;
      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;
        observable := size(ss.A, 1) == ssm2.r;

        annotation (Documentation(info="<html>
<p>
This function is to calculate whether a SISO state space system is observable or not. Therefore, the dual System (A', c', b', d')
it is transformed to upper observer Hessenberg form
</p>
<blockquote><pre>
              | *   *   ...   ...    * |             | * |
              | *   *   ...   ...    * |             | . |
<b>Q</b>*<b>A'</b>*<b>Q</b>' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>c'</b> =  | . |,   <b>b'</b>*<b>Q</b> = <b>q</b> = ( 0, ..., 0, * )
              | .   .    .     .     . |             | * |
              | 0  ...   0     *     * |             | * |
</pre></blockquote>
<p>
Note, that
</p>
<blockquote><pre>
rank(<b>c'</b>; <b>c'</b>*<b>A'</b>; ...; <b>c'</b>*<b>A'</b><sup><big>(n-1)</big></sup>) = rank(<b>q</b>; <b>q</b>*<b>H</b>; ...; <b>q</b>*<b>H</b><sup><big>(n-1)</big></sup>)
</pre></blockquote>
<p>
and that
</p>
<blockquote><pre>
(<b>q</b>; <b>H</b>*<b>q</b>; ...; <b>q</b>*<b>H</b><sup><big>(n-1)</big></sup>)
</pre></blockquote>
<p>
is a lower triangular matrix and has full rank if and only if none of the elements in
the diagonal is zero. That is, that neither qn or hi,i-1,   i = 2,...,&nbsp;n   may be zero.
</p>
</html>"));
      end isObservableSISO;

      encapsulated function isObservableMIMO
        "To check a MIMO system whether it is observable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

    protected
        StateSpace ss2=StateSpace.Internal.transposeStateSpace(ss);

    public
        output Boolean observable;
      algorithm
        assert(method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD or method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.QR, "\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore,
the variable \"method\" in \"Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\" has to be qr or svd but is method = "   + String(method));
        if min(size(ss.C)) == 0 then
          observable := false;
        else
          if method == Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.QR then
            observable := StateSpace.Internal.staircaseQR(ss2);
          else
            observable := StateSpace.Internal.staircaseSVD(ss2);
          end if;
        end if;

        annotation (Documentation(info="<html>
</html>"));
      end isObservableMIMO;

      encapsulated function isStabilizableSISO
        "To check whether a SISO system is stabliziable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";
        output Boolean stabilizable;
    protected
        Modelica_LinearSystems2.Internal.StateSpaceR ssm=
            StateSpace.Internal.cntrHessenberg(ss);
        Complex evd[:]=fill(Complex(0), size(ss.A, 1) - ssm.r);

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;
        stabilizable := true;

        if size(ss.A, 1) > ssm.r then
          evd := Complex.eigenValues(ssm.A[ssm.r + 1:size(ss.A, 1), ssm.r + 1:
            size(ss.A, 1)]);
          for i1 in 1:size(evd, 1) loop
            stabilizable := stabilizable and evd[i1].re < 0;
          end for;
        end if;

        annotation (Documentation(info="<html>
<p>
This function checks whether a SISO state space system is stabilizable or not.
</p>
<p>
A system is stabilizable for the continuous-time case if all of the uncontrollable eigenvalues have neagtive real part
or for the discrete-time case if all of the uncontrollable eigenvalues are in the complex unit circle respectively.
Hence, a controllable system is always stabilizable of course.
</p>
<p>
To check stabilizability, ths system is transformed to to upper controller Hessenberg form
</p>
<blockquote><pre>
              | *   *   ...   ...    * |               | * |
              | *   *   ...   ...    * |               | 0 |
<b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
              | .   .    .     .     . |               | . |
              | 0  ...   0     *     * |               | 0 |
</pre></blockquote>
<p>
The system can be partitioned to
</p>
<blockquote><pre>
<b>H</b>=[<b>H</b>11,<b>H</b>12; <b>H</b>21, <b>H</b>22], <b>q</b>=[<b>q</b>1;<b>0</b>],
</pre></blockquote>
<p>
where the pair (<b>H</b>11, <b>q</b>1) contains the controllable part of the system, that is, rank(<b>H</b>) = rank(<b>H</b>11). For
stabilizability the <b>H</b>22 has to be stable.
</p>
</html>"));
      end isStabilizableSISO;

      encapsulated function isStabilizableMIMO
        "To check whether a MIMO system is stabliziable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";

        output Boolean stabilizable;

    protected
        Complex evnc[:] "complex vector of uncontrollable poles";
        Real cPoles[:, 2] "controllable poles";
        Real ncPoles[:, 2] "uncontrollable poles";
        Real poles[size(ss.A, 1), 2] "controllable and uncontrollable poles";
        Complex j=Modelica_LinearSystems2.Math.Complex.j();

      algorithm
        (cPoles,ncPoles,poles) := StateSpace.Internal.controllablePoles(ss);
        evnc := fill(Complex(0), size(ncPoles, 1));
        for i1 in 1:size(ncPoles, 1) loop
          evnc[i1] := ncPoles[i1, 1] + j*ncPoles[i1, 2];
        end for;

        stabilizable := true;

        if size(ss.A, 1) > size(cPoles, 1) then
          for i1 in 1:size(ncPoles, 1) loop
            stabilizable := stabilizable and ncPoles[i1, 1] < 0;
          end for;
        end if;

        annotation (Documentation(info="<html>
This function checks whether a MIMO state space system is stabilizable or not.
<p>
A system is stabilizable for the continuous-time case if all of the uncontrollable eigenvalues have neagtive real part
or for the discrete-time case if all of the uncontrollable eigenvalues are in the complex unit circle respectively.
Hence, a controllable system is always stabilizable of course.
<p>
To check stabilizability, staircase algorithm is used to separate the controllable subspace from the uncontrollable subspace.
The uncontrollable poles are checked to to stable.
</html>"));
      end isStabilizableMIMO;

      encapsulated function numberOfPoles
        "Calculate the number of poles of the related transfer function"

        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

        output Integer numberOfPoles=StateSpace.Internal.numberOfPolesAndZeros(ss);

      algorithm
      end numberOfPoles;

      encapsulated function numberOfPolesAndZeros
        "Calculate the number poles and of zeros of the related transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;

        input StateSpace ss "State space system";
        output Integer numberOfPoles;
        output Integer numberOfZeros;

    protected
        Integer nx=size(ss.A, 2);
        Complex zeros[:];
        Complex zeros2[:]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";
        Complex poles[:];
        Complex poles2[:] "eigenvalues of ss";
        Real eval[nx, 2];
        Real evec[nx, nx];

        Integer index[:]=fill(0, nx) "indices of zeros which are equal to poles";
        Integer i;
        Integer j;
        Integer k;
        Boolean h;
        Integer nzero;

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            " function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        zeros := StateSpace.Analysis.invariantZeros(ss);
        zeros2 := zeros;

        poles := Modelica_LinearSystems2.Math.Complex.eigenValues(ss.A);
        poles2 := poles;

        //Reduce terms which are in nominator as well as in denominator
        for i in 1:size(zeros, 1) loop
          for j in 1:size(poles, 1) loop
            if zeros[i] == poles[j] then
              h := false;
              k := 1;
              while ((k < i) and (not h)) loop
                h := if (j == index[k]) then true else false;
                k := k + 1;
              end while;
              index[i] := if h then 0 else j;
            end if;
          end for;
        end for;

        j := 0;
        for i in 1:size(zeros, 1) loop
          if index[i] == 0 then
            j := j + 1;
            zeros2[j] := zeros[i];
          end if;
        end for;
        nzero := j;
        j := 0;
        for i in 1:size(poles, 1) loop
          h := false;
          k := 1;
          while (k <= size(zeros, 1) and (not h)) loop
            h := if i == index[k] then true else false;
            k := k + 1;
          end while;
          if not h then
            j := j + 1;
            poles2[j] := poles[i];

          end if;
        end for;

        numberOfPoles := nx - size(zeros, 1) + nzero;
        numberOfZeros := nzero;

      end numberOfPolesAndZeros;

      encapsulated function numberOfZeros
        "Calculate the number of zeros of the related transfer function"

        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "StateSpace object";

        output Integer numberOfZeros;

    protected
        Integer nop;
        Integer noz;

      algorithm
        (nop,noz) := StateSpace.Internal.numberOfPolesAndZeros(ss);
        numberOfZeros := noz;
      end numberOfZeros;

      encapsulated function partialGain "Algorithm for partial gain"
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;

        input Real H[:, size(H, 1)] "Upper Hessenberg matrix";
        input Real b[size(H, 1)];
        output Real result;
    protected
        Real Hh[:, :]=H;
        Real bh[:]=b;
        Integer q=size(H, 1);
      algorithm

        (Hh,bh) := StateSpace.Internal.trianUpperHess(Hh, bh);
        result := bh[q]/Hh[q, q];

      end partialGain;

      encapsulated function polesAndZeros
        "Generate poles and zeros from state space representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Internal.PolesAndZeros;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;

        input StateSpace ss "State space system";
        input StateSpace ssm=
            Modelica_LinearSystems2.StateSpace.Transformation.toIrreducibleForm(
            ss);
        output Internal.PolesAndZeros pz(
          redeclare Real p_real[size(ssm.A, 1)],
          redeclare Real p_im[size(ssm.A, 1)],
          redeclare Real z_real[size(StateSpace.Analysis.invariantZeros(ssm), 1)],
          redeclare Real z_im[size(StateSpace.Analysis.invariantZeros(ssm), 1)]);

    protected
        Complex poles[:]=Complex.eigenValues(ssm.A);
        Complex zeros[:]=StateSpace.Analysis.invariantZeros(ssm);

      algorithm
        pz.p_real := poles[:].re;
        pz.p_im := poles[:].im;
        pz.z_real := zeros[:].re;
        pz.z_im := zeros[:].im;
        pz.norz_p := Internal.numberOfRealZeros(poles);
        pz.norz_z := Internal.numberOfRealZeros(zeros);

      end polesAndZeros;

      encapsulated function readLength_nu
        "Read the number of inputs nu of a state space system from a file"

        input String fileName="ss_siso.mat"
          "Name of the state space system data file" annotation (Dialog(
              loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption=
                  "state space system data file")));
        input String matrixName="ABCD" "Name of the state space system matrix"
          annotation (Dialog);

        output Integer nu;
    protected
        Real nxMat[1, 1]=readMatrix(
                fileName,
                "nx",
                1,
                1);
        Integer ABCDsizes[2]=readMatrixSize(fileName, matrixName);
        Integer nx=integer(nxMat[1, 1]);

      algorithm
        nu := ABCDsizes[2] - nx;
      end readLength_nu;

      encapsulated function readLength_nx
        "Read the order nx of a state space system from a file"

        input String fileName="ss_siso.mat"
          "Name of the state space system data file" annotation (Dialog(
              loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption=
                  "state space system data file")));
        output Integer nx;
    protected
        Real nxMat[1, 1]=readMatrix(
                fileName,
                "nx",
                1,
                1);
      algorithm
        nx := integer(nxMat[1, 1]);
      end readLength_nx;

      encapsulated function readLength_ny
        "Read the number of outputs ny of a state space system from a file"

        input String fileName="ss_siso.mat"
          "Name of the state space system data file" annotation (Dialog(
              loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption=
                  "state space system data file")));
        input String matrixName="ABCD" "Name of the state space system matrix"
          annotation (Dialog);

        output Integer ny;
    protected
        Real nxMat[1, 1]=readMatrix(
                fileName,
                "nx",
                1,
                1);
        Integer ABCDsizes[2]=readMatrixSize(fileName, matrixName);
        Integer nx=integer(nxMat[1, 1]);

      algorithm
        ny := ABCDsizes[1] - nx;
      end readLength_ny;

      encapsulated function reducedCtrSystem2
        "Calculate the controllable part of a SISO system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;

        input StateSpace ss "State space system";
        input Real eps=0;

    protected
        StateSpace sst(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "transformed state space system";

        Integer nx=size(ss.A, 1);
        Real Ah1[size(ss.A, 1), size(ss.A, 2)];
        Real bh1[size(ss.A, 1)];
        Real ch1[size(ss.A, 1)];

        Real u[:] "householder vector";
        Real cpoles[:, 2]=
            Modelica_LinearSystems2.StateSpace.Internal.controllablePoles(ss);
        Integer rankQc=size(cpoles, 1);

        Integer rankQc2;
        Real Qc2[nx, nx];
        Real sigma[:];
        Real eps2;

        Real Ah2[rankQc, rankQc];
        Real bh2[rankQc];
        Real ch2[rankQc];

        Integer ll;
        Integer r;

        Boolean h;

    public
        output StateSpace ssm1(
          redeclare Real A[rankQc, rankQc],
          redeclare Real B[rankQc, 1],
          redeclare Real C[1, rankQc],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "controllable state space system";

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        Ah1 := ss.A;
        bh1 := ss.B[:, 1];
        ch1 := ss.C[1, :];

        if nx > 1 then

          u := Vectors.householderVector(bh1, cat(
                1,
                fill(0, nx - 1),
                {1}));

          Ah1 := Matrices.householderSimilarityTransformation(Ah1, u);

          bh1 := Vectors.householderReflexion(bh1, u);
          ch1 := Vectors.householderReflexion(ch1, u);

          ll := nx;

          h := true;
          r := 1;

          while r <= nx - 2 and h loop
            if max(Ah1[1:ll - 1, ll]) <= 1e-8 then

              u := cat(
                    1,
                    Vectors.householderVector(Ah1[1:ll - 1, ll], cat(
                      1,
                      fill(0, ll - 2),
                      {1})),
                    fill(0, nx - ll + 1));
              Ah1 := Matrices.householderSimilarityTransformation(Ah1, u);
              ch1 := Vectors.householderReflexion(ch1, u);

              Ah1[1:ll - 2, ll] := fill(0, ll - 2);

              ll := ll - 1;

            else
              h := false;

            end if;
            r := r + 1;
          end while;
        end if;

        Qc2 := cat(
              2,
              Ah1[:, 2:nx],
              matrix(bh1));
        sigma := Modelica.Math.Matrices.singularValues(Qc2);
        eps2 := if eps > 0 then eps else 1000*sigma[1]*Modelica.Constants.eps;
        rankQc2 := 0;

        for i in 1:nx loop
          Modelica.Utilities.Streams.print(" s[" + String(i) + "] = " + String(
            sigma[i]));
          if sigma[i] > eps2 then
            rankQc2 := rankQc2 + 1;
          end if;
        end for;

        Modelica.Utilities.Streams.print("rankQc = " + String(rankQc) +
          "     rankQc2 = " + String(rankQc2) + "     eps2 = " + String(eps2));

        sst := StateSpace(
              A=Ah1,
              B=matrix(bh1),
              C=transpose(matrix(ch1)),
              D=ss.D);

        Ah2 := Ah1[nx - rankQc2 + 1:nx, nx - rankQc2 + 1:nx];
        bh2 := bh1[nx - rankQc2 + 1:nx];
        ch2 := ch1[nx - rankQc2 + 1:nx];
        ssm1 := StateSpace(
              A=Ah2,
              B=matrix(bh2),
              C=transpose(matrix(ch2)),
              D=ss.D);

      end reducedCtrSystem2;

      encapsulated function readSystemDimension
        "Read the order nx of state matrix and the numbers nu and ny of inputs and outputs"
        import Modelica_LinearSystems2;
        input String fileName="stateSpace.mat"
          "File containing the matrix matrixName, e.g. A.mat, dsin.txt"
          annotation (Dialog(loadSelector(filter=
                  "MAT files (*.mat);; All files (*.*)", caption=
                  "State space system data file")));
        input String matrixName="ABCD"
          "Name of the generalized state space system matrix";
        output Integer xuy[3];

    protected
        Real sizeA[1, 1]=readMatrix(
                fileName,
                "nx",
                1,
                1);

        Integer ABCDsizes[2]=readMatrixSize(fileName, matrixName);

      algorithm
        xuy[1] := integer(sizeA[1, 1]);
        xuy[2] := ABCDsizes[2] - xuy[1];
        xuy[3] := ABCDsizes[1] - xuy[1];

      end readSystemDimension;

      encapsulated function scaleFactor1
        "Return scale factor for first order block"
        import Modelica;
        input Real n "(s+n)/(s+d)";
        input Real d "(s+n)/(s+d)";
        input Real small=100*Modelica.Constants.eps;
        output Real k "= d/n, if d,n are not zero, otherwise special cases";
      algorithm
        //  k := (if abs(d) > small then abs(d) else 1)/(if abs(n) > small then abs(n) else 1);
        k := if abs(d) > small and abs(n) > small then abs(d)/abs(n) else 1;

        //  k := if abs(n)<=small then 1 else  (if abs(d) > small then abs(d) else 1)/abs(n);

      end scaleFactor1;

      function scaleFactor2 "Return scale factor for second order block"
        import Modelica;
        input Real n1 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real n2 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real d1 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real d2 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real small=100*Modelica.Constants.eps;
        output Real k "= d2/n2, if d2,n2 are not zero, otherwise special cases";
      algorithm
        //  k := (if abs(d2) > small then abs(d2) else (if abs(d1) > small then abs(
        //    d1) else 1))/(if abs(n2) > small then abs(n2) else (if abs(n1) > small then
        //          abs(n1) else 1));

        //  if abs(d2) > small and abs(n2) > small then
        //    k := d2/n2;
        //  elseif abs(d2) < small and abs(n2) < small and abs(d1) > small and abs(n1) > small then
        //    k := d1/n1;
        //  else
        //    k := 1;
        //  end if;

        k := if abs(d2) > small and abs(n2) > small then d2/n2 else 1;

      end scaleFactor2;

      encapsulated function staircaseQR
        "Staircase algorithm to put a state space system to controller Hessenberg form"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;

        input StateSpace ss "State space system";

        output Boolean isControllable;
        output Modelica_LinearSystems2.Internal.StateSpaceR ssm1(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "controllable state space system";
        output Real PP[:, :];
    protected
        Real A[:, :];
        Real B[size(ss.B, 1), size(ss.B, 2)];
        Real C[:, :];
        Real Q[:, :];
        Real Q2[:, :];
        Real R[:, :];

        Real P[:, :];
        Real tau[:];

        Integer nx=size(ss.A, 1);
        Integer nu=size(ss.B, 2);
        Integer n1;
        Boolean stop;
        Real normA=Modelica.Math.Matrices.norm(A=ss.A, p=1);
        Real eps=normA*1e-10;
        Integer stairStepinSys;
        Integer info;
        Integer nn;
        Integer stairStep;
        Integer rankR;

      algorithm
        if nu > 0 then
          if nx > 1 then

            //#####  first step of staircase
            // transform b->Q'b = {*,0,...,0} and c->cQ, A->Q'AQ

            (Q,R,tau,Q2) := Matrices.QR(ss.B);
            B := [R; zeros(nx - nu, nu)];
            // should be the same as transopse(Q2)*ss.B

            A := transpose(Q2)*ss.A;
            A := A*Q2;
            C := ss.C*Q2;
            PP := transpose(Q2);

            stairStep := 0;
            rankR := 0;
            // for i in 1:size(R, 1) loop
            //   if abs(R[i, i]) > eps then
            //     rankR := rankR + 1;
            //   end if;
            // end for;

            //  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used
            for i in 1:min(size(R, 1), size(R, 2)) loop
              if abs(R[i, size(R, 2) - min(size(R, 1), size(R, 2)) + i]) > eps then
                rankR := rankR + 1;
              end if;
            end for;
            stairStep := stairStep + rankR;
            n1 := nx - stairStep;
            stop := false;

            // #######  buildig rest of staircase
            while not stop loop

              (Q,R,tau,Q2) := Matrices.QR(A[stairStep + 1:nx, stairStep - rankR
                 + 1:stairStep]);
              P := [identity(nx - n1), zeros(nx - n1, n1); zeros(n1, nx - n1), Q2];
              PP := transpose(P)*PP;
              A := [A[1:stairStep, 1:stairStep], A[1:stairStep, stairStep + 1:nx]
                *Q2; transpose(Q2)*A[stairStep + 1:nx, 1:stairStep], transpose(Q2)
                *A[stairStep + 1:nx, stairStep + 1:nx]*Q2];
              //=transpose(P)*A*P = [A11, A12*Q2; transpose(Q2)*A21, transpose(Q2)*A22*Q2]
              C[:, nx - n1 + 1:nx] := C[:, nx - n1 + 1:nx]*Q2;

              rankR := 0;
              // for i in 1:size(R, 1) loop
              //   if abs(R[i, i]) > eps then
              //     rankR := rankR + 1;
              //   end if;
              // end for;

              //  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used
              for i in 1:min(size(R, 1), size(R, 2)) loop
                if abs(R[i, size(R, 2) - min(size(R, 1), size(R, 2)) + i]) > eps then
                  rankR := rankR + 1;
                end if;
              end for;
              stairStep := stairStep + rankR;
              n1 := if rankR < 1 then -1 else n1 - rankR;
              stop := n1 <= 0;

            end while;
          else
            stairStep := if Modelica.Math.Matrices.isEqual(ss.B, zeros(size(ss.B,
              1), size(ss.B, 2))) then 0 else 1;
            A := ss.A;
            B := ss.B;
            C := ss.C;
          end if;

          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=A,
                B=B,
                C=C,
                D=ss.D,
                r=stairStep);

          isControllable := stairStep == nx;
        else
          // no inputs, nu==0
          isControllable := false;
          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=ss.A,
                B=ss.B,
                C=ss.C,
                D=ss.D,
                r=0);
          P := identity(nu);
        end if;

        annotation (Documentation(info="<html>
This algorithm usues QR factorization to generate staircase form i.e. block upper Hessenberg form of the pair (A,B). Due to the well known problem to determine
numerically reliable the rank of a matrix, this algorithm should only be used to well conditioned systems. The best way for rank decision would be singular value decomposition, that is used in staicasSVD.
</html>"));
      end staircaseQR;

      encapsulated function staircaseSVD
        "Staircase algorithm based on singular value decomposition"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";

        output Boolean isControllable;
        output Modelica_LinearSystems2.Internal.StateSpaceR ssm1(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1), size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "Upper block Hessenberg form state space system";
        output Real P[:, :];

    protected
        Real A[size(ss.A, 1), size(ss.A, 2)];
        Real B[size(ss.B, 1), size(ss.B, 2)];
        Real C[size(ss.C, 1), size(ss.C, 2)];
        Real U[:, :];
        Real VT[:, :];

        Real Q[:, :];
        Real Pi[:, :];
        Real tau[:];
        Real sigma[:];

        Integer nx=size(ss.A, 1);
        Integer nu=size(ss.B, 2);
        Integer ni;
        Boolean stop;
        Real normA=Modelica.Math.Matrices.norm(A=ss.A, p=1);
        Real eps=normA*1e-10;
        Integer stairStepinSys;
        Integer info;
        Integer nn;
        Integer stairStep;
        Integer rankS;
        Integer maxA=max(size(ss.A));
        //   Real evc[:,2];
        //   Real evnc[:,2];

      algorithm
        if nu > 0 then
          if nx > 1 then
            //#####  first step of staircase
            // transform b->Q'b = {*,0,...,0} and c->cQ, A->Q'AQ
            (sigma,U,VT) := Modelica.Math.Matrices.singularValues(ss.B);

            rankS := 0;
            for i in 1:size(sigma, 1) loop
              if sigma[i] > maxA*sigma[1]*Modelica.Constants.eps then
                rankS := rankS + 1;
              end if;
            end for;

            B := [diagonal(sigma[1:rankS]), zeros(rankS, nu - rankS); zeros(nx -
              rankS, nu)];
            P := transpose(U);
            Q := transpose(VT);
            A := transpose(U)*ss.A*U;
            //    C := ss.C*U;
            (sigma,U,VT) := Modelica.Math.Matrices.singularValues(A[rankS + 1:nx,
              1:rankS]);

            stairStep := rankS;
            rankS := 0;
            if size(sigma, 1) > 1 then
              for i in 1:size(sigma, 1) loop
                if sigma[i] > maxA*sigma[1]*Modelica.Constants.eps then
                  rankS := rankS + 1;
                end if;
              end for;
            else
              rankS := if size(sigma, 1) > 0 then if sigma[1] > maxA*Modelica.Constants.eps
                 then 1 else 0 else 0;
            end if;

            stairStep := stairStep + rankS;
            Pi := [VT, zeros(size(VT, 1), size(U, 1)); zeros(size(U, 2), size(VT,
              2)), transpose(U)];
            B := Pi*B;
            P := Pi*P;

            // P could be ambigious according to the sign
            if transpose(P)*B[:, 1]*ss.B[:, 1] < 0 then
              Pi := -Pi;
              P := -P;
            end if;

            A := Pi*A*transpose(Pi);

            // should be made better because of many zeros in B

            while stairStep < nx and rankS > 0 and not
                Modelica.Math.Matrices.isEqual(
                    A[stairStep + 1:nx, stairStep - rankS + 1:stairStep],
                    zeros(stairStep - rankS, rankS),
                    eps) loop

              (sigma,U,VT) := Modelica.Math.Matrices.singularValues(A[stairStep
                 + 1:nx, stairStep - rankS + 1:stairStep]);

              Pi := [identity(stairStep - rankS), zeros(stairStep - rankS, nx -
                stairStep + rankS); zeros(nx - stairStep + rankS, stairStep -
                rankS), [VT, zeros(rankS, nx - stairStep); zeros(nx - stairStep,
                rankS), transpose(U)]];
              P := Pi*P;
              A := Pi*A*transpose(Pi);

              //new implenmentation advisable because of many zeros in Pi
              //    C := C*transpose(Pi);
              rankS := 0;
              if size(sigma, 1) > 1 then
                for i in 1:size(sigma, 1) loop
                  if sigma[i] > maxA*sigma[1]*Modelica.Constants.eps then
                    rankS := rankS + 1;
                  end if;
                end for;
              else
                rankS := if size(sigma, 1) > 0 then if sigma[1] > maxA*Modelica.Constants.eps
                   then 1 else 0 else 0;
              end if;
              stairStep := stairStep + rankS;
            end while;

            B := P*ss.B;
            C := ss.C*transpose(P);

          else
            stairStep := if Modelica.Math.Matrices.isEqual(ss.B, zeros(size(ss.B,
              1), size(ss.B, 2))) then 0 else 1;
            A := ss.A;
            B := ss.B;
            C := ss.C;
          end if;

          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=A,
                B=B,
                C=C,
                D=ss.D,
                r=stairStep);
          isControllable := stairStep == nx;

        else
          // no inputs, nu==0
          isControllable := false;
          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=ss.A,
                B=ss.B,
                C=ss.C,
                D=ss.D,
                r=0);
          P := identity(nu);
        end if;

      end staircaseSVD;

      encapsulated function trianUpperHess
        "Triangulize an upper Hessenberg matrix by repeatedly applicated householder reflexion"
        import Modelica;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;

        input Real H[:, :] "Upper Hessenberg matrix";
        input Real b[size(H, 1)];

        output Real Ht[size(H, 1), size(H, 2)];
        output Real bt[size(b, 1)];

    protected
        Integer q=size(H, 1);
        Real u[:] "Householder vector";
        Integer ll;

      algorithm
        Ht := H;
        bt := b;

        for ll in 1:q - 1 loop
          u := cat(
                1,
                zeros(ll - 1),
                cat(
                  1,
                  Vectors.householderVector(vector(Ht[ll:ll + 1, ll]), {1,0}),
                  zeros(q - ll - 1)));
          Ht := Matrices.householderReflexion(Ht, u);
          bt := Vectors.householderReflexion(bt, u);
        end for;

        annotation (Documentation(info="<html>
<p>
This function computes an triangular matrix from an upper Hessenberg matrix by stepwise annihilation of the subdiagonal elements.
</p>
<blockquote><pre>
<b>A</b> -> <b>QA</b> = <b>T</b>
</pre></blockquote>
<p>
It is assumend that the original matrix has upper hessenberg form.
Additionally the vector b is transformed in the same way
</p>
<blockquote><pre>
<b>b</b> -> <b>Qb</b> = <b>q</b>
</pre></blockquote>
<p>
The function is primarily used to calculate the transfer function gain from a SISO state space system in observer Hessenberg form
</p>
<blockquote><pre>
    ( *   *   ...   ...    * )          ( * )
    ( *   *   ...   ...    * )          ( . )
<b>A</b> = ( 0   *   ...   ...    * ),    <b>b</b> =  ( . ),   <b>c</b> = ( 0, ..., 0, * )
    ( .   .    .     .     . )          ( * )
    ( 0  ...   0     *     * )          ( * )
</pre></blockquote>
<p>
If <b>A</b> is upper Hessenberg and <b>T</b> = <b>Q</b>*<b>A</b> is triangular then obviously <b>H</b>(s) = <b>Q</b>*(s*<b>I</b> -<b>A</b>) = s*<b>I</b> - <b>T</b>.
</p>
<p>
Further on, if <b>T</b> is triangular then also <b>H</b> = s<b>I</b> - <b>T</b> is and the element l_nn of <b>L</b> = inv(<b>H</b>) is given by 1/h_nn.
The frequency response G(s0)for a given s0 that is neither zero nor pole of the system can be calculated by
</p>
<blockquote><pre>
G(s0)  = <b>c</b>*(s0*<b>I</b> -<b>A</b>)<sup>-1</sup>*<b>b</b> = <b>c</b>*(s0*<b>I</b> -<b>A</b>)<sup>-1</sup> *<b>Q</b>*<b>Q</b><sup>-1</sup>*<b>b</b> = <b>c</b>*(<b>Q</b><sup>-1</sup>*(s0*<b>I</b> -<b>A</b>))<sup>-1</sup>*<b>Q</b><sup>-1</sup>*<b>b</b> = <b>c</b>*<b>H</b><sup>-1</sup>(s0)*<b>q</b>
</pre></blockquote>
<p>
and because only the n'th element of <b>c</b> is different to zero the gain k is given by
</p>
<blockquote><pre>
    q_nn*c_nn     product(s0 - poles_i)
k = ---------- * ----------------------
       h_nn       product(s0 - zeros_i)
</pre></blockquote>
</html>"));
      end trianUpperHess;

      encapsulated function transposeStateSpace
        "Return the transposed state space system"

        import Modelica_LinearSystems2.StateSpace;

        input StateSpace ss "State space system";

        output StateSpace sst=StateSpace(
                A=transpose(ss.A),
                B=transpose(ss.C),
                C=transpose(ss.B),
                D=transpose(ss.D),
                uNames=ss.yNames,
                yNames=ss.uNames);
      algorithm

        annotation (Documentation(info="<html>
</html>"));
      end transposeStateSpace;

      encapsulated function reduceRosenbrock
        "Algorithm to compress the generalized system matrix [A, B; C, D] to calculate the invariant zeros of a system"

        import Modelica;
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;

        import Modelica.Utilities.Streams.print;

        input Real A[:, :];
        input Real B[:, :];
        input Real C[:, :];
        input Real D[:, :];

        output Real Ar[:, :];
        output Real Br[:, :];
        output Real Cr[:, :];
        output Real Dr[:, :];
        output Integer n "= dimension of Ar: Ar[n,n]";
        output Integer m "= second dimension of Br: Br{n,m]";
        output Integer p "= first dimension of Cr: Cr[p,n]";

    protected
        Real A2[:, :];
        Real B2[:, :];
        Real C2[:, :];
        Real CC[:, :];
        Real Co[:, :];
        Real Cu[:, :];
        Real D2[:, :];
        Real DD[:, :];
        Real Mr[:, :];
        Real Vf[:, :];
        Real V[:, :];
        Real V2[:, :];
        Real R[:, :];
        Real tau[:];

        Integer nx=size(A, 1);
        Integer nu=size(B, 2);
        Integer ny=size(C, 1);

        Integer nue;
        Integer delta;
        Integer rho;
        Integer mue;
        Integer sigma;
        Integer j;
        Boolean stop;
        Boolean stop1 "reduction finished";
        Boolean stop2 "system has no zeros";
        Integer rankR;
        // Real normA=MatricesMSL.norm(A=A, p=1);
        // Real eps=normA*1e-12;
        Real normABCD=MatricesMSL.norm([A, B; C, D], p=1);
        Real eps=normABCD*Modelica.Constants.eps*1000;
      algorithm
        if nx > 0 then

          A2 := A;
          B2 := B;
          C2 := C;
          D2 := D;
          stop := false;
          stop1 := false;
          stop2 := false;
          nue := nx;
          delta := 0;
          mue := ny;
          sigma := ny;
          j := 1;

          while not stop loop
            (V,R,tau,V2) := Matrices.QR(D2);

            rankR := 0;
            //  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used
            for i in 1:min(size(R, 1), size(R, 2)) loop
              if abs(R[i, size(R, 2) - min(size(R, 1), size(R, 2)) + i]) > eps then
                rankR := rankR + 1;
              end if;
            end for;

            //rankR:=MatricesMSL.rank(R);

            DD := R[1:rankR, :];

            CC := transpose(V2)*C2;

            sigma := rankR;
            stop1 := size(CC, 1) == rankR;

            if not stop1 then
              Cu := CC[sigma + 1:end, :];
              Co := CC[1:sigma, :];

              (V,R,tau,V2) := Matrices.QR(MatricesMSL.flipLeftRight(transpose(Cu)));
              Vf := MatricesMSL.flipLeftRight(V2);

              rankR := 0;
              //  !!!! rank determination
              for i in 1:min(size(R, 1), size(R, 2)) loop
                if abs(R[i, size(R, 2) - min(size(R, 1), size(R, 2)) + i]) > eps then
                  rankR := rankR + 1;
                end if;
              end for;
              //rankR:=MatricesMSL.rank(R);

              rho := rankR;
              stop1 := rho == 0;
              stop2 := size(Cu, 2) == rankR;

              if not stop1 and not stop2 then
                nue := size(Cu, 2) - rankR;
                mue := rho + sigma;
                delta := delta + rho;

                if sigma == 0 then
                  Mr := [transpose(Vf)*A2*Vf, transpose(Vf)*B2];
                else
                  Mr := [transpose(Vf)*A2*Vf, transpose(Vf)*B2; Co*Vf, DD];
                end if;

                A2 := Mr[1:nue, 1:nue];
                B2 := Mr[1:nue, nue + rho + 1:nue + rho + nu];
                C2 := Mr[nue + 1:nue + mue, 1:nue];
                D2 := Mr[nue + 1:nue + mue, nue + rho + 1:nue + rho + nu];

                j := j + 1;
              end if;
              //not stop1 or not stop2

            end if;
            //if not stop1

            stop := stop1 or stop2 or j > 3*nx;

          end while;

          if stop1 then
            Ar := A2;
            Br := B2;
            Cr := C2;
            Dr := D2;
            n := nue;
            p := sigma;
            m := nu;
          else
            n := 0;
            p := 0;
            m := 0;
            Ar := fill(
                  0,
                  0,
                  0);
            Br := fill(
                  0,
                  0,
                  0);
            Cr := fill(
                  0,
                  0,
                  0);
            Dr := fill(
                  0,
                  0,
                  0);
          end if;

        else
          n := 0;
          p := 0;
          m := 0;
          A2 := A;
          B2 := B;
          C2 := C;
          D2 := D;
        end if;

        annotation (Documentation(info="<html>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Emami-Naeini, A. and Van Dooren, P. (1982):</dt>
<dd> <b>Computation of Zeros of Linear Multivariable Systems</b>.
     Automatica, 18, pp. 415-430.<br>&nbsp;</dd>
</dl>
</html>


"));
      end reduceRosenbrock;

      encapsulated function reducedCtrSystem
        "Calculate the controllable part of a SISO system"
        import Modelica.Utilities.Streams.print;
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";
        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        output Modelica_LinearSystems2.Internal.StateSpaceR ssm1(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), 1],
          redeclare Real C[1, size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "controllable state space system";

    protected
        Integer nx=size(ss.A, 1);
        Real Ah1[nx, size(ss.A, 2)];
        Real bh1[nx];
        Real ch1[nx];
        Real u[:] "householder vector";
        Integer ll;
        Integer r=1;
        Real maxa;
        Real normA=Modelica.Math.Matrices.norm(A=ss.A, p=1);

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        Ah1 := ss.A;
        bh1 := ss.B[:, 1];
        ch1 := ss.C[1, :];

        if Modelica.Math.Vectors.length(bh1) > 0 then
          r := 1;
          if nx > 1 then

            u := Vectors.householderVector(bh1, cat(
                  1,
                  fill(0, nx - 1),
                  {1}));

            Ah1 := Matrices.householderSimilarityTransformation(Ah1, u);
            bh1 := Vectors.householderReflexion_en(bh1, u);
            ch1 := Vectors.householderReflexion(ch1, u);
            bh1[1:nx - 1] := fill(0, nx - 1);
            ll := nx;
            maxa := max(abs(Ah1[1:ll - 1, ll]));

            while r <= nx - 1 and maxa > normA*tol loop
              u := cat(
                    1,
                    Vectors.householderVector(Ah1[1:ll - 1, ll], cat(
                      1,
                      fill(0, ll - 2),
                      {1})),
                    fill(0, nx - ll + 1));

              Ah1 := Matrices.Internal.hohoTrafoLowerHess(
                    Ah1,
                    u,
                    r);

              ch1 := Vectors.householderReflexion(ch1, u);
              ll := ll - 1;
              maxa := max(abs(Ah1[1:ll - 1, ll]));

              r := r + 1;
            end while;
          end if;
          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=Ah1,
                B=matrix(bh1),
                C=transpose(matrix(ch1)),
                D=ss.D,
                r=r);
          ssm1.r := r;
        end if;
      end reducedCtrSystem;

      encapsulated function reducedCtrSystemX
        "Calculate the controllable part of a SISO system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;

        input StateSpace ss "State space system";

        output Modelica_LinearSystems2.Internal.StateSpaceR ssm1(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), 1],
          redeclare Real C[1, size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1), size(ss.D, 2)])
          "Controllable state space system";

    protected
        Integer nx=size(ss.A, 1);
        Real Ah1[nx, size(ss.A, 2)];
        Real bh1[nx];
        Real ch1[nx];
        Real u[:] "householder vector";
        Integer ll;
        Integer r=1;
        Real maxa;
        Real normA=Modelica.Math.Matrices.norm(A=ss.A, p=1);

      algorithm
        if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
          assert(size(ss.B, 2) == 1,
            "A SISO-system is expected as input\n but the number of inputs is "
             + String(size(ss.B, 2)) + " instead of 1");
          assert(size(ss.C, 1) == 1,
            " A SISO-system is expected as input\n but the number of outputs is "
             + String(size(ss.C, 1)) + " instead of 1");
        end if;

        Ah1 := ss.A;
        bh1 := ss.B[:, 1];
        ch1 := ss.C[1, :];

        if Modelica.Math.Vectors.length(bh1) > 0 then
          r := 1;
          if nx > 1 then

            u := Vectors.householderVector(bh1, cat(
                  1,
                  fill(0, nx - 1),
                  {1}));

            Ah1 := Matrices.householderSimilarityTransformation(Ah1, u);
            bh1 := Vectors.householderReflexion_en(bh1, u);
            ch1 := Vectors.householderReflexion(ch1, u);
            bh1[1:nx - 1] := fill(0, nx - 1);

            ll := nx;
            maxa := max(abs(Ah1[1:ll - 1, ll]));

            while r <= nx - 1 and maxa > nx*normA*1e-5 loop
              u := cat(
                    1,
                    Vectors.householderVector(Ah1[1:ll - 1, ll], cat(
                      1,
                      fill(0, ll - 2),
                      {1})),
                    fill(0, nx - ll + 1));

              Ah1 := Matrices.Internal.hohoTrafoLowerHess(
                    Ah1,
                    u,
                    r);

              ch1 := Vectors.householderReflexion(ch1, u);
              ll := ll - 1;
              maxa := max(abs(Ah1[1:ll - 1, ll]));

              r := r + 1;
            end while;

          end if;

          ssm1 := Modelica_LinearSystems2.Internal.StateSpaceR(
                A=Ah1,
                B=matrix(bh1),
                C=transpose(matrix(ch1)),
                D=ss.D,
                r=r);
          ssm1.r := r;
        end if;
      end reducedCtrSystemX;

      function read_dslin "Read a StateSpace data record from mat-file"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;

        input String fileName="dslin" "Name of the result file";

    protected
        String fileName2=fileName + ".mat"
          "Name of the result file with extension";
        Real nxMat[1, 1]=readMatrix(
                fileName2,
                "nx",
                1,
                1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny, nx + nu]=readMatrix(
                fileName2,
                "ABCD",
                nx + ny,
                nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(
                fileName2,
                "xuyName",
                nx + nu + ny);
    public
        output StateSpace result(
          redeclare Real A[nx, nx],
          redeclare Real B[nx, nu],
          redeclare Real C[ny, nx],
          redeclare Real D[ny, nu]) "Outputs model linearized at initial point";

      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        result.uNames := xuyName[nx + 1:nx + nu];
        result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        result.xNames := xuyName[1:nx];

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = StateSpace.Import.<b>fromModel</b>(modelName, T_linearize, fileName)
</pre></blockquote>

<h4>Description</h4>
<p>Generate a StateSpace data record by linearization of a model defined by modelName. The linearization is performed at time T_linearize of the simulation. The result of linearization is transformed into a StateSpace record.
</p>

<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;

<b>algorithm</b>
  ss = Modelica_LinearSystems2.StateSpace.Import.fromModel(modelName, T_linearize);

// ss.A = [ 0.0,   1.0,    0.0,            0.0,      0.0,     0.0;
            0.0,   0.0,          -2.26,    0.08,     1.95,   -0.45;
            0.0,   0.0,           0.0,            1.0,      0.0,     0.0;
            0.0,   0.0,          -3.09,   -1.38,     7.70,   -3.01;
            0.0,   0.0,           0.0,            0.0,      0.0,     1.0;
            0.0,   0.0,          -6.47,    1.637,   -2.90,    1.29],

// ss.B=[0.0; 0.13; 0.0; -0.014; 0.0; -0.1],
// ss.C=identity(6),
// ss.D=[0; 0; 0; 0; 0; 0]
</pre></blockquote>
</html>"));
      end read_dslin;

      encapsulated function absComplexVector
        "Return the absolute values of all elements of a complex vector that is defined by a vr[:] vector (real part) and a vi[:] vector (imaginary part)"
        import Modelica;
        input Real vr[:] "Real part of complex vector";
        input Real vi[size(vr,1)] "Imaginary part of complex vector";
        output Real v_abs[size(vr,1)]
          "Absolute values of the elements of the complex vector";
    protected
        Real r_abs;
        Real i_abs;
      algorithm
         for i in 1:size(vr,1) loop
            r_abs :=abs(vr[i]);
            i_abs :=abs(vi[i]);
            v_abs[i] :=if r_abs == 0 and i_abs == 0 then 0 else if r_abs > i_abs
             then r_abs*sqrt(1 + (i_abs/r_abs)^2) else i_abs*sqrt(1 + (r_abs/i_abs)^2);
         end for;
      end absComplexVector;

      encapsulated function polesAndZeros_Old
        "Plot poles (i.e. eigenvalues) and/or invariant zeros of a state space system (previous version of polesAndZeros that is kept, just in case)"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "Linear system in state space form"
          annotation (Dialog);
        input Boolean poles=true
          "= true, to plot the poles (i.e. the eigenvalues) of ss"
          annotation (choices(checkBox=true));
        input Boolean zeros=true "= true, to plot the (invariant) zeros of ss "
          annotation (choices(checkBox=true));

        input Boolean print=false
          "= true, to print the selection to the output window"
          annotation (choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=if poles and zeros then
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros()
               else if poles then
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
              heading="Poles (x)") else
              Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
              heading="Invariant zeros (o)"));
    protected
        Integer nx=size(ss.A, 1);
        Real eval[nx, 2];
        Real invZerosRe[:];
        Real invZerosIm[:];
        Complex invZeros[:];
        Complex eig[size(ss.A,1)];
        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2;
      algorithm
        // Determine eigen values
        if poles then
          eval := Modelica.Math.Matrices.eigenValues(ss.A);
          //eval :=Modelica_LinearSystems2.Math.Matrices.eigenValuesAsRealMatrix(ss.A);
        end if;

        if zeros then
          invZeros := StateSpace.Analysis.invariantZeros(ss);
          invZerosRe := fill(0, size(invZeros, 1));
          invZerosIm := fill(0, size(invZeros, 1));
          for i in 1:size(invZeros, 1) loop
            invZerosRe[i] := invZeros[i].re;
            invZerosIm[i] := invZeros[i].im;
          end for;
        end if;

        i := 0;
        if poles then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=eval[:, 1],
                y=eval[:, 2],
                legend="poles",
                autoLine=false,
                linePattern=Plot.Types.LinePattern.None,
                lineSymbol=Plot.Types.PointSymbol.Cross);
        end if;

        if zeros then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=invZerosRe,
                y=invZerosIm,
                legend="zeros",
                autoLine=false,
                linePattern=Plot.Types.LinePattern.None,
                lineSymbol=Plot.Types.PointSymbol.Circle);
        end if;

        diagram2 := defaultDiagram;
        diagram2.curve := curves[1:i];
        Plot.diagram(diagram2, device);

        if print then
           if poles then
              for i in 1:nx loop
                eig[i].re := eval[i,1];
                eig[i].im := eval[i,2];
              end for;
              Modelica_LinearSystems2.Math.Complex.Vectors.printHTML(eig,heading="Eigenvalues", name="eigenvalue");
           end if;

           if zeros then
              Modelica_LinearSystems2.Math.Complex.Vectors.printHTML(invZeros,heading="Invariant zeros", name="invariant zero");
           end if;
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>polesAndZeros</b>(ss);
   or
StateSpace.Plot.<b>polesAndZeros</b>(
  ss,
  poles=true,
  zeros=true,
  plot=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>());
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots a pole-zero-map of the poles and transmission zeros of a state space system.
The poles are the eigenvalues of the system matrix (eigenvalues(ss.A)). The Boolean inputs
\"poles\" and \"zeros\" define what to plot. If Boolean input \"plot = true\", the pole-zero-map
is plotted. If false, only the diagram is generated and returned as output argument.
The records \"defaultDiagram\" and \"device\" allow to set various layout options and the
size and location of the diagram on the screen.
</p>

<h4>Example</h4>
<p>
The example <a href=\"modelica://Modelica_LinearSystems2.Examples.StateSpace.plotPolesAndZeros\">
Modelica_LinearSystems2.Examples.StateSpace.plotPolesAndZeros</a>
is defined as
</p>
<pre>
  Plot.polesAndZeros(ss = Modelica_LinearSystems2.StateSpace(
    A=[-3, 2,-3,  4, 5,6;
        0, 6, 7,  8, 9,4;
        0, 2, 3,  0,78,6;
        0, 1, 2,  2, 3,3;
        0,13,34,  0, 0,1;
        0, 0, 0,-17, 0,0],
    B=[1,0;
       0,1;
       1,0;
       0,1;
       1,0;
       0,1],
    C=[0,0,1,0,1,0;
       0,1,0,0,1,1],
    D=[0,0;
       0,0]));
</pre>

<p>
and results in
</p>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/StateSpace/polesAndZerosSS.png\"/>
</blockquote>
</html>"));
      end polesAndZeros_Old;

      encapsulated function bodeSISO_Old
        "Plot bode plot of the corresponding transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica.Utilities.Streams.print;

        input StateSpace ss "State space system";
        input Integer iu=1 "Index of input";
        input Integer iy=1 "Index of output";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input Modelica.Units.SI.Frequency f_min=0.1
          "Minimum frequency value, if autoRange = false";
        input Modelica.Units.SI.Frequency f_max=10
          "Maximum frequency value, if autoRange = false";

        input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot());

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));
        input Boolean onFile=false
          "= true, if frequency response is stored on file as matrix [f,A,phi]" annotation(choices(checkBox=true));
        input String fileName="frequencyResponse.mat"
          "If onFile=true, file on which the frequency response will be stored" annotation(Dialog(enable=onFile));
        input String matrixName=if Hz and not dB then "fHz_A_phiDeg" elseif
                                   Hz and dB then "fHz_AdB_phiDeg" elseif
                                   not Hz and dB then "f_AdB_phiDeg" else "f_A_phiDeg"
          "If onFile=true, Name of matrix on file" annotation(Dialog(enable=onFile));

    protected
        ZerosAndPoles zp "ZP-Transfer functions to be plotted";
        StateSpace ss_siso(
          redeclare Real A[size(ss.A, 1), size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1), 1],
          redeclare Real C[1, size(ss.C, 2)],
          redeclare Real D[1, 1]);

      algorithm
        // Check that system has inputs and outputs
        if size(ss.B, 2) == 0 then
          Modelica.Utilities.Streams.print(
            "\n... Not possible to plot transfer function because system has no inputs."
             + "\n... Call of Plot.bodeSISO is ignored.\n");
          return;
        elseif size(ss.C, 1) == 0 then
          Modelica.Utilities.Streams.print(
            "\n... Not possible to plot transfer function because system has no outputs."
             + "\n... Call of Plot.bodeSISO is ignored.\n");
          return;
        end if;

        assert(iu <= size(ss.B, 2) and iu > 0, "index for input is " + String(iu)
           + " which is not in [1, " + String(size(ss.B, 2)) + "].");
        assert(iy <= size(ss.C, 1) and iy > 0, "index for output is " + String(iy)
           + " which is not in [1, " + String(size(ss.C, 1)) + "].");
        ss_siso := StateSpace(
              A=ss.A,
              B=matrix(ss.B[:, iu]),
              C=transpose(matrix(ss.C[iy, :])),
              D=matrix(ss.D[iy, iu]));

        zp := StateSpace.Conversion.toZerosAndPoles(
                 StateSpace.Transformation.toBalancedForm(ss_siso), tol);

        ZerosAndPoles.Plot.bode(
              zp,
              nPoints,
              autoRange,
              f_min,
              f_max,
              Hz=Hz,
              magnitude=magnitude,
              dB=dB,
              phase=phase,
              onFile=onFile,
              fileName=fileName,
              matrixName=matrixName,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>bodeSISO</b>(ss)
   or
StateSpace.Plot.<b>bodeSISO</b>(
  ss,
  iu,
  iy,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a transfer function corresponding
to the behavior of the state space system from iu'th element of the input
vector <b>u</b> to the iy'th element of the output vector <b>y</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,0.0; 0.0,0.0,-3.0],
    B=[0.0,1.0; 1.0,1.0; -1.0,0.0],
    C=[0.0,1.0,1.0; 1.0,1.0,1.0],
    D=[1.0,0.0; 0.0,1.0])

  Integer iu=1;
  Integer iy=1;

<b>algorithm</b>
   Modelica_LinearSystems2.StateSpace.Plot.plotBodeSISO(ss, iu, iy)
//  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</p>
</html>"));
      end bodeSISO_Old;

      encapsulated function bodeMIMO_old
        "Plot bode plot of all transfer functions, corresponding to the state space system"
        import Modelica.Utilities.Streams.print;
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Plot;

        input StateSpace ss "State space system";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange[:, :]=fill(
            true,
            size(ss.C, 1),
            size(ss.B, 2)) "True, if abszissa range is automatically determined";
        input Modelica.Units.SI.Frequency f_min[:,:]=fill(
                0.1,
                size(ss.C, 1),
                size(ss.B, 2)) "Minimum frequency value, if autoRange = false";
        input Modelica.Units.SI.Frequency f_max[:,:]=fill(
                10,
                size(ss.C, 1),
                size(ss.B, 2)) "Maximum frequency value, if autoRange = false";

        input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

        input Real tol=1e-10
          "Tolerance of reduction procedure, default tol = 1e-10";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot());

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));
    protected
        ZerosAndPoles zp[size(ss.C, 1), size(ss.B, 2)]
          "ZerosAndPoles object to be plotted";
        Plot.Records.Diagram diagram2=defaultDiagram;
        String yNames[size(ss.C, 1)];
        String uNames[size(ss.B, 2)];

      algorithm
        // Check that system has inputs and outputs
        if size(ss.B, 2) == 0 then
          Modelica.Utilities.Streams.print("\n... Not possible to plot transfer function because system has no inputs."
             + "\n... Call of Plot.bodeMIMO is ignored.\n");
          return;
        elseif size(ss.C, 1) == 0 then
          Modelica.Utilities.Streams.print("\n... Not possible to plot transfer function because system has no outputs."
             + "\n... Call of Plot.bodeMIMO is ignored.\n");
          return;
        end if;

        // generate headings
        for i1 in 1:size(ss.B, 2) loop
          uNames[i1] := if ss.uNames[i1] == "" then "u" + String(i1) else ss.uNames[
            i1];
        end for;
        for i1 in 1:size(ss.C, 1) loop
          yNames[i1] := if ss.yNames[i1] == "" then "y" + String(i1) else ss.yNames[
            i1];
        end for;

        zp := StateSpace.Conversion.toZerosAndPolesMIMO(
              StateSpace.Transformation.toBalancedForm(ss), tol);

        for i1 in 1:size(ss.C, 1) loop
          for i2 in 1:size(ss.B, 2) loop
            diagram2.heading := defaultDiagram.heading + "  " + uNames[i2] + " -> " +
              yNames[i1];
            ZerosAndPoles.Plot.bode(
              zp[i1, i2],
              nPoints,
              autoRange[i1, i2],
              f_min[i1, i2],
              f_max[i1, i2],
              magnitude=magnitude,
              phase=phase,
              Hz=Hz,
              dB=dB,
              defaultDiagram=diagram2,
              device=device);
          end for;
        end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
StateSpace.Plot.<b>bodeMIMO</b>(ss)
   or
StateSpace.Plot.<b>bodeMIMO</b>(
  ss,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,0.0; 0.0,0.0,-3.0],
    B=[0.0,1.0; 1.0,1.0; -1.0,0.0],
    C=[0.0,1.0,1.0],
    D=[1.0,0.0])

<b>algorithm</b>
   Modelica_LinearSystems2.StateSpace.Plot.plotBodeMIMO(ss)
//  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</p>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude2.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase2.png\">
</p>
</html>"));
      end bodeMIMO_old;
    end Internal;

    annotation (defaultComponentName="stateSpace", Documentation(info="<html>
<p>
This record defines a linear time invariant differential
equation system in state space form:
</p>
<pre>
   <b>der</b>(x) = A * x + B * u
       y  = C * x + D * u
</pre>
<p>
with
</p>
<ul>
<li> u ... the input vector,</li>
<li> y ... the output vector,</li>
<li> x ... the state vector,</li>
<li> A, B, C, D - matrices of appropriate dimensions.</li>
</ul>
</html>"));
  end StateSpace;

  operator record ZerosAndPoles
    "Continuous zeros and poles description of a single input, single output system (data + operations)"
    extends Modelica.Icons.Record;

    Real k=1.0 "Multiplicative factor of transfer function"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real n1[:] "[p^0] coefficients of 1st order numerator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real n2[:,2] "[p,p^0] coefficients of 2nd order numerator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real d1[:] "[p^0] coefficients of 1st order denominator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real d2[:,2] "[p,p^0] coefficients of 2nd order denominator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    String uName="u" "Name of input signal" annotation(Dialog(group="Signal names"));
    String yName="y" "Name of output signal" annotation(Dialog(group="Signal names"));

    encapsulated operator 'constructor'
      "Collection of operators to construct a ZerosAndPoles data record"

      import Modelica;
      import Modelica_LinearSystems2;

      encapsulated function fromReal
        "Generate a ZerosAndPoles data record from a real value"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Real r "Value of real variable";
        input String uName="" "Input name";
        input String yName="" "Output name";
        output ZerosAndPoles zp(
          redeclare Real n1[0],
          redeclare Real n2[0,2],
          redeclare Real d1[0],
          redeclare Real d2[0,2]) "= r";

      algorithm
        zp.k := r;
        zp.uName := uName;
        zp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = ZerosAndPoles&apos;constructor&apos;.<b>fromReal</b>(r)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles record zp from a real value, i.e. a without dynamics:
</p>
<blockquote><pre>
y = r*u
</pre></blockquote>
<p>
Therefore, the record is defined by
</p>
<blockquote><pre>
zp.k = r;
zp.n1 = fill(0,1);
zp.n2 = fill(0,1,2);
zp.d1 = fill(0,1);
zp.d2 = fill(0,1,2);
</pre></blockquote>
</html>"));
      end fromReal;

      encapsulated function fromZerosAndPoles
        "Generate a ZerosAndPoles data record from a set of zeros and poles"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex z[:]=fill(Modelica_LinearSystems2.Math.Complex(0,0), 0)
          "Zeros (Complex vector of numerator zeros)";
        input Complex p[:]=fill(Modelica_LinearSystems2.Math.Complex(0,0), 0)
          "Poles (Complex vector of denominator zeros)";
        input Real k=1.0 "Constant multiplied with transfer function";
        input String uName="" "Input name";
        input String yName="" "Output name";
        output ZerosAndPoles zp(
          redeclare Real n1[Internal.numberOfRealZeros(z)],
          redeclare Real n2[integer((size(z, 1) - Internal.numberOfRealZeros(z))/2),
          2],
          redeclare Real d1[Internal.numberOfRealZeros(p)],
          redeclare Real d2[integer((size(p, 1) - Internal.numberOfRealZeros(p))/2),
          2]) "ZerosAndPoles transfer functions of the zeros, poles and k";

    protected
        Integer n_n1=size(zp.n1, 1);
        Integer n_d1=size(zp.d1, 1);
        Integer n_n2=size(zp.n2, 1);
        Integer n_d2=size(zp.d2, 1);
        Integer i;
        Integer j;
        Complex z_reordered[size(z, 1)] "Reordered zeros";
        Complex p_reordered[size(p, 1)] "Reordered poles";
        Integer nz_real "Number of real zeros";
        Integer np_real "Number of real poles";
      algorithm
        //Extra input (string) added
        (z_reordered,nz_real) := Internal.reorderZeros(z, "");
        (p_reordered,np_real) := Internal.reorderZeros(p, "");

        // Numerator
        for i in 1:n_n1 loop
          zp.n1[i] := -z_reordered[i].re;
        end for;

        j := 1;
        for i in n_n1 + 1:2:size(z, 1) loop
          zp.n2[j, :] := {-2*z_reordered[i].re,z_reordered[i].re^2 + z_reordered[i].im
            ^2};
          j := j + 1;
        end for;

        // Denominator
        for i in 1:n_d1 loop
          zp.d1[i] := -p_reordered[i].re;
        end for;

        j := 1;
        for i in n_d1 + 1:2:size(p, 1) loop
          zp.d2[j, :] := {-2*p_reordered[i].re,p_reordered[i].re^2 + p_reordered[i].im
            ^2};
          j := j + 1;
        end for;

        zp.k := k;
        zp.uName := uName;
        zp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = ZerosAndPoles&apos;constructor&apos;.<b>fromPolesAndZeros</b>(z, p, k)
   or
zp = ZerosAndPoles&apos;constructor&apos;.<b>fromPolesAndZeros</b>(z, p, k, uName, yName)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles transfer function from denominator
and numerator zeros, as well as a gain.
</p>
<p>
Since only transfer functions with real coefficients are supported,
complex roots must be defined as conjugate complex pairs.
It is required that complex conjugate pairs must directly
follow each other as above. An error occurs if this is not the case.
</p>

<h4>Example</h4>
<blockquote><pre>
                       (s+1)
zp = 4 * -------------------------------------
          (s - 1)*(s - (2+j*3))*(s - (2-j*3))
</pre></blockquote>
<p>
with j=sqrt(-1), is defined as
</p>
<blockquote><pre>
  <b>import</b> Modelica_LinearSystems2.Math.Complex;
  <b>import</b> Modelica_LinearSystems2.ZerosAndPoles;

  zp = ZerosAndPoles(z = {Complex(-1,0)},
                     p = {Complex(1,0),
                          Complex(2,3),
                          Complex(2,-3)},
                          k=4);
</pre></blockquote>
</html>"));
      end fromZerosAndPoles;

      function fromTransferFunction =
        Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles
        "Generate a ZerosAndPoles data record from a transfer function"
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
zp = ZerosAndPoles&apos;constructor&apos;.<b>fromTransferFunction</b>(tf)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles record zp from a transfer function tf.
For the simplicity of implementation, this function directly extends from
<a href=\"Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles\">TransferFunction.Conversion.toZerosAndPoles</a>.
</p>
</html>"));

      encapsulated function fromFactorization
        "Generate a ZerosAndPoles data record from first and second order polynomials"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Real n1[:]=fill(0, 0)
          "[p^0] coefficients of 1st order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real n2[:,2]=fill(0, 0, 2)
          "[p,p^0] coefficients of 2nd order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real d1[:]=fill(0, 0)
          "[p^0] coefficients of 1st order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real d2[:,2]=fill(0, 0, 2)
          "[p,p^0] coefficients of 2nd order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real k=1.0 "Multiplicative factor of transfer function"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input String uName="" "Input name";
        input String yName="" "Output name";
        output ZerosAndPoles zp(
          redeclare Real n1[size(n1, 1)],
          redeclare Real n2[size(n2, 1),2],
          redeclare Real d1[size(d1, 1)],
          redeclare Real d2[size(d2, 1),2]) "ZerosAndPoles transfer function";
      algorithm
        zp.n1 := n1;
        zp.n2 := n2;
        zp.d1 := d1;
        zp.d2 := d2;
        zp.k := k;
        zp.uName := uName;
        zp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
zp = ZerosAndPoles&apos;constructor&apos;.<b>fromFactorization</b>(n1, n2, d1, d2, k, uName, yName)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles record zp from first and second order polynomials.
</p>
</html>"));
      end fromFactorization;

      annotation (Documentation(info="<html>
<p>This package contains the default constructors for a data record of zeros-and-poles transfer function.</p>
</html>"));
    end 'constructor';

    encapsulated operator '-'
      "Collection of operators for subtraction of zeros and poles descriptions"
      import Modelica;

      function subtract "Subtract two zeros and poles descriptions (zp1 - zp2)"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp1 "Zeros-and-poles data record 1";
        input ZerosAndPoles zp2 "Zeros-and-poles data record 2";

    protected
        Integer size_z1n1=size(zp1.n1, 1);
        Integer size_z1d1=size(zp1.d1, 1);
        Integer size_z1n2=size(zp1.n2, 1);
        Integer size_z1d2=size(zp1.d2, 1);
        Integer size_z2n1=size(zp2.n1, 1);
        Integer size_z2d1=size(zp2.d1, 1);
        Integer size_z2n2=size(zp2.n2, 1);
        Integer size_z2d2=size(zp2.d2, 1);
        Polynomial p1;
        Polynomial p2;
        Polynomial p3;
        Complex numZeros[:];
        Complex dummy[:]=fill(Complex(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
            size_z2d2));
        Real k;

        output ZerosAndPoles result "= zp1/zp2";

      algorithm
        if zp1 == zp2 then
          result := ZerosAndPoles(0);
        else
          p1 := Polynomial(1);
          p2 := Polynomial(1);

          for i in 1:size_z1n1 loop
            p1 := p1*Polynomial({1,zp1.n1[i]});
          end for;
          for i in 1:size_z1n2 loop
            p1 := p1*Polynomial(cat(
              1,
              {1},
              zp1.n2[i, :]));
          end for;
          for i in 1:size_z2d1 loop
            p1 := p1*Polynomial({1,zp2.d1[i]});
          end for;
          for i in 1:size_z2d2 loop
            p1 := p1*Polynomial(cat(
              1,
              {1},
              zp2.d2[i, :]));
          end for;

          for i in 1:size_z2n1 loop
            p2 := p2*Polynomial({1,zp2.n1[i]});
          end for;
          for i in 1:size_z2n2 loop
            p2 := p2*Polynomial(cat(
              1,
              {1},
              zp2.n2[i, :]));
          end for;
          for i in 1:size_z1d1 loop
            p2 := p2*Polynomial({1,zp1.d1[i]});
          end for;
          for i in 1:size_z1d2 loop
            p2 := p2*Polynomial(cat(
              1,
              {1},
              zp1.d2[i, :]));
          end for;

          p3 := zp1.k*p1 - zp2.k*p2;
          k := 0;
          for i in size(p3.c, 1):-1:1 loop
            if abs(p3.c[i]) > Modelica.Constants.eps then
              k := p3.c[i];
            end if;
          end for;
          numZeros := Polynomial.roots(p3);
          result := ZerosAndPoles(
            numZeros,
            dummy,
            k);

          result.d1 := cat(
            1,
            zp1.d1,
            zp2.d1);
          result.d2 := cat(
            1,
            zp1.d2,
            zp2.d2);

        end if;
      end subtract;

      function negate "Unary minus (multiply zeros and poles description by -1)"
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "Zeros-and-poles data record";
        output ZerosAndPoles result(n1=zp.n1, n2=zp.n2, d1=zp.d1, d2=zp.d2, k=-zp.k) "= -zp";
      algorithm
      end negate;
      annotation (Documentation(info="<html>
  <p>This package contains operators for subtraction of zeros and poles descriptions. </p>
  </html>"));
    end '-';

    encapsulated operator function '+'
      "Addition of two zeros and poles descriptions zp1 + zp2, i.e. parallel connection of two transfer functions (= inputs are the same, outputs of the two systems are added)"

      import Modelica;
      import Modelica_LinearSystems2.ZerosAndPoles;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.Math.Complex;

      input ZerosAndPoles zp1 "Zeros-and-poles data record 1";
      input ZerosAndPoles zp2 "Zeros-and-poles data record 2";

  protected
      Integer size_z1n1=size(zp1.n1, 1);
      Integer size_z1d1=size(zp1.d1, 1);
      Integer size_z1n2=size(zp1.n2, 1);
      Integer size_z1d2=size(zp1.d2, 1);
      Integer size_z2n1=size(zp2.n1, 1);
      Integer size_z2d1=size(zp2.d1, 1);
      Integer size_z2n2=size(zp2.n2, 1);
      Integer size_z2d2=size(zp2.d2, 1);
      Polynomial p1;
      Polynomial p2;
      Polynomial p3;
      Complex numZeros[:];
      Complex dummy[:]=fill(Complex(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
          size_z2d2));
      Real k;

      output ZerosAndPoles result "= zp1+zp2";

    algorithm
      if zp1 == -zp2 then
        result := ZerosAndPoles(0);
      else

        p1 := Polynomial(1);
        p2 := Polynomial(1);

        for i in 1:size_z1n1 loop
          p1 := p1*Polynomial({1,zp1.n1[i]});
        end for;
        for i in 1:size_z1n2 loop
          p1 := p1*Polynomial(cat(
            1,
            {1},
            zp1.n2[i, :]));
        end for;
        for i in 1:size_z2d1 loop
          p1 := p1*Polynomial({1,zp2.d1[i]});
        end for;
        for i in 1:size_z2d2 loop
          p1 := p1*Polynomial(cat(
            1,
            {1},
            zp2.d2[i, :]));
        end for;

        for i in 1:size_z2n1 loop
          p2 := p2*Polynomial({1,zp2.n1[i]});
        end for;
        for i in 1:size_z2n2 loop
          p2 := p2*Polynomial(cat(
            1,
            {1},
            zp2.n2[i, :]));
        end for;
        for i in 1:size_z1d1 loop
          p2 := p2*Polynomial({1,zp1.d1[i]});
        end for;
        for i in 1:size_z1d2 loop
          p2 := p2*Polynomial(cat(
            1,
            {1},
            zp1.d2[i, :]));
        end for;

        p3 := zp1.k*p1 + zp2.k*p2;
        k := p3.c[1];
        numZeros := Polynomial.roots(p3);
        result := ZerosAndPoles(
          numZeros,
          dummy,
          k);

        result.d1 := cat(
          1,
          zp1.d1,
          zp2.d1);
        result.d2 := cat(
          1,
          zp1.d2,
          zp2.d2);
      end if;

    end '+';

    encapsulated operator function '*'
      "Multiply two zeros and poles descriptions (zp1 * zp2)"

      import Modelica;
      import Modelica_LinearSystems2.ZerosAndPoles;

      input ZerosAndPoles zp1 "Zeros-and-poles data record 1";
      input ZerosAndPoles zp2 "Zeros-and-poles data record 2";

      output ZerosAndPoles result "= zp1 * zp2";
    algorithm
      if zp1 == ZerosAndPoles(0) or zp2 == ZerosAndPoles(0) then
        result := ZerosAndPoles(0);
      else
        result.n1 := cat(
          1,
          zp1.n1,
          zp2.n1);
        result.n2 := cat(
          1,
          zp1.n2,
          zp2.n2);
        result.d1 := cat(
          1,
          zp1.d1,
          zp2.d1);
        result.d2 := cat(
          1,
          zp1.d2,
          zp2.d2);
        result.k := zp1.k*zp2.k;
      end if;

    end '*';

    encapsulated operator function '/'
      "Divide two zeros and poles descriptions (zp1 / zp2)"
      import Modelica;
      import Modelica_LinearSystems2.ZerosAndPoles;

      input ZerosAndPoles zp1 "Zeros-and-poles data record 1";
      input ZerosAndPoles zp2 "Zeros-and-poles data record 2";
      output ZerosAndPoles result "Result = zp1/zp2";

    algorithm
      assert(abs(zp2.k)>100*Modelica.Constants.small,"Record zp2 in operator \"Modelica_LinearSystems2.TransferFunction.'/'()\" may not be zero");
      if zp1==ZerosAndPoles(0) then
        result := ZerosAndPoles(0);
      else
        result.n1 := cat(1,zp1.n1, zp2.d1);
        result.n2 := cat(1,zp1.n2, zp2.d2);
        result.d1 := cat(1,zp1.d1, zp2.n1);
        result.d2 := cat(1,zp1.d2, zp2.n2);
        result.k := zp1.k/zp2.k;
      end if;

    end '/';

    encapsulated operator function '^'
      "Integer power of zeros and poles description (zp^k)"

      import Modelica;
      import Modelica_LinearSystems2.ZerosAndPoles;

      input ZerosAndPoles zp "Zeros-and-poles data record";
      input Integer k;

      output ZerosAndPoles result(
        redeclare Real n1[k*size(zp.n1, 1)],
        redeclare Real n2[k*size(zp.n2, 1),2],
        redeclare Real d1[k*size(zp.d1, 1)],
        redeclare Real d2[k*size(zp.d2, 1),2]) "= zp^k";
  protected
      Integer size_n1=size(zp.n1, 1);
      Integer size_d1=size(zp.d1, 1);
      Integer size_n2=size(zp.n2, 1);
      Integer size_d2=size(zp.d2, 1);
    algorithm
      for i in 1:k loop
        result.n1[(i - 1)*size_n1 + 1:i*size_n1] := zp.n1;
        result.d1[(i - 1)*size_d1 + 1:i*size_d1] := zp.d1;
        result.n2[(i - 1)*size_n2 + 1:i*size_n2, :] := zp.n2;
        result.d2[(i - 1)*size_d2 + 1:i*size_d2, :] := zp.d2;
      end for;
      result.k := zp.k^k;

    end '^';

    encapsulated operator function '=='
      "Check whether two zeros and poles descriptions are identical"
      import Modelica;
      import Modelica.Math;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.ZerosAndPoles;

      input ZerosAndPoles zp1 "Zeros-and-poles data record 1";
      input ZerosAndPoles zp2 "Zeros-and-poles data record 2";
      input Real eps(min=0) = 0
        "Two numbers n1 and n2 are identical if abs(n1-n2) <= eps";
      output Boolean result "= zp1 == zp2";

    algorithm
      result := Math.Vectors.isEqual(zp1.n1,zp2.n1,eps) and Math.Vectors.isEqual(zp1.d1,zp2.d1,eps) and Math.Matrices.isEqual(zp1.n2,zp2.n2,eps) and Math.Matrices.isEqual(zp1.d2,zp2.d2,eps) and (zp1.k==zp2.k);

    end '==';

    encapsulated operator function 'String'
      "Transform zeros and poles description into a String representation"
      import Modelica;
      import Modelica_LinearSystems2.ZerosAndPoles;

      input ZerosAndPoles zp
        "Zeros-and-poles data record to be transformed in a String representation";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      input String name="p" "Independent variable name used for printing";
        //input Boolean normalized = true;
      output String s="";
  protected
      Boolean normalized = false;
      Real gain=1.0;
      Integer num_order=size(zp.n1, 1) + 2*size(zp.n2, 1);
      Integer den_order=size(zp.d1, 1) + 2*size(zp.d2, 1);
      String sn1;
      String sn2;
      String sd1;
      String sd2;
      Real kn1;
      Real kn2;
      Real kd1;
      Real kd2;
    algorithm
      if num_order == 0 and den_order == 0 then
        s := String(zp.k);
        return;
      end if;

      // construct numerator and denominator strings
      (sn1,kn1) :=ZerosAndPoles.Internal.firstOrderToString( zp.n1, significantDigits, name, normalized);
      (sn2,kn2) :=ZerosAndPoles.Internal.secondOrderToString(zp.n2, significantDigits, name, normalized);
      (sd1,kd1) :=ZerosAndPoles.Internal.firstOrderToString( zp.d1, significantDigits, name, normalized);
      (sd2,kd2) :=ZerosAndPoles.Internal.secondOrderToString(zp.d2, significantDigits, name, normalized);

      // compute overall gain
      if normalized then
        gain :=zp.k*kn1*kn2/(kd1*kd2);
      else
        gain :=zp.k;
      end if;
      // Modelica.Utilities.Streams.print("gain = "+String(gain));

      // construct string for gain
      if gain <> 1.0 or gain == 1.0 and num_order == 0 then
        s := String(gain);
      end if;
      // Modelica.Utilities.Streams.print("s= "+s);

      // construct string for numerator
      if sn1 <> "" then
        if s == "" then
          s :=sn1;
        else
          s := s + "*" + sn1;
        end if;
      end if;
      if sn2 <> "" then
        if s == "" then
          s :=sn2;
        else
          s := s + "*" + sn2;
        end if;
      end if;

      // construct string for denominator
      if den_order <> 0 then
        s := s + " / ";
        if den_order > 1 then
          s := s + " ( ";
        end if;

        if sd1 <> "" then
          s := s + sd1;
        end if;

        if sd2 <> "" then
          if sd1 <> "" then
            s := s + "*";
          end if;
          s := s + sd2;
        end if;

        if den_order > 1 then
          s := s + " )";
        end if;
      end if;
    end 'String';

    encapsulated function p "Generate the transfer function p"
      import Modelica;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.ZerosAndPoles;

      output ZerosAndPoles zp(
        redeclare Real n1[1],
        redeclare Real n2[0,2],
        redeclare Real d1[0],
        redeclare Real d2[0,2]);
    algorithm
      zp.n1[1] := 0;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
p = ZerosAndPoles.<b>p</b>()
</pre></blockquote>

<h4>Description</h4>
<p>
Generate the complex Laplace variable p as a ZerosAndPoles transfer function. It can be used for generating like
</p>
<blockquote><pre>
ZerosAndPoles zp = p/(p^2 + p + 1)/(p + 1)
</pre></blockquote>
</html>"));
    end p;

    encapsulated package Analysis
      "Package of functions to analyse zeros-and-poles description represented by a ZerosAndPoles record"
      extends Modelica.Icons.Package;
      import Modelica;

      function analysis
        "Make a system analysis based on the poles and zeros of the system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Internal.AnalyseOptions;
        import Modelica_LinearSystems2.Internal.AnalyseOptions2;
        import Modelica_LinearSystems2.Internal.Eigenvalue;

        input ZerosAndPoles zp(uName="u", yName="y")
          "Transfer function of a system";

        input AnalyseOptions2 analyseOptions2 = Modelica_LinearSystems2.Internal.AnalyseOptions2(
                 printControllability=false,
                 printObservability=false);

        input String fileName="eigenvalues.html"
          "Name of html-file that contains eigenvalue table";

        input String systemName = ""
          "Name of system (used as heading in html file)";
        input String description = "" "Description of system (used in html file)";

    protected
        String dummyFileName = "dummy" + fileName;
        StateSpace ss=StateSpace(zp);

        AnalyseOptions analyseOptions=AnalyseOptions(
                 plotEigenValues=analyseOptions2.plotEigenValues,
                 plotInvariantZeros=analyseOptions2.plotInvariantZeros,
                 plotStepResponse=analyseOptions2.plotStepResponse,
                 plotFrequencyResponse=analyseOptions2.plotFrequencyResponse,
                 printSystem = analyseOptions2.printSystem,
                 printEigenValues=analyseOptions2.printEigenValues,
                 printEigenValueProperties=analyseOptions2.printEigenValueProperties,
                 printInvariantZeros=analyseOptions2.printInvariantZeros,
                 printControllability=analyseOptions2.printControllability,
                 printObservability=analyseOptions2.printObservability,
                 headingEigenValues=analyseOptions2.headingEigenValues,
                 headingInvariantzeros=analyseOptions2.headingInvariantzeros,
                 headingStepResponse=analyseOptions2.headingStepResponse,
                 headingFrequencyResponse=analyseOptions2.headingFrequencyResponse,
                 dB_w=analyseOptions2.dB_w);

      algorithm
        assert(ZerosAndPoles.Analysis.denominatorDegree(zp) >= ZerosAndPoles.Analysis.numeratorDegree(zp),
          " Denominator polynominal of ZerosAndPoles object in function\"ZerosAndPoles.Analysis.analysis\"has to be of higher or equal order than numerator polynomial");
        Modelica.Utilities.Files.removeFile(fileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);
        if analyseOptions.printSystem and size(ss.A,1) <= 50 then
          printSystem(
            zp,
            fileName,
            systemName,
            description);
          printSystem(
            zp,
            dummyFileName,
            systemName,
            description);
        end if;
        Modelica.Utilities.Streams.readFile(dummyFileName);
        analyseOptions.printSystem :=false;
        StateSpace.Analysis.analysis(
          ss=ss,
          analyseOptions=analyseOptions,
          fileName=fileName,
          systemName=systemName,
          description=description);

    public
        encapsulated function printSystem
          "Print the state space system in html format on file"
          import Modelica;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.ZerosAndPoles;
          import Modelica_LinearSystems2;

          input ZerosAndPoles zp "transfer function to analyze";
          input String fileName="systemAnalysis.html"
            "File on which the zeros-and-poles transfer function is written in html format";
          input String systemName="ZerosAndPoles Transfer Function"
            "name of the system";
          input String description = ""
            "Description of system (used in html file)";
          input String format=".3g" "Format of numbers (e.g. \"20.8e\")";
      protected
          String st=String(zp);

        algorithm
          Modelica.Utilities.Files.removeFile(fileName);
          print("<html><body><br><br><p>\n<b>System report</b>\n</p>",fileName);
          print("<body><p><br> The system <b>" + systemName + "</b> is defined by</p>",fileName);
          print("G(p) = "+st, fileName);

          if description=="" then
            print("</table>", fileName);
          else
            print("</table>", fileName);
            print("<body><p><b>Description</b></p>",fileName);
            print(description, fileName);
          end if;

        end printSystem;

        annotation (__Dymola_interactive=true, Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end analysis;

      encapsulated function timeResponse
        "Calculate the time response of a zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        extends Modelica_LinearSystems2.Internal.timeResponseMask2_zp;     // Input/Output declarations of time response functions
        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step;

        input Real x0[Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp)]=zeros(Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp))
          "Initial state vector";

    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        (y,t,x_continuous) := StateSpace.Analysis.timeResponse(sc=ss, dt=dt, tSpan=tSpan, response=response, x0=x0);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = ZerosAndPoles.Analysis.<b>timeResponse</b>(zp, dt, tSpan, responseType, x0)
</pre></blockquote>

<h4>Description</h4>
<p>First, the ZerosAndPoles record is transformed into state space representation which is given to StateSpace.Analysis.timeResponse to calculate the time response of the state space system. The type of the time response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
Impulse &quot;Impulse response&quot;,
Step &quot;Step response&quot;,
Ramp &quot;Ramp response&quot;,
Initial &quot;Initial condition response&quot;
</pre></blockquote>
<p>
The state space system is transformed to a appropriate discrete state space system and, starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y and x are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  p=Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=1/(p^2 + p + 1)

  Real Ts=0.1;
  Real tSpan= 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[2]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

algorithm
  (y,t,x):=Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse(zp,Ts,tSpan,response,x0);
//  y[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
</pre></blockquote>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse "Calculate the impulse time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_zp;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse(
              zp=zp,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
              x0=zeros(Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = ZerosAndPoles.Analysis.<b>impulseResponse</b>(zp, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>impulseResponse</b> calculates the time response of a ZerosAndPoles transfer function with impulse imput.
The system is first transformed zo a state space system, wich is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.impulseResponse(zp, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.timeResponse(zp, dt, tSpan, response=Types.TimeResponse.Impulse, x0=fill(0,ZerosAndPoles.Analysis.denominatorDegree(zp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.ZerosAndPoles zp=zp=1/(p^2 + p + 1)
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.ZerosAndPoles.Analysis.impulseResponse(zp,Ts,tSpan);
//  y[:,1,1]={0, 0.095, 0.18, 0.2553, 0.321}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.095, 0.18, 0.2553, 0.321}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse\">ZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse "Calculate the step time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_zp;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse(
              zp=zp,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = ZerosAndPoles.Analysis.<b>stepResponse</b>(zp, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>stepResponse</b> calculates the step response of a transfer function.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.stepResponse(zp, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.timeResponse(zp, dt, tSpan, response=Types.TimeResponse.Step, x0=fill(0,ZerosAndPoles.Analysis.denominatorDegree(zp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.ZerosAndPoles zp=zp=1/(p^2 + p + 1)
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.ZerosAndPoles.Analysis.stepResponse(zp,Ts,tSpan);
//  y[:,1,1]={0, 0.0048, 0.01867, 0.04, 0.0694}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0048, 0.01867, 0.04, 0.0694}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse\">ZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end stepResponse;

      encapsulated function rampResponse "Calculate the ramp time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_zp;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse(
              zp=zp,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
              x0=zeros(Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = ZerosAndPoles.Analysis.<b>rampResponse</b>(zp, dt, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rampResponse</b> calculates the time response of a transfer function for ramp imput u = t.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.rampResponse(zp, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.timeResponse(zp, dt, tSpan, response=Types.TimeResponse.Ramp, x0=fill(0,ZerosAndPoles.Analysis.denominatorDegree(zp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.ZerosAndPoles zp=zp=1/(p^2 + p + 1)
  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.ZerosAndPoles.Analysis.rampResponse(zp,Ts,tSpan);
//  y[:,1,1]={0, 0.0002, 0.0012, 0.0042, 0.0096}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0002, 0.0012, 0.0042, 0.0096}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse\">ZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the time response for given initial condition and zero inputs"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Real x0[:]=fill(0,0) "Initial state vector";

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_zp;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse(
              zp=zp,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
              x0=x0);

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = ZerosAndPoles.Analysis.<b>initialResponse</b>(zp, dt, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>initialResponse</b> calculates the time response of a state space system for given initial condition and zero inputs.
The state space system is transformed to a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.initialResponse(x0,zp, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
ZerosAndPoles.Analysis.timeResponse(zp, dt, tSpan, response=Types.TimeResponse.Initial, x0=x0).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.ZerosAndPoles zp=zp=1/(p^2 + p + 1)
  Real Ts=0.1;
  Real tSpan= 0.4;
  Real x0[2] = {1,1};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.ZerosAndPoles.Analysis.initialResponse(x0,zp,Ts,tSpan);
//  y[:,1,1]={1, 1.0903, 1.1616, 1.2151, 1.252}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={1, 1.0903, 1.1616, 1.2151, 1.252}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse\">ZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end initialResponse;

      encapsulated function numeratorDegree
        "Return numerator degree of a ZerosAndPoles transfer function"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Integer result;
      algorithm
        result := size(zp.n1, 1) + 2*size(zp.n2, 1);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = ZerosAndPoles.Analysis.<b>numeratorDegree</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>numeratorDegree</b> calculates the degree of the numerator polynomial constituted by the first and second order polynomials of the ZeroAndPoles numerator.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Real nDegree;

<b>algorithm</b>
  nDegree := ZerosAndPoles.Analysis.numeratorDegree(zp);
//  nDegree = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree\">ZerosAndPoles.Analysis.denominatorDegree</a>
</p>
</html>"));
      end numeratorDegree;

      encapsulated function denominatorDegree
        "Return denominator degree of a ZerosAndPoles transfer function"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Integer result;
      algorithm
        result := size(zp.d1, 1) + 2*size(zp.d2, 1);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = ZerosAndPoles.Analysis.<b>denominatorDegree</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>denominatorDegree</b> calculates the degree of the denominator polynomial constituted by the first and second order polynomials of the ZeroAndPoles denominator.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Real dDegree;

<b>algorithm</b>
  dDegree := ZerosAndPoles.Analysis.denominatorDegree(zp);
//  dDegree = 2
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.numeratorDegree\">ZerosAndPoles.Analysis.numeratorDegree</a>
</p>
</html>"));
      end denominatorDegree;

      encapsulated function evaluate
        "Evaluate a ZerosAndPoles transfer function at a given value of p"
        import Modelica.Utilities.Streams.print;
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        input Complex p=Complex(0) "Complex value p where zp is evaluated";
        input Real den_min(min=0)=0 "|denominator(p)| is limited by den_min";
        output Complex y "= zp(p)";
    protected
        Complex j=Modelica_LinearSystems2.Math.Complex.j();
        Complex num;
        Complex den;
        Real abs_den;
        Integer n1 = size(zp.n1,1);
        Integer n2 = size(zp.n2,1);
        Integer d1 = size(zp.d1,1);
        Integer d2 = size(zp.d2,1);
        Complex n[size(zp.n1,1)+size(zp.n2,1)];
        Complex d[size(zp.d1,1)+size(zp.d2,1)];
        Complex y2;
        Integer info;
      algorithm
        // Build numerator
        for i in 1:n1 loop
          n[i] :=ZerosAndPoles.Internal.'p+a'(p, zp.n1[i]);
        end for;
        for i in 1:n2 loop
          n[n1+i] := ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'(p, zp.n2[i, :]);
        end for;

        // Build denominator
        for i in 1:d1 loop
          d[i] := ZerosAndPoles.Internal.'p+a'(p, zp.d1[i]);
        end for;
        for i in 1:d2 loop
          d[d1+i] :=ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'(p, zp.d2[i, :]);
        end for;

        // Build value of transfer function
        (y2, info) :=Modelica_LinearSystems2.Internal.complexFraction(n, d);
        if info == 0 then
           y :=Complex(zp.k, 0)*y2;
        elseif info == 1 then
           y :=if zp.k >= 0 then y2 else -y2;
        else
           y :=y2;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = ZerosAndPoles.Analysis.<b>evaluate</b>(zp, p, den_min=0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>evaluate</b> evaluates the ZerosAndPoles transfer function at a given (complex) value of p and returns the value G(p)=N(p)/D(p). The optional argument den_min with default 0 is used to guard against a division by zero.
</p>
<pre>
  <b>if</b> |(D(p))| >= den_min <b>then</b>
     G(p) = N(p) / D(p);
  <b>elseif</b> D(p).re >= 0.0 <b>then</b>
     G(p) = N(p) / den_min
  <b>else</b>
     G(p) = -N(p) / den_min
  <b>end if</b>;
</p>
</pre>

<h4>Example</h4>
<blockquote><pre>
  Complex j = Modelica_LinearSystems2.Math.Complex.j();
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Complex result;

<b>algorithm</b>
  result := Modelica_LinearSystems2.ZerosAndPoles.Analysis.evaluate(zp, j+1);
//  result = 0.538462 - 0.307692j
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.Math.Polynomial.evaluateComplex\">Math.Polynomial.evaluateComplex</a>
</p>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end evaluate;

      encapsulated function zerosAndPoles
        "Calculate zeros and poles of a ZerosAndPoles transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Complex z[:]=fill(Complex(0, 0), size(zp.n1, 1) + 2*size(zp.n2, 1))
          "Zeros (Complex vector of numerator zeros)";
        output Complex p[:]=fill(Complex(0, 0), size(zp.d1, 1) + 2*size(zp.d2, 1))
          "Poles (Complex vector of denominator zeros)";
        output Real k "Constant multiplied with transfer function";

    protected
        Integer n_num1=size(zp.n1, 1);
        Integer n_num2=size(zp.n2, 1);
        Integer n_den1=size(zp.d1, 1);
        Integer n_den2=size(zp.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;
        Real re;
        Real im;
        Integer nz_real=ZerosAndPoles.Internal.numberOfRealZeros(zp.n1, zp.n2)
          "z[1:nz_real] are the real zeros";
        Integer np_real=ZerosAndPoles.Internal.numberOfRealZeros(zp.d1, zp.d2)
          "p[1:np_real] are the real poles";
        Real num_zeros1[nz_real];
        Real den_zeros1[np_real];
        Complex num_zeros2[:]=fill(Complex(0, 0), integer((n_num - nz_real)/2));
        Complex den_zeros2[:]=fill(Complex(0, 0), integer((n_den - np_real)/2));
        Integer n;
        Integer jj;
        Complex j=Modelica_LinearSystems2.Math.Complex.j();

      algorithm
        (num_zeros1,num_zeros2) := ZerosAndPoles.Internal.roots(
            zp.n1,
            zp.n2,
            nz_real);
        (den_zeros1,den_zeros2) := ZerosAndPoles.Internal.roots(
            zp.d1,
            zp.d2,
            np_real);

        n := size(num_zeros1, 1);
        for i in 1:n loop
          z[i] := Complex(num_zeros1[i], 0);
        end for;

        jj := 1;
        for i in 1:size(num_zeros2, 1) loop
          z[n + jj] := num_zeros2[i];
          z[n + jj + 1] := num_zeros2[i].re-num_zeros2[i].im*j;
          jj := jj + 2;
        end for;

        n := size(den_zeros1, 1);
        for i in 1:n loop
          p[i] := den_zeros1[i]+0*j;
        end for;

        jj := 1;
        for i in 1:size(den_zeros2, 1) loop
          p[n + jj] := den_zeros2[i];
          p[n + jj + 1] := den_zeros2[i].re-den_zeros2[i].im*j;
          jj := jj + 2;
        end for;

        k := zp.k;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(z,p,k) = ZerosAndPoles.Analysis.<b>zerosAndPoles</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the zeros, poles and gain of a ZerosAndPoels transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

public
  output Complex z;
  output Complex p;
  output Real k;

<b>algorithm</b>
  (z,p,k)=Modelica_LinearSystems2.ZerosAndPoles.Analysis.zerosAndPoles(zp);
//  z = {-1}
//  p = {-0.5 + 0.866025j, -0.5 - 0.866025j}
//  k = 1
</pre></blockquote>
</html>"));
      end zerosAndPoles;

      function eigenValues
        "Calculate the eigen values of a linear zeros-and-poles transfer function and write them in a complex vector"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Complex eigval[:] "eigen values of the system";
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        assert(ZerosAndPoles.Analysis.denominatorDegree(zp) >
          ZerosAndPoles.Analysis.numeratorDegree(zp),
          " Denominator polynominal of transfer function in function\"ZerosAndPoles.Analysis.eigenValues\"has to be of higher order than numerator polynomial");
        eigval := Complex.eigenValues(ss.A);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
eigenvalues = ZerosAndPoles.Analysis.<b>eigenValues</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvalues of the corresponding state space representation of a zeros-and-poles transfer function. The output is a complex vector containing the eigenvalues. Note, that the conversion of the transfer function does not result in a minimal state space system. Therefore also unobservable and uncontrollable eigenvalues will be calculated.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Complex eigenvalues[2];

<b>algorithm</b>
  eigenvalues = Modelica_LinearSystems2.ZerosAndPoles.Analysis.eigenValues(zp);
// eigenvalues = {-0.5 + j*sqrt(3)/2, -0.5 - j*sqrt(3)/2}
</pre></blockquote>
</html>"));
      end eigenValues;

      encapsulated function eigenVectors
        "Calculate the rigth eigenvectors of the corresponding state space system of a zeros-and-poles transfer function and write them columnwise in a matrix"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        input Boolean onlyEigenvectors=true;
        output Real eigvec[:,:] "eigen values of the system";
        output Complex eigval[:] "eigen values of the system";
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        assert(ZerosAndPoles.Analysis.denominatorDegree(zp) >
          ZerosAndPoles.Analysis.numeratorDegree(zp),
          " Denominator polynominal of transfer function in function\"ZerosAndPoles.Analysis.eigenVectors\"has to be of higher order than numerator polynomial");
        (eigvec,eigval) := StateSpace.Analysis.eigenVectors(ss=ss,
          onlyEigenvectors=onlyEigenvectors);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(eigenvectors, eigenvalues) = ZerosAndPoles.Analysis.<b>eigenVectors</b>(zp, onlyEigenvectors)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvectors and optionally (onlyEigenvectors=false) the eigenvalues of the corresponding state space system of a zeros-and-poles-transfer function. The output <tt>eigenvectors</tt> is a matrix with the same dimension as matrix <b>ss.A</b>. Just like in <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Modelica.Math.Matrices.eigenValues</a>, if the i-th eigenvalue has an imaginary part, then <tt>eigenvectors</tt>[:,i] is the real and <tt>eigenvectors</tt>[:,i+1] is the imaginary part of the eigenvector of the i-th eigenvalue.<br>
The eigenvalues are returned as a complex vector <tt>eigenvalues</tt>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(2*p+2)/(p^2+2*p+2);

  Real eigenvectors[2,2];
  Complex eigenvalues[2];

<b>algorithm</b>
  (eigenvectors, eigenvalues) = Modelica_LinearSystems2.ZerosAndPoles.Analysis.eigenVectors(zp, true);
// eigenvectors = [(-0.4082), (-0.4082);
                    0.8165, 0]
// eigenvalues = {-1 + 1j, -1 - 1j}

          |-0.4082 -i0.4082 |         | -0.4082 + i0.4082 |
i.e. v1 = |                 |,   v2 = |                   |
          |     0.8165      |         |      0.8165       |
</pre></blockquote>
</html>"));
      end eigenVectors;

      encapsulated function invariantZeros
        "Compute invariant zeros of zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";

        output Complex Zeros[:]= ZerosAndPoles.Analysis.zerosAndPoles(zp);

      algorithm
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zeros = ZerosAndPoles.Analysis.<b>invariantZeros</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes the invariant zeros of the corresponding state space representation of a zeros-and-poles transfer function. The output is a complex vector containing the eigenvalues. Note, that the conversion of the transfer function does not result in a minimal state space system. Therefore, also zeros equal to unobservable or uncontrollable eigenvalues will be computed.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Complex zeros[:];

<b>algorithm</b>
  zeros := Modelica_LinearSystems2.ZerosAndPoles.Analysis.invariantZeros(zp);
// zeros = {-1}

</pre></blockquote>
</html>",     revisions=
               "<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end invariantZeros;

      encapsulated function dcGain
        "Return steady state gain k (for a stable system: k = value of y at infinite time for a step input)"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica.Utilities.Streams.print;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Real k "Steady state gain";
        output Boolean finite = true
          "True, if k is finite, otherwise if k is infinite (k=Modelica.Constants.inf returned)";
    protected
        StateSpace ss=StateSpace(zp);
        Real K[1,1];
      algorithm
        (K, finite) := StateSpace.Analysis.dcGain(ss=ss);
        k :=K[1, 1];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
          k = <b>dcGain</b>(zp);
(k, finite) = <b>dcGain</b>(zp);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the steady state gain <b>k</b> of a
ZerosAndPoles transfer function g(s), i.e. k = g(s=0).
For a stable transfer function, a step input u results
in the output y(t->t<sub>&infin;</sub>) = k.
</p>

<p>
If the transfer function has one or more zero poles, <b>k</b> is infinite.
In this case, the output argument <b>finite</b> = <b>false</b> and
<b>k</b> = Modelica.Constants.inf.
</p>
</html>"));
      end dcGain;

      encapsulated function isControllable
        "Check controllability of a zp-transfer-function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean controllable;
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        controllable := StateSpace.Analysis.isControllable(ss=ss, method=method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
controllable = ZerosAndPoles.Analysis.<b>isControllable</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function ZerosAndPoles.Analysis.<b>isControllable</b> checks the controllability
of a zeros-and-poles transfer function. Therefore, the transfer function is converted
into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isControllable\">StateSpace.Analysis.isControllable</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2 + 2*p +1);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean controllable;

<b>algorithm</b>
  controllable := Modelica_LinearSystems2.StateSpace.Analysis.isControllable(zp, method);
// controllable = true
</pre></blockquote>
</html>"));
      end isControllable;

      encapsulated function isObservable
        "Check observability of a zp-transfer-function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean observable;
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        observable := StateSpace.Analysis.isObservable(ss=ss, method=method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
observable = ZerosAndPoles.Analysis.<b>isObservable</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function ZerosAndPoles.Analysis.<b>isObservable</b> checks the observability of a zeros-and-poles transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isObservable\">StateSpace.Analysis.isObservable</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2 + 2*p +1);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean observable;

<b>algorithm</b>
  observable := Modelica_LinearSystems2.StateSpace.Analysis.isObservable(zp, method);
// observable = false
</pre></blockquote>
</html>"));
      end isObservable;

      encapsulated function isStabilizable
        "Check stabilizability of a zp-transfer-function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";

        output Boolean stabilizable;
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        stabilizable := StateSpace.Analysis.isStabilizable(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
stabilizable = ZerosAndPoles.Analysis.<b>isStabilizable</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function ZerosAndPoles.Analysis.<b>isStabilizable</b> checks the Stabilizability of a zeros-and-poles transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable\">StateSpace.Analysis.isStabilizable</a>.
The transfer function is stabilizable if all unstable poles are controllable.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p-1)/(p^2 - 2*p +1);

  Boolean stabilizable;

<b>algorithm</b>
   stabilizable := Modelica_LinearSystems2.ZerosAndPoles.Analysis.isStabilizable(zp);
// stabilizable = true
</pre></blockquote>
</html>"));
      end isStabilizable;

      encapsulated function isDetectable
        "Check detectability of a zp-transfer-function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";

        output Boolean detectable;

    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        detectable := StateSpace.Analysis.isDetectable(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
detectable = ZerosAndPoles.Analysis.<b>isDetectable</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function ZerosAndPoles.Analysis.<b>isDetectable</b> checks the Detectability of a zeros-and-poles transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isDetectable\">StateSpace.Analysis.isDetectable</a>. <br>
The transfer function is detectable if all unstable poles are observable.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p-1)/(p^2 - 2*p +1);

  Boolean detectable;

<b>algorithm</b>
  detectable := Modelica_LinearSystems2.ZerosAndPoles.Analysis.isDetectable(zp);
// detectable = false
</pre></blockquote>
</html>"));
      end isDetectable;

      encapsulated function controllabilityMatrix
        "Calculate the controllability matrix [B, A*B, ..., A^(n-1)*B] of a zp-transfer-function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Real om[:,:];

    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        om := StateSpace.Analysis.controllabilityMatrix(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = ZerosAndPoles.Analysis.<b>controllabilityMatrix</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the controllability matrix
</p>
<blockquote>
<b>Q</b> = [<b>B</b>, <b>A</b>*<b>B</b>, ..., <b>A</b>^(n-1)*<b>B</b>]
</blockquote>
<p>
of the system corresponding to state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre></blockquote>
<p>
of a zeros and poles transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Real Q[2,2];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.ZerosAndPoles.Analysis.controllabilityMatrix(zp);
// Q = [0, 1, 1, -1]
</pre></blockquote>
</html>"));
      end controllabilityMatrix;

      encapsulated function observabilityMatrix
        "Calculate the observability matrix of zp-transfer-function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Real om[:,:];

    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        om := StateSpace.Analysis.observabilityMatrix(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = ZerosAndPoles.Analysis.<b>observabilityMatrix</b>(zp, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the observability matrix
</p>
<blockquote>
<b>Q</b> = [<b>C</b>; <b>C</b>*<b>A</b>; ...; <b>C</b>*<b>A</b>^(n-1)]
</blockquote>
<p>
of the system corresponding state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre></blockquote>
<p>
of a zeros-and-poles transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Real Q[2,2];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.ZerosAndPoles.Analysis.observabilityMatrix(zp);
// Q = [1, 1, -1, 0]
</pre></blockquote>
</html>"));
      end observabilityMatrix;

    end Analysis;

    encapsulated package Design
      "Package of functions to design zeros-and-poles controllers and observers"
      extends Modelica.Icons.Package;
      import Modelica;

      encapsulated function filter
        "Generate a ZerosAndPoles transfer function from a filter description"

        import Modelica;
        import Modelica.Utilities.Streams;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Utilities.Types;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Modelica_LinearSystems2.Utilities.Types.AnalogFilter analogFilter=Modelica_LinearSystems2.Utilities.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)";
        input Modelica_LinearSystems2.Utilities.Types.FilterType filterType=Modelica_LinearSystems2.Utilities.Types.FilterType.LowPass "Type of filter (LowPass/HighPass/BandPass)";
        input Integer order(min=1) = 2 "Order of filter";
        input Modelica.Units.SI.Frequency f_cut=1/(2*Modelica.Constants.pi)
          "Cut-off frequency (default is w_cut = 1 rad/s)";
        input Real gain=1.0
          "Gain (= amplitude of frequency response at zero frequency)";
        input Real A_ripple(unit="dB") = 0.5
          "Pass band ripple (only for Chebyshev filter)";
        input Boolean normalized=true "True, if amplitude at f_cut = -3db*gain";
        input Modelica.Units.SI.Frequency f_min=0
          "Band of normalized band pass/stop filter is f_min (-3db*gain) .. f_cut (-3db*gain)";

      /*
                               | size(n1,1)   | size(n2,1)       | size(d1,1)   | size(d2,1)
    ---------------------------+--------------+------------------+--------------+-------------------
    CriticalDamping - LowPass  |      0       |      0           |    order     |     0
    CriticalDamping - HighPass |    order     |      0           |    order     |     0
    CriticalDamping - BandPass |    order     |      0           |      0       |   order
    CriticalDamping - BandStop |      0       |    order         |      0       |   order
    ---------------------------+--------------+------------------+--------------+-------------------
    LowPass                    |      0       |      0           | mod(order,2) | integer(order/2)
    HighPass                   | mod(order,2) | integer(order/2) | mod(order,2) | integer(order/2)
    BandPass                   |     order    |      0           |      0       |   order
    BandStop                   |      0       |    order         |      0       |   order
 */
        output ZerosAndPoles filter(
          redeclare Real n1[if filterType == Types.FilterType.BandPass then order else
                            if filterType == Types.FilterType.HighPass then
                               (if analogFilter == Types.AnalogFilter.CriticalDamping then order else
                                   mod(order, 2)) else 0],
          redeclare Real n2[if filterType == Types.FilterType.BandStop then order else
                            if filterType == Types.FilterType.HighPass and
                               analogFilter <> Types.AnalogFilter.CriticalDamping then integer(order/2) else 0,2],
          redeclare Real d1[if filterType == Types.FilterType.BandPass or
                               filterType == Types.FilterType.BandStop then 0 else
                            if analogFilter == Types.AnalogFilter.CriticalDamping then order else
                               mod(order, 2)],
          redeclare Real d2[if filterType == Types.FilterType.BandPass or
                               filterType == Types.FilterType.BandStop then order else
                            if analogFilter == Types.AnalogFilter.CriticalDamping then 0 else
                               integer(order/2),2]) "Filter transfer function";
    protected
        Integer n_num1=size(filter.n1, 1);
        Integer n_num2=size(filter.n2, 1);
        Integer n_den1=size(filter.d1, 1);
        Integer n_den2=size(filter.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;
        Real pi=Modelica.Constants.pi;
        Boolean evenOrder=mod(order, 2) == 0
          "True, if even filter order, otherwise uneven";

        Modelica.Units.SI.Frequency f0=if filterType == Types.FilterType.BandPass
             or filterType == Types.FilterType.BandStop then sqrt(f_min*f_cut)
             else f_cut;
        Modelica.Units.SI.AngularVelocity w_cut=2*pi*f0
          "Cut-off angular frequency";
        constant Modelica.Units.SI.AngularVelocity wOne=1.0
          "Just to make unit handling correct";
        Modelica.Units.SI.AngularVelocity w_band=wOne*(f_cut - f_min)/f0;
        Real w_cut2 "= w_cut*w_cut";
        Real alpha=1.0 "Frequency correction factor";
        Real alpha2 "= alpha*alpha";

        Real alphax;

        Real epsilon "Ripple size";
        Real fac "arsinh(epsilon)";
        Real A2 "poleReal^2 + poleImag^2";
        Real A "Amplitude at w_cut";

        Real aux;
        Real k;
        Integer j;
        Real c;
        Real ww;
        ZerosAndPoles baseFilter;
      algorithm
        /* Compute filter coefficients of prototype low pass filter. If another filter
       characteristics is desired (e.g. high pass filter), it is derived
       from the low pass filter coefficients below
      */
        assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
        baseFilter :=ZerosAndPoles.Internal.baseFilter(analogFilter,order,A_ripple,normalized);

        /* ==============================================================================
       Compute desired filter characteristics by transformation of low pass filter
      */
        if filterType == Types.FilterType.LowPass then
           filter :=baseFilter;

        elseif filterType == Types.FilterType.HighPass then
          /* The high pass filter is derived from the low pass filter by
         the transformation new(p) = 1/p
         1/(p + a)         -> 1/((1/p) + a) = (1/a)*p / (p + (1/a))
         1/(p^2 + a*p + b) -> 1/((1/p)^2 + a*(1/p) + b) = (1/b)*p^2 / (p^2 + (a/b)*p + 1/b)
        */
          assert(n_num1 == n_den1 and n_num2 == n_den2, "Internal error 1, should not occur");
          filter.k  := baseFilter.k;
          filter.n1 := zeros(n_num1);
          filter.n2 := zeros(n_num2, 2);

          for i in 1:n_den1 loop
            filter.d1[i] := 1/baseFilter.d1[i];
          end for;

          for i in 1:n_den2 loop
            filter.d2[i, 1] := baseFilter.d2[i, 1]/baseFilter.d2[i, 2];
            filter.d2[i, 2] := 1/baseFilter.d2[i, 2];
          end for;

        elseif filterType == Types.FilterType.BandPass then
          /* The band pass filter is derived from the low pass filter by
         the transformation new(p) = (p + 1/p)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

         1/(p + a)         -> 1/(p/w + 1/p/w) + a)
                              = w*p / (p^2 + a*w*p + 1)

         1/(p^2 + a*p + b) -> 1/( (p+1/p)^2/w^2 + a*(p + 1/p)/w + b )
                              = 1 / ( p^2 + 1/p^2 + 2)/w^2 + (p + 1/p)*a/w + b )
                              = w^2*p^2 / (p^4 + 2*p^2 + 1 + (p^3 + p)a*w + b*w^2*p^2)
                              = w^2*p^2 / (p^4 + a*w*p^3 + (2+b*w^2)*p^2 + a*w*p + 1)

                              Assume the following description with PT2:
                              = w^2*p^2 /( (p^2 + p*(c/alpha) + 1/alpha^2)*
                                           (p^2 + p*(c*alpha) + alpha^2) )
                              = w^2*p^2 / ( p^4 + c*(alpha + 1/alpha)*p^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*p^2
                                                + c*(alpha + 1/alpha)*p + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = a*w           -> c = a*w / (alpha + 1/alpha)
                                                                         = a*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+b*w^2 -> equation to determine alpha
                                alpha^4 + 1 + a^2*w^2*alpha^4/(1+alpha^2)^2 = (2+b*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1 = 0
        */
          assert(n_num2 == 0 and n_den1 == 0, "Internal error 2, should not occur");
          assert(n_num1 == order and n_den2 == order, "Internal error 3, should not occur:");
          assert(f_min > 0 and f_min < f_cut, "Lower band pass frequency f_min must be > 0 and < f_cut");

          filter.n1 := zeros(n_num1);
          filter.k  := baseFilter.k;

          for i in 1:size(baseFilter.d1,1) loop
            filter.k := filter.k*w_band;
            filter.d2[i,1] := baseFilter.d1[i]*w_band;
            filter.d2[i,2] := 1.0;
          end for;

          for i in 1:size(baseFilter.d2,1) loop
            filter.k := filter.k*w_band*w_band;
            alpha := ZerosAndPoles.Internal.bandPassAlpha(baseFilter.d2[i,1], baseFilter.d2[i,2], w_band);
            c     := baseFilter.d2[i,1]*w_band / (alpha + 1/alpha);
            j     := size(baseFilter.d1,1) + 2*i - 1;
            filter.d2[j,   1] := c/alpha;
            filter.d2[j,   2] := 1/alpha^2;
            filter.d2[j+1, 1] := c*alpha;
            filter.d2[j+1, 2] := alpha^2;
          end for;

        elseif filterType == Types.FilterType.BandStop then
          /* The band stop filter is derived from the low pass filter by
         the transformation new(p) = w/( (p + 1/p) )   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

         1/(p + a)         -> 1/( w/(p + 1/p) ) + a)
                              = 1/a*(p^2 + 1) / (p^2 + (w/a)*p + 1)

         1/(p^2 + a*p + b) -> 1/( w^2/(p + 1/p)^2 + a*w/(p + 1/p) + b )
                              = 1/b*(p^2 + 1)^2 / (p^4 + a*w*p^3/b + (2+w^2/b)*p^2 + a*w*p/b + 1)

                              Assume the following description with PT2:
                              = 1/b*(p^2 + 1)^2 / ( (p^2 + p*(c/alpha) + 1/alpha^2)*
                                                    (p^2 + p*(c*alpha) + alpha^2) )
                              = 1/b*(p^2 + 1)^2 / (  p^4 + c*(alpha + 1/alpha)*p^3
                                                     + (alpha^2 + 1/alpha^2 + c^2)*p^2
                                                     + c*(alpha + 1/alpha)*p + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = a*w/b         -> c = a*w/(b*(alpha + 1/alpha))
                                alpha^2 + 1/alpha^2 + c^2 = 2+w^2/b -> equation to determine alpha
                                alpha^4 + 1 + (a*w/b*alpha^2)^2/(1+alpha^2)^2 = (2+w^2/b)*alpha^2
                                or z = alpha^2
                                z^2 + (a*w/b*z)^2/(1+z)^2 - (2+w^2/b)*z + 1 = 0

                              same as:  ww = w/b
                                z^2 + (a*ww*z)^2/(1+z)^2 - (2+b*ww)*z + 1 = 0  -> same equation as for BandPass

        */
          assert(n_num1 == 0 and n_den1 == 0, "Internal error 4, should not occur");
          assert(n_num2 == order and n_den2 == order, "Internal error 5, should not occur:");
          assert(f_min > 0 and f_min < f_cut, "Lower band pass frequency f_min must be > 0 and < f_cut");

          filter.k :=baseFilter.k;
          for i in 1:order loop
            filter.n2[i,1] := 0.0;
            filter.n2[i,2] := 1.0;
          end for;

          for i in 1:size(baseFilter.d1,1) loop
            filter.d2[i,1] := w_band/baseFilter.d1[i];
            filter.d2[i,2] := 1.0;
          end for;

          for i in 1:size(baseFilter.d2,1) loop
             ww    := w_band/baseFilter.d2[i,2];
             alpha := ZerosAndPoles.Internal.bandPassAlpha(baseFilter.d2[i,1], baseFilter.d2[i,2], ww);
             c     := baseFilter.d2[i,1]*ww / (alpha + 1/alpha);
             j     := size(baseFilter.d1,1) + 2*i - 1;
             filter.d2[j,   1] := c/alpha;
             filter.d2[j,   2] := 1/alpha^2;
             filter.d2[j+1, 1] := c*alpha;
             filter.d2[j+1, 2] := alpha^2;
          end for;

        else
          Streams.error("analogFilter (= " + String(analogFilter) + ") is not supported");
        end if;

        /* Transform filter to desired cut-off frequency ===================================

       Change filter coefficients according to transformation new(p) = p/w_cut
       Numerator  :     (p/w)^2 + a*(p/w) + b = (1/w^2)*(p^2 + (a*w)*p + b*w^2)
                                    (p/w) + a = (1/w)*(p + w*a)
       Denominator: 1/((p/w)^2 + a*(p/w) + b) = w^2/(p^2 + (a*w)*p + b*w^2)
                                1/((p/w) + a) = w/(p + w*a)
      */
        w_cut2 := w_cut*w_cut;
        filter.n1 := w_cut*filter.n1;
        filter.d1 := w_cut*filter.d1;
        filter.n2 := [w_cut*filter.n2[:, 1],w_cut2*filter.n2[:, 2]];
        filter.d2 := [w_cut*filter.d2[:, 1],w_cut2*filter.d2[:, 2]];

        /* Add gain ======================================================================= */
        if filterType == Types.FilterType.LowPass then
          /* A low pass filter does not have numerator polynomials and all coefficients
         of the denominator polynomial are guaranteed to be non-zero. It is then
         easy to compute the gain:
            1/(p + a)         -> a/(p + a)        , since g(0) = 1; k = a
            1/(p^2 + a*p + b) -> b/(p^2 + a*p + b), since g(0) = 1; k = b
        */
          k := 1.0;
          for i in 1:n_den1 loop
            k :=k*filter.d1[i];
          end for;
          for i in 1:n_den2 loop
            k :=k*filter.d2[i, 2];
          end for;
          filter.k := gain*k;

        elseif filterType == Types.FilterType.HighPass or
               filterType == Types.FilterType.BandStop then
          /* A high pass filter and a band stop filter have g(s->infinity) = 1
         and therefore filter.k = 1 is required, in ZerosAndPoles formulation
        */
          filter.k := gain;

        elseif filterType == Types.FilterType.BandPass then
          /* The gain due to the w-trasnformation must be added */
          filter.k := filter.k*gain*w_cut^(2*n_den2-n_num1);

        else
          Streams.error("analogFilter (= " + String(analogFilter) + ") is not supported");
        end if;

        annotation (Documentation(info="<html>

<h4>Syntax</h4>

<blockquote><pre>
zp = <b>filter</b>(analogFilter, filterType, order, f_cut, gain, A_ripple, normalized);
</pre></blockquote>

<h4>Description</h4>

<p>
This function constructs a ZerosAndPoles transfer function
description of low and high pass filters. For more details see also
<a href=\"modelica://Modelica_LinearSystems2.UsersGuide.Literature\">[Tietze2002]</a>, pp. 815-852.
</p>
<p>
Typical frequency responses for the 4 supported low pass filter types
are shown in the next figure (this figure was generated with function
<a href=\"modelica://Modelica_LinearSystems2.Examples.ZerosAndPoles.plotBodeFilter2\">Examples.ZerosAndPoles.plotBodeFilter2</a>):
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4Filters.png\">
</p>
<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4FiltersStepResponse.png\">
</p>
<p>
Obviously, the frequency responses give a somewhat wrong impression
of the filter characteristics: Although Butterworth and Chebyshev
filters have a significantly steeper magnitude as the
CriticalDamping and Bessel filters, the step responses of
the latter ones are much better. This means for example, that
a CriticalDamping or a Bessel filter should be selected,
if a filter is mainly used to make a non-linear inverse model
realizable.
</p>

<p>
Typical frequency responses for the 4 supported high pass filter types
are shown in the next figure:
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4Filters.png\">
</p>
<p>
The corresponding step responses of these high pass filters are
shown in the next figure:
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4FiltersStepResponse.png\">
</p>
<p>
All filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cutoff frequency is 3 dB. Note, when comparing the filters
of this function with other software systems, the setting of \"normalized\"
has to be selected appropriately. For example, the signal processing
toolbox of Matlab provides the filters in non-normalized form and
therefore a comparison makes only sense, if normalized = <b>false</b>
is set.


</p>

<h4>Example</h4>
<blockquote><pre>
   Types.AnalogFilter analogFilter=Types.AnalogFilter.CriticalDamping;
   Integer order=2;
   Modelica.Units.SI.Frequency f_cut=10;

   ZerosAndPoles zp_filter;

<b>algorithm</b>
    zp_filter=Modelica_LinearSystems2.ZerosAndPoles.Design.filter(
      order=order,
      f_cut=f_cut,
      analogFilter=analogFilter);

// zp_filter = 9530.93/( (p + 97.6265)^2 )
</pre></blockquote>
</html>"));
      end filter;

    end Design;

    encapsulated package Plot
      "Package of functions to plot zeros and poles description responses"
      extends Modelica.Icons.Package;
      import Modelica;

      encapsulated function polesAndZeros
        "Plot eigenvalues and or the zeros of a zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        import Modelica_LinearSystems2.Utilities.Plot;

        input ZerosAndPoles zp "Linear system in ZerosAndPoles form";
        input Boolean poles=true "= true, to plot the poles of zp" annotation(choices(checkBox=true));
        input Boolean zeros=true "= true, to plot the zeros of zp" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
         defaultDiagram = Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros());

    protected
        Real eval[ZerosAndPoles.Analysis.denominatorDegree(zp),2];
        Real invZerosRe[ZerosAndPoles.Analysis.numeratorDegree(zp)];
        Real invZerosIm[ZerosAndPoles.Analysis.numeratorDegree(zp)];

        Complex invZeros[:];
        Complex poles2[:];

        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2;
      algorithm
        (invZeros, poles2) := ZerosAndPoles.Analysis.zerosAndPoles(zp);

        for i in 1:size(invZeros, 1) loop
           invZerosRe[i] := invZeros[i].re;
           invZerosIm[i] := invZeros[i].im;
        end for;

        for i in 1:size(poles2, 1) loop
           eval[i,1] := poles2[i].re;
           eval[i,2] := poles2[i].im;
        end for;

        i :=0;
        if poles then
           i :=i + 1;
           curves[i] :=Plot.Records.Curve(
                              x=eval[:, 1],
                              y=eval[:, 2],
                              legend="poles",
                              autoLine=false,
                              linePattern=Plot.Types.LinePattern.None,
                              lineSymbol=Plot.Types.PointSymbol.Cross);
        end if;

        if zeros then
           i :=i + 1;
           curves[i] :=Plot.Records.Curve(
                              x=invZerosRe,
                              y=invZerosIm,
                              legend="zeros",
                              autoLine=false,
                              linePattern=Plot.Types.LinePattern.None,
                              lineSymbol=Plot.Types.PointSymbol.Circle);
        end if;

           diagram2 :=defaultDiagram;
           diagram2.curve :=curves[1:i];
           Plot.diagram(diagram2,device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>polesAndZeros</b>(zp);
   or
ZerosAndPoles.Plot.<b>polesAndZeros</b>(
  zp,
  poles=true,
  zeros=true,
  plot=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>());
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots a pole-zero-map of the poles and zeros of a transfer function
in ZerosAndPoles format. The Boolean inputs
\"poles\" and \"zeros\" define what to plot. If Boolean input \"plot = true\", the pole-zero-map
is plotted. If false, only the diagram is generated and returned as output argument.
The records \"defaultDiagram\" and \"device\" allow to set various layout options and the
size and location of the diagram on the screen.
</p>

<h4>Example</h4>
<p>
The example <a href=\"modelica://Modelica_LinearSystems2.Examples.ZerosAndPoles.plotPolesAndZeros\">
Modelica_LinearSystems2.Examples.ZerosAndPoles.plotPolesAndZeros</a>
defines a transfer functions as:
</p>

<blockquote><pre>
  TransferFunction s  = TransferFunction.s();
  TransferFunction tf = (s^3 + 4*s + 1)/(s^4 + 2*s^3 + 3*s^2 + 4*s);
  ZerosAndPoles    zp = ZerosAndPoles(tf);

  Modelica_LinearSystems2.ZerosAndPoles.Plot.polesAndZeros(zp=zp,
      defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
            heading=\"Poles and zeros of \" + String(tf)));
</pre></blockquote>

<p>
and results in
</p>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/polesAndZerosZP.png\">
</blockquote>
</html>"));
      end polesAndZeros;

      encapsulated function bode
        "Plot ZerosAndPoles transfer function as bode plot"
        import Modelica;
        import Modelica.Utilities.Streams.print;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;
        import Modelica.Units.SI;
        import Modelica_LinearSystems2.Utilities.Plot;

        input ZerosAndPoles zp "ZerosAndPoles transfer function to be plotted";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input SI.Frequency f_min(min=0) = 0.1
          "Minimum frequency value, if autoRange = false"
          annotation(Dialog(enable=not autoRange));
        input SI.Frequency f_max(min=0) = 10
          "Maximum frequency value, if autoRange = false"
          annotation(Dialog(enable=not autoRange));

        input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot(
            heading="Bode plot: "+ String(zp)));

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)"
          annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))"
          annotation(choices(checkBox=true),Dialog(enable=magnitude));

        input Boolean onFile=false
          "= true, if frequency response is stored on file as matrix [f,A,phi]"
          annotation(choices(checkBox=true));
        input String fileName="frequencyResponse.mat"
          "If onFile=true, file on which the frequency response will be stored"
          annotation(Dialog(enable=onFile));
        input String matrixName=if Hz and not dB then "fHz_A_phiDeg" elseif
                                   Hz and dB then "fHz_AdB_phiDeg" elseif
                                   not Hz and dB then "f_AdB_phiDeg" else "f_A_phiDeg"
          "If onFile=true, Name of matrix on file" annotation(Dialog(enable=onFile));
    protected
        SI.AngularVelocity w[nPoints];
        SI.Frequency f[nPoints];
          Modelica.Units.NonSI.Angle_deg phi[nPoints];
        Real A[nPoints];
        Real fAp[nPoints,if onFile then 3 else 0];
        Boolean OK;
        Complex c;
        Integer window=0;
        SI.Angle phi_old;
        Complex numZeros[:];
        Complex denZeros[:];
        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2[2];
        Boolean success;
      algorithm
        // Determine frequency vector f
        if autoRange then
          (numZeros,denZeros) := ZerosAndPoles.Analysis.zerosAndPoles(zp);
        else
          numZeros := fill(Complex(0), 0);
          denZeros := fill(Complex(0), 0);
        end if;
        f := Internal.frequencyVector(
          nPoints,
          autoRange,
          f_min,
          f_max,
          numZeros,
          denZeros,
          defaultDiagram.logX);

        // Compute magnitude/phase at the frequency points
        phi_old := 0.0;
        for i in 1:nPoints loop
          w[i] := Modelica.Units.Conversions.from_Hz(f[i]);
          c := ZerosAndPoles.Analysis.evaluate(
            zp,
            Complex(0, w[i]),
            1e-10);
          A[i] := Complex.'abs'(c);
          phi_old := Complex.arg(c, phi_old);
          phi[i] := Modelica.Units.Conversions.to_deg(phi_old);

          // Convert to other units, if required
          if not Hz then
             f[i] := w[i];
          end if;
          if dB then
             A[i] := 20*log10(A[i]);
          end if;
        end for;

        // Plot computed frequency response
        diagram2 := fill(defaultDiagram, 2);
        i := 0;
        if magnitude then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
            x=f,
            y=A,
            autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := if dB then "magnitude [dB]" else "magnitude";
          if phase then
             diagram2[i].xLabel:="";
          end if;
          if dB then
             diagram2[i].logY := false;
          end if;
        end if;

        if phase then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
            x=f,
            y=phi,
            autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := "phase [deg]";
          diagram2[i].logY := false;
          if magnitude then
            diagram2[i].heading:="";
          end if;
        end if;

        if not Hz then
           diagram2[i].xLabel:="Angular frequency [rad/s]";
        end if;

        if magnitude and phase then
          Plot.diagramVector(diagram2, device);
        else
          Plot.diagram(diagram2[1], device);
        end if;

        if onFile then
           fAp :=[f,A,phi];
           Modelica.Utilities.Files.removeFile(fileName);
           success:=writeMatrix(fileName,matrixName,fAp,append=false);
           if success then
              Modelica.Utilities.Streams.print("... Frequency response stored on file \"" +
                       Modelica.Utilities.Files.fullPathName(fileName) + "\"");
           end if;
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>bode</b>(zp)
   or
ZerosAndPoles.Plot.<b>bode</b>(
  zp,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>() )
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(p^2 + 5*p + 7)/(p + 2)/(p + 3);

<b>algorithm</b>
  Modelica_LinearSystems2.ZerosAndPoles.Plot.bode(zp)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</blockquote>
</html>"));
      end bode;

      encapsulated function timeResponse
        "Plot the time response of a system represented by a transfer function. The response type is selectable"
        import Modelica;
        import Modelica_LinearSystems2;
      //    import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.ZerosAndPoles zp;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        input Real x0[ZerosAndPoles.Analysis.denominatorDegree(zp)]=zeros(
          ZerosAndPoles.Analysis.denominatorDegree(zp)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="time response of  zp = " + String(zp)));

    protected
        Plot.Records.Curve curve;
        Plot.Records.Diagram diagram2;
        Real y[:,1,1] "Output response";
        Real t[:] "Time vector: (number of samples)";

      algorithm
        (y,t) := ZerosAndPoles.Analysis.timeResponse(
          zp,
          dt,
          tSpan,
          response,
          x0);

        curve := Plot.Records.Curve(
          x=t,
          y=y[:, 1, 1],
          legend="y",
          autoLine=true);
        diagram2 := defaultDiagram;
        diagram2.curve := {curve};

        Plot.diagram(diagram2, device);
        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>timeResponse</b>(zp);
   or
ZerosAndPoles.Plot.<b>timeResponse</b>(
  zp,
  dt,
  tSpan,
  response,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the time response of a transfer function. The character of the time response if defined by the input
<a href=\"modelica://Modelica_LinearSystems2.Types.TimeResponse\">response</a>, i.e. Impulse, Step, Ramp, or Initial.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(p + 1)/(p^2 + 5*p + 12);

  Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

<b>algorithm</b>
  Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse(zp, dt=0.02, tSpan=3, response=response)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/timeResponseZP.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end timeResponse;

      encapsulated function impulse "Impulse response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.ZerosAndPoles zp
          "zeros-and-poles transfer function";
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Real x0[ZerosAndPoles.Analysis.denominatorDegree(zp)]=zeros(ZerosAndPoles.Analysis.denominatorDegree(zp))
          "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Impulse response of  zp = " + String(zp)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse "type of time response";
      algorithm
        Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse(
          zp=zp,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>impulse</b>(zp)
   or
ZerosAndPoles.Plot.<b>impulse</b>(
  zp,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the impulse response of a zeros-and-poles transfer function. It is based on
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(p + 1)/(p^2 + 5*p + 12);

<b>algorithm</b>
   Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse(zp, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/impulseResponseZP.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end impulse;

      encapsulated function step "Step response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.ZerosAndPoles zp;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        input Real x0[ZerosAndPoles.Analysis.denominatorDegree(zp)]=zeros(
          ZerosAndPoles.Analysis.denominatorDegree(zp)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Step response of  zp = " + String(zp)));

      algorithm
        Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse(
          zp=zp,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>step</b>(zp)
   or
ZerosAndPoles.Plot.<b>step</b>(
  zp,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the step response of a zeros-and-poles transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(p + 1)/(p^2 + 5*p + 12);

<b>algorithm</b>
  Modelica_LinearSystems2.ZerosAndPoles.Plot.step(zp, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/stepResponseZP.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end step;

      encapsulated function ramp "Ramp response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.ZerosAndPoles zp;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";
        input Real x0[ZerosAndPoles.Analysis.denominatorDegree(zp)]=zeros(
          ZerosAndPoles.Analysis.denominatorDegree(zp)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Ramp response of  zp = " + String(zp)));

      algorithm
        Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse(
          zp=zp,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>ramp</b>(zp)
   or
ZerosAndPoles.Plot.<b>ramp</b>(
  zp,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the ramp response of a zeros-and-poles transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(2*p^2 + 7*p + 13)/(p + 1)/(p^2 + 5*p + 12);

<b>algorithm</b>
  Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp(zp)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/rampResponseZP.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end ramp;

      encapsulated function initialResponse "Initial condition response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.ZerosAndPoles zp;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";
        input Real y0 "Initial output (for initial condition plot)";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Initial response of  zp = " + String(zp) + " with y0 = " + String(y0)));

    protected
        Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(zp);
        Real x0[ZerosAndPoles.Analysis.denominatorDegree(zp)]=
            Modelica.Math.Matrices.equalityLeastSquares(
            ss.A,
            fill(0, size(ss.B, 1)),
            ss.C,
            vector(y0)) "Initial state vector (for initial condition plot)";
      algorithm

        Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse(
              zp=zp,
              dt=dt,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>initialResponse</b>(zp)
   or
ZerosAndPoles.Plot.<b>initialResponse</b>(
  zp,
  dt,
  tSpan,
  y0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the initial response, i.e. the zeros input response of a zeros and poles transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp = (p + 1)/(p^2 + 5*p + 12);
  Real y0=1;

<b>algorithm</b>
   Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponseZP(zp, y0=y0, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/ZerosAndPoles/initialResponseZP.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp\">ramp</a>
</p>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of ZerosAndPoles data record"
      extends Modelica.Icons.Package;
      import Modelica;

      function toTransferFunction
        "Generate a TransferFunction data record from a ZerosAndPoles data record"
        //encapsulated function fromZerosAndPoles
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.Math.Complex;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output TransferFunction tf(
          redeclare Real n[2*size(zp.n2,1)+size(zp.n1,1)+1],
          redeclare Real d[2*size(zp.d2,1)+size(zp.d1,1)+1]);

    protected
        Real k;
        Complex z[:];
        Complex p[:];
        Polynomial pn;
        Polynomial pd;
      algorithm
        (z,p,k) := ZerosAndPoles.Analysis.zerosAndPoles(zp);
        pn := Polynomial(z)*Polynomial(k);
        pd := Polynomial(p);
        tf.n := pn.c;
        tf.d := pd.c;
        tf.uName := zp.uName;
        tf.yName := zp.yName;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tf = ZerosAndPoles.Conversion.toStateSpace<b>toTransferFunction</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a TransferFunction record
</p>
<blockquote><pre>
      n(s)     b0 + b1*s + ... + bn*s^n
tf = ------ = --------------------------
      d(s)     a0 + a1*s + ... + an*s^n
</pre></blockquote>
<p>
from a ZerosAndPoles record representated by first and second order numerator and denominator polynomials. The poles and zeros and the gain <tt>k</tt> are computed (<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.zerosAndPoles\">zerosAndPoles</a>) and are used as inputs in the TransferFunction constructor.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp = 1/(p + 3)/(p + 1)

<b>algorithm</b>
  tf:=Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunction(zp);
//  tf = 1/( s^2 + 4*s + 3 )
</pre></blockquote>
</html>"));
      end toTransferFunction;

      encapsulated function toTransferFunctionMIMO
        "Generate a transfer function matrix  from zeros-and-poles transfer function matrix"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.TransferFunction;

        input ZerosAndPoles zp[:,:] "ZerosAndPoles transfer function of a system";

        output TransferFunction tf[size(zp, 1),size(zp, 2)];

    protected
        Integer ny=size(zp, 1);
        Integer nu=size(zp, 2);

      algorithm
        for iy in 1:ny loop
          for iu in 1:nu loop
            tf[iy, iu] := ZerosAndPoles.Conversion.toTransferFunction(zp[iy, iu]);
          end for;
        end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tf = ZerosAndPoles.Conversion.toStateSpace<b>toTransferFunctionMIMO</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Converts a matrix of ZerosAndPoles transfer functions denoted by the product of first and second order numerator and denominator polynomials into a matrix of transfer functions represented by (usual) numerator and denominator polynomial. The function repetitively uses <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunction\">toTransferFunction</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp = [1/(p + 2)/(p + 1);p/(p + 1)/(p + 1)]

<b>algorithm</b>
  tf := Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunction(zp);
//  tf = [1/( (p + 1)*(p + 2) ); p/( (p + 1)^2 )]
</pre></blockquote>
</html>"));
      end toTransferFunctionMIMO;

      function toMatrices
        "Convert a ZerosAndPoles object into the matrices A, B, C of a StateSpace"
       //encapsulated function fromZerosAndPoles
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output Real ABCD[ZerosAndPoles.Analysis.denominatorDegree(zp)+1,
            ZerosAndPoles.Analysis.denominatorDegree(zp)+1];

    protected
        Real ssA[ZerosAndPoles.Analysis.denominatorDegree(zp),ZerosAndPoles.Analysis.denominatorDegree(zp)]
          "system matrix of partial 2nd order system";
        Real ssB[ZerosAndPoles.Analysis.denominatorDegree(zp),1]
          "input matrix of partial 2nd order system";
        Real ssC[1,ZerosAndPoles.Analysis.denominatorDegree(zp)]
          "output matrix of partial 2nd order system";
        Real ssD[1,1] "feedthrough matrix of partial 2nd order system";

        Real A[2,2] "system matrix of partial 2nd order system";
        Real B[2,1] "input matrix of partial 2nd order system";
        Real C[1,2] "output matrix of partial 2nd order system";
        Real D[1,1] "feedthrough matrix of partial 2nd order system";
        Real a "system 'matrix' of partial 1st order system";
        Real b "input 'matrix' of partial 1st order system";
        Real c "output 'matrix' of partial 1st order system";
        Real d "feedthrough 'matrix' of partial 1st order system";
        Real eps=1e-6;
        Integer nx=max(ZerosAndPoles.Analysis.numeratorDegree(zp),ZerosAndPoles.Analysis.denominatorDegree(zp));
        Integer n_num1=size(zp.n1, 1);
        Integer n_num2=size(zp.n2, 1);
        Integer n_den1=size(zp.d1, 1);
        Integer n_den2=size(zp.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;

        Integer i_d=if n_num2 > n_den2 then 2*(n_num2 - n_den2) + 1 else 1;
        Integer i_k=if n_num2 > n_den2 then n_den2 - (n_num2 - n_den2) else n_den2;
        Integer i;
        Integer ili=if max(n_den2, n_num2) > 0 then i_d else  max(2, i_d);

        Real num[nx,2]=[zp.n2; [zp.n1,zeros(n_num1)]; zeros(max(0,nx - n_num2 - n_num1), 2)]
          "Numerator matrix, in order that indices are defined in all situations in all if clauses";
        Real den[nx,2]=[zp.d2; [zp.d1,zeros(n_den1)]; zeros(max(0,nx - n_den2 - n_den1), 2)]
          "Denominator matrix, in order that indices are defined in all situations in all if clauses";
        Real k[i_k + n_den1](each fixed=false)
          "Additional factors of the first and second order blocks, in order that the gain of the blocks is 1";
        Real k_total;

        Boolean dZero=true;

       //ZerosAndPoles zp2;

      algorithm
        assert(n_num <= n_den,
          "ZerosAndPoles transfer function is not proper as required from StateSpace system:\n"
           + "  numerator degree (= " + String(n_num) +
          ") <= denominator degree (= " + String(n_den) + ") required.");

        if n_den > 0 then
          for i in 1:max(n_den2, n_num2) loop
            // State space systems of order 2
            if i <= n_den2 then
              if i <= n_num2 then
                  // State space system in form (1)
                k[i] := StateSpace.Internal.scaleFactor2(
                    num[i, 1],
                    num[i, 2],
                    den[i, 1],
                    den[i, 2],eps);
              elseif 2*(i - n_num2) <= n_num1 then
                  // State space system in form (1) with 2 first order numerator polynomials
                k[i] := StateSpace.Internal.scaleFactor2(
                    num[max(1,2*(i - n_num2)-1), 1] + num[max(1,2*(i - n_num2)), 1],
                    num[max(1,2*(i - n_num2)-1), 1]*num[max(1,2*(i - n_num2)), 1],
                    den[i, 1],
                    den[i, 2],eps);
              elseif  2*(i-n_num2) -1== n_num1 then
                  // State space system in form (2) with 1 first order numerator polynomial
                k[i] := StateSpace.Internal.scaleFactor2(
                    1,
                    num[2*i-n_num2-1, 1],
                    den[i, 1],
                    den[i, 2],eps);
              else
                  // State space system in form (3)
                k[i] := StateSpace.Internal.scaleFactor2(
                    1,
                    1,
                    den[i, 1],
                    den[i, 2],eps);
              end if;
            else
               // State space system in form (1) with 2 first order denominator polynomials
              k[i] := StateSpace.Internal.scaleFactor2(
                  num[i, 1],
                  num[i, 2],
                  den[max(1,2*(i - n_den2)-1), 1] + den[max(1,2*(i - n_den2)), 1],
                  den[max(1,2*(i - n_den2)-1), 1]*den[max(1,2*(i - n_den2)), 1],eps);
            end if;
          end for;

          for i in i_d:n_den1 loop
            // State space systems of order 1
            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(num[max(1, n_num2 + 2*(n_den2 -
                n_num2) + i), 1], den[n_den2 + i, 1],eps);
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(num[max(1, n_num2 + i - i_d + 1),
                1], den[n_den2 + i, 1],eps);
            else
               // State space system in form (5)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(1, den[n_den2 + i, 1],eps);
            end if;
          end for;

          k_total := zp.k/product(k);

          ssA := zeros(nx, nx);
          ssB := zeros(nx, 1);
          ssC := zeros(1, nx);
          ssD := zeros(1, 1);

       // Calculation of matrices A, B, C, D
       //first elements of A, B, C and D
          if max(n_den2, n_num2) > 0 then
            A[1, :] := {0,1};
            B[1, 1] := 0;
            // Construct state space systems of order 2
            if 1 <= n_den2 then
              A[2, :] := {-den[1, 2],-den[1, 1]};
              B[2, 1] := if abs(den[1, 2])>eps and abs(num[1, 2])>eps then den[1, 2] else 1;

              if 1 <= n_num2 then
                // State space system in form (1)
                C := if abs(den[1, 2])>eps and abs(num[1, 2])>eps then k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]]/den[1, 2] else k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;
             elseif 1 - n_num2 + 1 <= n_num1 then
              // State space system in form (1) with 2 first order numerator polynomials
                B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then   k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]]/den[1, 2] else k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;
             elseif 1 - n_num2 == n_num1 then
                     // State space system in form (2) with 1 first order numerator polynomial
                B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then k[1]*[num[1, 1],1]/den[1, 2] else k[1]*[num[1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                     // State space system in form (3)
                B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then  k[1]*[1,0]/den[1, 2] else k[1]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;
            else
              // State space system in form (1) with 2 first order denominator polynomials
              A[2, :] := {-(den[1, 1]*den[2, 1]),-(den[1, 1] + den[2, 1])};
              B[2, 1] := if abs(den[1, 1]*den[2, 1])>eps then den[1, 1]*den[2, 1] else 1;
              C := if abs(den[1, 1]*den[2, 1])>eps then  k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])]/den[1, 1]/den[2, 1] else k[1]*[num[1, 2],num[1, 1] - den[2, 1]];
              D := [k[1]];
              dZero := false;
            end if;
            ssA[1:2, 1:2] := A;
            ssB[1:2, 1] := vector(B);
            ssC[1, 1:2] := vector(C);
            ssD := D;

          else

         // Construct state space systems of order 1
            a := -den[1, 1];

            if 1 <= n_num1 then
                  // State space system in form (4)
              b := if abs(den[1, 1])>eps then den[1,1] else num[1,1];
              c := if abs(den[1, 1])>eps then k[1]*(num[1, 1] - den[1, 1])/den[1, 1] else k[1];
              d := k[1];
              dZero := false;
            else
                  // State space system in form (5)
              b := if abs(den[1, 1])>eps then den[1,1] else if n_num1>0 then num[1,1] else 1;
              c := if abs(den[1, 1])>eps then k[1]/den[1, 1] else k[1];
              d := 0;
              dZero := dZero and true;
            end if;
            ssA[1, 1] := a;
            ssB[1, 1] := b;
            ssC[1, 1] := c;
            ssD[1, 1] := d;

          end if;
       /// for i=2 to degree(system)
          A[1, :] := {0,1};
          B[1, 1] := 0;
          for i in 2:max(n_den2, n_num2) loop
               // Construct state space systems of order 2
            if i <= n_den2 then
              A[2, :] := {-den[i, 2],-den[i, 1]};
              B[2, 1] := if abs(den[i, 2])>eps and abs(num[i, 2])>eps then den[i, 2] else 1;
              if i <= n_num2 then
                     // State space system in form (1)
                C := if abs(den[i, 2])>eps and abs(num[i, 2])>eps then k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]]/den[i, 2] else k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;
              elseif 2*(i - n_num2) <= n_num1 then
                // State space system in form (1) with 2 first order numerator polynomials
                C := if abs(den[i, 2])>eps and abs(num[2*i-n_num2-1, 2])>eps then k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]]/den[i, 2] else k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;
              elseif 2*(i-n_num2) -1== n_num1 then
              // State space system in form (2) with 1 first order numerator polynomial
              B[2, 1] := if abs(den[i, 2])>eps then den[i, 2] else 1;
                C := if abs(den[i, 2])>eps then k[i]*[num[2*i-n_num2-1, 1],1]/den[i, 2] else k[i]*[num[2*i-n_num2-1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                // State space system in form (3)
                B[2, 1] := if abs(den[i, 2])>eps then den[i, 2] else 1;
                C := if abs(den[i, 2])>eps then k[i]*[1,0]/den[i, 2] else k[i]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;

            else
                  // State space system in form (1) with 2 first order denominator polynomials
              A[2, :] := {-(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),-(den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])};
              B[2, 1] := if abs(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1])>eps then den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1] else 1;
              C := if abs(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1])>eps then k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])]/den[max(2*(i-n_den2)-1,i), 1]/den[max(2*(i-n_den2),i), 1] else k[i]*[num[max(2*(i-n_num2),i), 2],num[max(2*(i-n_num2),i), 1] - den[max(2*(i-n_den2),i), 1]];
              D := [k[i]];
              dZero := false;
            end if;
            ssA[2*i, 1:2*i - 2] := B[2, 1]*ssC[1, 1:2*i - 2];
            ssA[2*i - 1:2*i, 2*i - 1:2*i] := A;
            ssB[2*i, 1] := if dZero then 0 else B[2, 1]*ssD[1, 1];
            ssC[1, 1:2*i - 2] := if dZero then fill(0, 2*i - 2) else D[1, 1]*ssC[
              1, 1:2*i - 2];
            ssC[1, 2*i - 1:2*i] := vector(C);
            ssD := D*ssD;
          end for;
       //  for i in max(2,i_d):n_den1 loop
          for i in ili:n_den1 loop
               // Construct state space systems of order 1
            a := if abs(den[n_den2 + i, 1])>eps then -den[n_den2 + i, 1] else 0.0;

            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
                  // State space system in form (4)

              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]*(num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1] -  den[n_den2 + i, 1])/den[n_den2 + i, 1] else 1.0;
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1];
              d := k[i_k + i];
              dZero := false;
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
                  // State space system in form (4)
              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]*(num[max(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1])/den[n_den2 + i, 1] else 1.0;
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else num[max(1, n_num2 + i - i_d + 1), 1];
              d := k[i_k + i];
              dZero := false;
            else
                  // State space system in form (5)
              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]/den[n_den2 + i, 1] else k[i_k + i];
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else 1;
              d := 0;
              dZero := dZero and true;
            end if;
            ssA[2*n_den2 + i, 1:2*n_den2 + i - 1] := b*ssC[1, 1:2*n_den2 + i - 1];
            ssA[2*n_den2 + i, 2*n_den2 + i] := a;
            ssB[2*n_den2 + i, 1] := if dZero then 0 else b*ssD[1, 1];
            ssC[1, 1:2*n_den2 + i - 1] := if dZero then fill(0, 2*n_den2 + i - 1) else
                    d*ssC[1, 1:2*n_den2 + i - 1];
            ssC[1, 2*n_den2 + i] := c;
            ssD := if dZero then [0] else d*ssD;

          end for;

          ssC := k_total*ssC;
          ssD := k_total*ssD;
        else
          ABCD := [zp.k];
        end if;

        ABCD := [ssA,ssB; ssC,ssD];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ABCD = ZerosAndPoles.Conversion.toStateSpace<b>toStateSpace</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
This function transforms a zeros-poles-gain system representation into state space representation.
To achieve well numerical condition the ZerosAndPoles transfer function is transformed into state space
form by creating first and second order blocks that are connected
together in series. Every block is represented in controller
canonical form and scaled such that the gain from the input
of this block to its output is one (i.e. y(p=0) = u(p=0)),
if this is possible. Details are given below.
</p>

<h4>Algorithmic details</h4>
<p>
The ZerosAndPoles transfer function is defined as:
</p>
<blockquote><pre>
         product(p + n1[i]) * product(p^2 + n2[i,1]*p + n2[i,2])
y = k * --------------------------------------------------------- * u
         product(p + d1[i]) * product(p^2 + d2[i,1]*p + d2[i,2])
</pre></blockquote>
<p>
This is treated as a series connection of first and second order
systems. If size(n1) == size(d1) and size(n2) == size(d2)
this gives the following sequence of operations:
</p>
<blockquote><pre>
      p^2 + n2[1,1]*p + n2[1,2]
y_1 = ------------------------- * u
      p^2 + d2[1,1]*p + d2[1,2]
&nbsp;
      p^2 + n2[2,1]*p + n2[2,2]
y_2 = ------------------------- * y_1
      p^2 + d2[2,1]*p + d2[2,2]
&nbsp;
  ...
&nbsp;
      p + n1[..]
y_n = ---------- * y_(n-1)
      p + d1[..]
&nbsp;
  y = k*y_n
</pre></blockquote>
<p>
Based on this representation, evrey block with transfer function G(p) could be transformed into
</p>
<blockquote><pre>
G(p) = k * F(p)
</pre></blockquote>
<p>
with F(p) has unit gain. This leads to representations of the forms
</p>
<blockquote><pre>
          a2 + a1*p + p^2       a2      b2 + a1*b2/a2*p + b2/a2*p^2
G(p) = -------------------- = ---- * ------------------------------ = k * F(p),  k = a2/b2  (1)
          b2 + b1*p + p^2       b2           b2 + b1*p + p^2
</pre></blockquote>
<p>
for second order systems and
</p>
<blockquote><pre>
        a + p     a     b + b/a*p
G(p) = ------- = --- * ----------- = k * F(p),   k = a/b
        b + p     b       b + p
</pre></blockquote>
<p>
for first order systems respectively.
</p>
<p>
The complete system is now considered as the series connections of all
the single unit gain transfer functions and an overall gain k with
</p>
<blockquote><pre>
k = product(ki).
</pre></blockquote>

<p>
In the general case, the following system structures
and the corresponding state space systems can appear
(note, 'c' is the reciprocal local gain 1/k):
</p>
<blockquote><pre>
(1)
          a2 + a1*p + p^2           der(x1) = x2
    y = ---------------------  -->  der(x2) = -b2*x1 - b1*x2 + b2*u
          b2 + b1*p + p^2                 y = c*((a2-b2)*x1 + (a1-b1)*x2 + u),  c = b2/a2
&nbsp;
(2)
             p + a                 der(x1) = x2
    y = ---------------- * u  -->  der(x2) = -b2*x1 - b1*x2 + b2*u
        b2 + b1*p + p^2                  y = k*(a1/b2*x1 +x2/b2),  c = b2/a
&nbsp;
(3)
               1                  der(x1) = x2
    y = --------------- *u   -->  der(x2) = -b2*x1 - b1*x2 + b2*u
        b2 + b1*p + p^2                 y = c*x1/b2,  c = b2
&nbsp;
(4)
       a + p                       der(x) = -b*x + b*u
   y = ----- * u             -->        y = c*((a-b)/b*x + u),  c = b/a
       b + p
&nbsp;
(5)
         1
   y = ----- * u             -->   der(x) = -b*x + b*u
       b + p                            y = x,  c = b

</pre></blockquote>
<p>
If the sizes of the numerator and denominator polynomials
do not match, the small systems are built in the
following way:
</p>
<blockquote><pre>
(1) Build systems of form (1) by combining
    - 1 d2 and 1 n2
      (= 1 second order denominator and 1 second order numerator) or
    - 1 d2 and 2 n1 or
    - 2 d1 and 1 n2
(2) Build at most one system of form (2) by combining
    - 1 d2 and 1 n2
(3) Build systems of form (3) by
    - 1 d2
(4) Build systems of form (4) by combining
    - 1 d1 and 1 n1
(5) Build systems of form (5) by
    - 1 d1
</pre></blockquote>
<p>
The numeric properties of the resulting state space system
depends on which first and second order polynomials are
combined and connected together. From a numerical point of view, it
would therefore be useful to combine the polynomials
based on the numeric values of the polynomial coefficients,
(e.g., in a first step the polynomials could be sorted
according to their cut-off frequency).
</p>
<p>
However, this has the disadvantage that the structure of the
resulting state space system depends on the numeric
values of the polynomial coefficients. Since Modelica
environments perform symbolic pre-processing on equations,
this would mean that a change of a polynomial coefficient
requires to newly compile the state space system.
</p>
<p>
If, on the other hand, the structure of the state
space system depends only on dimension information
of the n1,n2,d1,d2 arrays, then the polynomial coefficients
can be changed without a new translation of the model.
This is the major reason why the structure of the
state space system in the implementation of this block
is based only on dimension information.
</p>
<p>
This is, e.g., not critical for the provided filters:
The dimension of the n1,n2,d1,d2 arrays depend for
filters only on the filter characteristics
(Bessel, Butterworth etc.), the filter type (low pass,
high pass etc.) and on the filter order. If any
of this data is changed, the model has to be
newly compiled. All the other filter data, such as
cut-off frequency or ripple amplitude, can be changed
without re-compilation of the model.
The ZerosAndPoles transfer function is now constructed
for the filters in such a way that the filter zeros
and poles are appropriately sorted to give better
numerical properties.
</p>
<p>
Another alternative implementation of the state
space system would be to use the function controller canonical
form that directly results from the transfer function.
The severe disadvantage
of this approach is that the structure of the state
space system from above is lost for the symbolic preprocessing.
If, e.g., index reduction has to be applied (e.g. since a
filter is used to realize a non-linear inverse model),
then the tool cannot perform the index reduction.
Example:
</p>
<p>
Assume, a generic first order state space system
is present
</p>
<blockquote><pre>
<b>der</b>(x) = a*x + b*u
     y = c*x + d*u
</pre></blockquote>
<p>
and the values of the scalars a,b,c,d are parameters
that might be changed before the simulation starts.
If y has to be differentiated symbolically during code
generation, then
</p>
<blockquote><pre>
<b>der</b>(y) = c*<b>der</b>(x) + d*<b>der</b>(u)
<b>der</b>(x) = a*x + b*u
</pre></blockquote>
<p>
As a result, u needs to be differentiated too, and this
might not be possible and therefore translation might fail.
</p>
<p>
On the other hand, if the first order system is
defined to be a low pass filter and the state space
system is generated by keeping this structure, we have
(see form (5) above):
</p>
<blockquote><pre>
<b>der</b>(x) = -b*x + u
      y = x
</pre></blockquote>
<p>
Differentiating y symbolically leads to:
</p>
<blockquote><pre>
<b>der</b>(y) = <b>der</b>(x)
<b>der</b>(x) = -b*x + u
</pre></blockquote>
<p>
Therefore, in this case, the derivative of u is not
needed and the tool can continue with the symbolic
processing.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2 + p +1);

<b>algorithm</b>
  ABCD := Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace(zp);
// ssA = [0, 1; -1, -1],
// ssB = [0; 1],
// ssC = [1, 1],
// ssD = [0],
</pre></blockquote>
</html>"));
      end toMatrices;

      function toStateSpace
        "Transform a ZerosAndPoles object into a StateSpace object"
        //encapsulated function fromZerosAndPoles
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input ZerosAndPoles zp "ZerosAndPoles transfer function of a system";
        output StateSpace ss(
          redeclare Real A[ZerosAndPoles.Analysis.denominatorDegree(zp),
            ZerosAndPoles.Analysis.denominatorDegree(zp)],
          redeclare Real B[ZerosAndPoles.Analysis.denominatorDegree(zp),1],
          redeclare Real C[1,ZerosAndPoles.Analysis.denominatorDegree(zp)],
          redeclare Real D[1,1]) "Transfer function in StateSpace SISO form";

    protected
        Real A[2,2] "system matrix of partial 2nd order system";
        Real B[2,1] "input matrix of partial 2nd order system";
        Real C[1,2] "output matrix of partial 2nd order system";
        Real D[1,1] "feedthrough matrix of partial 2nd order system";
        Real a "system 'matrix' of partial 1st order system";
        Real b "input 'matrix' of partial 1st order system";
        Real c "output 'matrix' of partial 1st order system";
        Real d "feedthrough 'matrix' of partial 1st order system";
        Real eps = 1e-6;
        Integer nx=max(ZerosAndPoles.Analysis.numeratorDegree(zp),ZerosAndPoles.Analysis.denominatorDegree(zp));
        Integer n_num1=size(zp.n1, 1);
        Integer n_num2=size(zp.n2, 1);
        Integer n_den1=size(zp.d1, 1);
        Integer n_den2=size(zp.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;

        Integer i_d=if n_num2 > n_den2 then 2*(n_num2 - n_den2) + 1 else 1;
        Integer i_k=if n_num2 > n_den2 then n_den2 - (n_num2 - n_den2) else n_den2;
        Integer i;
        Integer ili=if max(n_den2, n_num2) > 0 then i_d else  max(2, i_d);

        Real num[nx,2]=[zp.n2; [zp.n1,zeros(n_num1)]; zeros(max(0,nx - n_num2 - n_num1), 2)]
          "Numerator matrix, in order that indices are defined in all situations in all if clauses";
        Real den[nx,2]=[zp.d2; [zp.d1,zeros(n_den1)]; zeros(max(0,nx - n_den2 - n_den1), 2)]
          "Denominator matrix, in order that indices are defined in all situations in all if clauses";
        Real k[i_k + n_den1](each fixed=false)
          "Additional factors of the first and second order blocks, in order that the gain of the blocks is 1";
        Real k_total;

        Boolean dZero=true;

      algorithm
        assert(n_num <= n_den,
          "ZerosAndPoles transfer function is not proper as required from StateSpace system:\n"
           + "  numerator degree (= " + String(n_num) +
          ") <= denominator degree (= " + String(n_den) + ") required.");

        if n_den > 0 then
          for i in 1:max(n_den2, n_num2) loop
            // State space systems of order 2
            if i <= n_den2 then
              if i <= n_num2 then
                  // State space system in form (1)
                k[i] := StateSpace.Internal.scaleFactor2(
                    num[i, 1],
                    num[i, 2],
                    den[i, 1],
                    den[i, 2],eps);
              elseif 2*(i - n_num2) <= n_num1 then
                  // State space system in form (1) with 2 first order numerator polynomials
                k[i] := StateSpace.Internal.scaleFactor2(
                    num[2*(i - n_num2)-1, 1] + num[2*(i - n_num2), 1],
                    num[2*(i - n_num2)-1, 1]*num[2*(i - n_num2), 1],
                    den[i, 1],
                    den[i, 2],eps);
              elseif  2*(i-n_num2) -1== n_num1 then
                  // State space system in form (2) with 1 first order numerator polynomial
                k[i] := StateSpace.Internal.scaleFactor2(
                    1,
                    num[2*i-n_num2-1, 1],
                    den[i, 1],
                    den[i, 2],eps);
               else
                  // State space system in form (3)
                k[i] := StateSpace.Internal.scaleFactor2(
                    1,
                    1,
                    den[i, 1],
                    den[i, 2],eps);
              end if;
            else
               // State space system in form (1) with 2 first order denominator polynomials
              k[i] := StateSpace.Internal.scaleFactor2(
                  num[i, 1],
                  num[i, 2],
                  den[2*(i - n_den2)-1, 1] + den[2*(i - n_den2), 1],
                  den[2*(i - n_den2)-1, 1]*den[2*(i - n_den2), 1],eps);
            end if;
          end for;

          for i in i_d:n_den1 loop
            // State space systems of order 1
            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(num[max(1, n_num2 + 2*(n_den2 -
                n_num2) + i), 1], den[n_den2 + i, 1],eps);
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(num[max(1, n_num2 + i - i_d + 1),
                1], den[n_den2 + i, 1],eps);
            else
               // State space system in form (5)
              k[i_k + i] := StateSpace.Internal.scaleFactor1(1, den[n_den2 + i, 1],eps);
            end if;
          end for;

          k_total := zp.k/product(k);

          ss.A := zeros(nx, nx);
          ss.B := zeros(nx, 1);
          ss.C := zeros(1, nx);
          ss.D := zeros(1, 1);

       // Calculation of matrices A, B, C, D
       //first elements of A, B, C and D
          if max(n_den2, n_num2) > 0 then
            A[1, :] := {0,1};
            B[1, 1] := 0;
            // Construct state space systems of order 2
            if 1 <= n_den2 then
              A[2, :] := {-den[1, 2],-den[1, 1]};
              B[2, 1] := if abs(den[1, 2])>eps and abs(num[1, 2])>eps then den[1, 2] else 1;

              if 1 <= n_num2 then
               // State space system in form (1)
                C := if abs(den[1, 2])>eps and abs(num[1, 2])>eps then k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]]/den[1, 2] else k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;
             elseif 1 - n_num2 + 1 <= n_num1 then
              // State space system in form (1) with 2 first order numerator polynomials
              B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then   k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]]/den[1, 2] else k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;
             elseif 1 - n_num2 == n_num1 then
              // State space system in form (2) with 1 first order numerator polynomial
                B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then k[1]*[num[1, 1],1]/den[1, 2] else k[1]*[num[1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                     // State space system in form (3)
                B[2, 1] := if abs(den[1, 2])>eps then den[1, 2] else 1;
                C := if abs(den[1, 2])>eps then  k[1]*[1,0]/den[1, 2] else k[1]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;
            else
              // State space system in form (1) with 2 first order denominator polynomials
              A[2, :] := {-(den[1, 1]*den[2, 1]),-(den[1, 1] + den[2, 1])};
              B[2, 1] := if abs(den[1, 1]*den[2, 1])>eps then den[1, 1]*den[2, 1] else 1;
              C := if abs(den[1, 1]*den[2, 1])>eps then  k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])]/den[1, 1]/den[2, 1] else k[1]*[num[1, 2],num[1, 1] - den[2, 1]];
              D := [k[1]];
              dZero := false;
            end if;
            ss.A[1:2, 1:2] := A;
            ss.B[1:2, 1] := vector(B);
            ss.C[1, 1:2] := vector(C);
            ss.D := D;

          else

         // Construct state space systems of order 1
            a := -den[1, 1];

            if 1 <= n_num1 then
              // State space system in form (4)
              b := if abs(den[1, 1])>eps then den[1,1] else num[1,1];
              c := if abs(den[1, 1])>eps then k[1]*(num[1, 1] - den[1, 1])/den[1, 1] else k[1];
              d := k[1];
              dZero := false;
            else
             // State space system in form (5)
              b := if abs(den[1, 1])>eps then den[1,1] else if n_num1>0 then num[1,1] else 1;
              c := if abs(den[1, 1])>eps then k[1]/den[1, 1] else k[1];
              d := 0;
              dZero := dZero and true;
            end if;
            ss.A[1, 1] := a;
            ss.B[1, 1] := b;
            ss.C[1, 1] := c;
            ss.D[1, 1] := d;

          end if;
       /// for i=2 to degree(system)
          A[1, :] := {0,1};
          B[1, 1] := 0;
          for i in 2:max(n_den2, n_num2) loop
               // Construct state space systems of order 2
            if i <= n_den2 then
              A[2, :] := {-den[i, 2],-den[i, 1]};
              B[2, 1] := if abs(den[i, 2])>eps and abs(num[i, 2])>eps then den[i, 2] else 1;

              if i <= n_num2 then
                     // State space system in form (1)

                C := if abs(den[i, 2])>eps and abs(num[i, 2])>eps then k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]]/den[i, 2] else k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;

              elseif 2*(i - n_num2) <= n_num1 then
                // State space system in form (1) with 2 first order numerator polynomials
                C := if abs(den[i, 2])>eps and abs(num[2*i-n_num2-1, 2])>eps then k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]]/den[i, 2] else k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;

              elseif 2*(i-n_num2) -1== n_num1 then
              // State space system in form (2) with 1 first order numerator polynomial
              B[2, 1] := if abs(den[i, 2])>eps then den[i, 2] else 1;
                C := if abs(den[i, 2])>eps then k[i]*[num[2*i-n_num2-1, 1],1]/den[i, 2] else k[i]*[num[2*i-n_num2-1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                // State space system in form (3)
                B[2, 1] := if abs(den[i, 2])>eps then den[i, 2] else 1;
                C := if abs(den[i, 2])>eps then k[i]*[1,0]/den[i, 2] else k[i]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;

            else
                  // State space system in form (1) with 2 first order denominator polynomials
              A[2, :] := {-(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),-(den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])};
              B[2, 1] := if abs(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1])>eps then den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1] else 1;
              C := if abs(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1])>eps then k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])]/den[max(2*(i-n_den2)-1,i), 1]/den[max(2*(i-n_den2),i), 1] else k[i]*[num[max(2*(i-n_num2),i), 2],num[max(2*(i-n_num2),i), 1] - den[max(2*(i-n_den2),i), 1]];
              D := [k[i]];
              dZero := false;
            end if;
            ss.A[2*i, 1:2*i - 2] := B[2, 1]*ss.C[1, 1:2*i - 2];
            ss.A[2*i - 1:2*i, 2*i - 1:2*i] := A;
            ss.B[2*i, 1] := if dZero then 0 else B[2, 1]*ss.D[1, 1];
            ss.C[1, 1:2*i - 2] := if dZero then fill(0, 2*i - 2) else D[1, 1]*ss.C[
              1, 1:2*i - 2];
            ss.C[1, 2*i - 1:2*i] := vector(C);
            ss.D := D*ss.D;
          end for;
       //  for i in max(2,i_d):n_den1 loop
          for i in ili:n_den1 loop
               // Construct state space systems of order 1
            a := if abs(den[n_den2 + i, 1])>eps then -den[n_den2 + i, 1] else 0.0;

            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
                  // State space system in form (4)

              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]*(num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1] -  den[n_den2 + i, 1])/den[n_den2 + i, 1] else 1.0;
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1];
              d := k[i_k + i];
              dZero := false;
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
            // State space system in form (4)
              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]*(num[max(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1])/den[n_den2 + i, 1] else 1.0;
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else num[max(1, n_num2 + i - i_d + 1), 1];
              d := k[i_k + i];
              dZero := false;
            else
             // State space system in form (5)
              c := if abs(den[n_den2 + i, 1])>eps then k[i_k + i]/den[n_den2 + i, 1] else k[i_k + i];
              b := if abs(den[n_den2 + i, 1])>eps then den[n_den2 + i, 1] else 1;
              d := 0;
              dZero := dZero and true;
            end if;
            ss.A[2*n_den2 + i, 1:2*n_den2 + i - 1] := b*ss.C[1, 1:2*n_den2 + i - 1];
            ss.A[2*n_den2 + i, 2*n_den2 + i] := a;
            ss.B[2*n_den2 + i, 1] := if dZero then 0 else b*ss.D[1, 1];
            ss.C[1, 1:2*n_den2 + i - 1] := if dZero then fill(0, 2*n_den2 + i - 1) else
                    d*ss.C[1, 1:2*n_den2 + i - 1];
            ss.C[1, 2*n_den2 + i] := c;
            ss.D := if dZero then [0] else d*ss.D;

          end for;

          ss.C := k_total*ss.C;
          ss.D := k_total*ss.D;
        else
          ss := Modelica_LinearSystems2.StateSpace(zp.k);
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = ZerosAndPoles.Conversion.toStateSpace<b>toStateSpace</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
This function transforms a zeros-poles-gain system representation into state space representation.
To achieve well numerical condition the ZerosAndPoles transfer function is transformed into state space
form by creating first and second order blocks that are connected
together in series. Every block is represented in controller
canonical form and scaled such that the gain from the input
of this block to its output is one (i.e. y(p=0) = u(p=0)),
if this is possible. Details are given below.
</p>

<h4>Algorithmic details</h4>
<p>
The ZerosAndPoles transfer function is defined as:
</p>
<blockquote><pre>
         product(p + n1[i]) * product(p^2 + n2[i,1]*p + n2[i,2])
y = k * --------------------------------------------------------- * u
         product(p + d1[i]) * product(p^2 + d2[i,1]*p + d2[i,2])
</pre></blockquote>
<p>
This is treated as a series connection of first and second order
systems. If size(n1) == size(d1) and size(n2) == size(d2)
this gives the following sequence of operations:
</p>
<blockquote><pre>
      p^2 + n2[1,1]*p + n2[1,2]
y_1 = ------------------------- * u
      p^2 + d2[1,1]*p + d2[1,2]
&nbsp;
      p^2 + n2[2,1]*p + n2[2,2]
y_2 = ------------------------- * y_1
      p^2 + d2[2,1]*p + d2[2,2]
&nbsp;
  ...
&nbsp;
      p + n1[..]
y_n = ---------- * y_(n-1)
      p + d1[..]
&nbsp;
  y = k*y_n
</pre></blockquote>
<p>
Based on this representation, evrey block with transfer function G(p) could be transformed into
</p>
<blockquote><pre>
G(p) = k * F(p)
</pre></blockquote>
<p>
with F(p) has unit gain. This leads to representations of the forms
</p>
<blockquote><pre>
        a2 + a1*p + p^2     a2     b2 + a1*b2/a2*p + b2/a2*p^2
G(p) = ----------------- = ---- * ----------------------------- = k * F(p),  k = a2/b2  (1)
        b2 + b1*p + p^2     b2           b2 + b1*p + p^2
</pre></blockquote>
<p>
for second order systems and
</p>
<blockquote><pre>
        a + p     a     b + b/a*p
G(p) = ------- = --- * ----------- = k * F(p),   k = a/b
        b + p     b      b + p
</pre></blockquote>
<p>
for first order systems respectively.
</p>
<p>
The complete system is now considered as the series connections of all
the single unit gain transfer functions and an overall gain k with
</p>
<blockquote><pre>
k = product(ki).
</pre></blockquote>
<p>
In the general case, the following system structures
and the corresponding state space systems can appear
(note, 'c' is the reciprocal local gain 1/k):
</p>
<blockquote><pre>
(1)
          a2 + a1*p + p^2           der(x1) = x2
    y = ---------------------  -->  der(x2) = -b2*x1 - b1*x2 + b2*u
          b2 + b1*p + p^2                 y = c*((a2-b2)/b2*x1 + (a1-b1)/b2*x2 + u),  c = b2/a2
&nbsp;
(2)
             p + a                 der(x1) = x2
    y = ---------------- * u  -->  der(x2) = -b2*x1 - b1*x2 + b2*u
        b2 + b1*p + p^2                  y = k*(a/b2*x1 +x2/b2),  c = b2/a
&nbsp;
(3)
               1                  der(x1) = x2
    y = --------------- *u   -->  der(x2) = -b2*x1 - b1*x2 + b2*u
        b2 + b1*p + p^2                 y = c*x1/b2,  c = b2
&nbsp;
(4)
       a + p                       der(x) = -b*x + b*u
   y = ----- * u             -->        y = c*((a-b)/b*x + u),  c = b/a
       b + p
&nbsp;
(5)
         1
   y = ----- * u             -->   der(x) = -b*x + b*u
       b + p                            y = x,  c = b

</pre></blockquote>

<p>
If the sizes of the numerator and denominator polynomials
do not match, the small systems are built in the
following way:
</p>
<blockquote><pre>
(1) Build systems of form (1) by combining
    - 1 d2 and 1 n2
      (= 1 second order denominator and 1 second order numerator) or
    - 1 d2 and 2 n1 or
    - 2 d1 and 1 n2
(2) Build at most one system of form (2) by combining
    - 1 d2 and 1 n2
(3) Build systems of form (3) by
    - 1 d2
(4) Build systems of form (4) by combining
    - 1 d1 and 1 n1
(5) Build systems of form (5) by
    - 1 d1
</pre></blockquote>
<p>
The numeric properties of the resulting state space system
depends on which first and second order polynomials are
combined and connected together. From a numerical point of view, it
would therefore be useful to combine the polynomials
based on the numeric values of the polynomial coefficients,
(e.g., in a first step the polynomials could be sorted
according to their cut-off frequency).
</p>
<p>
However, this has the disadvantage that the structure of the
resulting state space system depends on the numeric
values of the polynomial coefficients. Since Modelica
environments perform symbolic pre-processing on equations,
this would mean that a change of a polynomial coefficient
requires to newly compile the state space system.
</p>
<p>
If, on the other hand, the structure of the state
space system depends only on dimension information
of the n1,n2,d1,d2 arrays, then the polynomial coefficients
can be changed without a new translation of the model.
This is the major reason why the structure of the
state space system in the implementation of this block
is based only on dimension information.
</p>
<p>
This is, e.g., not critical for the provided filters:
The dimension of the n1,n2,d1,d2 arrays depend for
filters only on the filter characteristics
(Bessel, Butterworth etc.), the filter type (low pass,
high pass etc.) and on the filter order. If any
of this data is changed, the model has to be
newly compiled. All the other filter data, such as
cut-off frequency or ripple amplitude, can be changed
without re-compilation of the model.
The ZerosAndPoles transfer function is now constructed
for the filters in such a way that the filter zeros
and poles are appropriately sorted to give better
numerical properties.
</p>
<p>
Another alternative implementation of the state
space system would be to use the function controller canonical
form that directly results from the transfer function.
The severe disadvantage
of this approach is that the structure of the state
space system from above is lost for the symbolic preprocessing.
If, e.g., index reduction has to be applied (e.g. since a
filter is used to realize a non-linear inverse model),
then the tool cannot perform the index reduction.
Example:
</p>
<p>
Assume, a generic first order state space system
is present
</p>
<blockquote><pre>
<b>der</b>(x) = a*x + b*u
     y = c*x + d*u
</pre></blockquote>
<p>
and the values of the scalars a,b,c,d are parameters
that might be changed before the simulation starts.
If y has to be differentiated symbolically during code
generation, then
</p>
<blockquote><pre>
<b>der</b>(y) = c*<b>der</b>(x) + d*<b>der</b>(u)
<b>der</b>(x) = a*x + b*u
</pre></blockquote>
<p>
As a result, u needs to be differentiated too, and this
might not be possible and therefore translation might fail.
</p>
<p>
On the other hand, if the first order system is
defined to be a low pass filter and the state space
system is generated by keeping this structure, we have
(see form (5) above):
</p>
<blockquote><pre>
<b>der</b>(x) = -b*x + u
      y = x
</pre></blockquote>
<p>
Differentiating y symbolically leads to:
</p>
<blockquote><pre>
<b>der</b>(y) = <b>der</b>(x)
<b>der</b>(x) = -b*x + u
</pre></blockquote>
<p>
Therefore, in this case, the derivative of u is not
needed and the tool can continue with the symbolic
processing.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2 + p +1);

<b>algorithm</b>
  ss := Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace(zp);
// ss.A = [0, 1; -1, -1],
// ss.B = [0; 1],
// ss.C = [1, 1],
// ss.D = [0],
</pre></blockquote>
</html>"));
      end toStateSpace;
    end Conversion;

    encapsulated package Import
      "Package of functions to generate a ZerosAndPoles data record from imported data"
      extends Modelica.Icons.Package;
      import Modelica;

      encapsulated function fromFile
        "Generate a ZerosAndPoles data record by reading the polynomial coefficients or zeros and poles from a file"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.DataDir;

        input String fileName=DataDir + "zp.mat"
          "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                          caption="state space system data file")));

    protected
        Integer n1n2d1d2[4]=if ZerosAndPoles.Internal.checkRepresentation(
            fileName) then ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp(
            fileName) else ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc(
            fileName) annotation(__Dymola_allowForSize=true);
        Integer n1=n1n2d1d2[1] annotation(__Dymola_allowForSize=true);
        Integer n2=n1n2d1d2[2] annotation(__Dymola_allowForSize=true);
        Integer d1=n1n2d1d2[3] annotation(__Dymola_allowForSize=true);
        Integer d2=n1n2d1d2[4] annotation(__Dymola_allowForSize=true);
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2] annotation(__Dymola_allowForSize=true);
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4] annotation(__Dymola_allowForSize=true);
    public
        output ZerosAndPoles zp(
          n1=fill(0, n1),
          n2=fill(0, n2, 2),
          d1=fill(0, d1),
          d2=fill(0, d2, 2));
      algorithm
        //Whenever this function becomes operational the code must be
        // rewritten if fromFile_pc2 and fromFile_zp2 are in the 'constructor'

        zp := if ZerosAndPoles.Internal.checkRepresentation(fileName) then ZerosAndPoles.Internal.fromFile_zp( fileName) else ZerosAndPoles.Internal.fromFile_pc(
          fileName);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = ZerosAndPoles.Import.<b>fromFile</b>(fileName)
</pre></blockquote>

<h4>Description</h4>
<p>
Reads and loads a zeros-and-poles transfer function from a mat-file <tt>fileName</tt>. The file must contain either the set of variables n1, n2, d1, d2, and k with the associated first and second order polynomials or the variables p, z, and k with the poles and zeros, written in two column arrays with real and imaginary in the first and second column respectively. The variable k is the real gail in both cases.
</p>

<h4>Example</h4>
<blockquote><pre>
<b>algorithm</b>
  zp:=Modelica_LinearSystems2.ZerosAndPoles.Import.fromFile(\"zp.mat\", \"n\", \"d\");
//  zp = (p^2 + 2*p + 3)/(p + 2)/(p^2 + 2*p + 2)
</pre></blockquote>
</html>"));
      end fromFile;

      function fromModel
        "Generate a ZerosAndPoles data record from a state space representation resulted from linearization of a model"

        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input String modelName "Name of the Modelica model" annotation(Dialog(__Dymola_translatedModel(translate=true)));
        input Real T_linearize=0
          "Point in time of simulation to linearize the model";
        input String fileName="dslin" "Name of the result file";

    protected
        String fileName2=fileName + ".mat";
        Boolean OK1=simulateModel(
              problem=modelName,
              startTime=0,
              stopTime=T_linearize);
        Boolean OK2=importInitial("dsfinal.txt");
        Boolean OK3=linearizeModel(
              problem=modelName,
              resultFile=fileName,
              startTime=T_linearize,
              stopTime=T_linearize + 1);
        Real nxMat[1,1]=readMatrix(
              fileName2,
              "nx",
              1,
              1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny,nx + nu]=readMatrix(
              fileName2,
              "ABCD",
              nx + ny,
              nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(
              fileName2,
              "xuyName",
              nx + nu + ny);

        StateSpace result(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";
    public
        output ZerosAndPoles zp[:,:];
      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        result.uNames := xuyName[nx + 1:nx + nu];
        result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        result.xNames := xuyName[1:nx];

        zp := StateSpace.Conversion.toZerosAndPolesMIMO(result);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = ZerosAndPoles.Import.<b>fromModel</b>(modelName, T_linearize, fileName)
</pre></blockquote>

<h4>Description</h4>
<p>
Generate a matrix of ZerosAndPoles data records by linearization of a model
defined by modelName. The linearization is performed at time T_linearize of
the simulation. The system is genrated by using <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Import.fromFile\">StateSpace.Import.fromModel</a>
followed by a conversion from sate space to transfer function representation.
</p>

<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;

<b>algorithm</b>
  zp = Modelica_LinearSystems2.ZerosAndPoles.Import.fromModel(modelName, T_linearize);

//  zp =[0.157605*(p + 0.706559)*(p + 12.3798)*(p^2-7.34273*p + 18.674)/( (p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572)*(p^2 + 2.07022e-015*p + 3.38074e-015) );
         0.157605*(p + 0.706559)*(p + 12.3798)*(p^2-7.34273*p + 18.674)/( (p-1.94349e-015)*(p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572) );
        -0.166305*(p^2-1.20297*p + 3.48327)/( (p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572) );
        -0.166305*p*(p^2-1.20297*p + 3.48327)/( (p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572) );
         0.283325*(p-5.23615)*(p + 0.551929)/( (p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572) );
         0.283325*p*(p-5.23615)*(p + 0.551929)/( (p + 0.829834)*(p + 10.6304)*(p^2-7.27298*p + 18.1572) )]
</pre></blockquote>
</html>"));
      end fromModel;

    end Import;

    encapsulated package Internal
      "Package of internal material of record ZerosAndPoles (for advanced users only)"
      extends Modelica.Icons.Package;

      import Modelica;
      import Modelica_LinearSystems2;

      record ZerosAndPoles
          "Continuous zeros and poles description of a single input, single output system (data + operations)"
        extends Modelica.Icons.Record;

        Real k=1.0 "Multiplicative factor of transfer function"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        Real n1[:] "[p^0] coefficients of 1st order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        Real n2[:,2] "[p,p^0] coefficients of 2nd order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        Real d1[:] "[p^0] coefficients of 1st order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        Real d2[:,2] "[p,p^0] coefficients of 2nd order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));

      end ZerosAndPoles;

      encapsulated function bandPassAlpha "Return alpha for band pass"
        import Modelica;

        input Real a "Coefficient of p^1";
        input Real b "Coefficient of p^0";
        input Modelica.Units.SI.AngularVelocity w "Bandwidth angular frequency";
        output Real alpha "Alpha factor to build up band pass";

    protected
        Real alpha_min;
        Real alpha_max;
        Real z_min;
        Real z_max;
        Real z;

        function residue "Residue of non-linear equation"
          input Real a;
          input Real b;
          input Real w;
          input Real z;
          output Real res;
        algorithm
          res := z^2 + (a*w*z/(1+z))^2 - (2+b*w^2)*z + 1;
        end residue;

        function solveOneNonlinearEquation
          "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
          import Modelica.Utilities.Streams.error;

          input Real aa;
          input Real bb;
          input Real ww;
          input Real u_min "Lower bound of search intervall";
          input Real u_max "Upper bound of search intervall";
          input Real tolerance=100*Modelica.Constants.eps
            "Relative tolerance of solution u";
          output Real u "Value of independent variable so that f(u) = 0";

      protected
          constant Real eps=Modelica.Constants.eps "machine epsilon";
          Real a=u_min "Current best minimum interval value";
          Real b=u_max "Current best maximum interval value";
          Real c "Intermediate point a <= c <= b";
          Real d;
          Real e "b - a";
          Real m;
          Real s;
          Real p;
          Real q;
          Real r;
          Real tol;
          Real fa "= f(a)";
          Real fb "= f(b)";
          Real fc;
          Boolean found=false;
        algorithm
          // Check that f(u_min) and f(u_max) have different sign
          fa := residue(aa,bb,ww,u_min);
          fb := residue(aa,bb,ww,u_max);
          fc := fb;
          if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
            error(
              "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
              "do not bracket the root of the single non-linear equation:\n" +
              "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
               + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
              "  fb = f(u_max) = " + String(fb) + "\n" +
              "fa and fb must have opposite sign which is not the case");
          end if;

          // Initialize variables
          c := a;
          fc := fa;
          e := b - a;
          d := e;

          // Search loop
          while not found loop
            if abs(fc) < abs(fb) then
              a := b;
              b := c;
              c := a;
              fa := fb;
              fb := fc;
              fc := fa;
            end if;

            tol := 2*eps*abs(b) + tolerance;
            m := (c - b)/2;

            if abs(m) <= tol or fb == 0.0 then
              // root found (interval is small enough)
              found := true;
              u := b;
            else
              // Determine if a bisection is needed
              if abs(e) < tol or abs(fa) <= abs(fb) then
                e := m;
                d := e;
              else
                s := fb/fa;
                if a == c then
                  // linear interpolation
                  p := 2*m*s;
                  q := 1 - s;
                else
                  // inverse quadratic interpolation
                  q := fa/fc;
                  r := fb/fc;
                  p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                  q := (q - 1)*(r - 1)*(s - 1);
                end if;

                if p > 0 then
                  q := -q;
                else
                  p := -p;
                end if;

                s := e;
                e := d;
                if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                  // interpolation successful
                  d := p/q;
                else
                  // use bi-section
                  e := m;
                  d := e;
                end if;
              end if;

              // Best guess value is defined as "a"
              a := b;
              fa := fb;
              b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
              fb := residue(aa,bb,ww,b);

              if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                // initialize variables
                c := a;
                fc := fa;
                e := b - a;
                d := e;
              end if;
            end if;
          end while;

          annotation (Documentation(info="<html>

<p>
This function determines the solution of <b>one non-linear algebraic equation</b> \"y=f(u)\"
in <b>one unknown</b> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <b>Algorithms for Minimization without derivatives</b>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>
</html>"));
        end solveOneNonlinearEquation;

      algorithm
        assert( a^2/4 - b <= 0,  "Band pass transformation cannot be computed");
        z :=solveOneNonlinearEquation(a, b, w, 0, 1);
        alpha := sqrt(z);

        annotation (Documentation(info="<html>
<p>
A band pass with bandwidth \"w\" is determined from a low pass
</p>

<blockquote><pre>
  1/(p^2 + a*p + b)
</pre></blockquote>

<p>
with the transformation
</p>

<blockquote><pre>
  new(p) = (p + 1/p)/w
</pre></blockquote>

<p>
This results in the following derivation:
</p>

<blockquote><pre>
  1/(p^2 + a*p + b) -> 1/( (p+1/p)^2/w^2 + a*(p + 1/p)/w + b )
                     = 1 / ( p^2 + 1/p^2 + 2)/w^2 + (p + 1/p)*a/w + b )
                     = w^2*p^2 / (p^4 + 2*p^2 + 1 + (p^3 + p)a*w + b*w^2*p^2)
                     = w^2*p^2 / (p^4 + a*w*p^3 + (2+b*w^2)*p^2 + a*w*p + 1)
</pre></blockquote>

<p>
This 4th order transfer function shall be split in to two transfer functions of order 2 each
for numerical reasons. With the following formulation, the fourth order
polynomial can be represented (with the unknowns \"c\" and \"alpha\"):
</p>

<blockquote><pre>
  g(p) = w^2*p^2 / ( (p*alpha)^2 + c*(p*alpha) + 1) * (p/alpha)^2 + c*(p/alpha) + 1)
       = w^2*p^2 / ( p^4 + c*(alpha + 1/alpha)*p^3 + (alpha^2 + 1/alpha^2 + c^2)*p^2
                                                   + c*(alpha + 1/alpha)*p + 1 )
</pre></blockquote>

<p>
Comparison of coefficients:
</p>

<blockquote><pre>
  c*(alpha + 1/alpha) = a*w           -> c = a*w / (alpha + 1/alpha)
  alpha^2 + 1/alpha^2 + c^2 = 2+b*w^2 -> equation to determine alpha

  alpha^4 + 1 + a^2*w^2*alpha^4/(1+alpha^2)^2 = (2+b*w^2)*alpha^2
    or z = alpha^2
  z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1 = 0
</pre></blockquote>

<p>
Therefore the last equation has to be solved for \"z\" (basically, this means to compute
a real zero of a fourth order polynomal):
</p>

<blockquote><pre>
   solve: 0 = f(z)  = z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1  for \"z\"
              f(0)  = 1  &gt; 0
              f(1)  = 1 + a^2*w^2/4 - (2+b*w^2) + 1
                    = (a^2/4 - b)*w^2  // must be &lt; 0
</pre></blockquote>

<p>
This function computes the solution of this equation and returns \"alpha = z^2\" and \"c\";
</p>
</html>"));
      end bandPassAlpha;

      encapsulated function baseFilter
        "Generate a ZerosAndPoles transfer function from a base filter description (= low pass filter with w_cut = 1 rad/s)"

        import Modelica;
        import Modelica.Math;
        import Modelica.Utilities.Streams;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Utilities.Types;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Modelica_LinearSystems2.Utilities.Types.AnalogFilter analogFilter=Modelica_LinearSystems2.Utilities.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)";
        input Integer order(min=1) = 2 "Order of filter";
        input Real A_ripple(unit="dB") = 0.5
          "Pass band ripple (only for Chebyshev filter)";
        input Boolean normalized=true
          "True, if amplitude at f_cut = -3db, otherwise unmodified filter";

        output ZerosAndPoles filter(
          redeclare Real n1[0],
          redeclare Real n2[0,2],
          redeclare Real d1[if analogFilter == Types.AnalogFilter.CriticalDamping then
                  order else mod(order, 2)],
          redeclare Real d2[if analogFilter == Types.AnalogFilter.CriticalDamping then
                  0 else integer(order/2),2]) "Filter transfer function";
    protected
        Integer n_den1=size(filter.d1, 1);
        Integer n_den2=size(filter.d2, 1);
        Integer n_den=n_den1 + 2*n_den2;
        Real pi=Modelica.Constants.pi;
        Boolean evenOrder=mod(order, 2) == 0
          "True, if even filter order (otherwise uneven)";
        Real alpha=1.0 "Frequency correction factor";
        Real alpha2 "= alpha*alpha";
        Real epsilon "Ripple size";
        Real fac "arsinh(epsilon)";
        Real den1[n_den1]
          "[p] coefficients of denominator first order polynomials (a*p + 1)";
        Real den2[n_den2,2]
          "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
        Real aux;
        Real k;
      algorithm
        /* Compute filter coefficients of prototype low pass filter. */
        if analogFilter == Types.AnalogFilter.CriticalDamping then
          if normalized then
            alpha := sqrt(2^(1/order) - 1);
            // alpha := sqrt(10^(3/10/order)-1);
          else
            alpha := 1;
          end if;
          for i in 1:n_den1 loop
            den1[i] := alpha;
          end for;

        elseif analogFilter == Types.AnalogFilter.Bessel then
          (den1,den2,alpha) := ZerosAndPoles.Internal.BesselCoefficients(order);
          if not normalized then
            alpha2 := alpha*alpha;
            for i in 1:n_den2 loop
              den2[i, 1] := den2[i, 1]*alpha2;
              den2[i, 2] := den2[i, 2]*alpha;
            end for;
            if not evenOrder then
              den1[1] := den1[1]*alpha;
            end if;
          end if;

        elseif analogFilter == Types.AnalogFilter.Butterworth then
           // Original filter is already normalized
          for i in 1:n_den2 loop
            den2[i, 1] := 1.0;
            den2[i, 2] := -2*cos(pi*(0.5 + (i - 0.5)/order));
          end for;
          if not evenOrder then
            den1[1] := 1.0;
          end if;

          /* Transformation of filter transfer function with "new(p) = alpha*p"
         in order that the filter transfer function has an amplitude of
         -3 db at the cutoff frequency
      */
          /*
      if normalized then
        alpha := ZerosAndPoles.Internal.normalizationFactor(den1, den2);
        alpha2 := alpha*alpha;
        for i in 1:n_den2 loop
          den2[i, 1] := den2[i, 1]*alpha2;
          den2[i, 2] := den2[i, 2]*alpha;
        end for;
        if not evenOrder then
          den1[1] := den1[1]*alpha;
        end if;
      end if;
      */

        elseif analogFilter == Types.AnalogFilter.Chebyshev then
          epsilon := sqrt(10^(A_ripple/10) - 1);
          fac := Math.asinh(1/epsilon)/order;

          if evenOrder then
             for i in 1:n_den2 loop
                den2[i,1] :=1/(cosh(fac)^2 - cos((2*i - 1)*pi/(2*order))^2);
                den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos((2*i - 1)*pi/(2*order));
             end for;
          else
             den1[1] := 1/sinh(fac);
             for i in 1:n_den2 loop
                den2[i,1] :=1/(cosh(fac)^2 - cos(i*pi/order)^2);
                den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos(i*pi/order);
             end for;
          end if;

           /* Transformation of filter transfer function with "new(p) = alpha*p"
          in order that the filter transfer function has an amplitude of
          -3 db at the cutoff frequency
       */
          if normalized then
            alpha := ZerosAndPoles.Internal.normalizationFactor(den1, den2);
            alpha2 := alpha*alpha;
            for i in 1:n_den2 loop
              den2[i, 1] := den2[i, 1]*alpha2;
              den2[i, 2] := den2[i, 2]*alpha;
            end for;
            if not evenOrder then
              den1[1] := den1[1]*alpha;
            end if;
          end if;

        else
          Streams.error("analogFilter (= " + String(analogFilter) +
            ") is not supported");
        end if;

        // Determine normalized denominator polynomials with highest power of p equal to one
        (filter.d1,filter.d2,k) := ZerosAndPoles.Internal.filterToNormalized(den1, den2);
        filter.k := 1.0/k;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = <b>baseFilter</b>(analogFilter, order, A_ripple, normalized);
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles transfer function
description of low pass filters with a cut-off angular frequency
of one rad/s and a gain of one. Filters returned by this function
are the starting point to construct other filters by transformation
of the filter transfer function:
</p>

<pre>
   zp(p) = 1 / ( product( p + a[i] ) * product(p^2 + b[i]*p + a[i]) )
</pre>

<p>
using the following rules:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td><i>Desired filter</i></td>
    <td><i>Transformation</i></td>
    </tr>

<tr><td> High pass filter </td>
    <td> replace \"p\" by \"1/p\" </td>
    </tr>

<tr><td> Band pass filter </td>
    <td> replace \"p\" by \"(p + 1/p)/w_band\"<br>
         (w_band = (f_max - f_min)/sqrt(f_min*f_max))</td>
    </tr>

<tr><td> Stop pass filter  </td>
    <td> replace \"p\" by \"w_band/(p + 1/p)\"<br>
         (w_band = (f_max - f_min)/sqrt(f_min*f_max))</td>
    </tr>

<tr><td> Filter with cut-off angular frequency w_cut </td>
    <td> replace \"p\" by \"p/w_cut\" </td>
    </tr>
</table>
<p>
For more details see also
<a href=\"modelica://Modelica_LinearSystems2.UsersGuide.Literature\">[Tietze2002]</a>, pp. 815-852.
</p>

<h4>Example</h4>
<blockquote><pre>
  // Generate a Butterworth high pass base filter of order 3
  <b>import</b> ZP = Modelica_LinearSystems2.ZerosAndPoles;
  <b>import</b> Modelica_LinearSystems2.Types;

  ZP zp_filter;
<b>algorithm</b>
  zp_filter = ZP.Internal.baseFilter(Types.AnalogFilter.Butterworth, order = 3);

 // zp_filter = 1 /  ( (p + 1)*(p^2 + p + 1) )
</pre></blockquote>
</html>"));
      end baseFilter;

      function BesselCoefficients
        "Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB"

        import Modelica.Utilities.Streams;
        import Modelica_LinearSystems2;
        input Integer order "Order of filter in the range 1..41";
        output Real c1[mod(order, 2)]
          "[p] coefficients of Bessel denominator polynomials (a*p + 1)";
        output Real c2[integer(order/2),2]
          "[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)";
        output Real alpha "Normalization factor";
      algorithm
        if order == 1 then
          alpha := 1.002377293007601;
          c1[1] := 0.9976283451109835;
        elseif order == 2 then
          alpha := 0.7356641785819585;
          c2[1, 1] := 0.6159132201783791;
          c2[1, 2] := 1.359315879600889;
        elseif order == 3 then
          alpha := 0.5704770156982642;
          c1[1] := 0.7548574865985343;
          c2[1, 1] := 0.4756958028827457;
          c2[1, 2] := 0.9980615136104388;
        elseif order == 4 then
          alpha := 0.4737978580281427;
          c2[1, 1] := 0.4873729247240677;
          c2[1, 2] := 1.337564170455762;
          c2[2, 1] := 0.3877724315741958;
          c2[2, 2] := 0.7730405590839861;
        elseif order == 5 then
          alpha := 0.4126226974763408;
          c1[1] := 0.6645723262620757;
          c2[1, 1] := 0.4115231900614016;
          c2[1, 2] := 1.138349926728708;
          c2[2, 1] := 0.3234938702877912;
          c2[2, 2] := 0.6205992985771313;
        elseif order == 6 then
          alpha := 0.3705098000736233;
          c2[1, 1] := 0.3874508649098960;
          c2[1, 2] := 1.219740879520741;
          c2[2, 1] := 0.3493298843155746;
          c2[2, 2] := 0.9670265529381365;
          c2[3, 1] := 0.2747419229514599;
          c2[3, 2] := 0.5122165075105700;
        elseif order == 7 then
          alpha := 0.3393452623586350;
          c1[1] := 0.5927147125821412;
          c2[1, 1] := 0.3383379423919174;
          c2[1, 2] := 1.092630816438030;
          c2[2, 1] := 0.3001025788696046;
          c2[2, 2] := 0.8289928256598656;
          c2[3, 1] := 0.2372867471539579;
          c2[3, 2] := 0.4325128641920154;
        elseif order == 8 then
          alpha := 0.3150267393795002;
          c2[1, 1] := 0.3151115975207653;
          c2[1, 2] := 1.109403015460190;
          c2[2, 1] := 0.2969344839572762;
          c2[2, 2] := 0.9737455812222699;
          c2[3, 1] := 0.2612545921889538;
          c2[3, 2] := 0.7190394712068573;
          c2[4, 1] := 0.2080523342974281;
          c2[4, 2] := 0.3721456473047434;
        elseif order == 9 then
          alpha := 0.2953310177184124;
          c1[1] := 0.5377196679501422;
          c2[1, 1] := 0.2824689124281034;
          c2[1, 2] := 1.022646191567475;
          c2[2, 1] := 0.2626824161383468;
          c2[2, 2] := 0.8695626454762596;
          c2[3, 1] := 0.2302781917677917;
          c2[3, 2] := 0.6309047553448520;
          c2[4, 1] := 0.1847991729757028;
          c2[4, 2] := 0.3251978031287202;
        elseif order == 10 then
          alpha := 0.2789426890619463;
          c2[1, 1] := 0.2640769908255582;
          c2[1, 2] := 1.019788132875305;
          c2[2, 1] := 0.2540802639216947;
          c2[2, 2] := 0.9377020417760623;
          c2[3, 1] := 0.2343577229427963;
          c2[3, 2] := 0.7802229808216112;
          c2[4, 1] := 0.2052193139338624;
          c2[4, 2] := 0.5594176813008133;
          c2[5, 1] := 0.1659546953748916;
          c2[5, 2] := 0.2878349616233292;
        elseif order == 11 then
          alpha := 0.2650227766037203;
          c1[1] := 0.4950265498954191;
          c2[1, 1] := 0.2411858478546218;
          c2[1, 2] := 0.9567800996387417;
          c2[2, 1] := 0.2296849355380925;
          c2[2, 2] := 0.8592523717113126;
          c2[3, 1] := 0.2107851705677406;
          c2[3, 2] := 0.7040216048898129;
          c2[4, 1] := 0.1846461385164021;
          c2[4, 2] := 0.5006729207276717;
          c2[5, 1] := 0.1504217970817433;
          c2[5, 2] := 0.2575070491320295;
        elseif order == 12 then
          alpha := 0.2530051198547209;
          c2[1, 1] := 0.2268294941204543;
          c2[1, 2] := 0.9473116570034053;
          c2[2, 1] := 0.2207657387793729;
          c2[2, 2] := 0.8933728946287606;
          c2[3, 1] := 0.2087600700376653;
          c2[3, 2] := 0.7886236252756229;
          c2[4, 1] := 0.1909959101492760;
          c2[4, 2] := 0.6389263649257017;
          c2[5, 1] := 0.1675208146048472;
          c2[5, 2] := 0.4517847275162215;
          c2[6, 1] := 0.1374257286372761;
          c2[6, 2] := 0.2324699157474680;
        elseif order == 13 then
          alpha := 0.2424910397561007;
          c1[1] := 0.4608848369928040;
          c2[1, 1] := 0.2099813050274780;
          c2[1, 2] := 0.8992478823790660;
          c2[2, 1] := 0.2027250423101359;
          c2[2, 2] := 0.8328117484224146;
          c2[3, 1] := 0.1907635894058731;
          c2[3, 2] := 0.7257379204691213;
          c2[4, 1] := 0.1742280397887686;
          c2[4, 2] := 0.5830640944868014;
          c2[5, 1] := 0.1530858190490478;
          c2[5, 2] := 0.4106192089751885;
          c2[6, 1] := 0.1264090712880446;
          c2[6, 2] := 0.2114980230156001;
        elseif order == 14 then
          alpha := 0.2331902368695848;
          c2[1, 1] := 0.1986162311411235;
          c2[1, 2] := 0.8876961808055535;
          c2[2, 1] := 0.1946683341271615;
          c2[2, 2] := 0.8500754229171967;
          c2[3, 1] := 0.1868331332895056;
          c2[3, 2] := 0.7764629313723603;
          c2[4, 1] := 0.1752118757862992;
          c2[4, 2] := 0.6699720402924552;
          c2[5, 1] := 0.1598906457908402;
          c2[5, 2] := 0.5348446712848934;
          c2[6, 1] := 0.1407810153019944;
          c2[6, 2] := 0.3755841316563539;
          c2[7, 1] := 0.1169627966707339;
          c2[7, 2] := 0.1937088226304455;
        elseif order == 15 then
          alpha := 0.2248854870552422;
          c1[1] := 0.4328492272335646;
          c2[1, 1] := 0.1857292591004588;
          c2[1, 2] := 0.8496337061962563;
          c2[2, 1] := 0.1808644178280136;
          c2[2, 2] := 0.8020517898136011;
          c2[3, 1] := 0.1728264404199081;
          c2[3, 2] := 0.7247449729331105;
          c2[4, 1] := 0.1616970125901954;
          c2[4, 2] := 0.6205369315943097;
          c2[5, 1] := 0.1475257264578426;
          c2[5, 2] := 0.4929612162355906;
          c2[6, 1] := 0.1301861023357119;
          c2[6, 2] := 0.3454770708040735;
          c2[7, 1] := 0.1087810777120188;
          c2[7, 2] := 0.1784526655428406;
        elseif order == 16 then
          alpha := 0.2174105053474761;
          c2[1, 1] := 0.1765637967473151;
          c2[1, 2] := 0.8377453068635511;
          c2[2, 1] := 0.1738525357503125;
          c2[2, 2] := 0.8102988957433199;
          c2[3, 1] := 0.1684627004613343;
          c2[3, 2] := 0.7563265923413258;
          c2[4, 1] := 0.1604519074815815;
          c2[4, 2] := 0.6776082294687619;
          c2[5, 1] := 0.1498828607802206;
          c2[5, 2] := 0.5766417034027680;
          c2[6, 1] := 0.1367764717792823;
          c2[6, 2] := 0.4563528264410489;
          c2[7, 1] := 0.1209810465419295;
          c2[7, 2] := 0.3193782657322374;
          c2[8, 1] := 0.1016312648007554;
          c2[8, 2] := 0.1652419227369036;
        elseif order == 17 then
          alpha := 0.2106355148193306;
          c1[1] := 0.4093223608497299;
          c2[1, 1] := 0.1664014345826274;
          c2[1, 2] := 0.8067173752345952;
          c2[2, 1] := 0.1629839591538256;
          c2[2, 2] := 0.7712924931447541;
          c2[3, 1] := 0.1573277802512491;
          c2[3, 2] := 0.7134213666303411;
          c2[4, 1] := 0.1494828185148637;
          c2[4, 2] := 0.6347841731714884;
          c2[5, 1] := 0.1394948812681826;
          c2[5, 2] := 0.5375594414619047;
          c2[6, 1] := 0.1273627583380806;
          c2[6, 2] := 0.4241608926375478;
          c2[7, 1] := 0.1129187258461290;
          c2[7, 2] := 0.2965752009703245;
          c2[8, 1] := 0.9533357359908857e-1;
          c2[8, 2] := 0.1537041700889585;
        elseif order == 18 then
          alpha := 0.2044575288651841;
          c2[1, 1] := 0.1588768571976356;
          c2[1, 2] := 0.7951914263212913;
          c2[2, 1] := 0.1569357024981854;
          c2[2, 2] := 0.7744529690772538;
          c2[3, 1] := 0.1530722206358810;
          c2[3, 2] := 0.7335304425992080;
          c2[4, 1] := 0.1473206710524167;
          c2[4, 2] := 0.6735038935387268;
          c2[5, 1] := 0.1397225420331520;
          c2[5, 2] := 0.5959151542621590;
          c2[6, 1] := 0.1303092459809849;
          c2[6, 2] := 0.5026483447894845;
          c2[7, 1] := 0.1190627367060072;
          c2[7, 2] := 0.3956893824587150;
          c2[8, 1] := 0.1058058030798994;
          c2[8, 2] := 0.2765091830730650;
          c2[9, 1] := 0.8974708108800873e-1;
          c2[9, 2] := 0.1435505288284833;
        elseif order == 19 then
          alpha := 0.1987936248083529;
          c1[1] := 0.3892259966869526;
          c2[1, 1] := 0.1506640012172225;
          c2[1, 2] := 0.7693121733774260;
          c2[2, 1] := 0.1481728062796673;
          c2[2, 2] := 0.7421133586741549;
          c2[3, 1] := 0.1440444668388838;
          c2[3, 2] := 0.6975075386214800;
          c2[4, 1] := 0.1383101628540374;
          c2[4, 2] := 0.6365464378910025;
          c2[5, 1] := 0.1310032283190998;
          c2[5, 2] := 0.5606211948462122;
          c2[6, 1] := 0.1221431166405330;
          c2[6, 2] := 0.4713530424221445;
          c2[7, 1] := 0.1116991161103884;
          c2[7, 2] := 0.3703717538617073;
          c2[8, 1] := 0.9948917351196349e-1;
          c2[8, 2] := 0.2587371155559744;
          c2[9, 1] := 0.8475989238107367e-1;
          c2[9, 2] := 0.1345537894555993;
        elseif order == 20 then
          alpha := 0.1935761760416219;
          c2[1, 1] := 0.1443871348337404;
          c2[1, 2] := 0.7584165598446141;
          c2[2, 1] := 0.1429501891353184;
          c2[2, 2] := 0.7423000962318863;
          c2[3, 1] := 0.1400877384920004;
          c2[3, 2] := 0.7104185332215555;
          c2[4, 1] := 0.1358210369491446;
          c2[4, 2] := 0.6634599783272630;
          c2[5, 1] := 0.1301773703034290;
          c2[5, 2] := 0.6024175491895959;
          c2[6, 1] := 0.1231826501439148;
          c2[6, 2] := 0.5285332736326852;
          c2[7, 1] := 0.1148465498575254;
          c2[7, 2] := 0.4431977385498628;
          c2[8, 1] := 0.1051289462376788;
          c2[8, 2] := 0.3477444062821162;
          c2[9, 1] := 0.9384622797485121e-1;
          c2[9, 2] := 0.2429038300327729;
          c2[10, 1] := 0.8028211612831444e-1;
          c2[10, 2] := 0.1265329974009533;
        elseif order == 21 then
          alpha := 0.1887494014766075;
          c1[1] := 0.3718070668941645;
          c2[1, 1] := 0.1376151928386445;
          c2[1, 2] := 0.7364290859445481;
          c2[2, 1] := 0.1357438914390695;
          c2[2, 2] := 0.7150167318935022;
          c2[3, 1] := 0.1326398453462415;
          c2[3, 2] := 0.6798001808470175;
          c2[4, 1] := 0.1283231214897678;
          c2[4, 2] := 0.6314663440439816;
          c2[5, 1] := 0.1228169159777534;
          c2[5, 2] := 0.5709353626166905;
          c2[6, 1] := 0.1161406100773184;
          c2[6, 2] := 0.4993087153571335;
          c2[7, 1] := 0.1082959649233524;
          c2[7, 2] := 0.4177766148584385;
          c2[8, 1] := 0.9923596957485723e-1;
          c2[8, 2] := 0.3274257287232124;
          c2[9, 1] := 0.8877776108724853e-1;
          c2[9, 2] := 0.2287218166767916;
          c2[10, 1] := 0.7624076527736326e-1;
          c2[10, 2] := 0.1193423971506988;
        elseif order == 22 then
          alpha := 0.1842668221199706;
          c2[1, 1] := 0.1323053462701543;
          c2[1, 2] := 0.7262446126765204;
          c2[2, 1] := 0.1312121721769772;
          c2[2, 2] := 0.7134286088450949;
          c2[3, 1] := 0.1290330911166814;
          c2[3, 2] := 0.6880287870435514;
          c2[4, 1] := 0.1257817990372067;
          c2[4, 2] := 0.6505015800059301;
          c2[5, 1] := 0.1214765261983008;
          c2[5, 2] := 0.6015107185211451;
          c2[6, 1] := 0.1161365140967959;
          c2[6, 2] := 0.5418983553698413;
          c2[7, 1] := 0.1097755171533100;
          c2[7, 2] := 0.4726370779831614;
          c2[8, 1] := 0.1023889478519956;
          c2[8, 2] := 0.3947439506537486;
          c2[9, 1] := 0.9392485861253800e-1;
          c2[9, 2] := 0.3090996703083202;
          c2[10, 1] := 0.8420273775456455e-1;
          c2[10, 2] := 0.2159561978556017;
          c2[11, 1] := 0.7257600023938262e-1;
          c2[11, 2] := 0.1128633732721116;
        elseif order == 23 then
          alpha := 0.1800893554453722;
          c1[1] := 0.3565232673929280;
          c2[1, 1] := 0.1266275171652706;
          c2[1, 2] := 0.7072778066734162;
          c2[2, 1] := 0.1251865227648538;
          c2[2, 2] := 0.6900676345785905;
          c2[3, 1] := 0.1227944815236645;
          c2[3, 2] := 0.6617011100576023;
          c2[4, 1] := 0.1194647013077667;
          c2[4, 2] := 0.6226432315773119;
          c2[5, 1] := 0.1152132989252356;
          c2[5, 2] := 0.5735222810625359;
          c2[6, 1] := 0.1100558598478487;
          c2[6, 2] := 0.5151027978024605;
          c2[7, 1] := 0.1040013558214886;
          c2[7, 2] := 0.4482410942032739;
          c2[8, 1] := 0.9704014176512626e-1;
          c2[8, 2] := 0.3738049984631116;
          c2[9, 1] := 0.8911683905758054e-1;
          c2[9, 2] := 0.2925028692588410;
          c2[10, 1] := 0.8005438265072295e-1;
          c2[10, 2] := 0.2044134600278901;
          c2[11, 1] := 0.6923832296800832e-1;
          c2[11, 2] := 0.1069984887283394;
        elseif order == 24 then
          alpha := 0.1761838665838427;
          c2[1, 1] := 0.1220804912720132;
          c2[1, 2] := 0.6978026874156063;
          c2[2, 1] := 0.1212296762358897;
          c2[2, 2] := 0.6874139794926736;
          c2[3, 1] := 0.1195328372961027;
          c2[3, 2] := 0.6667954259551859;
          c2[4, 1] := 0.1169990987333593;
          c2[4, 2] := 0.6362602049901176;
          c2[5, 1] := 0.1136409040480130;
          c2[5, 2] := 0.5962662188435553;
          c2[6, 1] := 0.1094722001757955;
          c2[6, 2] := 0.5474001634109253;
          c2[7, 1] := 0.1045052832229087;
          c2[7, 2] := 0.4903523180249535;
          c2[8, 1] := 0.9874509806025907e-1;
          c2[8, 2] := 0.4258751523524645;
          c2[9, 1] := 0.9217799943472177e-1;
          c2[9, 2] := 0.3547079765396403;
          c2[10, 1] := 0.8474633796250476e-1;
          c2[10, 2] := 0.2774145482392767;
          c2[11, 1] := 0.7627722381240495e-1;
          c2[11, 2] := 0.1939329108084139;
          c2[12, 1] := 0.6618645465422745e-1;
          c2[12, 2] := 0.1016670147947242;
        elseif order == 25 then
          alpha := 0.1725220521949266;
          c1[1] := 0.3429735385896000;
          c2[1, 1] := 0.1172525033170618;
          c2[1, 2] := 0.6812327932576614;
          c2[2, 1] := 0.1161194585333535;
          c2[2, 2] := 0.6671566071153211;
          c2[3, 1] := 0.1142375145794466;
          c2[3, 2] := 0.6439167855053158;
          c2[4, 1] := 0.1116157454252308;
          c2[4, 2] := 0.6118378416180135;
          c2[5, 1] := 0.1082654809459177;
          c2[5, 2] := 0.5713609763370088;
          c2[6, 1] := 0.1041985674230918;
          c2[6, 2] := 0.5230289949762722;
          c2[7, 1] := 0.9942439308123559e-1;
          c2[7, 2] := 0.4674627926041906;
          c2[8, 1] := 0.9394453593830893e-1;
          c2[8, 2] := 0.4053226688298811;
          c2[9, 1] := 0.8774221237222533e-1;
          c2[9, 2] := 0.3372372276379071;
          c2[10, 1] := 0.8075839512216483e-1;
          c2[10, 2] := 0.2636485508005428;
          c2[11, 1] := 0.7282483286646764e-1;
          c2[11, 2] := 0.1843801345273085;
          c2[12, 1] := 0.6338571166846652e-1;
          c2[12, 2] := 0.9680153764737715e-1;
        elseif order == 26 then
          alpha := 0.1690795702796737;
          c2[1, 1] := 0.1133168695796030;
          c2[1, 2] := 0.6724297955493932;
          c2[2, 1] := 0.1126417845769961;
          c2[2, 2] := 0.6638709519790540;
          c2[3, 1] := 0.1112948749545606;
          c2[3, 2] := 0.6468652038763624;
          c2[4, 1] := 0.1092823986944244;
          c2[4, 2] := 0.6216337070799265;
          c2[5, 1] := 0.1066130386697976;
          c2[5, 2] := 0.5885011413992190;
          c2[6, 1] := 0.1032969057045413;
          c2[6, 2] := 0.5478864278297548;
          c2[7, 1] := 0.9934388184210715e-1;
          c2[7, 2] := 0.5002885306054287;
          c2[8, 1] := 0.9476081523436283e-1;
          c2[8, 2] := 0.4462644847551711;
          c2[9, 1] := 0.8954648464575577e-1;
          c2[9, 2] := 0.3863930785049522;
          c2[10, 1] := 0.8368166847159917e-1;
          c2[10, 2] := 0.3212074592527143;
          c2[11, 1] := 0.7710664731701103e-1;
          c2[11, 2] := 0.2510470347119383;
          c2[12, 1] := 0.6965807988411425e-1;
          c2[12, 2] := 0.1756419294111342;
          c2[13, 1] := 0.6080674930548766e-1;
          c2[13, 2] := 0.9234535279274277e-1;
        elseif order == 27 then
          alpha := 0.1658353543067995;
          c1[1] := 0.3308543720638957;
          c2[1, 1] := 0.1091618578712746;
          c2[1, 2] := 0.6577977071169651;
          c2[2, 1] := 0.1082549561495043;
          c2[2, 2] := 0.6461121666520275;
          c2[3, 1] := 0.1067479247890451;
          c2[3, 2] := 0.6267937760991321;
          c2[4, 1] := 0.1046471079537577;
          c2[4, 2] := 0.6000750116745808;
          c2[5, 1] := 0.1019605976654259;
          c2[5, 2] := 0.5662734183049320;
          c2[6, 1] := 0.9869726954433709e-1;
          c2[6, 2] := 0.5257827234948534;
          c2[7, 1] := 0.9486520934132483e-1;
          c2[7, 2] := 0.4790595019077763;
          c2[8, 1] := 0.9046906518775348e-1;
          c2[8, 2] := 0.4266025862147336;
          c2[9, 1] := 0.8550529998276152e-1;
          c2[9, 2] := 0.3689188223512328;
          c2[10, 1] := 0.7995282239306020e-1;
          c2[10, 2] := 0.3064589322702932;
          c2[11, 1] := 0.7375174596252882e-1;
          c2[11, 2] := 0.2394754504667310;
          c2[12, 1] := 0.6674377263329041e-1;
          c2[12, 2] := 0.1676223546666024;
          c2[13, 1] := 0.5842458027529246e-1;
          c2[13, 2] := 0.8825044329219431e-1;
        elseif order == 28 then
          alpha := 0.1627710671942929;
          c2[1, 1] := 0.1057232656113488;
          c2[1, 2] := 0.6496161226860832;
          c2[2, 1] := 0.1051786825724864;
          c2[2, 2] := 0.6424661279909941;
          c2[3, 1] := 0.1040917964935006;
          c2[3, 2] := 0.6282470268918791;
          c2[4, 1] := 0.1024670101953951;
          c2[4, 2] := 0.6071189030701136;
          c2[5, 1] := 0.1003105109519892;
          c2[5, 2] := 0.5793175191747016;
          c2[6, 1] := 0.9762969425430802e-1;
          c2[6, 2] := 0.5451486608855443;
          c2[7, 1] := 0.9443223803058400e-1;
          c2[7, 2] := 0.5049796971628137;
          c2[8, 1] := 0.9072460982036488e-1;
          c2[8, 2] := 0.4592270546572523;
          c2[9, 1] := 0.8650956423253280e-1;
          c2[9, 2] := 0.4083368605952977;
          c2[10, 1] := 0.8178165740374893e-1;
          c2[10, 2] := 0.3527525188880655;
          c2[11, 1] := 0.7651838885868020e-1;
          c2[11, 2] := 0.2928534570013572;
          c2[12, 1] := 0.7066010532447490e-1;
          c2[12, 2] := 0.2288185204390681;
          c2[13, 1] := 0.6405358596145789e-1;
          c2[13, 2] := 0.1602396172588190;
          c2[14, 1] := 0.5621780070227172e-1;
          c2[14, 2] := 0.8447589564915071e-1;
        elseif order == 29 then
          alpha := 0.1598706626277596;
          c1[1] := 0.3199314513011623;
          c2[1, 1] := 0.1021101032532951;
          c2[1, 2] := 0.6365758882240111;
          c2[2, 1] := 0.1013729819392774;
          c2[2, 2] := 0.6267495975736321;
          c2[3, 1] := 0.1001476175660628;
          c2[3, 2] := 0.6104876178266819;
          c2[4, 1] := 0.9843854640428316e-1;
          c2[4, 2] := 0.5879603139195113;
          c2[5, 1] := 0.9625164534591696e-1;
          c2[5, 2] := 0.5594012291050210;
          c2[6, 1] := 0.9359356960417668e-1;
          c2[6, 2] := 0.5251016150410664;
          c2[7, 1] := 0.9047086748649986e-1;
          c2[7, 2] := 0.4854024475590397;
          c2[8, 1] := 0.8688856407189167e-1;
          c2[8, 2] := 0.4406826457109709;
          c2[9, 1] := 0.8284779224069856e-1;
          c2[9, 2] := 0.3913408089298914;
          c2[10, 1] := 0.7834154620997181e-1;
          c2[10, 2] := 0.3377643999400627;
          c2[11, 1] := 0.7334628941928766e-1;
          c2[11, 2] := 0.2802710651919946;
          c2[12, 1] := 0.6780290487362146e-1;
          c2[12, 2] := 0.2189770008083379;
          c2[13, 1] := 0.6156321231528423e-1;
          c2[13, 2] := 0.1534235999306070;
          c2[14, 1] := 0.5416797446761512e-1;
          c2[14, 2] := 0.8098664736760292e-1;
        elseif order == 30 then
          alpha := 0.1571200296252450;
          c2[1, 1] := 0.9908074847842124e-1;
          c2[1, 2] := 0.6289618807831557;
          c2[2, 1] := 0.9863509708328196e-1;
          c2[2, 2] := 0.6229164525571278;
          c2[3, 1] := 0.9774542692037148e-1;
          c2[3, 2] := 0.6108853364240036;
          c2[4, 1] := 0.9641490581986484e-1;
          c2[4, 2] := 0.5929869253412513;
          c2[5, 1] := 0.9464802912225441e-1;
          c2[5, 2] := 0.5693960175547550;
          c2[6, 1] := 0.9245027206218041e-1;
          c2[6, 2] := 0.5403402396359503;
          c2[7, 1] := 0.8982754584112941e-1;
          c2[7, 2] := 0.5060948065875106;
          c2[8, 1] := 0.8678535291732599e-1;
          c2[8, 2] := 0.4669749797983789;
          c2[9, 1] := 0.8332744242052199e-1;
          c2[9, 2] := 0.4233249626334694;
          c2[10, 1] := 0.7945356393775309e-1;
          c2[10, 2] := 0.3755006094498054;
          c2[11, 1] := 0.7515543969833788e-1;
          c2[11, 2] := 0.3238400339292700;
          c2[12, 1] := 0.7040879901685638e-1;
          c2[12, 2] := 0.2686072427439079;
          c2[13, 1] := 0.6515528854010540e-1;
          c2[13, 2] := 0.2098650589782619;
          c2[14, 1] := 0.5925168237177876e-1;
          c2[14, 2] := 0.1471138832654873;
          c2[15, 1] := 0.5225913954211672e-1;
          c2[15, 2] := 0.7775248839507864e-1;
        elseif order == 31 then
          alpha := 0.1545067022920929;
          c1[1] := 0.3100206996451866;
          c2[1, 1] := 0.9591020358831668e-1;
          c2[1, 2] := 0.6172474793293396;
          c2[2, 1] := 0.9530301275601203e-1;
          c2[2, 2] := 0.6088916323460413;
          c2[3, 1] := 0.9429332655402368e-1;
          c2[3, 2] := 0.5950511595503025;
          c2[4, 1] := 0.9288445429894548e-1;
          c2[4, 2] := 0.5758534119053522;
          c2[5, 1] := 0.9108073420087422e-1;
          c2[5, 2] := 0.5514734636081183;
          c2[6, 1] := 0.8888719137536870e-1;
          c2[6, 2] := 0.5221306199481831;
          c2[7, 1] := 0.8630901440239650e-1;
          c2[7, 2] := 0.4880834248148061;
          c2[8, 1] := 0.8335074993373294e-1;
          c2[8, 2] := 0.4496225358496770;
          c2[9, 1] := 0.8001502494376102e-1;
          c2[9, 2] := 0.4070602306679052;
          c2[10, 1] := 0.7630041338037624e-1;
          c2[10, 2] := 0.3607139804818122;
          c2[11, 1] := 0.7219760885744920e-1;
          c2[11, 2] := 0.3108783301229550;
          c2[12, 1] := 0.6768185077153345e-1;
          c2[12, 2] := 0.2577706252514497;
          c2[13, 1] := 0.6269571766328638e-1;
          c2[13, 2] := 0.2014081375889921;
          c2[14, 1] := 0.5710081766945065e-1;
          c2[14, 2] := 0.1412581515841926;
          c2[15, 1] := 0.5047740914807019e-1;
          c2[15, 2] := 0.7474725873250158e-1;
        elseif order == 32 then
          alpha := 0.1520196210848210;
          c2[1, 1] := 0.9322163554339406e-1;
          c2[1, 2] := 0.6101488690506050;
          c2[2, 1] := 0.9285233997694042e-1;
          c2[2, 2] := 0.6049832320721264;
          c2[3, 1] := 0.9211494244473163e-1;
          c2[3, 2] := 0.5946969295569034;
          c2[4, 1] := 0.9101176786042449e-1;
          c2[4, 2] := 0.5793791854364477;
          c2[5, 1] := 0.8954614071360517e-1;
          c2[5, 2] := 0.5591619969234026;
          c2[6, 1] := 0.8772216763680164e-1;
          c2[6, 2] := 0.5342177994699602;
          c2[7, 1] := 0.8554440426912734e-1;
          c2[7, 2] := 0.5047560942986598;
          c2[8, 1] := 0.8301735302045588e-1;
          c2[8, 2] := 0.4710187048140929;
          c2[9, 1] := 0.8014469519188161e-1;
          c2[9, 2] := 0.4332730387207936;
          c2[10, 1] := 0.7692807528893225e-1;
          c2[10, 2] := 0.3918021436411035;
          c2[11, 1] := 0.7336507157284898e-1;
          c2[11, 2] := 0.3468890521471250;
          c2[12, 1] := 0.6944555312763458e-1;
          c2[12, 2] := 0.2987898029050460;
          c2[13, 1] := 0.6514446669420571e-1;
          c2[13, 2] := 0.2476810747407199;
          c2[14, 1] := 0.6040544477732702e-1;
          c2[14, 2] := 0.1935412053397663;
          c2[15, 1] := 0.5509478650672775e-1;
          c2[15, 2] := 0.1358108994174911;
          c2[16, 1] := 0.4881064725720192e-1;
          c2[16, 2] := 0.7194819894416505e-1;
        elseif order == 33 then
          alpha := 0.1496489351138032;
          c1[1] := 0.3009752799176432;
          c2[1, 1] := 0.9041725460994505e-1;
          c2[1, 2] := 0.5995521047364046;
          c2[2, 1] := 0.8991117804113002e-1;
          c2[2, 2] := 0.5923764112099496;
          c2[3, 1] := 0.8906941547422532e-1;
          c2[3, 2] := 0.5804822013853129;
          c2[4, 1] := 0.8789442491445575e-1;
          c2[4, 2] := 0.5639663528946501;
          c2[5, 1] := 0.8638945831033775e-1;
          c2[5, 2] := 0.5429623519607796;
          c2[6, 1] := 0.8455834602616358e-1;
          c2[6, 2] := 0.5176379938389326;
          c2[7, 1] := 0.8240517431382334e-1;
          c2[7, 2] := 0.4881921474066189;
          c2[8, 1] := 0.7993380417355076e-1;
          c2[8, 2] := 0.4548502528082586;
          c2[9, 1] := 0.7714713890732801e-1;
          c2[9, 2] := 0.4178579388038483;
          c2[10, 1] := 0.7404596598181127e-1;
          c2[10, 2] := 0.3774715722484659;
          c2[11, 1] := 0.7062702339160462e-1;
          c2[11, 2] := 0.3339432938810453;
          c2[12, 1] := 0.6687952672391507e-1;
          c2[12, 2] := 0.2874950693388235;
          c2[13, 1] := 0.6277828912909767e-1;
          c2[13, 2] := 0.2382680702894708;
          c2[14, 1] := 0.5826808305383988e-1;
          c2[14, 2] := 0.1862073169968455;
          c2[15, 1] := 0.5321974125363517e-1;
          c2[15, 2] := 0.1307323751236313;
          c2[16, 1] := 0.4724820282032780e-1;
          c2[16, 2] := 0.6933542082177094e-1;
        elseif order == 34 then
          alpha := 0.1473858373968463;
          c2[1, 1] := 0.8801537152275983e-1;
          c2[1, 2] := 0.5929204288972172;
          c2[2, 1] := 0.8770594341007476e-1;
          c2[2, 2] := 0.5884653382247518;
          c2[3, 1] := 0.8708797598072095e-1;
          c2[3, 2] := 0.5795895850253119;
          c2[4, 1] := 0.8616320590689187e-1;
          c2[4, 2] := 0.5663615383647170;
          c2[5, 1] := 0.8493413175570858e-1;
          c2[5, 2] := 0.5488825092350877;
          c2[6, 1] := 0.8340387368687513e-1;
          c2[6, 2] := 0.5272851839324592;
          c2[7, 1] := 0.8157596213131521e-1;
          c2[7, 2] := 0.5017313864372913;
          c2[8, 1] := 0.7945402670834270e-1;
          c2[8, 2] := 0.4724089864574216;
          c2[9, 1] := 0.7704133559556429e-1;
          c2[9, 2] := 0.4395276256463053;
          c2[10, 1] := 0.7434009635219704e-1;
          c2[10, 2] := 0.4033126590648964;
          c2[11, 1] := 0.7135035113853376e-1;
          c2[11, 2] := 0.3639961488919042;
          c2[12, 1] := 0.6806813160738834e-1;
          c2[12, 2] := 0.3218025212900124;
          c2[13, 1] := 0.6448214312000864e-1;
          c2[13, 2] := 0.2769235521088158;
          c2[14, 1] := 0.6056719318430530e-1;
          c2[14, 2] := 0.2294693573271038;
          c2[15, 1] := 0.5626925196925040e-1;
          c2[15, 2] := 0.1793564218840015;
          c2[16, 1] := 0.5146352031547277e-1;
          c2[16, 2] := 0.1259877129326412;
          c2[17, 1] := 0.4578069074410591e-1;
          c2[17, 2] := 0.6689147319568768e-1;
        elseif order == 35 then
          alpha := 0.1452224267615486;
          c1[1] := 0.2926764667564367;
          c2[1, 1] := 0.8551731299267280e-1;
          c2[1, 2] := 0.5832758214629523;
          c2[2, 1] := 0.8509109732853060e-1;
          c2[2, 2] := 0.5770596582643844;
          c2[3, 1] := 0.8438201446671953e-1;
          c2[3, 2] := 0.5667497616665494;
          c2[4, 1] := 0.8339191981579831e-1;
          c2[4, 2] := 0.5524209816238369;
          c2[5, 1] := 0.8212328610083385e-1;
          c2[5, 2] := 0.5341766459916322;
          c2[6, 1] := 0.8057906332198853e-1;
          c2[6, 2] := 0.5121470053512750;
          c2[7, 1] := 0.7876247299954955e-1;
          c2[7, 2] := 0.4864870722254752;
          c2[8, 1] := 0.7667670879950268e-1;
          c2[8, 2] := 0.4573736721705665;
          c2[9, 1] := 0.7432449556218945e-1;
          c2[9, 2] := 0.4250013835198991;
          c2[10, 1] := 0.7170742126011575e-1;
          c2[10, 2] := 0.3895767735915445;
          c2[11, 1] := 0.6882488171701314e-1;
          c2[11, 2] := 0.3513097926737368;
          c2[12, 1] := 0.6567231746957568e-1;
          c2[12, 2] := 0.3103999917596611;
          c2[13, 1] := 0.6223804362223595e-1;
          c2[13, 2] := 0.2670123611280899;
          c2[14, 1] := 0.5849696460782910e-1;
          c2[14, 2] := 0.2212298104867592;
          c2[15, 1] := 0.5439628409499822e-1;
          c2[15, 2] := 0.1729443731341637;
          c2[16, 1] := 0.4981540179136920e-1;
          c2[16, 2] := 0.1215462157134930;
          c2[17, 1] := 0.4439981033536435e-1;
          c2[17, 2] := 0.6460098363520967e-1;
        elseif order == 36 then
          alpha := 0.1431515914458580;
          c2[1, 1] := 0.8335881847130301e-1;
          c2[1, 2] := 0.5770670512160201;
          c2[2, 1] := 0.8309698922852212e-1;
          c2[2, 2] := 0.5731929100172432;
          c2[3, 1] := 0.8257400347039723e-1;
          c2[3, 2] := 0.5654713811993058;
          c2[4, 1] := 0.8179117911600136e-1;
          c2[4, 2] := 0.5539556343603020;
          c2[5, 1] := 0.8075042173126963e-1;
          c2[5, 2] := 0.5387245649546684;
          c2[6, 1] := 0.7945413151258206e-1;
          c2[6, 2] := 0.5198817177723069;
          c2[7, 1] := 0.7790506514288866e-1;
          c2[7, 2] := 0.4975537629595409;
          c2[8, 1] := 0.7610613635339480e-1;
          c2[8, 2] := 0.4718884193866789;
          c2[9, 1] := 0.7406012816626425e-1;
          c2[9, 2] := 0.4430516443136726;
          c2[10, 1] := 0.7176927060205631e-1;
          c2[10, 2] := 0.4112237708115829;
          c2[11, 1] := 0.6923460172504251e-1;
          c2[11, 2] := 0.3765940116389730;
          c2[12, 1] := 0.6645495833489556e-1;
          c2[12, 2] := 0.3393522147815403;
          c2[13, 1] := 0.6342528888937094e-1;
          c2[13, 2] := 0.2996755899575573;
          c2[14, 1] := 0.6013361864949449e-1;
          c2[14, 2] := 0.2577053294053830;
          c2[15, 1] := 0.5655503081322404e-1;
          c2[15, 2] := 0.2135004731531631;
          c2[16, 1] := 0.5263798119559069e-1;
          c2[16, 2] := 0.1669320999865636;
          c2[17, 1] := 0.4826589873626196e-1;
          c2[17, 2] := 0.1173807590715484;
          c2[18, 1] := 0.4309819397289806e-1;
          c2[18, 2] := 0.6245036108880222e-1;
        elseif order == 37 then
          alpha := 0.1411669104782917;
          c1[1] := 0.2850271036215707;
          c2[1, 1] := 0.8111958235023328e-1;
          c2[1, 2] := 0.5682412610563970;
          c2[2, 1] := 0.8075727567979578e-1;
          c2[2, 2] := 0.5628142923227016;
          c2[3, 1] := 0.8015440554413301e-1;
          c2[3, 2] := 0.5538087696879930;
          c2[4, 1] := 0.7931239302677386e-1;
          c2[4, 2] := 0.5412833323304460;
          c2[5, 1] := 0.7823314328639347e-1;
          c2[5, 2] := 0.5253190555393968;
          c2[6, 1] := 0.7691895211595101e-1;
          c2[6, 2] := 0.5060183741977191;
          c2[7, 1] := 0.7537237072011853e-1;
          c2[7, 2] := 0.4835036020049034;
          c2[8, 1] := 0.7359601294804538e-1;
          c2[8, 2] := 0.4579149413954837;
          c2[9, 1] := 0.7159227884849299e-1;
          c2[9, 2] := 0.4294078049978829;
          c2[10, 1] := 0.6936295002846032e-1;
          c2[10, 2] := 0.3981491350382047;
          c2[11, 1] := 0.6690857785828917e-1;
          c2[11, 2] := 0.3643121502867948;
          c2[12, 1] := 0.6422751692085542e-1;
          c2[12, 2] := 0.3280684291406284;
          c2[13, 1] := 0.6131430866206096e-1;
          c2[13, 2] := 0.2895750997170303;
          c2[14, 1] := 0.5815677249570920e-1;
          c2[14, 2] := 0.2489521814805720;
          c2[15, 1] := 0.5473023527947980e-1;
          c2[15, 2] := 0.2062377435955363;
          c2[16, 1] := 0.5098441033167034e-1;
          c2[16, 2] := 0.1612849131645336;
          c2[17, 1] := 0.4680658811093562e-1;
          c2[17, 2] := 0.1134672937045305;
          c2[18, 1] := 0.4186928031694695e-1;
          c2[18, 2] := 0.6042754777339966e-1;
        elseif order == 38 then
          alpha := 0.1392625697140030;
          c2[1, 1] := 0.7916943373658329e-1;
          c2[1, 2] := 0.5624158631591745;
          c2[2, 1] := 0.7894592250257840e-1;
          c2[2, 2] := 0.5590219398777304;
          c2[3, 1] := 0.7849941672384930e-1;
          c2[3, 2] := 0.5522551628416841;
          c2[4, 1] := 0.7783093084875645e-1;
          c2[4, 2] := 0.5421574325808380;
          c2[5, 1] := 0.7694193770482690e-1;
          c2[5, 2] := 0.5287909941093643;
          c2[6, 1] := 0.7583430534712885e-1;
          c2[6, 2] := 0.5122376814029880;
          c2[7, 1] := 0.7451020436122948e-1;
          c2[7, 2] := 0.4925978555548549;
          c2[8, 1] := 0.7297197617673508e-1;
          c2[8, 2] := 0.4699889739625235;
          c2[9, 1] := 0.7122194706992953e-1;
          c2[9, 2] := 0.4445436860615774;
          c2[10, 1] := 0.6926216260386816e-1;
          c2[10, 2] := 0.4164072786327193;
          c2[11, 1] := 0.6709399961255503e-1;
          c2[11, 2] := 0.3857341621868851;
          c2[12, 1] := 0.6471757977022456e-1;
          c2[12, 2] := 0.3526828388476838;
          c2[13, 1] := 0.6213084287116965e-1;
          c2[13, 2] := 0.3174082831364342;
          c2[14, 1] := 0.5932799638550641e-1;
          c2[14, 2] := 0.2800495563550299;
          c2[15, 1] := 0.5629672408524944e-1;
          c2[15, 2] := 0.2407078154782509;
          c2[16, 1] := 0.5301264751544952e-1;
          c2[16, 2] := 0.1994026830553859;
          c2[17, 1] := 0.4942673259817896e-1;
          c2[17, 2] := 0.1559719194038917;
          c2[18, 1] := 0.4542996716979947e-1;
          c2[18, 2] := 0.1097844277878470;
          c2[19, 1] := 0.4070720755433961e-1;
          c2[19, 2] := 0.5852181110523043e-1;
        elseif order == 39 then
          alpha := 0.1374332900196804;
          c1[1] := 0.2779468246419593;
          c2[1, 1] := 0.7715084161825772e-1;
          c2[1, 2] := 0.5543001331300056;
          c2[2, 1] := 0.7684028301163326e-1;
          c2[2, 2] := 0.5495289890712267;
          c2[3, 1] := 0.7632343924866024e-1;
          c2[3, 2] := 0.5416083298429741;
          c2[4, 1] := 0.7560141319808483e-1;
          c2[4, 2] := 0.5305846713929198;
          c2[5, 1] := 0.7467569064745969e-1;
          c2[5, 2] := 0.5165224112570647;
          c2[6, 1] := 0.7354807648551346e-1;
          c2[6, 2] := 0.4995030679271456;
          c2[7, 1] := 0.7222060351121389e-1;
          c2[7, 2] := 0.4796242430956156;
          c2[8, 1] := 0.7069540462458585e-1;
          c2[8, 2] := 0.4569982440368368;
          c2[9, 1] := 0.6897453353492381e-1;
          c2[9, 2] := 0.4317502624832354;
          c2[10, 1] := 0.6705970959388781e-1;
          c2[10, 2] := 0.4040159353969854;
          c2[11, 1] := 0.6495194541066725e-1;
          c2[11, 2] := 0.3739379843169939;
          c2[12, 1] := 0.6265098412417610e-1;
          c2[12, 2] := 0.3416613843816217;
          c2[13, 1] := 0.6015440984955930e-1;
          c2[13, 2] := 0.3073260166338746;
          c2[14, 1] := 0.5745615876877304e-1;
          c2[14, 2] := 0.2710546723961181;
          c2[15, 1] := 0.5454383762391338e-1;
          c2[15, 2] := 0.2329316824061170;
          c2[16, 1] := 0.5139340231935751e-1;
          c2[16, 2] := 0.1929604256043231;
          c2[17, 1] := 0.4795705862458131e-1;
          c2[17, 2] := 0.1509655259246037;
          c2[18, 1] := 0.4412933231935506e-1;
          c2[18, 2] := 0.1063130748962878;
          c2[19, 1] := 0.3960672309405603e-1;
          c2[19, 2] := 0.5672356837211527e-1;
        elseif order == 40 then
          alpha := 0.1356742655825434;
          c2[1, 1] := 0.7538038374294594e-1;
          c2[1, 2] := 0.5488228264329617;
          c2[2, 1] := 0.7518806529402738e-1;
          c2[2, 2] := 0.5458297722483311;
          c2[3, 1] := 0.7480383050347119e-1;
          c2[3, 2] := 0.5398604576730540;
          c2[4, 1] := 0.7422847031965465e-1;
          c2[4, 2] := 0.5309482987446206;
          c2[5, 1] := 0.7346313704205006e-1;
          c2[5, 2] := 0.5191429845322307;
          c2[6, 1] := 0.7250930053201402e-1;
          c2[6, 2] := 0.5045099368431007;
          c2[7, 1] := 0.7136868456879621e-1;
          c2[7, 2] := 0.4871295553902607;
          c2[8, 1] := 0.7004317764946634e-1;
          c2[8, 2] := 0.4670962098860498;
          c2[9, 1] := 0.6853470921527828e-1;
          c2[9, 2] := 0.4445169164956202;
          c2[10, 1] := 0.6684507689945471e-1;
          c2[10, 2] := 0.4195095960479698;
          c2[11, 1] := 0.6497570123412630e-1;
          c2[11, 2] := 0.3922007419030645;
          c2[12, 1] := 0.6292726794917847e-1;
          c2[12, 2] := 0.3627221993494397;
          c2[13, 1] := 0.6069918741663154e-1;
          c2[13, 2] := 0.3312065181294388;
          c2[14, 1] := 0.5828873983769410e-1;
          c2[14, 2] := 0.2977798532686911;
          c2[15, 1] := 0.5568964389813015e-1;
          c2[15, 2] := 0.2625503293999835;
          c2[16, 1] := 0.5288947816690705e-1;
          c2[16, 2] := 0.2255872486520188;
          c2[17, 1] := 0.4986456327645859e-1;
          c2[17, 2] := 0.1868796731919594;
          c2[18, 1] := 0.4656832613054458e-1;
          c2[18, 2] := 0.1462410193532463;
          c2[19, 1] := 0.4289867647614935e-1;
          c2[19, 2] := 0.1030361558710747;
          c2[20, 1] := 0.3856310684054106e-1;
          c2[20, 2] := 0.5502423832293889e-1;
        elseif order == 41 then
          alpha := 0.1339811106984253;
          c1[1] := 0.2713685065531391;
          c2[1, 1] := 0.7355140275160984e-1;
          c2[1, 2] := 0.5413274778282860;
          c2[2, 1] := 0.7328319082267173e-1;
          c2[2, 2] := 0.5371064088294270;
          c2[3, 1] := 0.7283676160772547e-1;
          c2[3, 2] := 0.5300963437270770;
          c2[4, 1] := 0.7221298133014343e-1;
          c2[4, 2] := 0.5203345998371490;
          c2[5, 1] := 0.7141302173623395e-1;
          c2[5, 2] := 0.5078728971879841;
          c2[6, 1] := 0.7043831559982149e-1;
          c2[6, 2] := 0.4927768111819803;
          c2[7, 1] := 0.6929049381827268e-1;
          c2[7, 2] := 0.4751250308594139;
          c2[8, 1] := 0.6797129849758392e-1;
          c2[8, 2] := 0.4550083840638406;
          c2[9, 1] := 0.6648246325101609e-1;
          c2[9, 2] := 0.4325285673076087;
          c2[10, 1] := 0.6482554675958526e-1;
          c2[10, 2] := 0.4077964789091151;
          c2[11, 1] := 0.6300169683004558e-1;
          c2[11, 2] := 0.3809299858742483;
          c2[12, 1] := 0.6101130648543355e-1;
          c2[12, 2] := 0.3520508315700898;
          c2[13, 1] := 0.5885349417435808e-1;
          c2[13, 2] := 0.3212801560701271;
          c2[14, 1] := 0.5652528148656809e-1;
          c2[14, 2] := 0.2887316252774887;
          c2[15, 1] := 0.5402021575818373e-1;
          c2[15, 2] := 0.2545001287790888;
          c2[16, 1] := 0.5132588802608274e-1;
          c2[16, 2] := 0.2186415296842951;
          c2[17, 1] := 0.4841900639702602e-1;
          c2[17, 2] := 0.1811322622296060;
          c2[18, 1] := 0.4525419574485134e-1;
          c2[18, 2] := 0.1417762065404688;
          c2[19, 1] := 0.4173260173087802e-1;
          c2[19, 2] := 0.9993834530966510e-1;
          c2[20, 1] := 0.3757210572966463e-1;
          c2[20, 2] := 0.5341611499960143e-1;
        else
          Streams.error("Input argument order (= " + String(order) +
            ") of Bessel filter is not in the range 1..41");
        end if;

        annotation (Documentation(info="<html>
<p>
The transfer function H(p) of a <i>n</i> 'th order Bessel filter is given by
</p>
<blockquote><pre>
        Bn(0)
H(p) = -------
        Bn(p)
</pre></blockquote>
<p>
with the denominator polynomial
</p>
<blockquote><pre>
         n             n  (2n - k)!       p^k
Bn(p) = sum c_k*p^k = sum ----------- * -------   (1)
        k=0           k=0 (n - k)!k!    2^(n-k)
</pre></blockquote>
<p>
and the numerator
</p>
<blockquote><pre>
               (2n)!     1
Bn(0) = c_0 = ------- * ---- .                     (2)
                n!      2^n
</pre></blockquote>
<p>
Although the coefficients c_k are integer numbers, it is not advisable to use the
polynomials in an unfactorized form because the coefficients are fast growing with order
n (c_0 is approximately 0.3e24 and 0.8e59 for order n=20 and order n=40
respectively).
</p>
<p>
Therefore, the polynomial Bn(p) is factorized to first and second order polynomials with
real coefficients corresponding to zeros and poles representation that is used in this library.
</p>
<p>
The function returns the coefficients which resulted from factorization of the normalized transfer function
</p>
<blockquote><pre>
H'(p') = H(p),  p' = p/w0
</pre></blockquote>
<p>
as well as
</p>
<blockquote><pre>
alpha = 1/w0
</pre></blockquote>
<p>
the reciprocal of the cut of frequency w0 where the gain of the transfer function is
decreased 3dB.
</p>
<p>
Both, coefficients and cut off frequency were calculated symbolically and were eventually evaluated
with high precision calculation. The results were stored in this function as real
numbers.
</p>

<h4>Calculation of normalized Bessel filter coefficients</h4>
<p>
Equation
<blockquote><pre>
abs(H(j*w0)) = abs(Bn(0)/Bn(j*w0)) = 10^(-3/20)
</pre></blockquote>
<p>
which must be fulfilled for cut off frequency w = w0 leads to
</p>
<blockquote><pre>
[Re(Bn(j*w0))]^2 + [Im(Bn(j*w0))]^2 - (Bn(0)^2)*10^(3/10) = 0
</pre></blockquote>
<p>
which has exactly one real solution w0 for each order n. This solutions of w0 are
calculated symbolically first and evaluated by using high precise values of the
coefficients c_k calculated by following (1) and (2).
</p>
<p>
With w0, the coefficients of the factorized polynomial can be computed by calculating the
zeros of the denominator polynomial
</p>
<blockquote><pre>
        n
Bn(p) = sum w0^k*c_k*(p/w0)^k
        k=0
</pre></blockquote>
<p>
of the normalized transfer function H'(p'). There exist n/2 of conjugate complex
pairs of zeros (beta +-j*gamma) if n is even and one additional real zero (alpha) if n is
odd. Finally, the coefficients a, b1_k, b2_k of the polynomials
</p>
<blockquote><pre>
a*p + 1,  n is odd
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>
b2_k*p^2 + b1_k*p + 1,   k = 1,... div(n,2)
</pre></blockquote>
<p>
results from
<blockquote><pre>
a = -1/alpha
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>
b2_k = 1/(beta_k^2 + gamma_k^2) b1_k = -2*beta_k/(beta_k^2 + gamma_k^2)
</pre></blockquote>
</html>"));
      end BesselCoefficients;

      function checkRepresentation
        "Check whether the system on file is represented by zeros and poles (z, p) or first and second order polynomials (n1, n2, d1, d2)"
        import Modelica_LinearSystems2.ZerosAndPoles;
        input String fileName="zp.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
            caption="state space system data file")));
        output Boolean iszp=true;
    protected
        Integer m=0;

      algorithm
        m := ZerosAndPoles.Internal.findMatrixName(fileName, "z");
        m := m + ZerosAndPoles.Internal.findMatrixName(fileName, "p");
        iszp := m == 2;

        annotation (Documentation(info="<html>
<p>
The function output is true if the system is given in zeros and poles representation.
Therefore, it is assumend that the used array names are \"z\" and \"p\" or \"n1, n2, d1\" and \"d2\" respectively.
</p>
</html>"));
      end checkRepresentation;

      encapsulated function filter
        "Generate the data record of a ZerosAndPoles transfer function from a filter description"

        import Modelica;
        import Modelica.Utilities.Streams;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Utilities.Types;
        import Modelica_LinearSystems2.ZerosAndPoles;

        import MMath = Modelica.Math;

        input Modelica_LinearSystems2.Utilities.Types.AnalogFilter analogFilter=Modelica_LinearSystems2.Utilities.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)";
        input Modelica_LinearSystems2.Utilities.Types.FilterType filterType=Modelica_LinearSystems2.Utilities.Types.FilterType.LowPass "Type of filter (LowPass/HighPass)";
        input Integer order(min=1) = 2 "Order of filter";
        input Modelica.Units.SI.Frequency f_cut=1/(2*Modelica.Constants.pi)
          "Cut-off frequency (default is w_cut = 1 rad/s)";
        input Real gain=1.0
          "Gain (= amplitude of frequency response at zero frequency)";
        input Real A_ripple(unit="dB") = 0.5
          "Pass band ripple for Chebyshev filter (otherwise not used)";
        input Boolean normalized=true
          "True, if amplitude at f_cut decreases/increases 3 db (for low/high pass filter), otherwise unmodified filter";
        output ZerosAndPoles.Internal.ZerosAndPoles filter(
          redeclare Real n1[if filterType == Types.FilterType.LowPass then 0 else (
            if analogFilter == Types.AnalogFilter.CriticalDamping then order else
            mod(order, 2))],
          redeclare Real n2[if filterType == Types.FilterType.LowPass then 0 else (
            if analogFilter == Types.AnalogFilter.CriticalDamping then 0 else
            integer(order/2)),2],
          redeclare Real d1[if analogFilter == Types.AnalogFilter.CriticalDamping then
                  order else mod(order, 2)],
          redeclare Real d2[if analogFilter == Types.AnalogFilter.CriticalDamping then
                  0 else integer(order/2),2]) "Filter transfer function";

    protected
        Integer n_num1=size(filter.n1, 1);
        Integer n_num2=size(filter.n2, 1);
        Integer n_den1=size(filter.d1, 1);
        Integer n_den2=size(filter.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;
        Real pi=Modelica.Constants.pi;
        Boolean evenOrder=mod(order, 2) == 0
          "True, if even filter order, otherwise uneven";
        Modelica.Units.SI.AngularVelocity w_cut=2*pi*f_cut
          "Cut-off angular frequency";
        Real w_cut2 "= w_cut*w_cut";
        Real alpha=1.0 "Frequency correction factor";
        Real alpha2 "= alpha*alpha";

        Real alphax;

        Real epsilon "Ripple size";
        Real fac "arsinh(epsilon)";
        Real A2 "poleReal^2 + poleImag^2";
        Real A "Amplitude at w_cut";
        Real num1[n_num1]
          "[p] coefficients of numerator first order polynomials (a*p + 1)";
        Real num2[n_num2,2]
          "[p^2, p] coefficients of numerator second order polynomials (b*p^2 + a*p + 1I)";
        Real den1[n_den1]
          "[p] coefficients of denominator first order polynomials (a*p + 1)";
        Real den2[n_den2,2]
          "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1I)";
        Real aux;
        Real k;
      algorithm
        // Set properties that are common for all filters
        filter.k := gain;

        /* Compute filter coefficients of prototype low pass filter. If another filter
       characteristics is desired (e.g. high pass filter), it is derived
       from the low pass filter coefficients below
    */
        if analogFilter == Types.AnalogFilter.CriticalDamping then
          if normalized then
            alpha := sqrt(2^(1/order) - 1);
      //alpha := sqrt(10^(3/10/order)-1)
          else
            alpha := 1;
          end if;
          for i in 1:n_den1 loop
            den1[i] := alpha;
          end for;

        elseif analogFilter == Types.AnalogFilter.Bessel then
          (den1,den2,alpha) := ZerosAndPoles.Internal.BesselCoefficients(order);
          if not normalized then
            alpha2 := alpha*alpha;
            for i in 1:n_den2 loop
              den2[i, 1] := den2[i, 1]*alpha2;
              den2[i, 2] := den2[i, 2]*alpha;
            end for;
            if not evenOrder then
              den1[1] := den1[1]*alpha;
            end if;
          end if;

        elseif analogFilter == Types.AnalogFilter.Butterworth then
           // Original filter is already normalized
          for i in 1:n_den2 loop
            den2[i, 1] := 1.0;
            den2[i, 2] := -2*cos(pi*(0.5 + (i - 0.5)/order));
          end for;
          if not evenOrder then
            den1[1] := 1.0;
          end if;

        elseif analogFilter == Types.AnalogFilter.Chebyshev then
          epsilon := sqrt(10^(A_ripple/10) - 1);
          fac := MMath.asinh(1/epsilon)/order;

          if evenOrder then
             for i in 1:n_den2 loop
                den2[i,1] :=1/(cosh(fac)^2 - cos((2*i - 1)*pi/(2*order))^2);
                den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos((2*i - 1)*pi/(2*order));
             end for;
          else
             den1[1] := 1/sinh(fac);
             for i in 1:n_den2 loop
                den2[i,1] :=1/(cosh(fac)^2 - cos(i*pi/order)^2);
                den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos(i*pi/order);
             end for;
          end if;

           /* Transformation of filter transfer function with "new(p) = alpha*p"
          in order that the filter transfer function has an amplitude of
          1/sqrt(2) at the cutoff frequency
       */
          if normalized then
            alpha := ZerosAndPoles.Internal.normalizationFactor(den1, den2);
            alpha2 := alpha*alpha;
            for i in 1:n_den2 loop
              den2[i, 1] := den2[i, 1]*alpha2;
              den2[i, 2] := den2[i, 2]*alpha;
            end for;
            if not evenOrder then
              den1[1] := den1[1]*alpha;
            end if;
          end if;

        else
          Streams.error("analogFilter (= " + String(analogFilter) +
            ") is not supported");
        end if;

        // Compute amplitude at w=1
      /*
    A := 1.0;
    for i in 1:n_den2 loop
       A := A*(1 + den2[i,2]^2 - 2*den2[i,1]
                 + den2[i,1]^2);
    end for;
    for i in 1:n_den1 loop
       A := A*(1 + den1[i]^2);
    end for;
    A := 1/sqrt(A);
    Streams.print("A = " + String(A));
    */

        // Determine normalized denominator polynomials with highest power of p equal to one
        filter.n1 := zeros(n_num1);
        filter.n2 := zeros(n_num2, 2);
        (filter.d1,filter.d2,k) := ZerosAndPoles.Internal.filterToNormalized(den1, den2);
        filter.k := filter.k/k;

        // Compute desired filter characteristics from low pass filter coefficients
        if filterType == Types.FilterType.HighPass then
           /* The high pass filter is derived from the low pass filter by
          the transformation new(p) = 1/p
          1/(p^2 + a*p + b) -> 1/((1/p)^2 + a*(1/p) + b) = (1/b)*p^2 / (p^2 + (a/b)*p + 1/b)
          1/(p + a)         -> 1/((1/p) + a) = (1/a)*p / (p + (1/a))
       */
          assert(n_num1 == n_den1 and n_num2 == n_den2,
            "Internal error 1, should not occur");
          filter.n1 := zeros(n_num1);
          filter.n2 := zeros(n_num2, 2);
          for i in 1:n_num1 loop
            filter.k := filter.k/filter.d1[i];
            filter.d1[i] := 1/filter.d1[i];
          end for;
          for i in 1:n_num2 loop
            filter.k := filter.k/filter.d2[i, 2];
            filter.d2[i, 1] := filter.d2[i, 1]/filter.d2[i, 2];
            filter.d2[i, 2] := 1/filter.d2[i, 2];
          end for;
        end if;

        /* Change filter coefficients according to transformation new(p) = p/w_cut
       Numerator  :     (p/w)^2 + a*(p/w) + b = (1/w^2)*(p^2 + (a*w)*p + b*w^2)
                                    (p/w) + a = (1/w)*(p + w*a)
       Denominator: 1/((p/w)^2 + a*(p/w) + b) = w^2/(p^2 + (a*w)*p + w^2/b)
                                1/((p/w) + a) = w/(p + w*a)
    */
        w_cut2 := w_cut*w_cut;
        filter.k := filter.k*w_cut^(n_den1 + 2*n_den2 - n_num1 - 2*n_num2);
        filter.n1 := w_cut*filter.n1;
        filter.d1 := w_cut*filter.d1;
        filter.n2 := [w_cut*filter.n2[:, 1],w_cut2*filter.n2[:, 2]];
        filter.d2 := [w_cut*filter.d2[:, 1],w_cut2*filter.d2[:, 2]];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
filterFunction = ZerosAndPoles.Internal<b>filter</b>(
  analogFilter,
  filterType,
  order,
  f_cut,
  gain,
  A_ripple,
  normalized)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a ZerosAndPoles transfer function
description of low and high pass filters. For more details see also
<a href=\"modelica://Modelica_LinearSystems2.UsersGuide.Literature\">[Tietze2002]</a>, pp. 815-852.
</p>
<p>
Typical frequency responses for the four supported low pass filter types
are shown in the next figure (this figure was generated with function
<a href=\"modelica://Modelica_LinearSystems2.Examples.ZerosAndPoles.plotBodeFilter2\">Examples.ZerosAndPoles.plotBodeFilter2</a>):
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4Filters.png\">
</p>
<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4FiltersStepResponse.png\">
</p>
<p>
Obviously, the frequency responses give a somewhat wrong impression
of the filter characteristics: Although Butterworth and Chebyshev
filters have a significantly steeper magnitude as the
CriticalDamping and Bessel filters, the step responses of
the latter ones are much better. This means for example, that
a CriticalDamping or a Bessel filter should be selected,
if a filter is mainly used to make a non-linear inverse model
realizable.
</p>

<p>
Typical frequency responses for the four supported high pass filter types
are shown in the next figure (generated with function
<a href=\"modelica://Modelica_LinearSystems2.Examples.ZerosAndPoles.plotBodeFilter3\">Examples.ZerosAndPoles.plotBodeFilter3</a>):
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4Filters.png\">
</p>
<p>
The corresponding step responses of these high pass filters are
shown in the next figure:
</p>
<p align=\"center\">
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4FiltersStepResponse.png\">
</p>
<p>
All filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cutoff frequency is 1/sqrt(2) (= 3 dB). Note, when comparing the filters
of this function with other software systems, the setting of \"normalized\"
has to be selected appropriately. For example, the signal processing
toolbox of Matlab provides the filters in non-normalized form and
therefore a comparison makes only sense, if normalized = <b>false</b>
is set.
</p>

<h4>Example</h4>
<blockquote><pre>
  Types.AnalogFilter analogFilter=Types.AnalogFilter.CriticalDamping;
  Integer order=2;
  Modelica.Units.SI.Frequency f_cut=10;

  ZerosAndPoles zp_filter;

<b>algorithm</b>
  zp_filter=Modelica_LinearSystems2.ZerosAndPoles.Design.filter(
    order=order,
    f_cut=f_cut,
    analogFilter=analogFilter);

// zp_filter = 9530.93/( (p + 97.6265)^2 )
</pre></blockquote>
</html>"));
      end filter;

      function filterToNormalized
        "Given [p^2,p] and [p] coefficients, transform to normalized form with highest power of p equal 1"

        input Real c1[:] "[p] coefficients of polynomials (c1[i]*p + 1)";
        input Real c2[:,2]
          "[p^2, p] coefficients of polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
        output Real n1[size(c1, 1)]
          "[p^0] coefficients of polynomials c1[i]*(p+1/c1[i])";
        output Real n2[size(c2, 1),2]
          "[p, p^0] coefficients of polynomials c2[i,1]*(p^2 + (c2[i,2]/c2[i,1])*p + (1/c2[i,1]))";
        output Real k "Gain (product(1/c1[i])*(1/c2[i,1])";
      algorithm
        k := 1.0;
        for i in 1:size(c1, 1) loop
          k := k*c1[i];
          n1[i] := 1/c1[i];
        end for;

        for i in 1:size(c2, 1) loop
          k := k*c2[i, 1];
          n2[i, 1] := c2[i, 2]/c2[i, 1];
          n2[i, 2] := 1/c2[i, 1];
        end for;
      end filterToNormalized;

      function findMatrixName
        "Find out whether matrix matName exists in file filename"
        input String filename;
        input String matName="z";

        output Integer m;

      external "C" m = findMatrixName(
              filename,
              matName,
              "NoClass") annotation (Include="#include <matrixop.h>
#include <matrixop.c>


#if !defined(DYMOLA_DSPACE) && !defined(NO_FILE)
#include <amat.h>
#include <sprwat.h>
#endif

extern int findMatrixName(const char* fil,const char* matname, char *noClass) {
int found=0;


#if !defined(DYMOLA_DSPACE) && !defined(NO_FILE)
{
        AmatGetFile afile;
        Amatrix amatrix;

        int ret=amatGetOpen((char*)fil,noClass,(char*)0,&afile);

        Assert(ret==0,amatError);
        for(;ret==0 && !found;)
{
                amatInit(&amatrix);
                ret=amatGetMatrix(&afile, &amatrix);
                if (ret<=1 && strcmp(matname,amatrix.name)==0)
                  found=1;
                else
                  found=0;

                amatDel(&amatrix);
        }
        amatGetClose(&afile);
}
#else
        Assert(false, 'nn');
#endif
        return found;
}");
      end findMatrixName;

      function firstOrderToString
        "Transform vector of coefficients of first order polynomials to a string representation"
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math;

        input Real c[:] = fill(0.0,0)
          "Coefficients of first order polynomials: polynom(p) = p + c[i]";
        input Integer significantDigits=6
          "Number of significant digits that are shown";
        input String name="p" "Independent variable name used for printing";
        input Boolean normalized=false
          "= true, the polynomials in the string are represented as p/c[i] + 1, provided c[i]<>0";
        output String s="";
        output Real gain=1.0
          "If normalized=true, the product(c[i]) (for i, where c[i]<>0), otherwise gain=1.0";
    protected
        Integer nc=size(c, 1);
        Real cs[nc];
        Real cc[nc];
        Integer i;
        Integer j;
        Integer j2;
        Integer nj;
        Integer k;
        constant Real smallNumber = 100*Modelica.Constants.small;
        constant Real eps = 10*Modelica.Constants.eps;
      algorithm
        // Change coefficients, if normalized output, and sort them
        for i in 1:nc loop
           if Math.isEqual(c[i], 0.0, smallNumber) then
              cs[i] := 0.0;
           elseif normalized then
              cs[i] := 1/c[i];
              gain := gain*c[i];
           else
              cs[i] := c[i];
           end if;
        end for;
        cc :=Modelica.Math.Vectors.sort(cs);

        // Move zeros to the beginning
        j :=0;
        k :=nc + 1;
        for i in nc:-1:1 loop
           if cc[i] == 0.0 then
              j := j + 1;
              cs[j] := 0.0;
           else
              k := k - 1;
              cs[k] := cc[i];
           end if;
        end for;

        // Transform coefficients to string
        if j == 1 then
           s := name;
        elseif j > 1 then
           s := name + "^" + String(j);
        end if;

        i :=j + 1;
        if normalized then
          while i <= nc loop
            if i > 1 then
              s := s + "*";
            end if;
            if Math.isEqual(cs[i], 1.0, eps) then
               s := s + "(";
            elseif Math.isEqual(cs[i], -1.0, eps) then
               s := s + "(-";
            else
               s := s + "(" + String(cs[i], significantDigits=significantDigits) + "*";
            end if;
            s :=s + name + " + 1)";
            j2 := sameVectorElements(cs, i);
            nj := j2 - i + 1;
            if nj > 1 then
              s := s + "^" + String(nj);
            end if;
            i := j2 + 1;
          end while;
        else
          while i <= nc loop
            if i > 1 then
              s := s + "*";
            end if;
            if cs[i] > 0 then
               s := s + "(" + name + " + ";
            else
               s := s + "(" + name + " - ";
            end if;
            s  := s + String(abs(cs[i]), significantDigits=significantDigits) + ")";
            j2 := sameVectorElements(cs, i);
            nj := j2 - i + 1;
            if nj > 1 then
              s := s + "^" + String(nj);
            end if;
            i := j2 + 1;
          end while;
        end if;
      end firstOrderToString;

      function frequencyRange "Determine min. and max. resonance frequencies"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;

        input Real poly1[:];
        input Real poly2[:,2];
        output Boolean w_found=false;
        output Modelica.Units.SI.AngularVelocity w_min;
        output Modelica.Units.SI.AngularVelocity w_max;
    protected
        Integer order=size(poly1, 1) + 2*size(poly2, 1);
        Integer n_real=numberOfRealZeros(poly1, poly2);
        Real zeros1[n_real];
        Complex zeros2[:]=fill(Complex(0, 0), integer((order - n_real)/2));
        Real w;
      algorithm
        // Compute zeros
        (zeros1,zeros2) := roots(
              poly1,
              poly2,
              n_real);

        // Compute resonance frequencies
        w_min := Modelica.Constants.inf;
        w_max := -Modelica.Constants.inf;
        for i in 1:size(zeros1, 1) loop
          if zeros1[i] <> 0 then
            w := abs(zeros1[i]);
            w_min := min(w_min, w);
            w_max := max(w_max, w);
            w_found := true;
          end if;
        end for;

        for i in 1:size(zeros2, 1) loop
          w := Complex.'abs'(zeros2[i]);
          w_min := min(w_min, w);
          w_max := max(w_max, w);
          w_found := true;
        end for;
      end frequencyRange;

      function frequencyRangeBode
        "Determine min. and max. frequencies for Bode plot"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles tf "ZerosAndPoles transfer function";
        output Modelica.Units.SI.AngularVelocity w_min;
        output Modelica.Units.SI.AngularVelocity w_max;
    protected
        Real phi_min=Modelica.Units.Conversions.from_deg(3);
        Real real_min=1.0e-4;
        Real pi=Modelica.Constants.pi;
        Complex numZeros[:];
        Complex denZeros[:];
        Integer n_num;
        Integer n_den;
        Real w_min1;
        Real w_min2;
        Real w_max1;
        Real w_max2;
      algorithm
        // Compute zeros and poles
        (numZeros,denZeros) := ZerosAndPoles.Analysis.zerosAndPoles(tf);

        // Compute frequencies for numerator
        n_num := size(numZeros, 1);
        if n_num > 0 then
          (w_min1,w_max1) := Modelica_LinearSystems2.Internal.frequencyRangeZeros(
                numZeros,
                phi_min,
                real_min);
        end if;

        // Compute frequencies for denominator
        n_den := size(denZeros, 1);
        if n_den > 0 then
          (w_min2,w_max2) := Modelica_LinearSystems2.Internal.frequencyRangeZeros(
                denZeros,
                phi_min,
                real_min);
        end if;

        // Use largest range
        if n_num == 0 and n_den == 0 then
          w_min := 0.1;
          w_max := 10;
        elseif n_num == 0 then
          w_min := w_min2;
          w_max := w_max2;
        elseif n_den == 0 then
          w_min := w_min1;
          w_max := w_max1;
        else
          w_min := min(w_min1, w_min2);
          w_max := max(w_max1, w_max2);
        end if;
      end frequencyRangeBode;

      encapsulated function fromFile_pc
        "Generate a ZerosAndPoles data record by reading the polynomial coefficients from a file (default file name is pc.mat)"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input String fileName="pc.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption="state space system data file")));

    protected
        Integer n1n2d1d2[4]=
            ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc(fileName);
        Integer n1=n1n2d1d2[1];
        Integer n2=n1n2d1d2[2];
        Integer d1=n1n2d1d2[3];
        Integer d2=n1n2d1d2[4];
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    public
        output ZerosAndPoles zp(
          n1=fill(0, n1),
          n2=fill(
                0,
                n2,
                2),
          d1=fill(0, d1),
          d2=fill(
                0,
                d2,
                2));

    protected
        Integer n1_2=if n1 > 0 then 1 else 0 "second dimension of n1-matrix";
        Integer n2_2=if n2 > 0 then 2 else 0 "second dimension of n2-matrix";
        Integer d1_2=if d1 > 0 then 1 else 0 "second dimension of d1-matrix";
        Integer d2_2=if d2 > 0 then 2 else 0 "second dimension of d2-matrix";

        Real k=scalar(readMatrix(
              fileName,
              "k",
              1,
              1));
        Real n1Vector[n1]=vector(readMatrix(
              fileName,
              "n1",
              n1,
              n1_2)) "coefficients of first order numenator polynomials";
        Real n2Matrix[n2,n2_2]=readMatrix(
              fileName,
              "n2",
              n2,
              n2_2) "coefficients of second order denominator polynomials";
        Real d1Vector[d1]=vector(readMatrix(
              fileName,
              "d1",
              d2,
              d1_2)) "coefficients of first order denominator polynomials";
        Real d2Matrix[d2,d2_2]=readMatrix(
              fileName,
              "d2",
              d2,
              d2_2) "coefficients of second order numenator polynomials";

      algorithm
        zp.k := k;
        zp.n1 := if n1 > 0 then n1Vector else fill(0, 0);
        zp.n2 := if n2 > 0 then n2Matrix else fill(
            0,
            0,
            2);
        zp.d1 := if d1 > 0 then d1Vector else fill(0, 0);
        zp.d2 := if d2 > 0 then d2Matrix else fill(
            0,
            0,
            2);

      end fromFile_pc;

      encapsulated function fromFile_zp
        "Generate a ZerosAndPoles data record by reading poles and zeros from a file (default file name is zp.mat)"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input String fileName="zp.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                        caption="state space system data file")));
    protected
        Integer n1n2d1d2[4]=
          ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp(fileName);
        Integer n1=n1n2d1d2[1];
        Integer n2=n1n2d1d2[2];
        Integer d1=n1n2d1d2[3];
        Integer d2=n1n2d1d2[4];
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    public
        output ZerosAndPoles zp(
          n1=fill(0, n1),
          n2=fill(0, n2, 2),
          d1=fill(0, d1),
          d2=fill(0, d2, 2));

    protected
        Integer z_2=if zSize > 0 then 2 else 0 "second dimension of zeros-matrix";
        Integer p_2=if pSize > 0 then 2 else 0 "second dimension of poles-matrix";

        Real k=scalar(readMatrix(
              fileName,
              "k",
              1,
              1));
        Real zerosMatrix[zSize,z_2]=readMatrix(
              fileName,
              "z",
              zSize,
              z_2) "zeros in rows of real parts and imaginary parts";
        Real polesMatrix[pSize,p_2]=readMatrix(
              fileName,
              "p",
              pSize,
              p_2) "poles in rows of real parts and imaginary parts";
        Complex zeros[:]=if zSize > 0 then ZerosAndPoles.Internal.fromRealAndImag(
            zerosMatrix[:, 1], zerosMatrix[:, z_2]) else fill(Complex(0), 0);
        Complex poles[:]=if pSize > 0 then ZerosAndPoles.Internal.fromRealAndImag(
            polesMatrix[:, 1], polesMatrix[:, p_2]) else fill(Complex(0), 0);

      algorithm
        zp := ZerosAndPoles(
            k=k,
            z=zeros,
            p=poles);
      end fromFile_zp;

      function fromRealAndImag
        "Generate a complex vector from a real part vector and imaginary part vector "

        import Modelica_LinearSystems2.Math.Complex;

        input Real real[:];
        input Real imag[size(real, 1)];
        output Complex result[size(real, 1)] "Number of real zeros";
      algorithm
        for i in 1:size(real, 1) loop
          result[i].re := real[i];
          result[i].im := imag[i];
        end for;
      end fromRealAndImag;

      encapsulated function isControllableAndObservableSISO
        "To check whether a SISO system is controllable and observable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input ZerosAndPoles zp;

        output Boolean controllableAndObservable;
    protected
        StateSpace ss=StateSpace(zp);

      algorithm
        controllableAndObservable := StateSpace.Internal.isControllableAndObservableSISO(ss=ss);

      end isControllableAndObservableSISO;

      function isRoot
        "Check if frequency is an element of the complex vector zeros"

        import Modelica_LinearSystems2.Math.Complex;
        //import Modelica_LinearSystems2;

        input Complex zeros[:];
        input Complex p;
      //Never used
        input Real eps(min=0) = 0;
        output Boolean result;

    protected
        Integer sz=size(zeros, 1);
        Integer i;

      algorithm
        i := 1;
        result := false;
        while i <= sz and not result loop

      //The implementation of Complex.'==' does not take a third parameter.
          result := p == zeros[i];
          i := i + 1;
        end while;

      end isRoot;

      encapsulated function normalizationFactor
        "Compute correction factor of low pass filter such that amplitude at cut-off frequency is -3db (=10^(-3/20) = 0.70794...)"
        import Modelica;
        import Modelica.Utilities.Streams;

        input Real c1[:]
          "[p] coefficients of denominator polynomials (c1[i}*p + 1)";
        input Real c2[:,2]
          "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
        output Real alpha "Correction factor (replace p by alpha*p)";
    protected
        Real alpha_min;
        Real alpha_max;

        function normalizationResidue "Residue of correction factor computation"
          input Real c1[:]
            "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
          input Real c2[:,2]
            "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
          input Real alpha;
          output Real residue;
      protected
          constant Real beta= 10^(-3/20)
            "Amplitude of -3db required, i.e. -3db = 20*log(beta)";
          Real cc1;
          Real cc2;
          Real p;
          Real alpha2=alpha*alpha;
          Real alpha4=alpha2*alpha2;
          Real A2=1.0;
        algorithm
          assert(size(c1,1) <= 1, "Internal error 2 (should not occur)");
          if size(c1, 1) == 1 then
            cc1 := c1[1]*c1[1];
            p := 1 + cc1*alpha2;
            A2 := A2*p;
          end if;
          for i in 1:size(c2, 1) loop
            cc1 := c2[i, 2]*c2[i, 2] - 2*c2[i, 1];
            cc2 := c2[i, 1]*c2[i, 1];
            p := 1 + cc1*alpha2 + cc2*alpha4;
            A2 := A2*p;
          end for;
          residue := 1/sqrt(A2) - beta;
        end normalizationResidue;

        function findInterval "Find interval for the root"
          input Real c1[:]
            "[p] coefficients of denominator polynomials (a*p + 1)";
          input Real c2[:,2]
            "[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)";
          output Real alpha_min;
          output Real alpha_max;
      protected
          Real alpha = 1.0;
          Real residue;
        algorithm
          alpha_min :=0;
          residue := normalizationResidue(c1, c2, alpha);
          if residue < 0 then
             alpha_max :=alpha;
          else
             while residue >= 0 loop
                alpha := 1.1*alpha;
                residue := normalizationResidue(c1, c2, alpha);
             end while;
             alpha_max :=alpha;
          end if;
        end findInterval;

        function solveOneNonlinearEquation
          "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
          import Modelica.Utilities.Streams.error;

          input Real c1[:]
            "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
          input Real c2[:,2]
            "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
          input Real u_min "Lower bound of search intervall";
          input Real u_max "Upper bound of search intervall";
          input Real tolerance=100*Modelica.Constants.eps
            "Relative tolerance of solution u";
          output Real u "Value of independent variable so that f(u) = 0";

      protected
          constant Real eps=Modelica.Constants.eps "machine epsilon";
          Real a=u_min "Current best minimum interval value";
          Real b=u_max "Current best maximum interval value";
          Real c "Intermediate point a <= c <= b";
          Real d;
          Real e "b - a";
          Real m;
          Real s;
          Real p;
          Real q;
          Real r;
          Real tol;
          Real fa "= f(a)";
          Real fb "= f(b)";
          Real fc;
          Boolean found=false;
        algorithm
          // Check that f(u_min) and f(u_max) have different sign
          fa := normalizationResidue(c1,c2,u_min);
          fb := normalizationResidue(c1,c2,u_max);
          fc := fb;
          if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
            error(
              "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
              "do not bracket the root of the single non-linear equation:\n" +
              "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
               + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
              "  fb = f(u_max) = " + String(fb) + "\n" +
              "fa and fb must have opposite sign which is not the case");
          end if;

          // Initialize variables
          c := a;
          fc := fa;
          e := b - a;
          d := e;

          // Search loop
          while not found loop
            if abs(fc) < abs(fb) then
              a := b;
              b := c;
              c := a;
              fa := fb;
              fb := fc;
              fc := fa;
            end if;

            tol := 2*eps*abs(b) + tolerance;
            m := (c - b)/2;

            if abs(m) <= tol or fb == 0.0 then
              // root found (interval is small enough)
              found := true;
              u := b;
            else
              // Determine if a bisection is needed
              if abs(e) < tol or abs(fa) <= abs(fb) then
                e := m;
                d := e;
              else
                s := fb/fa;
                if a == c then
                  // linear interpolation
                  p := 2*m*s;
                  q := 1 - s;
                else
                  // inverse quadratic interpolation
                  q := fa/fc;
                  r := fb/fc;
                  p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                  q := (q - 1)*(r - 1)*(s - 1);
                end if;

                if p > 0 then
                  q := -q;
                else
                  p := -p;
                end if;

                s := e;
                e := d;
                if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                  // interpolation successful
                  d := p/q;
                else
                  // use bi-section
                  e := m;
                  d := e;
                end if;
              end if;

              // Best guess value is defined as "a"
              a := b;
              fa := fb;
              b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
              fb := normalizationResidue(c1,c2,b);

              if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                // initialize variables
                c := a;
                fc := fa;
                e := b - a;
                d := e;
              end if;
            end if;
          end while;

          annotation (Documentation(info="<html>

<p>
This function determines the solution of <b>one non-linear algebraic equation</b> \"y=f(u)\"
in <b>one unknown</b> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <b>Algorithms for Minimization without derivatives</b>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>
</html>"));
        end solveOneNonlinearEquation;

      algorithm
        // Find interval for alpha
        (alpha_min, alpha_max) :=findInterval(c1, c2);

        // Compute alpha, so that abs(G(p)) = -3db
        alpha :=solveOneNonlinearEquation(
          c1,
          c2,
          alpha_min,
          alpha_max);
      end normalizationFactor;

      function numberOfRealPoles "Calculate number of real poles"
        import Modelica;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input TransferFunction tf "TransferFunction";
        output Integer result=Internal.numberOfRealZeros(Polynomial.roots(Polynomial(tf.d)));
      algorithm
      end numberOfRealPoles;

      encapsulated function numberOfRealZeros "Calculate number of real zeros"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Real poly1[:];
        input Real poly2[:,2];
        output Integer result "Number of real zeros";
    protected
        Real D;
      algorithm
        result := size(poly1, 1);
        for i in 1:size(poly2, 1) loop
          D := (poly2[i, 1]/2)^2 - poly2[i, 2];
          if D >= 0 then
              // two real zeros
            result := result + 2;
          end if;
        end for;
      end numberOfRealZeros;

      function numberOfRealZeros2 "Calculate number of real zeros"
        import Modelica;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input TransferFunction tf "TransferFunction";
        output Integer result=Internal.numberOfRealZeros(Polynomial.roots(Polynomial(tf.n)));
      algorithm
      end numberOfRealZeros2;

      function numberOfRealZerosAndPoles_pc
        "Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is zp.mat)"
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica;

        input String fileName="pc.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption="state space system data file")));
        output Integer n1n2d1d2[4];

    protected
        Integer n1Size[2]=readMatrixSize(fileName, "n1");
        Integer n2Size[2]=readMatrixSize(fileName, "n2");
        Integer d1Size[2]=readMatrixSize(fileName, "d1");
        Integer d2Size[2]=readMatrixSize(fileName, "d2");

      algorithm
        n1n2d1d2[1] := n1Size[1];
        n1n2d1d2[2] := n2Size[1];
        n1n2d1d2[3] := d1Size[1];
        n1n2d1d2[4] := d2Size[1];

      end numberOfRealZerosAndPoles_pc;

      function numberOfRealZerosAndPoles_zp
        "Get the number of first oder polynomials (n1, d1) and second order polynomials (n2, d2) of zeros and poles from zeros and poles written in a MAT-file"

        import Modelica_LinearSystems2.DataDir;
        import Modelica_LinearSystems2.Internal;

        input String fileName=DataDir + "/zp.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                        caption="state space system data file")));
        input Real eps=Modelica.Constants.eps;

        output Integer n1n2d1d2[4];

    protected
        Integer n1;
        Integer d1;

        Integer zSize[2]=readMatrixSize(fileName, "z");
        Integer pSize[2]=readMatrixSize(fileName, "p");

        Real zerosMatrix[zSize[1],zSize[2]]=readMatrix(
                fileName,
                "z",
                zSize[1],
                zSize[2]) "zeros in rows of real parts and imaginary parts";
        Real polesMatrix[pSize[1],pSize[2]]=readMatrix(
                fileName,
                "p",
                pSize[1],
                pSize[2]) "poles in rows of real parts and imaginary parts";

      algorithm
        n1 := zSize[1];
        d1 := pSize[1];
        for i in 1:zSize[1] loop
          if abs(zerosMatrix[i, 2]) >= eps then
            n1 := n1 - 1;
          end if;
        end for;
        for i in 1:pSize[1] loop
          if abs(polesMatrix[i, 2]) >= eps then
            d1 := d1 - 1;
          end if;
        end for;
        n1n2d1d2[1] := n1;
        n1n2d1d2[2] := div((zSize[1] - n1), 2);
        n1n2d1d2[3] := d1;
        n1n2d1d2[4] := div((pSize[1] - d1), 2);

      end numberOfRealZerosAndPoles_zp;

      function 'p+a' "Addition of a complex number and a real value"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica.ComplexMath.j;

        input Complex p; // "Complex number";
        input Real a "Value of Real variable";
        output Complex c;
      algorithm
        c := p.re + p.im*j +a;
        annotation(Inline=true);
      end 'p+a';

      function 'p^2+k[1]*p+k[2]'
        import Modelica;
        import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica.ComplexMath.j;

        input Complex p;
        input Real k[2];
        output Complex c;
      algorithm
        c := p.re^2 - p.im^2 + k[1]*p.re + k[2]+p.im*(2*p.re + k[1])*j;
        annotation(Inline=true);
      end 'p^2+k[1]*p+k[2]';

      function roots "Determine zeros of factorized polynomial"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;

        input Real poly1[:] "[p^0] coefficients of first order polynomials";
        input Real poly2[:,2] "[p, p^0] coefficients of second order polynomials";
        input Integer n_real
          "Number of real zeros computed with Internal.numberOfRealZeros";
        output Real realZeros[n_real] "All real zeros of poly1 and poly2";
        output Complex complexZeros[:]=fill(Complex(0, 0), integer((size(poly1, 1)
             + 2*size(poly2, 1) - n_real)/2))
          "All complex zeros of poly1 and poly2; for a complex conjugate pair, only one zero is stored";
    protected
        Integer np1=size(poly1, 1);
        Integer np2=size(poly2, 1);
        Real D;
        Real D2;
        Real b;
        Integer j1;
        Integer j2;
        Complex j = Modelica_LinearSystems2.Math.Complex.j();

      algorithm
        assert(np1 <= n_real, "Size of poly1 = " + String(np1) + " > n_real " +
          " (= " + String(n_real) + ").");
        for i in 1:np1 loop
          realZeros[i] := -poly1[i];
        end for;

        j1 := np1 + 1;
        j2 := 1;
        for i in 1:np2 loop
          b := poly2[i, 1]/2;
          D := b*b - poly2[i, 2];
          D2 := sqrt(abs(D));
          if D >= 0 then
            realZeros[j1] := -b + D2;
            realZeros[j1 + 1] := -b - D2;
            j1 := j1 + 2;
          else
            complexZeros[j2] := -b+D2*j;
            j2 := j2 + 1;
          end if;
        end for;
      end roots;

      function sameMatrixRows "Determine identical rows of a [:,2] matrix"

        input Real M[:,2] "Matrix";
        input Integer startIndex=1 "Start index";
        output Integer endIndex=startIndex
          "startIndex:endIndex are identical rows in M";
    protected
        Integer n=size(M, 1);
        Integer i=startIndex + 1;
        Real v0[size(M, 2)]=M[startIndex, :];
      algorithm
        while i <= n loop
          if M[i, 1] == v0[1] and M[i, 2] == v0[2] then
            endIndex := i;
            i := i + 1;
          else
            i := n + 1;
          end if;
        end while;
      end sameMatrixRows;

      function sameVectorElements "Determine identical elements of a vector"

        input Real v[:] "Vector";
        input Integer startIndex=1 "Start index";
        output Integer endIndex=startIndex
          "startIndex:endIndex are identical elements in v";
    protected
        Integer nv=size(v, 1);
        Integer i=startIndex + 1;
        Real v0=v[startIndex];
      algorithm
        while i <= nv loop
          if v[i] == v0 then
            endIndex := i;
            i := i + 1;
          else
            i := nv + 1;
          end if;
        end while;
      end sameVectorElements;

      encapsulated function scaleFactor1
        "Return scale factor for first order block"
        import Modelica;
        input Real n "(s+n)/(s+d)";
        input Real d "(s+n)/(s+d)";
        input Real small=100*Modelica.Constants.eps;
        output Real k "= n/d, if d,n are not zero, otherwise special cases";
      algorithm
        k := if abs(d) > small  and abs(n) > small then abs(n)/abs(d) else 1;

      end scaleFactor1;

      function scaleFactor2 "Return scale factor for second order block"
        import Modelica;
        input Real n1 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real n2 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real d1 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real d2 "(s^2 + n1*s + n2)/(s^2 + d1*s + d2)";
        input Real small=100*Modelica.Constants.eps;
        output Real k "= n2/d2, if d2,n2 are not zero, otherwise special cases";
      algorithm

        k := if abs(n2) > small and abs(d2) > small then d2/n2 else 1;

      end scaleFactor2;

      function secondOrderToString
        "Transform vector of coefficients of second order polynomials to a string representation"
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math;

        input Real c[:,2]=fill(0.0,0,2)
          "[p,p^0] coefficients osecond order polynomials: polynom(p) = p^2 + c[:,1]*p + c[:,2]";
        input Integer significantDigits=6
          "Number of significant digits that are shown";
        input String name="p" "Independent variable name used for printing";
        input Boolean normalized=false
          "= true, the polynomials in the string are represented as p^2/c[:,2] + c[:,1]/c[:,2]*p + 1, provided c[i,2]<>0";
        output String s="";
        output Real gain=1.0
          "If normalized=true, the product(c[i,2]) (for i, where c[i,2]<>0), otherwise gain=1.0";
    protected
        Integer nc=size(c, 1);
        Real cs[nc,2];
        Real cc[nc,2];
        Integer i=1;
        Integer j;
        Integer nj;
        constant Real smallNumber = 100*Modelica.Constants.small;
        constant Real eps = 10*Modelica.Constants.eps;
      algorithm
        // Change coefficients, if normalized output, and sort them
        for i in 1:nc loop
           if Math.isEqual(c[i,2], 0.0, smallNumber) then
              cs[i,1] := c[i,1];
              cs[i,2] := 0.0;
           elseif normalized then
              cs[i,1] := 1/c[i,2];
              cs[i,2] := c[i,1]/c[i,2];
              gain := gain*c[i,2];
           else
              cs[i,1] := c[i,1];
              cs[i,2] := c[i,2];
           end if;
        end for;
        cc :=Modelica.Math.Matrices.sort(cs);

        // Generate string
        if normalized then
          while i <= nc loop
            if i > 1 then
              s := s + "*";
            end if;
            j := sameMatrixRows(cc, i);
            nj := j - i + 1;
            if cc[i, 1] == 0.0 and cc[i, 2] == 0.0 then
              // case p^2
              s := s + name + "^" + String(2*nj);
            else
              // b*p^2 term
              if Math.isEqual(cc[i, 1], 1.0) then
                s := s + "(" + name + "^2";
              elseif Math.isEqual(cc[i, 1], -1.0) then
                s := s + "(-" + name + "^2";
              else
                s := s + "(" + String(cc[i, 1], significantDigits=significantDigits) +
                  "*" + name + "^2";
              end if;

              // a*p term
              if cc[i, 2] == 0.0 then
                 s := s + " + 1)";
              else
                 if Math.isEqual(cc[i, 2], 1.0, eps) then
                    s := s + " + ";
                 elseif Math.isEqual(cc[i, 2], -1.0, eps) then
                    s := s + " - ";
                 elseif cc[i, 2] >= 0.0 then
                    s := s + " + " + String(cc[i, 2], significantDigits=significantDigits) + "*";
                 else
                    s := s + " - " + String(-cc[i, 2], significantDigits=significantDigits) + "*";
                 end if;
                 s := s + name + " + 1)";
              end if;
              if nj > 1 then
                s := s + "^" + String(nj);
              end if;
            end if;
            i := j + 1;
          end while;

        else
          while i <= nc loop
            if i > 1 then
              s := s + "*";
            end if;
            j := sameMatrixRows(cc, i);
            nj := j - i + 1;
            if cc[i, 1] == 0 and cc[i, 2] == 0 then
              // case p^2
              s := s + name + "^" + String(2*nj);
            else
              s := s + "(" + name + "^2";

              // b*p term
              if cc[i, 1] == 1.0 then
                s := s + " + " + name;
              elseif cc[i, 1] == -1.0 then
                s := s + " - " + name;
              elseif cc[i, 1] <> 0.0 then
                if cc[i, 1] > 0 then
                  s := s + " + ";
                else
                  s := s + " - ";
                end if;
                s := s + String(abs(cc[i, 1]), significantDigits=significantDigits) +
                  "*" + name;
              end if;

              // a*p^0 term
              if (cc[i, 2]) > 0.0 then
                s := s + " + " + String(cc[i, 2], significantDigits=significantDigits) + ")";
              elseif (cc[i, 2]) < 0.0 then
                s := s + " - " + String(-cc[i, 2], significantDigits=significantDigits) + ")";
              else
                s := s + ")";
              end if;
              if nj > 1 then
                s := s + "^" + String(nj);
              end if;
            end if;
            i := j + 1;
           end while;
        end if;
      end secondOrderToString;

    end Internal;

    annotation (
      defaultComponentName="filter",
      Documentation(info="<html>
<p>
This record defines a transfer function by its zeros, poles and a gain:
</p>
<pre>         product(p - z[i])
  y = k*------------------- * u
         product(p - n[i])
</pre>
<p>
where z[:] is a Complex vector of zeros, n[:] is a Complex
vector of poles and k is an additional multiplicative factor.
The elements of the two Complex vectors must either be real
numbers or conjugate complex pairs (in order that their product
results in a polynomial with Real coefficients).
</p>
<p>
In the record, the zeros and poles are transformed
into a product of first and second order polynomials.
The data structure is especially useful in applications where first and
second order polynomials are naturally occurring, e.g., as
for <b>filters</b>. In fact, via function
<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Design.filter\">ZerosAndPoles.Design.filter</a>, a
ZeroAndPole transfer function is generated from
<b>low</b> and <b>high pass</b> analog filters
(<b>CriticalDamping</b>, <b>Bessel</b>, <b>Butterworth</b>, <b>Chebyshev</b>).
The filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cutoff frequency is 3&nbsp;dB.
</p>
<p>
A ZeroAndPole transfer function is internally stored by the coefficients
of first and second order polynomials, and by an additional
multiplicative factor k:
</p>
<pre>         product(p + n1[i]) * product(p^2 + n2[i,1]*p + n2[i,2])
  y = k*---------------------------------------------------------
         product(p + d1[i]) * product(p^2 + d2[i,1]*p + d2[i,2])
</pre>
<p>
Note, the degrees of the numerator and denominator
polynomials are given as:
</p>
<pre>
   degree of numerator   = size(n1,1) + 2*size(n2,1);
   degree of denominator = size(d1,1) + 2*size(d2,1);
</pre>
<p>
Example:
</p>
<pre>                          (p+1)
  zp = 4* -------------------------------------
           (p - 1)*(p - (2+j*3))*(p - (2-j*3))
</pre>
<p>
with j=sqrt(-1), is defined as
</p>
<pre>
   <b>import</b> Modelica_LinearSystems2.Math.Complex;
   <b>import</b> Modelica_LinearSystems2.ZerosAndPoles;

   zp = ZerosAndPoles(z = {Complex(-1,0)},
                      p = {Complex(1,0),
                           Complex(2,3),
                           Complex(2,-3)},
                           k=4);
</pre>
</html>"));
  end ZerosAndPoles;

  operator record TransferFunction
    "Continuous transfer function description of a single input, single output system (data + operations)"
    extends Modelica.Icons.Record;

    import Modelica_LinearSystems2.Math.Polynomial;

    Real n[:] "Coefficients of numerator polynomial (in descending order)" annotation(Dialog(group="y = n*{s^m, ... , s, 1} / (d*{s^r, ... , s, 1}) * u"));
    Real d[:] "Coefficients of denominator polynomial (in descending order)" annotation(Dialog(group="y = n*{s^m, ... , s, 1} / (d*{s^r, ... , s, 1}) * u"));

    String uName="u" "Name of input signal" annotation(Dialog(group="Signal names"));
    String yName="y" "Name of output signal" annotation(Dialog(group="Signal names"));

  /* If the numerator polynomial has no coefficients, the transfer function
   is zero. The denominator polynomial must always have at
   least one coefficient, such as {1}
*/

    encapsulated operator 'constructor'
      "Collection of operators to construct a TransferFunction data record"
      import Modelica;
      import Modelica_LinearSystems2.TransferFunction;

      function fromReal
        "Generate a TransferFunction data record from a real value"
        import Modelica;
        import Modelica_LinearSystems2.TransferFunction;

        input Real r "Value of Real variable";
        input String uName="" "input name";
        input String yName="" "output name";
        output TransferFunction tf(n={r}, d={1});

      algorithm
        tf.uName := uName;
        tf.yName := yName;
      end fromReal;

      encapsulated function fromZerosAndPoles
        "Generate a TransferFunction data record from a set of zeros and poles"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex z[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
          "Zeros (Complex vector of numerator zeros)";
        input Complex p[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
          "Poles (Complex vector of denominator zeros)";
        input Real k=1.0 "Constant multiplied with transfer function";
        input String uName="" "input name";
        input String yName="" "output name";
        output TransferFunction tf(redeclare Real n[size(z, 1)+1], redeclare Real d[size(p, 1)+1])
          "TransferFunction built by ZerosAndPoles object";

    protected
        Polynomial pn=k*Polynomial(z);
        Polynomial pd=Polynomial(p);
      algorithm

        tf.n := pn.c;
          tf.d := pd.c;
          tf.uName := uName;
          tf.yName := yName;

        annotation (Documentation(info="<html>
<p>
This function constructs a transfer function from numerator zeros.
Example:
</p>

<p> The transfer function</p>
<pre>
   zp = (s+(2+3*j))*(s+(2-3*j))
</pre>
<p>
can be expressed as
</p>
<pre>
   <b>import</b> Modelica_LinearSystems2.Math.Complex;
   <b>import</b> Modelica_LinearSystems2.ZerosAndPoles;

   j = Complex.j();
   zp = ZerosAndPoles({2+3*j}, {2-3*j});
</pre>

<p>
Since only transfer functions with real coefficients are supported,
complex zeros must be defined as conjugate complex pairs.
It is required that complex conjugate pairs must directly
follow each other as above. An error occurs if this is not the case.
</p>
</html>"));
      end fromZerosAndPoles;

      encapsulated function fromArrays
        "Generate a TransferFunction data record from numerator and denominator array"
        import Modelica;
        import Modelica_LinearSystems2.TransferFunction;

        input Real n[:] "Coefficients of numerator polynomial";
        input Real d[:] "Coefficients of denominator polynomial";
        input String uName = "" "input name";
        input String yName = "" "output name";

        output TransferFunction tf(
          redeclare Real n[size(n, 1)],
          redeclare Real d[size(d, 1)])
          "Transfer function";

      algorithm
        //this is the constructor algorithm
        assert(size(d, 1) > 0, "Input denominator d must have at least one element, however\n"
           + "d is an empty vector");
        tf.n := n;
        tf.d := d;
        tf.uName := uName;
        tf.yName := yName;
      end fromArrays;

      function fromPolynomials
        "Generate a TransferFunction data record from a numerator and denominator polynomial"
        import Modelica;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial n "Numerator polynomial";
        input Polynomial d "Denominator polynomial";
        input String uName="" "input name";
        input String yName="" "output name";
        output TransferFunction tf(n=n.c, d=d.c,uName=uName, yName=yName);

      algorithm
      end fromPolynomials;

    end 'constructor';

    encapsulated operator '-'
      "Collection of operators for subtraction of transfer functions"
      import Modelica;

      function subtract "Subtract two transfer functions (tf1 - tf2)"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf1;
        input TransferFunction tf2;

        output TransferFunction result = (Polynomial(tf1.n)*Polynomial(tf2.d) - Polynomial(tf2.n)*Polynomial(tf1.d))/(Polynomial(tf1.d)*Polynomial(tf2.d));

      algorithm
      end subtract;

      function negate "Unary minus (multiply transfer function by -1)"
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf;
        output TransferFunction result(n=-tf.n, d=tf.d) "= -tf";
      algorithm
      end negate;
      annotation (Documentation(info="<html>
<p>This package contains operators for subtraction of transfer function records. </p>
</html>"));
    end '-';

    encapsulated operator function '+'
      "Parallel connection of two transfer functions (= inputs are the same, outputs of the two systems are added)"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf1 "Transfer function system 1";
      input TransferFunction tf2 "Transfer function system 2";
      output TransferFunction result;
    algorithm
      result := (Polynomial(tf1.n)*Polynomial(tf2.d) + Polynomial(tf2.n)*Polynomial(tf1.d))/(Polynomial(tf1.d)*Polynomial(tf2.d));
    end '+';

    encapsulated operator function '*'
      "Multiply two TransferFunctions (tf1 * tf2)"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf1 "Transfer function 1";
      input TransferFunction tf2 "Transfer function 2";
      output TransferFunction result;
    algorithm
      result := (Polynomial(tf1.n)*Polynomial(tf2.n))/(Polynomial(tf1.d)*Polynomial(tf2.d));
    end '*';

    encapsulated operator function '/'
      "Divide two transfer functions (tf1 / tf2)"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf1 "Transfer function system 1";
      input TransferFunction tf2 "Transfer function system 2";
      output TransferFunction result "Result = tf1/tf2";

    algorithm
      result := (Polynomial(tf1.n)*Polynomial(tf2.d))/(Polynomial(tf1.d)*
        Polynomial(tf2.n));
    end '/';

    encapsulated operator function '^'
      "Integer power of TransferFunction (tf1^k)"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf "Transfer function";
      input Integer k(min=0) = 1 "Integer exponent";
      output TransferFunction result;
    algorithm
      result := (Polynomial(tf.n)^k)/(Polynomial(tf.d)^k);
    end '^';

    encapsulated operator function '=='
      "Check whether two transfer functions are identical"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf1 "Transfer function system 1";
      input TransferFunction tf2 "Transfer function system 1";
      input Real eps(min=0) = 0
        "Two coefficients c1 and c2 of the two transfer functions are identical if abs(c1-c2) <= eps";

      output Boolean result "= tf1 == tf2";
    algorithm
      result := (Polynomial(tf1.n) == Polynomial(tf2.n)) and (Polynomial(tf1.d) == Polynomial(tf2.d));
    end '==';

    encapsulated operator function 'String'
      "Transform TransferFunction into a String representation"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      input TransferFunction tf
        "Transfer function to be transformed in a String representation";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      input String name="s" "Independent variable name used for printing";
      output String s="";
  protected
      Integer n_num=size(tf.n, 1) - 1;
      Integer n_den=size(tf.d, 1) - 1;
      Boolean numParenthesis;
    algorithm
      if n_num == -1 then
        s := "0";
      else
        numParenthesis := n_num > 0 and not (n_den == 0 and tf.d[1] == 1);
        if numParenthesis then
          s := "(";
        end if;
         s := s + String(
              Polynomial(tf.n),
              significantDigits,
              name);

        if numParenthesis then
          s := s + ")";
        end if;
      if n_den > 0 or tf.d[1] <> 1 then
          if n_den > 0 then
            s := s + "/(";
          else
            s := s + "/";
          end if;

          s := s + String(
                Polynomial(tf.d),
                significantDigits,
                name);

          if n_den > 0 then
            s := s + ")";
          end if;
        end if;
      end if;
    end 'String';

    encapsulated function s "Generate the transfer function s"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.TransferFunction;

      output TransferFunction tf(n={1,0}, d={1}) "s";
    algorithm

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
s = TransferFunction.<b>s</b>()
</pre></blockquote>

<h4>Description</h4>
<p>
Generate the complex Laplace variable as a TransferFunction.
It can be used for generating like
</p>
<blockquote><pre>
TransferFunction tf = s/(3*s^2 + 2*s +2)
</pre></blockquote>
</html>"));
    end s;

    encapsulated package Analysis
      "Package of functions to analyse transfer function represented by a TransferFunction record"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.StateSpace;
      import Modelica_LinearSystems2.TransferFunction;
      import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
      extends Modelica.Icons.Package;

      function analysis
        "Make a system analysis based on the poles and zeros of the system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Internal.AnalyseOptions;
        import Modelica_LinearSystems2.Internal.AnalyseOptions2;
        import Modelica_LinearSystems2.Internal.Eigenvalue;

        input TransferFunction tf(uName="u", yName="y")
          "transfer function of a system";

        input AnalyseOptions2 analyseOptions2=
            Modelica_LinearSystems2.Internal.AnalyseOptions2(printControllability=
             false, printObservability=false);

        input String fileName="eigenvalues.html"
          "Name of html-file that contains eigenvalue table";

        input String systemName="tf"
          "Name of system (used as heading in html file)";
        input String description="" "Description of system (used in html file)";

    protected
        String dummyFileName = "dummy" + fileName;

        input StateSpace ss=StateSpace(tf);

        Modelica_LinearSystems2.Internal.AnalyseOptions analyseOptions=
            AnalyseOptions(
                plotEigenValues=analyseOptions2.plotEigenValues,
                plotInvariantZeros=analyseOptions2.plotInvariantZeros,
                plotStepResponse=analyseOptions2.plotStepResponse,
                plotFrequencyResponse=analyseOptions2.plotFrequencyResponse,
                printSystem=analyseOptions2.printSystem,
                printEigenValues=analyseOptions2.printEigenValues,
                printEigenValueProperties=analyseOptions2.printEigenValueProperties,
                printInvariantZeros=analyseOptions2.printInvariantZeros,
                printControllability=analyseOptions2.printControllability,
                printObservability=analyseOptions2.printObservability,
                headingEigenValues=analyseOptions2.headingEigenValues,
                headingInvariantzeros=analyseOptions2.headingInvariantzeros,
                headingStepResponse=analyseOptions2.headingStepResponse,
                headingFrequencyResponse=analyseOptions2.headingFrequencyResponse,
                dB_w=analyseOptions2.dB_w);

      algorithm
        assert(TransferFunction.Analysis.denominatorDegree(tf) >=
          TransferFunction.Analysis.numeratorDegree(tf),
          " Denominator polynominal of transfer function in function\"TransferFunction.Analysis.analysis\"has to be of higher or equal order than numerator polynomial");

        Modelica.Utilities.Files.removeFile(fileName);
        Modelica.Utilities.Files.removeFile(dummyFileName);
        if analyseOptions.printSystem and size(ss.A,1) <= 50 then
          Modelica_LinearSystems2.TransferFunction.Analysis.analysis.printSystem(
              tf,
              fileName,
              systemName,
              description);
          Modelica_LinearSystems2.TransferFunction.Analysis.analysis.printSystem(
              tf,
              dummyFileName,
              systemName,
              description);
        end if;
        Modelica.Utilities.Streams.readFile(dummyFileName);

        analyseOptions.printSystem :=false;
        StateSpace.Analysis.analysis(
              ss=ss,
              analyseOptions=analyseOptions,
              fileName=fileName,
              systemName=systemName,
              description=description);
      equation

    public
        encapsulated function printSystem
          "Print the state space system in html format on file"
          import Modelica;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.TransferFunction;
          import Modelica_LinearSystems2;

          input TransferFunction tf "transfer function to analyze";
          input String fileName="systemAnalysis.html"
            "File on which the transfer fucntion is written in html format";
          input String systemName="Transfer Function" "name of the system";
          input String description="" "Description of system (used in html file)";
          input String format=".3g" "Format of numbers (e.g. \"20.8e\")";
      protected
          String st=String(tf);

        algorithm
          Modelica.Utilities.Files.removeFile(fileName);
          print("<html>\n<body>\n<p><b>System report</b></p>", fileName);
          print("<p> The system " + systemName + " is defined by</p>", fileName);
          print("G(s) = " + st, fileName);
           if description == "" then
            print("</table> ", fileName);
          else
            print("</table>", fileName);
            print("<p><b>Description</b></p>", fileName);
            print(description, fileName);
          end if;
          print("<br></body></html>",fileName);

        end printSystem;

        annotation (__Dymola_interactive=true);
      end analysis;

      encapsulated function timeResponse
        "Calculate the time response of a transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        extends Modelica_LinearSystems2.Internal.timeResponseMask2_tf;     // Input/Output declarations of time response functions
        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step;

        input Real x0[TransferFunction.Analysis.denominatorDegree(tf)]=zeros(TransferFunction.Analysis.denominatorDegree(tf))
          "Initial state vector";

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        (y,t,x_continuous) := StateSpace.Analysis.timeResponse(sc=ss, dt=dt, tSpan=tSpan, response=response, x0=x0);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = TransferFunction.Analysis.<b>timeResponse</b>(tf, dt, tSpan, responseType, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the transfer function representation is transformed into state
space representation which is given to StateSpace.Analysis.timeResponse
and the time response of the state space system is calculated. The type
of the time response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
Impulse &quot;Impulse response&quot;,
Step &quot;Step response&quot;,
Ramp &quot;Ramp response&quot;,
Initial &quot;Initial condition response&quot;.
</pre></blockquote>
<p>
The state space system is transformed to a appropriate discrete state space
system and, starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y and
x are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=1/(s^2+s+1);

  Real Ts=0.1;
  Real tSpan= 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(tf,Ts,tSpan,response,x0);
//  y[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
</pre></blockquote>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse "Calculate the impulse time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_tf;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(
              tf=tf,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
              x0=zeros(Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = TransferFunction.Analysis.<b>timeResponse</b>(tf, dt, tSpan, responseType, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the transfer function representation is transformed into state space
representation which is given to StateSpace.Analysis.timeResponse and the
time response of the state space system is calculated. The type of the time
response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
    Impulse \"Impulse response\",
    Step \"Step response\",
    Ramp \"Ramp response\",
    Initial \"Initial condition response\"
</pre></blockquote>
<p>
The state space system is transformed to a appropriate discrete state space
system and, starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y
and x are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=1/(s^2+s+1);

  Real Ts=0.1;
  Real tSpan= 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(tf,Ts,tSpan,response,x0);
//  y[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0048, 0.0187, 0.04, 0.0694}
</pre></blockquote>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse "Calculate the step time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_tf;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(
              tf=tf,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = TransferFunction.Analysis.<b>stepResponse</b>(tf, dt, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>stepResponse</b> calculates the step response of a transfer function.
The state space system is transformed to a appropriate discrete state space
system and, starting at
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
TransferFunction.Analysis.stepResponse(tf, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
TransferFunction.Analysis.timeResponse(tf, dt, tSpan, response=Types.TimeResponse.Step, x0=fill(0,TransferFunction.Analysis.denominatorDegree(tf))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=1/(s^2+s+1);

  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=TransferFunction.Analysis.stepResponse(tf,Ts,tSpan);
//  y[:,1,1]={0, 0.0048, 0.01867, 0.04, 0.0694}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0048, 0.01867, 0.04, 0.0694}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse\">TransferFunction.Analysis.timeResponse</a>
</p>
</html>"));
      end stepResponse;

      encapsulated function rampResponse "Calculate the ramp time response"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_tf;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(
              tf=tf,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
              x0=zeros(Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = TransferFunction.Analysis.<b>rampResponse</b>(tf, dt, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rampResponse</b> calculates the time response of a transfer
function for ramp imput u = t. The state space system is transformed
to a appropriate discrete state space system and, starting at
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
TransferFunction.Analysis.rampResponse(ss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
TransferFunction.Analysis.timeResponse(tf, dt, tSpan, response=Types.TimeResponse.Ramp, x0=fill(0,TransferFunction.Analysis.denominatorDegree(tf))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=1/(s^2+s+1);

  Real Ts=0.1;
  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=TransferFunction.Analysis.rampResponse(tf,Ts,tSpan);
//  y[:,1,1]={0, 0.0002, 0.0012, 0.0042, 0.0096}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0002, 0.0012, 0.0042, 0.0096}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse\">TransferFunction.Analysis.timeResponse</a>
</p>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the time response for given initial condition and zero inputs"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;

        input Real x0[:]=fill(0,0) "Initial state vector";

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask2_tf;

      algorithm
        (y,t,x_continuous) :=Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse(
              tf=tf,
              dt=dt,
              tSpan=tSpan,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
              x0=x0);

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = TransferFunction.Analysis.<b>initialResponse</b>(tf, dt, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the time response of a state space system for
given initial condition and zero inputs. The state space system is transformed
to a appropriate discrete state space system and, starting at
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
TransferFunction.Analysis.initialResponse(x0,tf, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
TransferFunction.Analysis.timeResponse(tf, dt, tSpan, response=Types.TimeResponse.Initial, x0=x0).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=1/(s^2+s+1);

  Real Ts=0.1;
  Real tSpan= 0.4;
  Real x0[2] = {1,1};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=TransferFunction.Analysis.initialResponse(x0,tf,Ts,tSpan);
//  y[:,1,1]={1, 1.0903, 1.1616, 1.2151, 1.252}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={1, 1.0903, 1.1616, 1.2151, 1.252}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse\">TransferFunction.Analysis.timeResponse</a>
</p>
</html>"));
      end initialResponse;

      encapsulated function numeratorDegree "Return numerator degree"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        output Integer result;

      algorithm
        result := size(tf.n,1)-1;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = TransferFunction.Analysis.<b>numeratorDegree</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>numeratorDegree</b> calculates the degree of the numerator polynomial of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
   TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
   Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

   Real nDegree;

<b>algorithm</b>
  nDegree := TransferFunction.Analysis.numeratorDegree(tf);
//  nDegree = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree\">TransferFunction.Analysis.denominatorDegree</a>
</p>
</html>"));
      end numeratorDegree;

      encapsulated function denominatorDegree "Return denominator degree"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        output Integer result;

      algorithm
        result := size(tf.d,1)-1;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = TransferFunction.Analysis.<b>denominatorDegree</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>denominatorDegree</b> calculates the degree of the denominator polynomial of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
   TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
   Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

   Real dDegree;

<b>algorithm</b>
  dDegree := TransferFunction.Analysis.denominatorDegree(tf);
//  dDegree = 2
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.numeratorDegree\">TransferFunction.Analysis.numeratorDegree</a>
</p>
</html>"));
      end denominatorDegree;

      encapsulated function evaluate
        "Evaluate a transfer function for a given (Complex) value of s"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        input Complex s "Value of s where tf shall be evaluated";
        input Real den_min=0 "|denominator(s)| is limited by den_min";
        output Complex result "= tf(s)";

    protected
        Complex j = Modelica_LinearSystems2.Math.Complex.j();
        Complex den=Polynomial.evaluateComplex(Polynomial(tf.d), s);
        Real abs_den=Complex.'abs'(den);
      algorithm
        den := if abs_den >= den_min then den else -abs_den+0*j;
        result := Polynomial.evaluateComplex(Polynomial(tf.n), s)/den;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = TransferFunction.Analysis.<b>evaluate</b>(tf, s)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>evaluate</b> evaluates a transfer function at a given (complex) value of s.
The transfer function G(s)=N(s)/D(s) is evaluated by calculating the numerator polynomial N(s) and the denominator polynomial D(s).
</p>

<h4>Example</h4>
<blockquote><pre>
   Complex j = Modelica_LinearSystems2.Math.Complex.j();
   TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
   Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

   Complex result;

<b>algorithm</b>
  result := Modelica_LinearSystems2.TransferFunction.Analysis.evaluate(tf, j+1);
//  result = 0.538462 - 0.307692j
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.Math.Polynomial.evaluateComplex\">Math.Polynomial.evaluateComplex</a>
</p>
</html>"));
      end evaluate;

      encapsulated function zerosAndPoles
        "Calculate zeros and poles of a transfer function"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";

        output Complex z[:]=Polynomial.roots(Polynomial(tf.n))
          "Zeros (Complex vector of numerator zeros)";
        output Complex p[:]=Polynomial.roots(Polynomial(tf.d))
          "Poles (Complex vector of denominator zeros)";
        output Real k
          "Constant multiplied with transfer function that is factorized with zeros and poles";

    protected
        TransferFunction tf2=TransferFunction(z, p);
        Real r;
        Complex s;
        Complex y1;
        Complex y2;
      algorithm
        // Determine an s-value that is neither a zero nor a pole
        r := 1.0;
        for i in 1:size(z, 1) loop
          r := max(r, abs(z[i].re));
        end for;
        for i in 1:size(p, 1) loop
          r := max(r, abs(p[i].re));
        end for;
        r := 2*r;
        s := Complex(r, 0);

        // Evaluate both tf and tf2 and determine k from the quotient
        y1 := TransferFunction.Analysis.evaluate(tf, s);
        y2 := TransferFunction.Analysis.evaluate(tf2, s);
        k := y1.re/y2.re;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(z,p,k) = TransferFunction.Analysis.<b>zerosAndPoles</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the zeros, poles and gain of transfer function.
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.evaluate\">Analysis.evaluate</a> is used to calculate gain <tt>k</tt>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

public
  output Complex z;
  output Complex p;
  output Real k;

<b>algorithm</b>
  (z,p,k)=Modelica_LinearSystems2.TransferFunction.Analysis.zerosAndPoles(tf);
//  z = {-1}
//  p = {-0.5 + 0.866025j, -0.5 - 0.866025j}
//  k = 1
</pre></blockquote>
</html>"));
      end zerosAndPoles;

      function eigenValues
        "Calculate the eigenvalues of a linear transfer function system and write them in a complex vector"
      //encapsulated function eigenValues
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input TransferFunction tf "transfer function of a system";
        output Complex eigval[:] "eigen values of the system";

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        assert(TransferFunction.Analysis.denominatorDegree(tf) >
          TransferFunction.Analysis.numeratorDegree(tf),
          " Denominator polynominal of transfer function in function\"TransferFunction.Analysis.eigenValues\"has to be of higher order than numerator polynomial");

        eigval := StateSpace.Analysis.eigenValues(ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
eigenvalues = TransferFunction.Analysis.<b>eigenValues</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvalues of the corresponding state space representation of a transfer function. The output is a complex vector containing the eigenvalues. Note, that the conversion of the transfer function does not result in a minimal state space system. Therefore also unobservable and uncontrollable eigenvalues will be calculated.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

  Complex eigenvalues[2];

<b>algorithm</b>
  eigenvalues = Modelica_LinearSystems2.TransferFunction.Analysis.eigenValues(tf);
// eigenvalues = {-0.5 + j*sqrt(3)/2, -0.5 - j*sqrt(3)/2}
</pre></blockquote>
</html>"));
      end eigenValues;

      encapsulated function eigenVectors
        "Calculate the right eigenvectors of the state space system corresponding to a transfer function and write them columnwise in a matrix. Optionally, the eigenvalues are computed"
        import Modelica;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica.Math.Matrices.LAPACK;
        import Modelica_LinearSystems2.Math.Complex;

        input TransferFunction tf "transfer function of a system";
        input Boolean onlyEigenvectors=true;
        output Real eigvec[:,:] "eigen values of the system";
        output Complex eigval[:] "eigen values of the system";
    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        assert(TransferFunction.Analysis.denominatorDegree(tf) >
          TransferFunction.Analysis.numeratorDegree(tf),
          " Denominator polynominal of transfer function in function\"TransferFunction.Analysis.eigenVectors\"has to be of higher order than numerator polynomial");
        (eigvec,eigval) := StateSpace.Analysis.eigenVectors(ss=ss,
          onlyEigenvectors=onlyEigenvectors);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(eigenvectors, eigenvalues) = TransferFunction.Analysis.<b>eigenVectors</b>(tf, onlyEigenvectors)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvectors and optionally (onlyEigenvectors=false) the eigenvalues of the corresponding state space system of a transfer function. The output <tt>eigenvectors</tt> is a matrix with the same dimension as matrix <b>ss.A</b>. Just like in <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Modelica.Math.Matrices.eigenValues</a>, if the i-th eigenvalue has an imaginary part, then <tt>eigenvectors</tt>[:,i] is the real and <tt>eigenvectors</tt>[:,i+1] is the imaginary part of the eigenvector of the i-th eigenvalue.<br>
The eigenvalues are returned as a complex vector <tt>eigenvalues</tt>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(2*s+2)/(s^2+2*s+2);

  Real eigenvectors[2,2];
  Complex eigenvalues[2];

<b>algorithm</b>
  (eigenvectors, eigenvalues) = Modelica_LinearSystems2.TransferFunction.Analysis.eigenVectors(tf, true);
// eigenvectors = [(-0.4082), (-0.4082);
                    0.8165, 0]
// eigenvalues = {-1 + 1j, -1 - 1j}

          |-0.4082 -i0.4082 |         | -0.4082 + i0.4082 |
i.e. v1 = |                 |,   v2 = |                   |
          |     0.8165      |         |      0.8165       |
</pre></blockquote>
</html>"));
      end eigenVectors;

      encapsulated function invariantZeros
        "Compute invariant zeros of linear transfer function"

        import Modelica;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.StateSpace;

        input TransferFunction tf "transfer function of a system";

        output Complex Zeros[:] "invariant zeros";

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        Zeros := StateSpace.Analysis.invariantZeros(ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zeros = TransferFunction.Analysis.<b>invariantZeros</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes the invariant zeros of the corresponding state space representation of a transfer function. The output is a complex vector containing the eigenvalues. Note, that the conversion of the transfer function does not result in a minimal state space system. Therefore, also zeros equal to unobservable or uncontrollable eigenvalues will be computed.

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

  Complex zeros[:];

<b>algorithm</b>
  zeros := Modelica_LinearSystems2.TransferFunction.Analysis.invariantZeros(tf);
// zeros = {-1}
</pre></blockquote>
</html>"));
      end invariantZeros;

      encapsulated function dcGain
        "Return steady state gain k (for a stable system: k = value of y at infinite time for a step input)"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "Transfer function of a system";
        output Real k "Steady state gain";
        output Boolean finite = true
          "True, if k is finite, otherwise k is infinite (k=Modelica.Constants.inf returned)";
    protected
        StateSpace ss=StateSpace(tf);
        Real K[1,1];
      algorithm
        (K, finite) := StateSpace.Analysis.dcGain(ss=ss);
        k :=K[1, 1];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
          k = <b>dcGain</b>(tf);
(k, finite) = <b>dcGain</b>(tf);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the steady state gain <b>k</b> of a
TransferFunction tf(s), i.e. k = tf(s=0).
For a stable transfer function, a step input u results
in the output y(t->t<sub>&infin;</sub>) = k.
</p>
<p>
If the transfer function has one or more zero poles, <b>k</b> is infinite.
In this case, the output argument <b>finite</b> = <b>false</b> and
<b>k</b> = Modelica.Constants.inf.
</p>
</html>"));
      end dcGain;

      encapsulated function isControllable
        "Check controllability of a transfer function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;

        output Boolean controllable;
    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        controllable := StateSpace.Analysis.isControllable(ss=ss, method=method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
controllable = TransferFunction.Analysis.<b>isControllable</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function TransferFunction.Analysis.<b>isControllable</b> checks the controllability of a transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isControllable\">StateSpace.Analysis.isControllable</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2 + 2*s +1);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean controllable;

<b>algorithm</b>
  controllable := Modelica_LinearSystems2.StateSpace.Analysis.isControllable(tf, method);
// controllable = true
</pre></blockquote>
</html>"));
      end isControllable;

      encapsulated function isObservable
        "Check oberservability of a transfer function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        input Modelica_LinearSystems2.Utilities.Types.StaircaseMethod method=Modelica_LinearSystems2.Utilities.Types.StaircaseMethod.SVD;
        output Boolean observable;
    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        observable := StateSpace.Analysis.isObservable(ss=ss, method=method);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
observable = TransferFunction.Analysis.<b>isObservable</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function TransferFunction.Analysis.<b>isObservable</b> checks the observability of a transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isObservable\">StateSpace.Analysis.isObservable</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2 + 2*s +1);

  Types.Method method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD

  Boolean controllable;

<b>algorithm</b>
  controllable := Modelica_LinearSystems2.StateSpace.Analysis.isObservable(tf, method);
// controllable = false
</pre></blockquote>
</html>"));
      end isObservable;

      encapsulated function isStabilizable
        "Check stabilizability of a transfer function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";

        output Boolean stabilizable;
    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        stabilizable := StateSpace.Analysis.isStabilizable(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
stabilizable = TransferFunction.Analysis.<b>isStabilizable</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function TransferFunction.Analysis.<b>isStabilizable</b> checks the Stabilizability of a transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable\">StateSpace.Analysis.isStabilizable</a>.
The transfer function is stabilizable if all unstable poles are controllable.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s-1)/(s^2 - 2*s +1);

  Boolean stabilizable;

<b>algorithm</b>
   stabilizable := Modelica_LinearSystems2.TransferFunction.Analysis.isStabilizable(tf);
// stabilizable = true
</pre></blockquote>
</html>"));
      end isStabilizable;

      encapsulated function isDetectable
        "Check detectability of a transfer function"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";

        output Boolean detectable;

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        detectable := StateSpace.Analysis.isDetectable(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
detectable = TransferFunction.Analysis.<b>isDetectable</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Function TransferFunction.Analysis.<b>isDetectable</b> checks the Detectability of a transfer function. Therefore, the transfer function is converted into a state space representation which is applied to <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Analysis.isDetectable\">StateSpace.Analysis.isDetectable</a>.
The transfer function is detectable if all unstable poles are observable.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s-1)/(s^2 - 2*s +1);

  Boolean detectable;

<b>algorithm</b>
  detectable := Modelica_LinearSystems2.TransferFunction.Analysis.isDetectable(tf);
// detectable = false
</pre></blockquote>
</html>"));
      end isDetectable;

      encapsulated function controllabilityMatrix
        "Calculate the controllability matrix [B, A*B, ..., A^(n-1)*B] of a transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        output Real om[:,:];

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        om := StateSpace.Analysis.controllabilityMatrix(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = TransferFunction.Analysis.<b>controllabilityMatrix</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the controllability matrix
<blockquote><pre>
<b>Q</b> = [<b>B</b>, <b>A</b>*<b>B</b>, ..., <b>A</b>^(n-1)*<b>B</b>]
</pre></blockquote>
<p>
of the system corresponding state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre>
</blockquote>
<p>
of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

  Real Q[2,2];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.TransferFunction.Analysis.controllabilityMatrix(tf);
// Q = [0, 1, 1, -1]
</pre></blockquote>
</html>"));
      end controllabilityMatrix;

      encapsulated function observabilityMatrix
        "Calculate the observability matrix of a transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf "transfer function of a system";
        output Real om[:,:];

    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        om := StateSpace.Analysis.observabilityMatrix(ss=ss);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Q = TransferFunction.Analysis.<b>observabilityMatrix</b>(tf, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the observability matrix
</p>
<blockquote><pre>
<b>Q</b> = [<b>C</b>; <b>C</b>*<b>A</b>; ...; <b>C</b>*<b>A</b>^(n-1)]
</pre></blockquote>
<p>
of the system corresponding state space system
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
</pre></blockquote>
<p>
of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^2+s+1);

  Real Q[2,2];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.TransferFunction.Analysis.observabilityMatrix(tf);
// Q = [1, 1, -1, 0]
</pre></blockquote>
</html>"));
      end observabilityMatrix;
    end Analysis;

    encapsulated package Design
      "Package of functions to design transfer function controllers and observers"
      import Modelica;
      extends Modelica.Icons.Package;
      encapsulated function filter
        "Generate the data record of a ZerosAndPoles transfer function from a filter description"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.ZerosAndPoles;

        input Modelica_LinearSystems2.Utilities.Types.AnalogFilter analogFilter=Modelica_LinearSystems2.Utilities.Types.AnalogFilter.CriticalDamping "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)";
        input Modelica_LinearSystems2.Utilities.Types.FilterType filterType=Modelica_LinearSystems2.Utilities.Types.FilterType.LowPass "Type of filter (LowPass/HighPass)";
        input Integer order(min=1) = 2 "Order of filter";
        input Modelica.Units.SI.Frequency f_cut=1/(2*Modelica.Constants.pi)
          "Cut-off frequency (default is w_cut = 1 rad/s)";
        input Real gain=1.0
          "Gain (= amplitude of frequency response at zero frequency)";
        input Real A_ripple(unit="dB") = 0.5
          "Pass band ripple for Chebyshev filter (otherwise not used)";
        input Boolean normalized=true
          "True, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter";

        output TransferFunction filter "Filter transfer function";

    protected
        ZerosAndPoles zpFilter;
      algorithm
        zpFilter := ZerosAndPoles.Design.filter(analogFilter, filterType, order, f_cut, gain, A_ripple, normalized);
        filter := ZerosAndPoles.Conversion.toTransferFunction(zpFilter);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
filterFunction = TransferFunction.Design.<b>filter</b>(analogFilter, filterType, order, f_cut, gain, A_ripple, normalized)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a transfer function description
of low and high pass filters. For more details see also
<a href=\"modelica://Modelica_LinearSystems2.UsersGuide.Literature\">[Tietze2002]</a>, pp. 815-852.
</p>
<p>
Typical frequency responses for the four supported
low pass filter types are shown in the next figure (this figure was generated
with function <a href=\"modelica://Modelica_LinearSystems2.Examples.TransferFunction.plotBodeFilter2\">Examples.TransferFunction.plotBodeFilter2</a>):
</p>
<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4Filters.png\"/> </p>
<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>
<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/LowPassOrder4FiltersStepResponse.png\"/> </p>
<p>
Obviously, the frequency responses give a somewhat wrong impression of the filter
characteristics: Although Butterworth and Chebyshev filters have a significantly
steeper magnitude as the CriticalDamping and Bessel filters, the step responses
of the latter ones are much better. This means for example, that a CriticalDamping
or a Bessel filter should be selected, if a filter is mainly used to make
a non-linear inverse model realizable.
</p>
<p>
Typical frequency responses for the four supported high pass filter types are shown
in the next figure:
</p>
<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4Filters.png\"/> </p>
<p>
The corresponding step responses of these high pass filters are shown in the next figure:
</p>
<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/HighPassOrder4FiltersStepResponse.png\"/> </p>
<p>
All filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function at the cutoff
frequency is 1/sqrt(2) (= 3 dB). Note, when comparing the filters of this function
with other software systems, the setting of \"normalized\" has to be selected
appropriately. For example, the signal processing toolbox of Matlab provides
the filters in non-normalized form and therefore a comparison makes only sense,
if normalized = <b>false</b> is set.
</p>

<h4>Example</h4>
<blockquote><pre>
  Types.AnalogFilter analogFilter=Modelica_LinearSystems2.Types.AnalogFilter.CriticalDamping;
  Integer order=2;
  Modelica.Units.SI.Frequency f_cut=10;

  TransferFunction tf_filter;

algorithm
  tf_filter=Modelica_LinearSystems2.TransferFunction.Design.filter(
    order=order,
    f_cut=f_cut,
    analogFilter=analogFilter);

// tf_filter = 9530.93/(s^2 + 195.253*s + 9530.93)
</pre></blockquote>
</html>"));
      end filter;

    end Design;

    encapsulated package Plot
      "Package of functions to plot transfer function responses"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.TransferFunction;
      import Modelica_LinearSystems2.ZerosAndPoles;
      extends Modelica.Icons.Package;

      encapsulated function polesAndZeros
        "Plot poles and/or the zeros of a transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        import Modelica_LinearSystems2.Utilities.Plot;

        input TransferFunction tf "Linear system in transfer function form";
        input Boolean poles=true "= true, to plot the poles of tf" annotation(choices(checkBox=true));
        input Boolean zeros=true "= true, to plot the zeros of tf" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram = Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros());

      algorithm
        StateSpace.Plot.polesAndZeros(StateSpace(tf), poles, zeros, defaultDiagram=defaultDiagram, device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>polesAndZeros</b>(tf);
   or
TransferFunction.Plot.<b>polesAndZeros</b>(
  tf,
  poles=true,
  zeros=true,
  plot=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>());
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots a pole-zero-map of the poles and zeros of a transfer function.
The Boolean inputs \"poles\" and \"zeros\" define what to plot. If Boolean input
\"plot = true\", the pole-zero-map is plotted. If false, only the diagram is generated
and returned as output argument. The records \"defaultDiagram\" and \"device\" allow
to set various layout options and the size and location of the diagram on the screen.
</p>

<h4>Example</h4>
<p>
The example <a href=\"modelica://Modelica_LinearSystems2.Examples.TransferFunction.plotPolesAndZeros\">
Modelica_LinearSystems2.Examples.TransferFunction.plotPolesAndZeros</a>
defines two transfer functions. The second one is defined as:
</p>
<blockquote><pre>
TransferFunction s   = TransferFunction.s();
TransferFunction tf2 = (s^3 + 4*s + 1)/(s^4 + 2*s^3 + 3*s^2 + 4*s);

Modelica_LinearSystems2.TransferFunction.Plot.polesAndZeros(
  tf=tf2,
  defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros(
    heading=\"Poles and zeros of \" + String(tf2)));
</pre></blockquote>
<p>
and results in
</p>
<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/PolesAndZerosTF.png\">
</blockquote>
</html>"));
      end polesAndZeros;

      encapsulated function bode "Plot transfer function as bode plot"
        import Modelica;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Utilities.Plot;
        import Modelica.Units.SI;

        input TransferFunction tf "Transfer function to be plotted";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input SI.Frequency f_min(min=0) = 0.1
          "Minimum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));
        input SI.Frequency f_max(min=0) = 10
          "Maximum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));

        input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot(heading="Bode plot: "
               + String(tf)));

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));

    protected
        SI.AngularVelocity w[nPoints];
        SI.Frequency f[nPoints];
        Modelica.Units.NonSI.Angle_deg phi[nPoints];
        Real A[nPoints];
        Boolean OK;
        Complex c;
        SI.Angle phi_old;
        Complex numZeros[:];
        Complex denZeros[:];

        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2[2];

      algorithm
              // Determine frequency vector f
        if autoRange then
          (numZeros,denZeros) := TransferFunction.Analysis.zerosAndPoles(tf);
        else
          numZeros := fill(Complex(0), 0);
          denZeros := fill(Complex(0), 0);
        end if;
        f := Internal.frequencyVector(
              nPoints,
              autoRange,
              f_min,
              f_max,
              numZeros,
              denZeros);

        // Compute magnitude/phase at the frequency points
        phi_old := 0.0;
        for i in 1:nPoints loop
          w[i] := Modelica.Units.Conversions.from_Hz(f[i]);
          c := TransferFunction.Analysis.evaluate(
                tf,
                Complex(0, w[i]),
                1e-10);
          A[i] := Complex.'abs'(c);
          phi_old := Complex.arg(c, phi_old);
          phi[i] := Modelica.Units.Conversions.to_deg(phi_old);

          // Convert to other units, if required
          if not Hz then
             f[i] := w[i];
          end if;
          if dB then
             A[i] := 20*log10(A[i]);
          end if;
        end for;

        // Plot computed frequency response
        diagram2 := fill(defaultDiagram, 2);
        i := 0;
        if magnitude then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=A,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := if dB then "magnitude [dB]" else "magnitude";
          if phase then
             diagram2[i].xLabel:="";
          end if;
          if dB then
             diagram2[i].logY := false;
          end if;
        end if;

        if phase then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=phi,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := "phase [deg]";
          diagram2[i].logY := false;
          if magnitude then
            diagram2[i].heading:="";
         end if;
        end if;

        if not Hz then
           diagram2[i].xLabel:="Angular frequency [rad/s]";
        end if;

        if magnitude and phase then
          Plot.diagramVector(diagram2, device);
        else
          Plot.diagram(diagram2[1], device);
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>bode</b>(tf)
   or
TransferFunction.Plot.<b>bode</b>(
  tf,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>() )
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf =(s^2 + 5*s + 7)/(s^2 + 5*s + 6);

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.plotBode(tf)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</blockquote>
</html>"));
      end bode;

      encapsulated function timeResponse
        "Plot the time response of a system represented by a transfer function. The response type is selectable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.TransferFunction tf;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        input Real x0[TransferFunction.Analysis.denominatorDegree(tf)]=zeros(
          TransferFunction.Analysis.denominatorDegree(tf)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Time response of  tf = " + String(tf)));

    protected
        Plot.Records.Curve curve;
        Plot.Records.Diagram diagram2;
        Real y[:,1,1] "Output response";
        Real t[:] "Time vector: (number of samples)";

      algorithm
        (y,t) := TransferFunction.Analysis.timeResponse(
              tf,
              dt,
              tSpan,
              response,
              x0);

        curve := Plot.Records.Curve(
              x=t,
              y=y[:, 1, 1],
              legend="y",
              autoLine=true);
        diagram2 := defaultDiagram;
        diagram2.curve := {curve};

        Plot.diagram(diagram2, device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>timeResponse</b>(tf);
   or
TransferFunction.Plot.<b>timeResponse</b>(
  tf,
  dt,
  tSpan,
  response,
  x0,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the time response of a transfer function. The character of the time response if defined by the input
<a href=\"modelica://Modelica_LinearSystems2.Types.TimeResponse\">response</a>, i.e. Impulse, Step, Ramp, or Initial.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf =(s + 1)/(s^2 + 5*s + 12);

  Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.timeResponse(tf, dt=0.02, tSpan=3, response=response)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/timeResponseTF.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end timeResponse;

      encapsulated function impulse "Impulse response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.TransferFunction tf "transfer function";
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Real x0[TransferFunction.Analysis.denominatorDegree(tf)]=zeros(
          TransferFunction.Analysis.denominatorDegree(tf)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Impulse response of  tf = " + String(tf)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse "Type of time response";
      algorithm
        Modelica_LinearSystems2.TransferFunction.Plot.timeResponse(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>impulse</b>(tf)
   or
TransferFunction.Plot.<b>impulse</b>(
  tf,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the impulse response of a transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf =(s + 1)/(s^2 + 5*s + 12);

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.impulse(tf, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/impulseResponseTF.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end impulse;

      encapsulated function step "Step response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.TransferFunction tf;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        input Real x0[TransferFunction.Analysis.denominatorDegree(tf)]=zeros(
          TransferFunction.Analysis.denominatorDegree(tf)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Step response of  tf = " + String(tf)));

      algorithm
        Modelica_LinearSystems2.TransferFunction.Plot.timeResponse(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>step</b>(tf)
   or
TransferFunction.Plot.<b>step</b>(
  tf,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the step response of a transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf =(s + 1)/(s^2 + 5*s + 12);

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.step(tf, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/stepResponseTF.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end step;

      encapsulated function ramp "Ramp response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.TransferFunction tf;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";
        input Real x0[TransferFunction.Analysis.denominatorDegree(tf)]=zeros(
          TransferFunction.Analysis.denominatorDegree(tf)) "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Ramp response of  tf = " + String(tf)));

      algorithm
        Modelica_LinearSystems2.TransferFunction.Plot.timeResponse(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>ramp</b>(tf)
   or
TransferFunction.Plot.<b>ramp</b>(
  tf,
  dt,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the ramp response of a transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf =(2*s^2 + 7*s + 13)/(s^3 + 6*s^2 + 17*s + 12);

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.ramp(tf)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/rampResponseTF.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end ramp;

      encapsulated function initialResponse "Initial condition response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.TransferFunction tf;
        input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";
        input Real y0 "Initial output (for initial condition plot)";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
            defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading=
               "Initial response of  tf = " + String(tf) + "  with y0 = " + String(
              y0)));

    protected
        Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
            tf);
        Integer nx=TransferFunction.Analysis.denominatorDegree(tf);
        Real x0[nx]=Modelica.Math.Matrices.equalityLeastSquares(
              ss.A,
              fill(0, nx),
              ss.C,
              vector(y0)) "Initial state vector (for initial condition plot)";
      algorithm
        Modelica_LinearSystems2.TransferFunction.Plot.timeResponse(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
TransferFunction.Plot.<b>initialResponse</b>(tf)
   or
TransferFunction.Plot.<b>initialResponse</b>(
  tf,
  dt,
  tSpan,
  y0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the initial response, i.e. the zeros input response of a transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf = (s + 1)/(s^2 + 5*s + 12);
  Real y0=1;

<b>algorithm</b>
  Modelica_LinearSystems2.TransferFunction.Plot.initialResponse(tf,y0=y0, dt=0.02, tSpan=3)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/TransferFunction/initialResponseTF.png\">
</blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Plot.ramp\">ramp</a>
</p>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of TransferFunction data record"
      import Modelica;
      extends Modelica.Icons.Package;
      encapsulated function toZerosAndPoles
        "Convert a TransferFunction into a ZerosAndPoles object"
        import Modelica;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Complex;

        input TransferFunction tf "Transfer function of a system";
        output ZerosAndPoles zp(
          redeclare Real n1[ZerosAndPoles.Internal.numberOfRealZeros2(tf)],
          redeclare Real n2[integer((size(tf.n, 1) - 1 -
            ZerosAndPoles.Internal.numberOfRealZeros2(tf))/2),2],
          redeclare Real d1[ZerosAndPoles.Internal.numberOfRealPoles(tf)],
          redeclare Real d2[integer((size(tf.d, 1) - 1 -
            ZerosAndPoles.Internal.numberOfRealPoles(tf))/2),2]) "ZerosAndPoles object";
    protected
        Complex z[:];
        Complex p[:];
        Real k;
      algorithm
        (z,p,k) := TransferFunction.Analysis.zerosAndPoles(tf);
        zp := ZerosAndPoles(z, p, k);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = TransferFunction.Conversion.<b>toZerosAndPoles</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a ZerosAndPoles record
</p>
<blockquote><pre>
          product(s + n1[i]) * product(s^2 + n2[i,1]*s + n2[i,2])
zp = k * ---------------------------------------------------------
          product(s + d1[i]) * product(s^2 + d2[i,1]*s + d2[i,2])
</pre></blockquote>
<p>
of a transfer function representated by numerator and denominator polynomial.
The poles and zeros and the gain <tt>k</tt> are computed
(<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Analysis.zerosAndPoles\">zerosAndPoles</a>)
and are used as inputs the ZerosAndPoles constructor.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction dtf = 1/(s^2 + 3*s +2)

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles(tf);
//  zp = 1/( (s + 1)*(s + 2) )
</pre></blockquote>
</html>"));
      end toZerosAndPoles;

      function toStateSpace
        "Convert a TransferFunction into a StateSpace representation"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica.Math.Vectors;

        input Modelica_LinearSystems2.TransferFunction tf
          "Transfer function of a system";
        output Modelica_LinearSystems2.StateSpace ss(
          redeclare Real A[TransferFunction.Analysis.denominatorDegree(tf),TransferFunction.Analysis.denominatorDegree(tf)],
          redeclare Real B[TransferFunction.Analysis.denominatorDegree(tf),1],
          redeclare Real C[1,TransferFunction.Analysis.denominatorDegree(tf)],
          redeclare Real D[1,1]) "Transfer function in StateSpace form";

    protected
        Integer na=TransferFunction.Analysis.denominatorDegree(tf) + 1;
        Integer nb=TransferFunction.Analysis.numeratorDegree(tf) + 1;
        Integer nx=na - 1;
        Real a[na]=Vectors.reverse(tf.d) "Reverse element order of tf.a";
        Real b[na]=vector([Vectors.reverse(tf.n); zeros(na - nb, 1)]);
        Real d=b[na]/a[na];
      algorithm
        if nx == 0 then
          ss.A := fill(0, 0, nx);
          ss.B := fill(0, 0, 1);
          ss.C := fill(0, 1, 0);
        else
          ss.A[1:nx - 1, 1:nx] := [zeros(nx - 1, 1),identity(nx - 1)];
          ss.A[nx, 1:nx] := -a[1:na - 1]/a[na];
          ss.B := [zeros(nx - 1, 1); 1/a[na]];
          ss.C := {b[1:nx] - d*a[1:nx]};
        end if;

        ss.D := [d];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ss = TransferFunction.Conversion.<b>toStateSpace</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Transforms a transfer function into state space representation.
There are an infinite number of possible realizations.
Here, the transfer function is transformed into
controller canonical form, i.e. the transfer function
</p>
<blockquote><pre>
     b4*s^4 + b3*s^3 + b2*s^2 + b1*s + b0
y = -------------------------------------- * u
     a4*s^4 + a3*s^3 + a2*s^2 + a1*s + a0
</pre></blockquote>
<p>
is transformed into:
</p>
<blockquote><pre>
<b>der</b>(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
   with
           <b>A</b> = [   0  ,    1  ,    0  ,    0;
                   0  ,    0  ,    1  ,    0:
                   0  ,    0  ,    0  ,    1;
                -a0/a4, -a1/a4, -a2/a4, -a3/a4];
            <b>B</b> = [  0;
                  0;
                  0;
                 1/a4];
           <b>C</b> = [b0-b4*a0/a4, b1-b4*a1/a4, b2-b4*a2/a4, b3-b4*a3/a4];
           <b>D</b> = [b4/a4];
</pre></blockquote>
<p>
If the numerator polynomial is 1, then the state vector
<b>x</b> is built up of y and of all derivatives of y up to nx-1
(nx is the dimension of the state vector):
</p>
<blockquote><pre>
<b>x</b> = {y, dy/dt, d^2y/dt^2, ..., d^(n-1)y/dt^(n-1)};
</pre></blockquote>
<p>
Note, the state vector <b>x</b> of Modelica.Blocks.Continuous.TransferFunction
is defined slightly differently.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^3 + s^2 + s +1);

<b>algorithm</b>
  ss := Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace(tf);
// ss.A = [0, 1, 0; 0, 0, 1; -1, -1, -1],
// ss.B = [0; 0; 1],
// ss.C = [1, 1, 0],
// ss.D = [0],
</pre></blockquote>
</html>"));
      end toStateSpace;

      encapsulated function toZerosAndPolesMIMO
        "Convert a TransferFunction into a zeros-and-poles representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf[:,:] "transfer function of a system";

        output ZerosAndPoles zp[size(tf, 1),size(tf, 2)];

    protected
        Integer ny=size(tf, 1);
        Integer nu=size(tf, 2);

      algorithm
        for iy in 1:ny loop
          for iu in 1:nu loop
            zp[iy, iu] := ZerosAndPoles(tf[iy, iu]);
          end for;
        end for;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = TransferFunction.Conversion.<b>toZerosAndPolesMIMO</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Converts a matrix of transfer functions denoted as rational polynomial function into a matrix of transfer functions in zeros-and-poles representation. The function repetitively uses
<a href=\"modelica://Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles\">toZerosAndPoles</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf = [1/(s^2 + 3*s +2);s/(s^2 + 2*s +1)]

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles(tf);
//  zp = [1/( (s + 1)*(s + 2) ); s/( (s + 1)^2 )]
</pre></blockquote>
</html>"));
      end toZerosAndPolesMIMO;

      function toMatrices
        "Convert a TransferFunction into the matrices A, B, C of a StateSpace"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica.Math.Vectors;

        input Modelica_LinearSystems2.TransferFunction tf
          "Transfer function of a system";

        output Real ABCD[size(tf.d,1),size(tf.d,1)];

    protected
        Integer na=TransferFunction.Analysis.denominatorDegree(tf) + 1;
        Integer nb=TransferFunction.Analysis.numeratorDegree(tf) + 1;
        Integer nx=na - 1;
        Real A[nx,nx];
        Real B[nx,1];
        Real C[1,nx];
        Real D[1,1];
        Real a[na]=Vectors.reverse(tf.d) "Reverse element order of tf.a";
        Real b[na]=vector([Vectors.reverse(tf.n); zeros(na - nb, 1)]);
        Real d=b[na]/a[na];
      algorithm
        if nx == 0 then
          A := fill(0, 0, nx);
          B := fill(0, 0, 1);
          C := fill(0, 1, 0);
        else
          A[1:nx - 1, 1:nx] := [zeros(nx - 1, 1),identity(nx - 1)];
          A[nx, 1:nx] := -a[1:na - 1]/a[na];
          B := [zeros(nx - 1, 1); 1/a[na]];
          C := {b[1:nx] - d*a[1:nx]};
        end if;
        D := [d];
        ABCD := [A,B;C,D];
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(A, B, C, D) = TransferFunction.Conversion.toStateSpace<b>toStateSpace</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Transforms a transfer function into state space representation. The outputs are the system functions A, B, C, D.
There are an infinite number of possible realizations.
Here, the transfer function is transformed into
controller canonical form, i.e. the transfer function
</p>
<blockquote><pre>
     b4*s^4 + b3*s^3 + b2*s^2 + b1*s + b0
y = -------------------------------------- * u
     a4*s^4 + a3*s^3 + a2*s^2 + a1*s + a0
</pre></blockquote>
<p>
is transformed into:
</p>
<blockquote><pre>
<b>der</b>(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>;
    <b>y</b>  = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>;
   with
           <b>A</b> = [   0  ,    1  ,    0  ,    0;
                   0  ,    0  ,    1  ,    0:
                   0  ,    0  ,    0  ,    1;
                -a0/a4, -a1/a4, -a2/a4, -a3/a4];
            <b>B</b> = [  0;
                  0;
                  0;
                 1/a4];
           <b>C</b> = [b0-b4*a0/a4, b1-b4*a1/a4, b2-b4*a2/a4, b3-b4*a3/a4];
           <b>D</b> = [b4/a4];
</pre></blockquote>
<p>
If the numerator polynomial is 1, then the state vector
<b>x</b> is built up of y and of all derivatives of y up to nx-1
(nx is the dimension of the state vector):
</p>
<blockquote><pre>
<b>x</b> = {y, dy/dt, d^2y/dt^2, ..., d^(n-1)y/dt^(n-1)};
</pre></blockquote>
<p>
Note, the state vector <b>x</b> of Modelica.Blocks.Continuous.TransferFunction
is defined slightly differently.
</p>

<h4>Example</h4>
<blockquote><pre>
  TransferFunction s = Modelica_LinearSystems2.TransferFunction.s();
  Modelica_LinearSystems2.TransferFunction tf=(s+1)/(s^3 + s^2 + s +1);

<b>algorithm</b>
  (A, B, C, D) := Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace(tf);
// A = [0, 1, 0; 0, 0, 1; -1, -1, -1],
// B = [0; 0; 1],
// C = [1, 1, 0],
// D = [0],
</pre></blockquote>
</html>"));
      end toMatrices;
    end Conversion;

    encapsulated package Import
      "Package of functions to generate a TransferFunction data record from imported data"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function fromFile
        "Generate a TransferFunction data record by reading numenator coefficients and denominator coefficients from a file (default file name is tf.mat)"

        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;
        input String fileName="tf.mat" "Name of the transfer function data file" annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                          caption="transfer function data file")));
        input String numName="n" "Name of the numenator of the transfer function";
        input String denName="d" "Name of the denominator of the transfer function";

    protected
        Integer numSize[2]=readMatrixSize(fileName, numName) annotation(__Dymola_allowForSize=true);
        Integer denSize[2]=readMatrixSize(fileName, denName) annotation(__Dymola_allowForSize=true);

        Real num[numSize[1],numSize[2]]=readMatrix(
              fileName,
              numName,
              numSize[1],
              numSize[2]) "numenator coefficients";
        Real den[denSize[1],denSize[2]]=readMatrix(
              fileName,
              denName,
              denSize[1],
              denSize[2]) "denominator coefficients";
        Integer ns2=numSize[2] annotation(__Dymola_allowForSize=true);
        Integer ds2=denSize[2] annotation(__Dymola_allowForSize=true);
    public
        output TransferFunction tf(n=fill(0,ns2),d=fill(0,ds2)) "transfer function";

      algorithm
        tf.n := vector(num);
        tf.d := vector(den);
        tf.uName := numName;
        tf.yName := denName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<table>
<tr> <td align=right>  tf </td><td align=center> =  </td>  <td> TransferFunction.Import.<b>fromFile</b>(fileName, numName, denName)  </td> </tr>
</table>
<h4>Description</h4>
<p>
Reads and loads a transfer function from a mat-file <tt>fileName</tt>. The file must contain the names of the vector with the polynomial coefficients of numerator and denominator

<h4>Example</h4>
<blockquote><pre>


<b>algorithm</b>
  tf:=Modelica_LinearSystems2.TransferFunction.Import.fromFile(\"tf.mat\", \"n\", \"d\");
//  tf = (s^2 + 2*s + 3)/(4*s^2 + 5*s + 6)
</pre></blockquote>
</html>"));
      end fromFile;

      function fromModel
        "Generate a TransferFunction data record from a state space representation resulted from linearization of a model"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input String modelName "Name of the Modelica model" annotation(Dialog(__Dymola_translatedModel(translate=true)));
        input Real T_linearize=0
          "Point in time of simulation to linearize the model";
        input String fileName="dslin" "Name of the result file";

    protected
        String fileName2=fileName + ".mat";
        Boolean OK1 = simulateModel(problem=modelName, startTime=0, stopTime=T_linearize);
        Boolean OK2 = importInitial("dsfinal.txt");
        Boolean OK3 = linearizeModel(problem=modelName, resultFile=fileName, startTime=T_linearize, stopTime=T_linearize+1);
        Real nxMat[1,1]=readMatrix(fileName2, "nx", 1, 1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny,nx + nu]=readMatrix(fileName2, "ABCD", nx + ny, nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(fileName2, "xuyName", nx + nu + ny);

        StateSpace result(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";
    public
        output TransferFunction tf[:,:];

      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        result.uNames := xuyName[nx + 1:nx + nu];
        result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        result.xNames := xuyName[1:nx];

        tf := Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunctionMIMO(result);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
tf = TransferFunction.Import.<b>fromModel</b>(modelName, T_linearize, fileName)
</pre></blockquote>

<h4>Description</h4>
<p>Generate a matrix of TransferFunction data records by linearization of a model
defined by modelName. The linearization is performed at time T_linearize of
the simulation. The system is genrated by using
<a href=\"modelica://Modelica_LinearSystems2.StateSpace.Import.fromFile\">StateSpace.Import.fromFile</a>
followed by a conversion from sate space to transfer function representation.
</p>

<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;

<b>algorithm</b>
  tf = Modelica_LinearSystems2.TransferFunction.Import.fromModel(modelName, T_linearize);

//  tf = [(0.13*s^4 + 0.05558*s^3 + 1.12241*s^2 - 5.16971*s + 9.04744)/(s^6 + 0.09*s^5 + 9.13717*s^4 - 32.0637*s^3 + 58.78*s^2 + 6.3659e-014*s - 1.1703e-014);
          (0.13*s^4 + 0.05558*s^3 + 1.12241*s^2 - 5.16971*s + 9.04744)/(s^5 + 0.09*s^4 + 9.13717*s^3 - 32.0637*s^2 + 58.78*s - 2.7929e-015);
          (-0.014*s^2 + 0.31906*s - 0.8106)/(s^4 + 0.09*s^3 + 9.13717*s^2 - 32.0637*s + 58.78);
          (-0.014*s^3 + 0.31906*s^2 - 0.8106*s)/(s^4 + 0.09*s^3 + 9.13717*s^2 - 32.0637*s + 58.78);
          (-0.1*s^2 - 0.160918*s - 0.21842)/(s^4 + 0.09*s^3 + 9.13717*s^2 - 32.0637*s + 58.78);
          (-0.1*s^3 - 0.160918*s^2 - 0.21842*s)/(s^4 + 0.09*s^3 + 9.13717*s^2 - 32.0637*s + 58.78)]
</pre></blockquote>
</html>"));
      end fromModel;

    end Import;

    encapsulated package Internal
      "Package of internal material of record TransferFunction (for advanced users only)"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function readLength
        "Read the number n of coefficients written in a [n,1]-matrix"
        input String fileName="tf.mat" "Name of the transfer function data file";
        input String polyName="n"
          "Name of the polynominal (numenator or denominator) coefficients of the transfer function" annotation(Dialog);
        output Integer result;
    protected
        Integer polySize[2]=readMatrixSize(fileName, polyName);

      algorithm
        result := polySize[2];
      end readLength;

      encapsulated function isControllableAndObservableSISO
        "To check whether a SISO system is controllable and observable"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.TransferFunction;

        input TransferFunction tf;

        output Boolean controllableAndObservable;
    protected
        StateSpace ss=StateSpace(tf);

      algorithm
        controllableAndObservable := StateSpace.Internal.isControllableAndObservableSISO(ss=ss);

      end isControllableAndObservableSISO;

    end Internal;

    annotation (defaultComponentName="transferFunction", Documentation(info="<html>
<p>
This record defines the transfer function between the input signal u
and the output signal y by the coefficients of the numerator and denominator
polynomials n(s) and d(s) respectively:
</p>
<pre>        n(s)
   y = ------ * u
        d(s)
</pre>
<p>
The order of the numerator
polynomial can be larger as the order of the denominator polynomial
(in such a case, the transfer function can not be
transformed to a StateSpace system, but other operations are possible).
</p>
<p>
Example: The transfer function
</p>
<pre>             2*s+3
   y = ----------------- * u
        4*s^2 + 5*s + 6
</pre>
<p>
is transformed in the following way in a TransferFunction record:
</p>
<pre>
   <b>import</b> Modelica_LinearSystems2.TransferFunction;
   <b>import</b> Modelica.Utilities.Streams;
   TransferFunction tf(n={2,3}, d={4,5,6});
   print(\"y = \" + TransferFunction.'String'(tf) + \" * u\");
   // prints the following string to the output window:
   //   y = (2*s + 3) / (4*s^2 + 5*s + 6) * u
</pre>
</html>"));
  end TransferFunction;

  operator record DiscreteStateSpace
    "Discrete state space description of a linear, time invariant difference equation system (data + operations)"
    extends Modelica.Icons.Record;

    Real A[:,size(A, 1)]  annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
    Real B[size(A, 1),:]  annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
    Real C[:,size(A, 1)]  annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
    Real D[size(C, 1),size(B, 2)] annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));

    Modelica.Units.SI.Time Ts=1 "Sample time"
      annotation (Dialog(group="Data used to construct discrete from continuous system"));
    Real B2[size(B, 1),size(B, 2)]=fill(0,size(B,1),size(B,2))
      "Reconstruct continuous state"
      annotation(Dialog(group="Data used to construct discrete from continuous system"));
    Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));

  //      String yNames[size(C, 1)]=fill("", size(C, 1)) "Names of the output signals" annotation(Dialog(group="Signal names"));
  //      String xNames[size(A, 1)]=fill("", size(A, 1)) "Names of the states" annotation(Dialog(group="Signal names"));
  //      String uNames[size(B, 2)]=fill("", size(B, 2)) "Names of the input signals" annotation(Dialog(group="Signal names"));

    encapsulated operator 'constructor'
      "Collection of operators to construct a DiscreteStateSpace data record"
      import Modelica_LinearSystems2;
      import Modelica;

      function fromDiscreteTransferFunction =
        Modelica_LinearSystems2.DiscreteTransferFunction.Conversion.toDiscreteStateSpace
        "Generate a DiscreteStateSpace data record from a discrete transfer function"
        annotation (Documentation(info="<html> </html>"));

      function fromDiscreteZerosAndPoles =
        Modelica_LinearSystems2.DiscreteZerosAndPoles.Conversion.toDiscreteStateSpace
        "Generate a DiscreteStateSpace data record from a discrete zeros-and-poles description"
        annotation (Documentation(info="<html> </html>"));

      encapsulated function fromReal
        "Generate a DiscreteStateSpace data record from a real value"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input Real r "Value of Real variable";
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        output DiscreteStateSpace dss(
          redeclare Real A[0,0],
          redeclare Real B[0,1],
          redeclare Real B2[0,1],
          redeclare Real C[1,0],
          redeclare Real D[1,1]) "= r";

      algorithm
        dss.D[1, 1] := r;
        dss.Ts := Ts;
        dss.method := method;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dss = 'constructor'.<b>fromReal</b>(r)
   or
dss = 'constructor'.<b>fromReal</b>(r, Ts, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a DiscreteStateSpace record dss from a Real value,
i.e. a discrete state space system without a state and an output without dynamics:
</p>
<blockquote><pre>
y = r*u
</pre></blockquote>
<p>
Therefore, the matrices are defined by
</p>
<blockquote><pre>
dss.A = fill(0,0,0);
dss.B = fill(0,0,1);
dss.C = fill(0,1,0);
dss.D = [r];
dss.B2 = fill(0,0,1);
</pre></blockquote>
<p>
The default values of sample time <b>Ts</b> and discretization method <b>method</b> are
</p>
<blockquote><pre>
    Ts = 1
method = Modelica_LinearSystems2.Types.Method.Trapezoidal
</pre></blockquote>
<p>
respectively.
</p>
</html>"));
      end fromReal;

      function fromMatrices
        "Generate a DiscreteStateSpace data record from A, B, C and D matrices"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input Real A[:,size(A, 1)]
          annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
        input Real B[size(A, 1),:]
          annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
        input Real C[:,size(A, 1)]
          annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));
        input Real D[size(C, 1),size(B, 2)]
          annotation(Dialog(group="new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u"));

        input Modelica.Units.SI.Time Ts=1 "Sample time" annotation (Dialog(group=
                "Data used to construct discrete from continuous system"));
        input Real B2[:,:]=zeros(size(B, 1), size(B, 2));
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization methodDiscretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));
        output DiscreteStateSpace result(
          redeclare Real A[size(A, 1),size(A, 2)],
          redeclare Real B[size(B, 1),size(B, 2)],
          redeclare Real C[size(C, 1),size(C, 2)],
          redeclare Real D[size(D, 1),size(D, 2)],
          redeclare Real B2[size(B2, 1),size(B2, 2)]);
      algorithm
        result.A := A;
        result.B := B;
        result.C := C;
        result.D := D;

        result.B2 := B2;
        result.Ts := Ts;
        result.method := method;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
dss = 'constructor'.<b>fromMatrices</b>(A, B, C, D)
dss = 'constructor'.<b>fromMatrices</b>(A, B, C, D, Ts, B2, method)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This function constructs a DiscreteStateSpace record dss with
</p>
<blockquote><pre>
dss.A = A;
dss.B = B;
dss.C = C;
dss.D = D;
dss.B2 = B2;
dss.Ts = Ts;
dss.method = method;
</pre></blockquote>
<p>
i.e. the input-matrices are the system matrices of the discrete system.
The default values of sample time <b>Ts</b> and discretization method
<b>method</b> are
</p>
<blockquote><pre>
    Ts = 1
method = Modelica_LinearSystems2.Types.Method.Trapezoidal
</pre></blockquote>
<p>
respectively. See also
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromMatrices2\">fromMatrices2</a>
where the inputs are the matrices of a continuous system which is to convert to discrete state space.
</p>

<h4>Example</h4>
<blockquote><pre>
  import dss=Modelica_LinearSystems2.DiscreteStateSpace;
  Real A[1,1] = [1];
  Real B[1,1] = [1];
  Real C[1,1] = [1];
  Real D[1,1] = [0];

public
  DiscreteStateSpace dss;

<b>algorithm</b>
  dss := dss.'constructor'.fromMatrices(A, B, C, D)  // or just: dss := dss(A, B, C, D, Ts=1, B2=[0], method=Modelica_LinearSystems2.Types.Method.Trapezoidal);
  // dss.A = [1]
  // dss.B = [1]
  // dss.C = [1]
  // dss.D = [0]
  // dss.B2 = [0]
  // dss.Ts = 1
  // dss.method = Modelica_LinearSystems2.Types.Method.Trapezoidal
</pre></blockquote>
</html>"));
      end fromMatrices;

      function fromStateSpace
        "Generate a DiscreteStateSpace data record from a continuous state space system "
        import Modelica;
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Utilities.Types.Method;

        input Modelica_LinearSystems2.StateSpace ss
          "Continuous linear state space system";
        input Modelica.Units.SI.Time Ts "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        output Modelica_LinearSystems2.DiscreteStateSpace dss(
          redeclare Real A[size(ss.A, 1),size(ss.A, 2)],
          redeclare Real B[size(ss.B, 1),size(ss.B, 2)],
          redeclare Real C[size(ss.C, 1),size(ss.C, 2)],
          redeclare Real D[size(ss.D, 1),size(ss.D, 2)],
          redeclare Real B2[size(ss.B, 1),size(ss.B, 2)])
          "Discrete state space system";

    protected
        Integer nx=size(ss.A, 1) "Number of states";
        Integer nu=size(ss.B, 2) "Number of input signals";
        Real LU[nx,nx] "LU decomposition";
        Integer pivots[nx] "Pivots of LU decomposition";
      algorithm
        dss.Ts := Ts;
        dss.method := method;

        if method == Method.ExplicitEuler then
              /*  der_x = A*x + B*u
             x = pre(x) + Ts*pre(der_x)
     */
          dss.A := identity(nx) + Ts*ss.A;
          dss.B := Ts*ss.B;
          dss.C := ss.C;
          dss.D := ss.D;
          dss.B2 := zeros(nx, nu);

        elseif method == Method.ImplicitEuler then
              /*  der_x = A*x + B*u
             x = pre(x) + Ts*der_x
     */
          (LU,pivots) := MatricesMSL.LU(identity(nx) -
            Ts*ss.A);
          dss.B2 := MatricesMSL.LU_solve2(
                LU,
                pivots,
                Ts*ss.B);
          dss.A := MatricesMSL.LU_solve2(
                LU,
                pivots,
                identity(nx));
          dss.B := dss.A*dss.B2;
          dss.C := ss.C;
          dss.D := dss.C*dss.B2 + ss.D;

        elseif method == Method.Trapezoidal then
              /*  der_x = A*x + B*u
             x = pre_x + (Ts/2)*(pre_der_x + der_x);
     */
          (LU,pivots) := MatricesMSL.LU(identity(nx) -
            (Ts/2)*ss.A);
          dss.B2 := MatricesMSL.LU_solve2(
                LU,
                pivots,
                (Ts/2)*ss.B);
          dss.A := MatricesMSL.LU_solve2(
                LU,
                pivots,
                identity(nx) + (Ts/2)*ss.A);
          dss.B := dss.A*dss.B2 + dss.B2;
          dss.C := ss.C;
          dss.D := dss.C*dss.B2 + ss.D;

        elseif method == Method.StepExact then
             /* x = phi*pre(x) + gamma*pre(u);
       y = C*x + D*u
    */
          (dss.A,dss.B) := MatricesMSL.integralExp(
                ss.A,
                ss.B,
                Ts);
          dss.C := ss.C;
          dss.D := ss.D;
          dss.B2 := zeros(nx, nu);

        elseif method == Method.RampExact then
             /* x = phi*pre(x) + gamma*pre(u) + gamma1/Ts*(u - pre_u);
        -> x = phi*pre(x) + (gamma - gamma1/Ts)*pre(u) + gamma1/Ts*u;
  z = x - gamma1/Ts*u
      leads to
        z = phi*pre(z) + phi*gamma1/Ts*pre(u) +gamma*pre(u) - gamma1/Ts*pre(u)
       y = C*x + D*u
      -> y = C*z + (D + C*gamma1/Ts)*u
      x = z + gamma1/Ts*u

    */
          (dss.A,dss.B,dss.B2) := MatricesMSL.integralExpT(
                ss.A,
                ss.B,
                Ts);
          dss.B2 := dss.B2/Ts;
          dss.B := dss.A*dss.B2 + dss.B - dss.B2;
          dss.C := ss.C;
          dss.D := dss.C*dss.B2 + ss.D;

        elseif method == Method.ImpulseExact then
             /* x = phi*pre(x) + phi*B*u;
        y = C*x
        (u = [1,0,1,1,0..,0])
      Limitations: The infinite impulses at t = kT is ignored in the mapping
    */

          dss.A := MatricesMSL.exp(ss.A, Ts);
          dss.B := dss.A*ss.B;
          dss.C := ss.C;
          dss.D := ss.C*ss.B;
          dss.B2 := ss.B;

        else
          assert(false, "Argument method (= " + String(method) +
            ") of makeDiscrete is wrong.");
        end if;
        annotation (
          Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dss = 'constructor'.<b>fromStateSpace</b>(ss, Ts)
dss = 'constructor'.<b>fromStateSpace</b>(ss, Ts, method)
</pre></blockquote>

<h4>Description</h4>
<p>
This function derives a linear time invariant difference
equation system in state space form
</p>
<blockquote><pre>
<b>x</b>(Ts*(k+1))        = <b>A</b> * <b>x</b>(Ts*k) + <b>B</b> * <b>u</b>(Ts*k)
<b>y</b>(Ts*k)            = <b>C</b> * <b>x</b>(Ts*k) + <b>D</b> * <b>u</b>(Ts*k)
<b>x</b>_continuous(Ts*k) =     <b>x</b>(Ts*k) + <b>B2</b> * <b>u</b>(Ts*k)
</pre></blockquote>
<p>
with
</p>
<ul>
<li> <b>Ts</b> - the sample time,</li>
<li> <b>k</b> - the index of the actual sample instance (k=0,1,2,3,...),</li>
<li> <b>t</b> - the time,</li>
<li> <b>u</b>(t) - the input vector,</li>
<li> <b>y</b>(t) - the output vector,</li>
<li> <b>x</b>(t) - the discrete state vector (x(t=Ts*0) is the initial state),</li>
<li> <b>x</b>_continuous(t) - the state vector of the continuous system
     from which the discrete block has been derived (details see below),</li>
<li> <b>A, B, C, D, B2</b> - matrices of appropriate dimensions.</li>
</ul>
<p>
from continuous state space form
</p>
<blockquote><pre>
der(<b>xc</b>(t)) = <b>ss.A</b> * <b>xc</b>(t) + <b>ss.B</b> * <b>us</b>(t)
    <b>yc</b>(t)  = <b>ss.C</b> * <b>xc</b>(t) + <b>ss.D</b> * <b>uc</b>(t)
</pre></blockquote>
<p>
The applied discretization method is selected by the user from
</p>
<ul>
<li> <b>ExplicitEuler</b> - Discretization with explicit Euler integration,</li>
<li> <b>ImplicitEuler</b> - Discretization with implicit Euler integration,</li>
<li> <b>Trapezoidal</b> - Discretization with trapezoidal integration (Tustins method, recommended),</li>
<li> <b>ImpulseExact</b> - Exact discretization for impulse inputs,</li>
<li> <b>StepExact</b> - Exact discretization for step inputs (zero-order hold equivalent),</li>
<li> <b>RampExact</b> - Exact discretization for ramp inputs (first-order hold equivalent).</li>
</ul>

<h4>Example</h4>
<blockquote><pre>
  import dss=Modelica_LinearSystems2.DiscreteStateSpace;
  import Modelica_LinearSystems2.StateSpace;

  StateSpace ss=StateSpace(A = [1], B = [1], C = [1], D = [0]);
  Modelica.Units.SI.Time Ts=0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.Trapezoidal;

public
  DiscreteStateSpace dss;

<b>algorithm</b>
  dss := dss.'constructor'.fromStateSpace(ss, Ts);

  //or just:
  //dss := dss(ss=ss, Ts=Ts, method=method);

  //  dss.A = [1.1053],
  //  dss.B = [0.11080],
  //  dss.C = [1],
  //  dss.D = [0.0526],
  //  dss.Ts = 0.1,
  //  dss.B2 = [0.0526],
  //  dss.method = Modelica_LinearSystems2.Types.Method.Trapezoidal
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromMatrices2\">fromMatrices2</a>
</p>
</html>"));
      end fromStateSpace;

      encapsulated function fromMatrices2
        "Generate a DiscreteStateSpace data record from matrices of a continuous state space system"
        import Modelica;
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Utilities.Types.Method;

        input Real A[:,size(A, 1)] annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
        input Real B[size(A, 1),:] annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
        input Real C[:,size(A, 1)] annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
        input Real D[size(C, 1),size(B, 2)] annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
        input Modelica.Units.SI.Time Ts "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
      //  input Modelica_LinearSystems2.Types method=Modelica_LinearSystems2.Types.Method.Trapezoidal
        output Modelica_LinearSystems2.DiscreteStateSpace dss(
          redeclare Real A[size(A, 1),size(A, 2)],
          redeclare Real B[size(B, 1),size(B, 2)],
          redeclare Real C[size(C, 1),size(C, 2)],
          redeclare Real D[size(D, 1),size(D, 2)],
          redeclare Real B2[size(B, 1),size(B, 2)]) "Discrete state space system";

    protected
        Integer nx=size(A, 1) "Number of states";
        Integer nu=size(B, 2) "Number of input signals";
        Real LU[nx,nx] "LU decomposition";
        Integer pivots[nx] "Pivots of LU decomposition";
      algorithm
        dss.Ts := Ts;
        dss.method := method;

        if method == Method.ExplicitEuler then
              /*  der_x = A*x + B*u
             x = pre(x) + Ts*pre(der_x)
     */
          dss.A := identity(nx) + Ts*A;
          dss.B := Ts*B;
          dss.C := C;
          dss.D := D;
          dss.B2 := zeros(nx, nu);

        elseif method == Method.ImplicitEuler then
              /*  der_x = A*x + B*u
             x = pre(x) + Ts*der_x
     */
          (LU,pivots) := MatricesMSL.LU(identity(nx) -
            Ts*A);
          dss.B2 := MatricesMSL.LU_solve2(
                LU,
                pivots,
                Ts*B);
          dss.A := MatricesMSL.LU_solve2(
                LU,
                pivots,
                identity(nx));
          dss.B := dss.A*dss.B2;
          dss.C := C;
          dss.D := dss.C*dss.B2 + D;

        elseif method == Method.Trapezoidal then
              /*  der_x = A*x + B*u
             x = pre_x + (Ts/2)*(pre_der_x + der_x);
     */
          (LU,pivots) := MatricesMSL.LU(identity(nx) -
            (Ts/2)*A);
          dss.B2 := MatricesMSL.LU_solve2(
                LU,
                pivots,
                (Ts/2)*B);
          dss.A := MatricesMSL.LU_solve2(
                LU,
                pivots,
                identity(nx) + (Ts/2)*A);
          dss.B := dss.A*dss.B2 + dss.B2;
          dss.C := C;
          dss.D := dss.C*dss.B2 + D;

        elseif method == Method.StepExact then
             /* x = phi*pre(x) + gamma*pre(u);
       y = C*x + D*u
    */
          (dss.A,dss.B) := MatricesMSL.integralExp(
                A,
                B,
                Ts);
          dss.C := C;
          dss.D := D;
          dss.B2 := zeros(nx, nu);

        elseif method == Method.RampExact then
             /* x = phi*pre(x) + gamma*pre(u) + gamma1/Ts*(u - pre_u);
        -> x = phi*pre(x) + (gamma - gamma1/Ts)*pre(u) + gamma1/Ts*u;
  z = x - gamma1/Ts*u
      leads to
        z = phi*pre(z) + phi*gamma1/Ts*pre(u) +gamma*pre(u) - gamma1/Ts*pre(u)
       y = C*x + D*u
      -> y = C*z + (D + C*gamma1/Ts)*u
      x = z + gamma1/Ts*u

    */
          (dss.A,dss.B,dss.B2) := MatricesMSL.integralExpT(
                A,
                B,
                Ts);
          dss.B2 := dss.B2/Ts;
          dss.B := dss.A*dss.B2 + dss.B - dss.B2;
          dss.C := C;
          dss.D := dss.C*dss.B2 + D;

        elseif method == Method.ImpulseExact then
             /* x = phi*pre(x) + phi*B*u;
        y = C*x
        (u = [1,0,1,1,0..,0])
      Limitations: The infinite impulses at t = kT is ignored in the mapping
    */

          dss.A := MatricesMSL.exp(A, Ts);
          dss.B := dss.A*B;
          dss.C := C;
          dss.D := C*B;
          dss.B2 := B;

        else
          assert(false, "Argument method (= " + String(method) +
            ") of makeDiscrete is wrong.");
        end if;
        annotation (
          Documentation(info="<html>
<p>
This function derives a linear time invariant difference
equation system in state space form:
</p>
<blockquote><pre>
<b>xd</b>(Ts*(k+1))       = <b>Ad</b> * <b>xd</b>(Ts*k) + <b>Bd</b> * <b>ud</b>(Ts*k)
<b>yd</b>(Ts*k)           = <b>Cd</b> * <b>xd</b>(Ts*k) + <b>Dd</b> * <b>ud</b>(Ts*k)
<b>x</b>_continuous(Ts*k) =      <b>xd</b>(Ts*k) + <b>B2</b> * <b>ud</b>(Ts*k)
</pre></blockquote>
<p>
from the matrices <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b> of the corresponding continuous system
</p>
<blockquote><pre>
der(<b>x</b>(t)) = <b>A</b> * <b>x</b>(t) + <b>B</b> * <b>u</b>(t)
    <b>y</b>(t)  = <b>C</b> * <b>x</b>(t) + <b>D</b> * <b>u</b>(t)
</pre></blockquote>
<p>
The function is similar to
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromStateSpace\">fromStateSpace</a>
but the inputs are restricted to the matrices, the sample time and the discretization method.
</p>

<h4>Example</h4>
<blockquote><pre>
  import dss=Modelica_LinearSystems2.DiscreteStateSpace;
  Real A[1,1] = [1];
  Real B[1,1] = [1];
  Real C[1,1] = [1];
  Real D[1,1] = [0];

public
  DiscreteStateSpace dss;

<b>algorithm</b>
  dss := dss.'constructor'.fromMatrices2(A, B, C, D);

  //or just:
  //dss := dss(A, B, C, D, Ts=0.1, method=Modelica_LinearSystems2.Types.Method.Trapezoidal);

  //  dss.A = [1.1053],
  //  dss.B = [0.11080],
  //  dss.C = [1],
  //  dss.D = [0.0526],
  //  dss.Ts = 0.1,
  //  dss.B2 = [0.0526],
  //  dss.method = Modelica_LinearSystems2.Types.Method.Trapezoidal
</pre></blockquote>
</html>"));
      end fromMatrices2;
    end 'constructor';

    encapsulated operator '-'
      "Contains operators for subtraction of discrete state space systems"
      import Modelica;

      function subtract
        "Subtraction of two state space systems connected in parallel (= inputs are the same, outputs of the two systems are subtracted)"

        import Modelica;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss1 "State space system 1";
        input DiscreteStateSpace dss2 "State Space system 2 is subtracted from system 1";
        output DiscreteStateSpace result(
          redeclare Real A[size(dss1.A, 1) + size(dss2.A, 1),size(dss1.A, 2) + size(dss2.A, 2)],
          redeclare Real B[size(dss1.B, 1) + size(dss2.B, 1),size(dss1.B, 2)],
          redeclare Real C[size(dss1.C, 1),size(dss1.C, 2) + size(dss2.C, 2)],
          redeclare Real D[size(dss1.D, 1),size(dss1.D, 2)],
          redeclare Real B2[size(dss1.B2, 1) + size(dss2.B2, 1),size(dss1.B2, 2)])
            "= dss1 - dss2";
    protected
        Integer nx1=size(dss1.A, 1);
        Integer nx2=size(dss2.A, 1);
      algorithm
        assert(abs(dss1.Ts-dss2.Ts)<=Modelica.Constants.eps,"Two discrete state space systems must have the same sample time Ts for subtraction with \"-\".");
        result.A := [dss1.A,zeros(nx1, nx2); zeros(nx2, nx1),dss2.A];
        result.B := [dss1.B; dss2.B];
        result.B2 := [dss1.B2; dss2.B2];
        result.C := [dss1.C,-dss2.C];
        result.D := dss1.D - dss2.D;
        result.Ts := dss1.Ts;
        result.method := dss1.method;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote>
<pre>
dss = DiscreteStateSpace.'-'.<b>subtract</b>(dss1, dss2)
</pre>
</blockquote>

<h4>Description</h4>
<p>
This operator function computes the subtraction of two discrete state space
systems connected in parallel, i.e. the inputs are the same and the outputs
of the two systems are subtracted. Therefore, The systems must have the same
number of inputs and outputs but not the same number of states.
The resulting system has an order of system_order1 + system_order2.
</p>
<p>
The operator is used by writing just the following command:
</p>
<blockquote><pre>
dss3 := dss1 - dss2;
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  DiscreteStateSpace dss1 = DiscreteStateSpace(A=[-1, 0; 0, -2], B=[1;2], C=[0, 1], D=[0]);
  DiscreteStateSpace dss2 = DiscreteStateSpace(A=[-3, 0; 0, -4], B=[3;4], C=[0, 2], D=[0]);

  DiscreteStateSpace dss3;

<b>algorithm</b>
  dss3 := dss1 - dss2;
// dss.A = [-1, 0, 0, 0; 0, -2, 0, 0; 0, 0, -3, 0; 0, 0, 0, -4],
// dss.B = [1; 2; 3; 4],
// dss.C = [0, 1, 0, -2],
// dss.D = [0],
// dss.B2 = [0; 0; 0; 0],
</pre></blockquote>
</html>"));
      end subtract;

      function negate
        "Unary minus (discrete state space system where the output is multiplied by a gain of -1)"
        import Modelica;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss;
        output DiscreteStateSpace result(
          redeclare Real A[size(dss.A, 1),size(dss.A, 2)],
          redeclare Real B[size(dss.B, 1),size(dss.B, 2)],
          redeclare Real C[size(dss.C, 1),size(dss.C, 2)],
          redeclare Real D[size(dss.D, 1),size(dss.D, 2)]) "= -dss";
      algorithm
        result.A := dss.A;
        result.B := dss.B;
        result.B2 := dss.B2;
        result.C := -dss.C;
        result.D := -dss.D;
        result.Ts := dss.Ts;
        result.method := dss.method;
      end negate;
      annotation (Documentation(info="<html>
<p>
This package contains operators for subtraction of discrete state space records.
</p>
</html>"));
    end '-';

    encapsulated operator function '+'
      "Parallel connection of two discrete state space systems (= inputs are the same, outputs of the two systems are added)"
      import Modelica;
      import Modelica_LinearSystems2.DiscreteStateSpace;

      input DiscreteStateSpace dss1 "System 1";
      input DiscreteStateSpace dss2 "System 2 is added in parallel to system 1";
      output DiscreteStateSpace result(
        redeclare Real A[size(dss1.A, 1) + size(dss2.A, 1),size(dss1.A, 2) + size(
          dss2.A, 2)],
        redeclare Real B[size(dss1.B, 1) + size(dss2.B, 1),size(dss1.B, 2)],
        redeclare Real C[size(dss1.C, 1),size(dss1.C, 2) + size(dss2.C, 2)],
        redeclare Real D[size(dss1.D, 1),size(dss1.D, 2)],
        redeclare Real B2[size(dss1.B2, 1) + size(dss2.B2, 1),size(dss1.B2, 2)])
        "= dss1 + dss2";
  protected
      Integer nx1=size(dss1.A, 1);
      Integer nx2=size(dss2.A, 1);
    algorithm
      assert(abs(dss1.Ts-dss2.Ts)<=Modelica.Constants.eps,"Two discrete state space systems must have the same sample time Ts for addition with \"+\".");
      result.A := [dss1.A,zeros(nx1, nx2); zeros(nx2, nx1),dss2.A];
      result.B := [dss1.B; dss2.B];
      result.B2 := [dss1.B2; dss2.B2];
      result.C := [dss1.C,dss2.C];
      result.D := dss1.D + dss2.D;
      result.Ts := dss1.Ts;
      result.method := dss1.method;

    end '+';

    encapsulated operator function '*'
      "Series connection of two discrete state space systems"
      import Modelica;
      import Modelica_LinearSystems2.DiscreteStateSpace;

      input DiscreteStateSpace dss1 "System 1";
      input DiscreteStateSpace dss2 "System 2";
      output DiscreteStateSpace result(
        redeclare Real A[size(dss1.A, 1) + size(dss2.A, 1),size(dss1.A, 2) + size(
          dss2.A, 2)],
        redeclare Real B[size(dss1.B, 1) + size(dss2.B, 1),size(dss2.B, 2)],
        redeclare Real C[size(dss1.C, 1),size(dss1.C, 2) + size(dss2.C, 2)],
        redeclare Real D[size(dss1.D, 1),size(dss2.D, 2)],
        redeclare Real B2[size(dss1.B2, 1) + size(dss2.B2, 1),size(dss2.B2, 2)])
        "y = G(s)*u = G(dss1)*G(dss2)*u";
  protected
      Integer nx1=size(dss1.A, 1);
      Integer nx2=size(dss2.A, 1);
    algorithm
      if size(dss1.A,1)>0 then
        assert(abs(dss1.Ts-dss2.Ts)<=Modelica.Constants.eps,"Two discrete state space systems must have the same sample time Ts for multiplication with \"*\".");
      end if;
      result.A := [dss1.A,dss1.B*dss2.C; zeros(nx2, nx1),dss2.A];
      result.B := [dss1.B*dss2.D; dss2.B];
      result.B2 := [dss1.B2*dss2.D; dss2.B2];
      result.C := [dss1.C,dss1.D*dss2.C];
      result.D := dss1.D*dss2.D;
      result.Ts := dss2.Ts;
      result.method := dss2.method;

    end '*';

    encapsulated operator function '=='
      "Check whether two linear discrete state space systems have identical matrices"
      import Modelica;
      import Modelica.Math.Matrices.isEqual;
      import Modelica_LinearSystems2.DiscreteStateSpace;

      input DiscreteStateSpace dss1 "System 1";
      input DiscreteStateSpace dss2 "System 2";
      input Real eps(min=0) = 0
        "Two elements e1 and e2 of the two systems are identical if abs(e1-e2) <= eps";
      output Boolean same "=true, if the two systems are identical";
    algorithm
      same := isEqual(dss1.A, dss2.A, eps) and isEqual(dss1.B, dss2.B, eps)  and isEqual(dss1.B2, dss2.B2, eps) and isEqual(dss1.C, dss2.C, eps) and isEqual(dss1.D, dss2.D, eps) and abs(dss1.Ts - dss2.Ts) <= Modelica.Constants.eps;
    end '==';

  // encapsulated operator function 'String'
  //     "Transform discrete state space into a String representation"
  //    import Modelica;
  //    import Modelica_LinearSystems2;
  //    import Modelica_LinearSystems2.DiscreteStateSpace;
  //    import Modelica.Utilities.Strings;
  //
  //    input DiscreteStateSpace dss
  //       "State space system to be transformed in a String representation";
  //    input Integer significantDigits=12
  //       "Number of significant digits that are shown";
  //    input String name="dss" "Independent variable name used for printing";
  //    output String s="";
  //
  //   protected
  //     String space=Strings.repeat(5);
  //     String space2=Strings.repeat(3);
  //     String space3=Strings.repeat(8);
  //     Integer nx=size(dss.A, 1);
  //     Integer nu=size(dss.B, 2);
  //     Integer ny=size(dss.C, 1);
  //     Integer sizeD=size(dss.D, 2);
  //     Integer stringMaxLength;
  //     Boolean xNamesExist=false;
  //     Boolean uNamesExist=false;
  //     Boolean yNamesExist=false;
  //
  // algorithm
  //   //Checking if name arrays are empty
  //     for i in 1:nx loop
  //       xNamesExist := xNamesExist or (dss.xNames[i] <> "");
  //     end for;
  //
  //     for i in 1:ny loop
  //       yNamesExist := yNamesExist or (dss.yNames[i] <> "");
  //     end for;
  //
  //     for i in 1:nu loop
  //       uNamesExist := uNamesExist or (dss.uNames[i] <> "");
  //     end for;
  //
  //     if xNamesExist then
  //       Modelica.Utilities.Streams.print("xNamesExist == true");
  //     else
  //       Modelica.Utilities.Streams.print("xNamesExist == false");
  //     end if;
  //
  //     stringMaxLength := max(size(dss.xNames, 1), min(size(dss.yNames, 1),
  //       11));
  //
  //     if nx == 0 and sizeD == 0 then
  //       s := name + ".A = []\n  " + name + ".B = []\n   " + name + ".C = [] \n   " + name + ".D = []"+ name + ".B2 = []";
  //     else
  //       s := "\n" + name + ".A = \n";
  //
  //   //Horizontal
  //   // Two alternatives when printing state names
  //       if xNamesExist == false then
  //         s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
  //           "x1 ";
  //       else
  //         s := s + Strings.repeat(11 + significantDigits - min(Strings.length(
  //           dss.xNames[1]), 11)) + Strings.repeat(min(Strings.length(dss.xNames[
  //           1]), 11)) + " " + Strings.substring(
  //               dss.xNames[1],
  //               1,
  //               min(Strings.length(dss.xNames[1]), 11));
  //       end if;
  //
  //       for i in 2:nx loop
  //
  //   //Two alternatives when printing state names
  //
  //         if xNamesExist == false then
  //           s := s + Strings.repeat(significantDigits + 11 - Strings.length("x"
  //              + String(i - 1))) + "x" + String(i) + " ";
  //         else
  //           s := s + " " + Strings.repeat(significantDigits + 11 - min(
  //             Strings.length(dss.xNames[i - 1]), 11)) + Strings.substring(
  //                 dss.xNames[i],
  //                 1,
  //                 min(Strings.length(dss.xNames[i]), 11));
  //
  //         end if;
  //
  //   //s := s + Strings.repeat(6) + "x" + String(i);
  //       end for;
  //       s := s + "\n";
  //
  //       for i in 1:nx loop
  //   //Vertical
  //   //Two alternatives when printing state names
  //         if xNamesExist == false then
  //           s := s + space + "x" + String(i) + " ";
  //         else
  //           s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
  //             dss.xNames[i]), 11)) + Strings.substring(
  //                 dss.xNames[i],
  //                 1,
  //                 min(Strings.length(dss.xNames[i]), 11)) + " ";
  //         end if;
  //
  //         for j in 1:nx loop
  //           if dss.A[i, j] >= 0 then
  //             s := s + " ";
  //           end if;
  //           s := s + String(dss.A[i, j], significantDigits=significantDigits) +
  //             Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
  //             dss.A[i, j]), significantDigits=significantDigits)));
  //        end for;
  //         s := s + "\n";
  //       end for;
  //   //--------------------------------------------------------------------------------------------------------------------------------------------------
  //       s := s + "\n" + name + ".B = \n";
  //    //Horizontal
  //   // Two alternatives when printing state names
  //       if uNamesExist == false then
  //         s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
  //           "u1 ";
  //       else
  //         s := s + Strings.repeat(11 + significantDigits - min(Strings.length(
  //           dss.uNames[1]), 11)) + Strings.repeat(min(Strings.length(dss.uNames[
  //           1]), 11)) + " " + Strings.substring(
  //               dss.uNames[1],
  //               1,
  //               min(Strings.length(dss.uNames[1]), 11));
  //       end if;
  //
  //       for i in 2:nu loop
  //   //Two alternatives when printing state names
  //         if uNamesExist == false then
  //           s := s + Strings.repeat(significantDigits + 11 - Strings.length("u"
  //              + String(i - 1))) + "u" + String(i) + " ";
  //         else
  //           s := s + " " + Strings.repeat(significantDigits + 11 - min(
  //             Strings.length(dss.uNames[i - 1]), 11)) + Strings.substring(
  //                 dss.uNames[i],
  //                 1,
  //                 min(Strings.length(dss.uNames[i]), 11));
  //         end if;
  //       end for;
  //       s := s + "\n";
  //   //s := s + Strings.repeat(6) + "x" + String(i);
  //       for i in 1:nx loop
  //
  //   //Vertical
  //   //Two alternatives when printing state names
  //         if xNamesExist == false then
  //           s := s + space + "x" + String(i) + " ";
  //         else
  //
  //           s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
  //             dss.xNames[i]), 11)) + Strings.substring(
  //                 dss.xNames[i],
  //                 1,
  //                 min(Strings.length(dss.xNames[i]), 11)) + " ";
  //         end if;
  //
  //         for j in 1:nu loop
  //           if dss.B[i, j] >= 0 then
  //             s := s + " ";
  //           end if;
  //           s := s + String(dss.B[i, j], significantDigits=significantDigits) +
  //             Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
  //             dss.B[i, j]), significantDigits=significantDigits)));
  //         end for;
  //         s := s + "\n";
  //           end for;
  //   //--------------------------------------------------------------------------------------------------------------------------------------------------
  //       s := s + "\n" + name + ".C = \n";
  //    //Horizontal
  //   // Two alternatives when printing state names
  //       if xNamesExist == false then
  //         s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
  //           "x1 ";
  //       else
  //         s := s + Strings.repeat(11 + significantDigits - min(Strings.length(
  //           dss.xNames[1]), 11)) + Strings.repeat(min(Strings.length(dss.xNames[
  //           1]), 11)) + " " + Strings.substring(
  //               dss.xNames[1],
  //               1,
  //               min(Strings.length(dss.xNames[1]), 11));
  //       end if;
  //
  //       for i in 2:nx loop
  //   //Two alternatives when printing state names
  //         if xNamesExist == false then
  //           s := s + Strings.repeat(significantDigits + 11 - Strings.length("x"
  //              + String(i - 1))) + "x" + String(i) + " ";
  //         else
  //           s := s + " " + Strings.repeat(significantDigits + 11 - min(
  //             Strings.length(dss.xNames[i - 1]), 11)) + Strings.substring(
  //                 dss.xNames[i],
  //                 1,
  //                 min(Strings.length(dss.xNames[i]), 11));
  //         end if;
  //       end for;
  //       s := s + "\n";
  //   //s := s + Strings.repeat(6) + "x" + String(i);
  //
  //       for i in 1:ny loop
  //   //Vertical
  //   //Two alternatives when printing state names
  //         if yNamesExist == false then
  //           s := s + space + "y" + String(i) + " ";
  //         else
  //           s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
  //             dss.yNames[i]), 11)) + Strings.substring(
  //                 dss.yNames[i],
  //                 1,
  //                 min(Strings.length(dss.yNames[i]), 11)) + " ";
  //
  //         end if;
  //
  //         for j in 1:nx loop
  //           if dss.C[i, j] >= 0 then
  //             s := s + " ";
  //           end if;
  //           s := s + String(dss.C[i, j], significantDigits=significantDigits) +
  //             Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
  //             dss.C[i, j]), significantDigits=significantDigits)));
  //         end for;
  //         s := s + "\n";
  //       end for;
  //   //--------------------------------------------------------------------------------------------------------------------------------------------------
  //       s := s + "\n" + name + ".D = \n";
  //    //Horizontal
  //   // Two alternatives when printing state names
  //       if uNamesExist == false then
  //         s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
  //           "u1 ";
  //       else
  //         s := s + Strings.repeat(11 + significantDigits - min(Strings.length(
  //           dss.uNames[1]), 11)) + Strings.repeat(min(Strings.length(dss.uNames[
  //           1]), 11)) + " " + Strings.substring(
  //               dss.uNames[1],
  //               1,
  //               min(Strings.length(dss.uNames[1]), 11));
  //       end if;
  //
  //       for i in 2:nu loop
  //   //Two alternatives when printing state names
  //         if uNamesExist == false then
  //           s := s + Strings.repeat(significantDigits + 11 - Strings.length("u"
  //              + String(i - 1))) + "u" + String(i) + " ";
  //         else
  //           s := s + " " + Strings.repeat(significantDigits + 11 - min(
  //             Strings.length(dss.uNames[i - 1]), 11)) + Strings.substring(
  //                 dss.uNames[i],
  //                 1,
  //                 min(Strings.length(dss.uNames[i]), 11));
  //         end if;
  //       end for;
  //       s := s + "\n";
  //       for i in 1:ny loop
  //   //Vertical
  //   //Two alternatives when printing state names
  //         if yNamesExist == false then
  //           s := s + space + "y" + String(i) + " ";
  //         else
  //           s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
  //             dss.yNames[i]), 11)) + Strings.substring(
  //                 dss.yNames[i],
  //                 1,
  //                 min(Strings.length(dss.yNames[i]), 11)) + " ";
  //         end if;
  //
  //         for j in 1:nu loop
  //           if dss.D[i, j] >= 0 then
  //             s := s + " ";
  //           end if;
  //           s := s + String(dss.D[i, j], significantDigits=significantDigits) +
  //             Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
  //             dss.D[i, j]), significantDigits=significantDigits)));
  //         end for;
  //         s := s + "\n";
  //           end for;
  //
  // //##################
  //
  // //--------------------------------------------------------------------------------------------------------------------------------------------------
  //       s := s + "\n" + name + ".B2 = \n";
  //    //Horizontal
  //   // Two alternatives when printing state names
  //       if uNamesExist == false then
  //         s := s + Strings.repeat(stringMaxLength + significantDigits - 1) +
  //           "u1 ";
  //       else
  //         s := s + Strings.repeat(11 + significantDigits - min(Strings.length(
  //           dss.uNames[1]), 11)) + Strings.repeat(min(Strings.length(dss.uNames[
  //           1]), 11)) + " " + Strings.substring(
  //               dss.uNames[1],
  //               1,
  //               min(Strings.length(dss.uNames[1]), 11));
  //       end if;
  //
  //       for i in 2:nu loop
  //   //Two alternatives when printing state names
  //         if uNamesExist == false then
  //           s := s + Strings.repeat(significantDigits + 11 - Strings.length("u"
  //              + String(i - 1))) + "u" + String(i) + " ";
  //         else
  //           s := s + " " + Strings.repeat(significantDigits + 11 - min(
  //             Strings.length(dss.uNames[i - 1]), 11)) + Strings.substring(
  //                 dss.uNames[i],
  //                 1,
  //                 min(Strings.length(dss.uNames[i]), 11));
  //         end if;
  //       end for;
  //       s := s + "\n";
  //   //s := s + Strings.repeat(6) + "x" + String(i);
  //       for i in 1:nx loop
  //
  //   //Vertical
  //   //Two alternatives when printing state names
  //         if xNamesExist == false then
  //           s := s + space + "x" + String(i) + " ";
  //         else
  //
  //           s := s + Strings.repeat(significantDigits + 11 - min(Strings.length(
  //             dss.xNames[i]), 11)) + Strings.substring(
  //                 dss.xNames[i],
  //                 1,
  //                 min(Strings.length(dss.xNames[i]), 11)) + " ";
  //         end if;
  //
  //         for j in 1:nu loop
  //           if dss.B2[i, j] >= 0 then
  //             s := s + " ";
  //           end if;
  //           s := s + String(dss.B2[i, j], significantDigits=significantDigits) +
  //             Strings.repeat(significantDigits + 11 - Strings.length(String(abs(
  //             dss.B2[i, j]), significantDigits=significantDigits)));
  //         end for;
  //         s := s + "\n";
  //       end for;
  //
  // //#################
  //
  //     end if;
  //
  //     s := s +"\n\n Ts = " + String(dss.Ts) + "\n method = "+ Modelica_LinearSystems2.Internal.methodString(dss.method);
  //
  // end 'String';

    encapsulated function timeResponse
      "Compute time response of DiscreteStateSpace system"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.DiscreteStateSpace;

      input DiscreteStateSpace sd "Linear system in discrete state space form";
      input Real u[:,size(sd.B, 2)]=ones(3, size(sd.B, 2))
        "System input (dimension: (input samples) x (number of inputs))";
      input Real x0[size(sd.A, 1)]=zeros(size(sd.A, 1)) "Initial system state";
      output Real y[size(u, 1),size(sd.C, 1)]
        "System response (dimension: (input samples) x (number of outputs))";
      output Real x_continuous[size(u, 1),size(sd.A, 1)]
        "State trajectories (dimension: (input samples) x (number of states)";

  protected
      Integer samples=size(u, 1);
      Integer i;
      Real new_x[size(sd.A, 1)];
      Real x[size(sd.A, 1)]=x0;

    algorithm
      for i in 1:samples loop
        new_x := sd.A*x + sd.B*u[i, :];
        y[i, :] := sd.C*x + sd.D*u[i, :];
        x_continuous[i, :] := x + sd.B2*u[i, :];
        x := new_x;
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
    (y) = DiscreteStateSpace.<b>timeResponse</b>(dss, u)
            or
(y, xc) = DiscreteStateSpace.<b>timeResponse</b>(dss, u, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the time responses to input u of a discrete state space system.
Default of initial state <b>x0</b> is <b>x0</b>=<b>0</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
  import dss=Modelica_LinearSystems2.DiscreteStateSpace;
  import Modelica_LinearSystems2.StateSpace;
  StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
     B=[1],
     C=[2],
     D=[0]);
  Real Ts=0.1;
  dss=dss(ss,Ts);
  Real x0[1]={0};

  Real y[:,:]=dss.timeResponse(dss,ones(51,1));

//  y=[0.09524, 0.2766, 0.4408,..., 1.9844, 1.9859, 1.9872]
</pre></blockquote>
</html>",    revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
    end timeResponse;

    encapsulated function initialResponse
      "Compute initial response of DiscreteStateSpace system"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.DiscreteStateSpace;

      input DiscreteStateSpace dss "Linear system in discrete state space form";
      input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial system state";
      input Integer samples "Number of samples";
      output Real y[samples,size(dss.C, 1)]
        "System response (dimension: (input samples) x (number of outputs))";
      output Real x_continuous[samples,size(dss.A, 1)]
        "State trajectories (dimension: (input samples) x (number of states)";

  protected
      Integer i;
      Real new_x[size(dss.A, 1)];
      Real x[size(dss.A, 1)]=x0;

    algorithm
      for i in 1:samples loop
        new_x := dss.A*x;
        y[i, :] := dss.C*x;
        x_continuous[i, :] := x;
        x := new_x;
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
    (y) = DiscreteStateSpace.<b>initialResponse</b>(dss, x0, samples)
            or
(y, xc) = DiscreteStateSpace.<b>initialResponse</b>(dss, x0, samples)
</pre></blockquote>

<h4>Description</h4>
<p>
Function DiscreteStateSpace.initialResponse calculates the initial response to Default of initial state <b>x0</b> of a discrete state space system.
Input <b>sample</b> is the number of samples. Sample time is the sample time of the discrete state space system.
</p>

<h4>Example</h4>
<blockquote><pre>
  import dss=Modelica_LinearSystems2.DiscreteStateSpace;
  import Modelica_LinearSystems2.StateSpace;
  StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1],
    B=[1],
    C=[2],
    D=[0]);
  Real Ts=0.1;
  dss=dss(ss,Ts);
  Real x0[1]={1};

  Real y[:,:]=dss.initialResponse(dss,x0,50);

//  y=[2, 1.8095, 1.6372,..., 0.01812, 0.01639, 0.01483]
</pre></blockquote>
</html>",    revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
    end initialResponse;

    encapsulated package Analysis
      "Package of functions to analyse discrete state space system represented by a DiscreteStateSpace record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function eigenValues
        "Calculate the eigenvalues of a linear discrete state space system and write them in a complex vector"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Math.Complex;

        input DiscreteStateSpace dss "Discrete state space system";
        output Complex eigvalues[size(dss.A, 1)]=Complex.eigenValues(dss.A)
          "Eigenvalues of the system";
      algorithm

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
eigenvalues = DiscreteStateSpace.Analysis.<b>eigenValues</b>(dss)
</pre></blockquote>

<h4>Description</h4>
<p>
Calculate the eigenvalues of a discrete state space system, i.e. the eigenvalues of the system matrix <b>A</b> of a discrete state space system.
The output is a complex vector containing the eigenvalues.<br>
The eigenvalues <b>ev</b>_d of the discrete system are related to the eigenvalues of the corresponding continuous system <b>ev</b>_c by
</p>
<blockquote>
<b>ev</b>_d = exp(Ts*<b>ev</b>_c).
</blockquote>

<h4>Example</h4>
<blockquote><pre>
  StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1,1;-1,-1],
    B=[1;1],
    C=[1,1],
    D=[0],
    B2=[0;0],
    Ts=0.1);

  DiscreteStateSpace dss=DiscreteStateSpace(ss, Ts=0.1);

  Complex eigenvalues[2];

<b>algorithm</b>
  eigenvalues = Modelica_LinearSystems2.DiscreteStateSpace.Analysis.eigenValues(dss);
// eigenvalues = {0.900452 + 0.0904977*j, 0.900452 - 0.0904977*j}
//
</pre></blockquote>
</html>"));
      end eigenValues;

      encapsulated function timeResponse
        "Calculate the time response of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        input TimeResponse response=TimeResponse.Step;
        extends Modelica_LinearSystems2.Internal.timeResponseMask_discrete(
          redeclare Real y[:,size(dss.C, 1),if response == TimeResponse.Initial then 1 else
          size(dss.B, 2)],
          redeclare Real x_discrete[:,size(dss.A, 1),if response == TimeResponse.Initial then 1 else
          size(dss.B, 2)]);// Input/Output declarations of time response functions

        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

    protected
        Real dtVar;
        Real tSpanVar;
        Integer samples;
        Real u[:,size(dss.B, 2)];
        //  Real new_x[size(sc.A, 1),1];
        //  Real x[size(sc.A, 1),1]=zeros(size(sc.A, 1), 1);

        Real i1;
        Real i2;

      algorithm
        // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        samples := integer(tSpanVar/dss.Ts + dss.Ts/100 + 1);
        // Modelica.Utilities.Streams.print("\nsamples = "+String(samples));

        t := 0:dss.Ts:tSpanVar;
        u := zeros(samples, size(dss.B, 2));

        y := if response == TimeResponse.Initial then zeros(
          samples,
          size(dss.C, 1),
          1) else zeros(
          samples,
          size(dss.C, 1),
          size(dss.B, 2));
        x_discrete := if response == TimeResponse.Initial then zeros(
          samples,
          size(dss.A, 1),
          1) else zeros(
          samples,
          size(dss.A, 1),
          size(dss.B, 2));

        if response == TimeResponse.Initial then
          (y[:, :, 1],x_discrete[:, :, 1]) :=
            Modelica_LinearSystems2.DiscreteStateSpace.Internal.initialResponse1(
            dss,
            x0,
            samples);
        else

          for i1 in 1:size(dss.B, 2) loop
             // Loop over inputs

             // time response to plot
            if response == TimeResponse.Impulse then
              u[1, :] := zeros(size(dss.B, 2));
              u[1, i1] := 1;
            elseif response == TimeResponse.Step then
              u[:, :] := zeros(samples, size(dss.B, 2));
              u[:, i1] := ones(samples);
            elseif response == TimeResponse.Ramp then
              u[:, :] := zeros(samples, size(dss.B, 2));
              u[:, i1] := 0:dss.Ts:tSpanVar + dss.Ts/100;
            else
              assert(false, "Argument response (= " + String(response) + ") of \"Time response to plot\" is wrong.");
            end if;
            (y[:, :, i1],x_discrete[:, :, i1]) :=
              DiscreteStateSpace.Internal.timeResponse1(
              dss,
              u,
              x0);

          end for;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
      (y) = DiscreteStateSpace.Analysis.<b>timeResponse</b>(responseType, dss)
(y, t, x) = DiscreteStateSpace.Analysis.<b>timeResponse</b>(responseType, dss, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function timeResponse calculates the time responses of a discrete state space
system. The type of the time response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
Impulse \"Impulse response\",
Step \"Step response\",
Ramp \"Ramp response\",
Initial \"Initial condition response\"
</pre></blockquote>
<p>
Starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y and states x
are calculated for each time step t=k*dss.Ts.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A = [0.904837418036],
    B = [0.095162581964],
    C = [2],
    D = [0],
    B2 = [0],
    Ts = 0.1);

  Real tSpan = 0.4;

  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

  Real x0[1] = {0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(dss,tSpan,response,x0);
//  y[:,1,1] = {0, 0.1903, 0.3625, 0.5184, 0.6594}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0, 0.0952, 0.1813, 0.2592, 0.33}
</pre></blockquote>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse
        "Calculate the impulse time response of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_discrete;
    protected
        Real tSpanVar;
      algorithm

        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(
              dss=dss,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
              x0=zeros(size(dss.A, 1)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
      (y) = DiscreteStateSpace.Analysis.<b>impulseResponse</b>(dss)
(y, t, x) = DiscreteStateSpace.Analysis.<b>impulseResponse</b>(dss, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and states <b>x</b> are calculated for each time step t=k*dss.Ts. The function call
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.impulseResponse(dss, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.timeResponse(dss, tSpan, response=Types.TimeResponse.Impulse, x0=fill(0,size(ss.A,1))).
</pre></blockquote>
<p>
Note that an appropriate impulse response of a discrete system that is comparable
to the impulse response of the corresponding continuous system requires
the \"ImpulseExact\" conversion from continuous system to discrete system.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A=[0.904837418036 ],
    B=[0.095162581964],
    C=[2],
    D=[0],
    B2=[0],
    Ts=0.1,
    method = Modelica_LinearSystems2.Types.Method.StepExact);

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.impulseResponse(dss,tSpan);
//  y[:,1,1]  = {0, 0.190, 0.1722, 0.1558, 0.1410}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = = {0, 0.0952, 0.08611, 0.0779, 0.07050}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse\">DiscreteStateSpace.Analysis.timeResponse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.impulseResponse\">StateSpace.Analysis.impulseResponse</a>
</p>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse
        "Calculate the step time response of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_discrete;
    protected
        Real tSpanVar;

      algorithm
        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(
              dss=dss,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(size(dss.A, 1)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
      (y) = DiscreteStateSpace.Analysis.<b>stepResponse</b>(dss)
(y, t, x) = DiscreteStateSpace.Analysis.<b>stepResponse</b>(dss, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>stepResponse</b> calculates the step response of a discrete
state space system. Starting at
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and the states <b>x</b> are calculated for each
time step t=k*dss.Ts. The function call
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.stepResponse(dss, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.timeResponse(response=Types.TimeResponse.Step, dss, tSpan, x0=fill(0,size(ss.A,1))).
</pre></blockquote>
<p>
Note that an appropriate step response of a discrete system that is comparable
to the step response of the corresponding continuous system requires
the \"StepExact\" conversion from continuous system to discrete system.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A=[0.904837418036 ],
    B=[0.095162581964],
    C=[2],
    D=[0],
    B2=[0],
    Ts=0.1,
    method = Modelica_LinearSystems2Types.Method.StepExact);

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x) := Modelica_LinearSystems2.DiscreteStateSpace.Analysis.stepResponse(dss,tSpan);
//  y[:,1,1]={0, 0.19, 0.3625, 0.518, 0.659}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0.0952, 0.1813, 0.2592, 0.33}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse\">DiscreteStateSpace.Analysis.timeResponse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.stepResponse\">StateSpace.Analysis.stepResponse</a>
</p>
</html>"));
      end stepResponse;

      encapsulated function rampResponse
        "Calculate the ramp time response of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_discrete;
    protected
        Real tSpanVar;
      algorithm

        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(
              dss=dss,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
              x0=zeros(size(dss.A, 1)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
      (y) = DiscreteStateSpace.Analysis.<b>rampResponse</b>(dss)
(y, t, x) = DiscreteStateSpace.Analysis.<b>rampResponse</b>(dss, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rampResponse</b> calculates the time response
of a discrete state space system for ramp imput u = t. Starting at
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dss.Ts.
The function call
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.rampResponse(dss, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.timeResponse(response=Types.TimeResponse.Ramp, dss, tSpan, x0=fill(0,size(ss.A,1))).
</pre></blockquote>
<p>
Note that an appropriate ramp response of a discrete system that is comparable to the ramp response of the corresponding continuous system
requires the \"RampExact\" conversion from continuous system to discrete system.
</p>

<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
      A=[0.904837418036 ],
      B=[0.095162581964],
      C=[2],
      D=[0.0967483607192],
      B2=[0.0483741803596],
      Ts=0.1,
      method = Modelica_LinearSystems2.Types.Method.RampExact);

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x) := Modelica_LinearSystems2.DiscreteStateSpace.Analysis.rampResponse(dss,tSpan);
//  y[:,1,1] = {0, 0.00967, 0.03746, 0.08164, 0.14064}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0, 0.00484, 0.01873, 0.04082, 0.07032}
</pre></blockquote>


<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse\">DiscreteStateSpace.Analysis.timeResponse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.rampResponse\">StateSpace.Analysis.rampResponse</a>
</p>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the time response of a discrete state space system for given initial condition and zero inputs"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input Real x0[:]=fill(0, 0) "Initial state vector";

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_discrete(
          redeclare Real y[:,size(dss.C, 1),1],
          redeclare Real x_discrete[:,size(dss.A, 1),1]);
    protected
        Real tSpanVar;

      algorithm
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(
              dss=dss,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
              x0=x0);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
      (y) = DiscreteStateSpace.Analysis.<b>initialResponse</b>(x0, dss)
(y, t, x) = DiscreteStateSpace.Analysis.<b>initialResponse</b>(x0, dss, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>initialResponse</b> calculates the time response of
a discrete state space system for given initial condition and zero inputs.
Starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dss.Ts. The function call
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.initialResponse(x0,dss, dt, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteStateSpace.Analysis.timeResponse(dss, tSpan, response=Types.TimeResponse.Initial, x0=x0).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A=[0.904837418036 ],
    B=[0.095162581964],
    C=[2],
    D=[0],
    B2=[0],
    Ts=0.1,
    method = Modelica_LinearSystems2.Types.Method.StepExact);

  Real tSpan= 0.4;
  Real x0[1] = {1};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteStateSpace.Analysis.initialResponse(x0,dss,tSpan);
//  y[:,1,1]={2, 1.809, 1.637, 1.4812, 1.3402}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={1, 0.9048, 0.8186, 0.7406, 0.6701}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse\">DiscreteStateSpace.Analysis.timeResponse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.StateSpace.Analysis.initialResponse\">StateSpace.Analysis.initialResponse</a>
</p>
</html>"));
      end initialResponse;

    end Analysis;

    encapsulated package Design
      "Package of functions to design discrete state space controllers and observers"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function assignPolesMI
        "Pole assignment design algorithm for multi input systems"

        import Modelica;
      //  import Modelica.Utilities.Streams.print;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Matrices;

        input DiscreteStateSpace dss "state space system";

        input Complex gamma[:]=fill(Complex(0), 0) "Designed Poles";
      //  input Integer np=size(gamma, 1) "number of given eigenvalues to assign";
        input Real alpha=exp(-1e10)
            "maximum admissible value for the moduli of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm";
        input Real tolerance=Modelica.Math.Matrices.norm(dss.A, 1)*1e-12
            "The tolerance to be used in determining the controllability of (A,B)";
        input Boolean calculateEigenvectors=false
            "Calculate the eigenvectors X of the closed loop system when true";

        output Real K[size(dss.B, 2),size(dss.A, 1)]
            "State feedback matrix assigning the desired poles";
        output Real S[:,:] "Closed loop System matrix";
        output Complex po[size(dss.A, 1)] "poles of the closed loop system";
        output Integer nfp
            "number of eigenvalues that are not modified with respect to alpha";
        output Integer nap "number of assigned eigenvalues";
        output Integer nup "number of uncontrollable eigenvalues";
        output Complex X[size(dss.A, 1),size(dss.A, 1)]
            "eigenvectors of the closed loop system";

    protected
        Real A_rsf[size(dss.A, 1),size(dss.A, 2)];
        Real B_rsf[size(dss.B, 1),size(dss.B, 2)];
        Real Q[size(dss.A, 1),size(dss.A, 1)];
        Real Ks1[:,:];
        Real Ks2[:,:];
        Real Q2[:,:];
        Real A_rsf_1[:,:];
        Real Q1[:,:];
        Boolean select[:];
        Boolean rselectA[:];
        Real Z[:,:] "orthogonal transformation matrix";
        Real ZT[:,:] "orthogonal transformation matrix";
        Complex pf[:];
        Complex gammaReordered[:]=gamma;
        Integer info;
        Real wr[size(gamma, 1)];
        Real wi[size(gamma, 1)];
        Boolean imag=false;
        Integer i;
        Integer ii;
        Integer iii;
        Integer counter;
        Integer counter2;
        Integer n=size(dss.A, 1);
        Integer nccA "number of conjugated complex pole pairs of openloop system";
        Integer nccg "number of conjugated complex pole pairs of gamma";
        Integer rpg "number of real poles in gamma";
        Integer rpA "number of real poles of open loop system";
        Integer ncc "Min(nccA, nccg)";
        Integer rp "Min(rpg, rpA)";
        Integer ng=size(gamma,1);
        Integer nr "Differenz between rpA and rpg; Sign(rpA-rpg)*(rpA-rpg)";

        Real alphaReal[size(dss.A, 1)]
            "Real part of eigenvalue=alphaReal+i*alphaImag";
        Real alphaImag[size(dss.A, 1)]
            "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";

        Complex SS[:,:];
        Complex Xj[:,:];
        Complex h;

        Real dist;
        Real evImag;

      algorithm
        assert(size(gamma, 1) <= size(dss.A, 1),
          "At most n (order of dss) eigenvalues can be assigned");

       /* Extraction of Poles (Variable conversation) and pole sequence check */
        for i in 1:size(gamma, 1) loop
          wr[i] := gamma[i].re;
          wi[i] := gamma[i].im;
          if imag then
            assert(wi[i - 1] == -wi[i] and wr[i - 1] == wr[i],
              "Poles are in wrong sequence");
            imag := false;
          elseif wi[i] <> 0 then
            imag := true;
          end if;
        end for;

        // put matrix dss.A to real Schur form A <- QAQ' and compute B <- QB
        (A_rsf,Z,alphaReal,alphaImag) := Modelica.Math.Matrices.realSchur(dss.A);
        ZT := transpose(Z);

        // reorder real Schur form according to alpha
        (A_rsf,Z,alphaReal,alphaImag) := Matrices.Internal.reorderRSFd(
            A_rsf,
            identity(size(A_rsf, 1)),
            alphaReal,
            alphaImag,
            alpha);
        ZT := transpose(Z)*ZT;
        B_rsf := ZT*dss.B;

        // determine number of poles not to be assigned according to alpha
        nfp := 0;
        for i in 1:n loop
          if alphaReal[i]^2+alphaImag[i]^2 < alpha^2 then
            nfp := nfp + 1;
          end if;
        end for;
        nap := n - nfp;

        assert(size(gamma, 1) >= nap, String(nap) +
          " poles should be modified, therefore gamma should contain at at least "
           + String(nap) + " assigned eigenvalues");

        // second reorder (reorderRSF3) according to conjugated complex pairs in A and p
        // count numbre of conjugated complex pole pairs = max(number_ccpp(eig(A), number_ccpp(gamma))
        nccA := 0;
        //mark the real poles of original system
        rselectA := fill(true, nap);
        ii := 1;
        for i in nfp + 1:n loop
          if abs(alphaImag[i]) > 0 then
            nccA := nccA + 1;
          else
            rselectA[ii] := false;

          end if;
          ii := ii + 1;
          end for;
          rpA := n-nccA;
          nccA := div(nccA, 2);

        // reorder gamma and A_rsf
        (gammaReordered,rpg) := Modelica_LinearSystems2.Internal.reorderZeros(gamma);
        gammaReordered := Complex.Vectors.reverse(gammaReordered);
        nccg := div(size(gammaReordered, 1) - rpg, 2);
        ncc := min(nccA, nccg);
        rp := min(rpA, rpg);
        if nccA > 0 then
          (A_rsf[nfp + 1:n, nfp + 1:n],Q2) := Matrices.LAPACK.dtrsen(
              "E",
              "V",
              rselectA,
              A_rsf[nfp + 1:n, nfp + 1:n],
              identity(n - nfp));//The Schur vector matrix is identity, since A_rsf already has Schur form

          A_rsf[1:nfp, nfp + 1:n] := A_rsf[1:nfp, nfp + 1:n]*Q2;
          B_rsf[nfp + 1:n, :] := transpose(Q2)*B_rsf[nfp + 1:n, :];
          ZT[nfp + 1:n, :] := transpose(Q2)*ZT[nfp + 1:n, :];
        end if;

        // main algorithm
        K := zeros(size(dss.B, 2), size(dss.A, 1));
        counter := nfp + 1;
        counter2 := 1;

        for i in 1:rp loop // 1x1 blocks; real system pole and real assigned poles; take the next eigenvalue in the
                             // diagonal of the Schur form and search the nearest pole in the set of the real poles to assign
            dist := Modelica.Constants.inf;
            for ii in i:rpg loop // looking for nearest pole and reorder gamma
              if abs(A_rsf[n, n] - gammaReordered[ng - ii + 1].re) < dist then
                iii := ng - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - ii + 1].re);
              end if;
            end for;
            h := gammaReordered[ng - i + 1];
            gammaReordered[ng - i + 1] := gammaReordered[iii];
            gammaReordered[iii] := h;

            Ks1 := DiscreteStateSpace.Internal.assignOneOrTwoPoles(
              matrix(A_rsf[n, n]),
              transpose(matrix(B_rsf[n, :])),
              {gammaReordered[ng - i + 1]},
              tolerance);
            K := K + [zeros(size(Ks1, 1), size(K, 2) - 1),Ks1]*ZT;
            A_rsf := A_rsf - B_rsf*[zeros(size(Ks1, 1), size(K, 2) - 1),Ks1];
            select := fill(false, n - counter + 1);
            select[n - counter + 1] := true;

            (A_rsf[counter:n, counter:n],Q1) := Matrices.LAPACK.dtrsen(
              "E",
              "V",
              select,
              A_rsf[counter:n, counter:n],
              identity(n - counter + 1));//The Schur vector matrix is identity, since A_rsf already has Schur form

            A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q1;
            B_rsf[counter:n, :] := transpose(Q1)*B_rsf[counter:n, :];
            ZT[counter:n, :] := transpose(Q1)*ZT[counter:n, :];
            counter := counter + 1;
            counter2 := counter2 + 1;
          end for;

          if counter2<rpg and counter2>rpA then //System has less real eigenvalues than real assigned poles
          for i in 1:div(rpg - rpA, 2) loop // 2x2 blocks; complex pair of system poles and 2 real assigned poles; take the next complex pair
                                            // (Schur bump) in the diagonal of the Schur form and search the two nearest poles in the set of the
                                            // remaining real assigned poles
            dist := Modelica.Constants.inf;
            evImag := sqrt(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);//positive imaginary part of the complex system pole pair
            for ii in 2*(i - 1) + 1:2:rpg - rpA loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag;
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*(i - 1)];
            gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
            gammaReordered[iii] := h;
            dist := Modelica.Constants.inf;
            for ii in 2*(i - 1) + 1:2:rpg - rpA loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag;
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*i + 1];
            gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii];
            gammaReordered[iii] := h;

            Ks2 := DiscreteStateSpace.Internal.assignOneOrTwoPoles(
              A_rsf[n - 1:n, n - 1:n],
              matrix(B_rsf[n - 1:n, :]),
              gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
              tolerance);

            K := K + [zeros(size(Ks2, 1), size(K, 2) - 2),Ks2]*ZT;
            A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2),Ks2];
            select := fill(false, n - counter + 1);
            select[n - counter:n - counter + 1] := {true,true};

            (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
              "E",
              "V",
              select,
              A_rsf[counter:n, counter:n],
              identity(n - counter + 1)); //The Schur vector matrix is identity, since A_rsf already has Schur form

            A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
            B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
            ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
            counter := counter + 2;
            counter2 := counter2 + 2;
          end for;
        end if;

        if counter2>rpg and counter2<rpA then//System has more real eigenvalues than real assigned poles
          for i in 1:div(rpA - rpg, 2) loop// 2x2 blocks; 2 real system poles and a pair of complex assigned poles; take the next two real
                                            // eigenvalues in the diagonal of the Schur form and search the complex pole pair of the assigned poles
                                            // which is nearest to the two real poles
            dist := Modelica.Constants.inf;
            for ii in 2*(i - 1)+1:2:rpA - rpg loop
              if abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + abs(gammaReordered[ng - rp - ii + 1].im) + abs(A_rsf[n - 1, n - 1] -
                gammaReordered[ng - rp - ii + 1].re) + abs(gammaReordered[ng - rp - ii + 1].im) < dist then
                iii := ng - rp - ii + 1;
                dist := abs(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re)
                   + abs(gammaReordered[ng - rp - ii + 1].im) + abs(A_rsf[
                  n - 1, n - 1] - gammaReordered[ng - rp - ii + 1].re) +
                  abs(gammaReordered[ng - rp - ii + 1].im);
              end if;
            end for;
            h := gammaReordered[ng - rp - 2*(i - 1)];
            gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
            gammaReordered[iii] := h;
            h := gammaReordered[ng - rp - 2*i + 1];
            gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii - 1];
            gammaReordered[iii - 1] := h;

            Ks2 := DiscreteStateSpace.Internal.assignOneOrTwoPoles(
              A_rsf[n - 1:n, n - 1:n],
              matrix(B_rsf[n - 1:n, :]),
              gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
              tolerance);

            K := K + [zeros(size(Ks2, 1), size(K, 2) - 2),Ks2]*ZT;
            A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2),Ks2];
            select := fill(false, n - counter + 1);
            select[n - counter:n - counter + 1] := {true,true};

            (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
              "E",
              "V",
              select,
              A_rsf[counter:n, counter:n],
              identity(n - counter + 1)); //The Schur vector matrix is identity, since A_rsf already has Schur form

            A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
            B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
            ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
            counter := counter + 2;
            counter2 := counter2 + 2;
      //      Modelica.Utilities.Streams.print("counter2Case3 = " + String(counter2));
          end for;
        end if;

        for i in 1:ncc loop // 2x2 blocks; 2 complex system poles and two complex assigned poles; take the next complex
                            // system pole pair (next Schur bump) in the diagonal of the Schur form and search the complex
                            //  assigned pole pair which is nearest
          dist := Modelica.Constants.inf;
          evImag := sqrt(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);//positive imaginary part of the complex system pole pair
          for ii in 2*(i - 1) + 1:2:2*ncc loop
            if abs(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + abs(evImag -
                abs(gammaReordered[2*ncc - ii + 1].im)) < dist then
              iii := 2*ncc - ii + 1;
              dist := abs(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + abs(
                evImag - abs(gammaReordered[2*ncc - ii + 1].im));
            end if;
          end for;
          h := gammaReordered[2*ncc - 2*(i - 1)];
          gammaReordered[2*ncc - 2*(i - 1)] := gammaReordered[iii];
          gammaReordered[iii] := h;
          h := gammaReordered[2*ncc - 2*i + 1];
          gammaReordered[2*ncc - 2*i + 1] := gammaReordered[iii - 1];
          gammaReordered[iii - 1] := h;

          Ks2 := DiscreteStateSpace.Internal.assignOneOrTwoPoles(
            A_rsf[n - 1:n, n - 1:n],
            matrix(B_rsf[n - 1:n, :]),
            gammaReordered[2*ncc - 2*i + 1:2*ncc - 2*(i - 1)],
            tolerance);
          K := K + [zeros(size(Ks2, 1), size(K, 2) - 2),Ks2]*ZT;
          A_rsf := A_rsf - B_rsf*[zeros(size(Ks2, 1), size(K, 2) - 2),Ks2];
          select := fill(false, n - counter + 1);
          select[n - counter:n - counter + 1] := {true,true};

          (A_rsf[counter:n, counter:n],Q2) := Matrices.LAPACK.dtrsen(
            "E",
            "V",
            select,
            A_rsf[counter:n, counter:n],
            identity(n - counter + 1));   //The Schur vector matrix is identity, since A_rsf already has Schur form

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
          B_rsf[counter:n, :] := transpose(Q2)*B_rsf[counter:n, :];
          ZT[counter:n, :] := transpose(Q2)*ZT[counter:n, :];
          counter := counter + 2;
          counter2 := counter2 + 2;
        end for;

        S := dss.A - dss.B*K;
        po := Complex.eigenValues(S);

        if calculateEigenvectors then
      //     X := fill(Complex(0), n, n);
      //     for i in 1:n loop
      //       SS := Complex(1)*S;
      //       for ii in 1:n loop
      //         SS[ii, ii] := SS[ii, ii] - po[i];
      //       end for;
      //       Xj := Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace(
      //                                  SS);
      //       for ii in 1:n loop
      //         X[ii, i] := Xj[ii, 1];
      //       end for;
      //     end for;
      //      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,"X1");
          X := Complex.eigenVectors(S);
      //      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,"X2");

        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(K, S, po, nfp, nap, nup) = DiscreteStateSpace.Design.<b>assignPolesMI</b>(dss, gamma, np, tol, calculateEigenvectors)
</pre></blockquote>

<h4>Description</h4>
<p>
The purpose of this function is to determine the state feedback matrix <b>K</b> for a
given time invariant multi input state system (<b>A</b>,<b>B</b>) such that the
closed-loop state matrix <b>A</b>-<b>B</b>*<b>K</b> has specified eigenvalues. The
feedback matrix <b>K</b> is calculated by factorization following [1]. The algorithm
modifies the eigenvalues sequentially and also allows partial eigenvalue assignment.
</p>
<p>
At the beginning of the algorithm, the feedback matrix <b>K</b> is set
to zero (<b>K</b> = <b>0</b>) and the matrix <b>A</b> is reduced to an ordered
real Schur form by separating its spectrum in two parts
</p>
<blockquote><pre>
              | <b>F</b>1  <b>F</b>3|
 <b>F</b> = <b>Q</b>*<b>A</b>*<b>Q</b>' = |       |
              | <b>0</b>   <b>F</b>2|
</pre>
</blockquote>
<p>
in such a way, that <b>F</b>1 contains the eigenvalues that will be retained
and <b>F</b>3 contains the eigenvalues going to be modified. On the suggestion
of [1] the eigenvalues <i>evr</i> to be retained are chosen as
</p>
<blockquote><pre>
evr = {s in C: Re(s) &lt; -alpha, alpha &gt;=0}
</pre> </blockquote>
<p>
but other specification are conceivable of course.
</p>
<p>
Let
</p>
<blockquote><pre>
<b>G</b> = [<b>G</b>1;<b>G</b>2] = <b>Q</b>*<b>B</b>
</pre> </blockquote>
<p>
with an appropriate partition according to <b>F</b>2. (<b>F</b>2, <b>G</b>2) has to be
controllable.
</p>
<p>
If the feedback matrix <b>K</b> is taken in a form
</p>
<blockquote><pre>
<b>K</b> = [0, <b>K</b>2]
</pre></blockquote>
<p>
the special structure of <b>F</b> and <b>K</b> results in a closed loop state
matrix
</p>
<blockquote><pre>
          |<b>F</b>1 <b>F</b>3 - <b>G</b>1*<b>K</b>2|
<b>F</b> - <b>G</b>*<b>K</b> = |             |
          |0  <b>F</b>2 - <b>G</b>2*<b>K</b>2|
</pre></blockquote>
<p>
with only the eigenvalues of <b>F</b>2 are modified. This approach to modify
separated eigenvalues is used to sequentially shift one real eigenvalue ore two
complex conjugated eigenvalues stepwise until all assigned eigenvalues are placed.
Therefore, at each step i always the (two) lower right eigenvalue(s) are modified by an
appropriate feedback matrix <b>K</b>i. The matrix <b>F</b> - <b>G</b>*<b>K</b>i remains
in real Schur form. The assigned eigenvalue(s) is (are) then moved to another diagonal
position of the real Schur form using reordering techniques <b>F</b>
&lt; -- <b>Q</b>i*<b>F</b>*<b>Q</b>i'  and a new block is transferred to the
lower right diagonal position. The transformations are accumulated in <b>Q</b>i
and are also applicated to the matrices
</p>
<blockquote><pre>
<b>G</b> &lt; - <b>Q</b>i*<b>G</b> <b>Q</b> &lt; - <b>Q</b>i*<b>Q</b>
</pre></blockquote>
<p>
The eigenvalue(s) to be assigned at  each step is (are) chosen such that
the norm of each <b>K</b>i is minimized [1].
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A=[-1, 1, 1;0, 1, 1;0, 0, 1],
    B=[0; 0; 1],
    C=[0, 1, 0],
    D=[0]);

  Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.DiscreteStateSpace.Analysis.observabilityMatrix(dss);
// Q = [0, 1, 0; 0, 1, 1; 1, 1, 2]
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga A. (1981):</dt>
<dd> <b>A Schur method for pole assignment</b>.
     IEEE Trans. Autom. Control, Vol. AC-26, pp. 517-519.<br>&nbsp;</dd>
</dl>
</html>",  revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end assignPolesMI;

    end Design;

    encapsulated package Plot
      "Package of functions to plot discrete state space system responses"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function bodeSISO
        "Plot bode plot of the corresponding discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteStateSpace dss "discrete state space system";
        input Integer iu=1 "index of input";
        input Integer iy=1 "index of output";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input Modelica.Units.SI.Frequency f_min=0.1
          "Minimum frequency value, if autoRange = false";
        input Modelica.Units.SI.Frequency f_max=10
          "Maximum frequency value, if autoRange = false";

        input Boolean magnitude=true "= true, to plot the magnitude of dtf"
          annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot the pase of tf" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot());

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)"
          annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))"
          annotation(choices(checkBox=true),Dialog(enable=magnitude));
    protected
        Modelica_LinearSystems2.DiscreteZerosAndPoles dzp
              "Zeros and poles Transfer functions to be plotted";
        DiscreteStateSpace dss_siso(
          redeclare Real A[size(dss.A, 1),size(dss.A, 2)],
          redeclare Real B[size(dss.B, 1),1],
          redeclare Real C[1,size(dss.C, 2)],
          redeclare Real D[1,1],
          redeclare Real B2[size(dss.B2, 1),1]);

      algorithm
        assert(iu <= size(dss.B, 2) and iu > 0, "index for input is " + String(iu) + " which is not in [1, "
           + String(size(dss.B, 2)) + "].");
        assert(iy <= size(dss.C, 1) and iy > 0, "index for output is " + String(iy) + " which is not in [1, "
           + String(size(dss.C, 1)) + "].");
        dss_siso := DiscreteStateSpace(
          A=dss.A,
          B=matrix(dss.B[:, iu]),
          C=transpose(matrix(dss.C[iy, :])),
          D=matrix(dss.D[iy, iu]),
          B2=matrix(dss.B2[:, iu]),
          Ts=dss.Ts,
          method=dss.method);
        dzp := DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(dss_siso);

        DiscreteZerosAndPoles.Plot.bode(
          dzp,
          nPoints,
          autoRange,
          f_min,
          f_max,
          Hz=Hz,
          magnitude=magnitude,
          dB=dB,
          phase=phase,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>bodeSISO</b>(dss)
   or
DiscreteStateSpace.Plot.<b>bodeSISO</b>(
  dss,
  iu,
  iy,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>() )
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots a bode-diagram of the transfer function corresponding
to the behavior of the state space system from iu'th element of the input
vector <b>u</b> to the iy'th element of the output vector <b>y</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A = [0.9048, 0.0,    0.0;
           0.0,   0.8187, 0.0;
           0.0,   0.0,    0.7408]
    B = [0.0;
          0.0906;
        -0.0864],
    C = [0.0, 1.0, 1.0],
    D = [1.0],
    B2 = [0.0;
          0.0;
          0.0],
    Ts = 0.1);

  Integer iu=1;
  Integer iy=1;

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteStateSpace.Plot.plotBodeSISO(dss, iu, iy)
//  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagDis.png\">
</p>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhaseDis.png\">
</p>
</html>"));
      end bodeSISO;

      encapsulated function timeResponse
        "Plot the time response of a discrete state space system. The response type is selectable"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteStateSpace dss;
        input Real tSpan=0 "Simulation time span [s]";

        input TimeResponse response=TimeResponse.Step;

        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Time response"));

    protected
        Plot.Records.Curve curve;
        Integer i1;
        Integer i2;
        Plot.Records.Diagram diagram2[size(dss.C, 1)];

        Real y[:,size(dss.C, 1),if response == TimeResponse.Initial then 1 else size(dss.B,2)]
              "Output response: (number of samples) x (number of outputs) x (number of inputs)";
        Real t[:] "Time vector: (number of samples)";
        Real x[:,size(dss.A, 1),if response == TimeResponse.Initial then 1 else size(dss.B,2)]
              "State trajectories: (number of samples) x (number of states) x (number of inputs)";

        Real yy[:,:,:] "Output response";
        Real tt[:] "Time vector: (number of samples)";

        String yNames[size(dss.C, 1)];
        String uNames[size(dss.B, 2)];
        Integer loops=if response == TimeResponse.Initial then 1 else size(dss.B,2);

      algorithm
        (y,t,x) := Modelica_LinearSystems2.DiscreteStateSpace.Analysis.timeResponse(
          dss=dss,
          tSpan=tSpan,
          response=response,
          x0=x0);

        tt := fill(0,2*size(t,1)-1);
        yy := fill(0,2*size(t,1)-1,size(y,2),size(y,3));

        for i in 1:size(t,1)-1 loop
          tt[2*i-1] := t[i];
          tt[2*i] := t[i+1];
          yy[2*i-1,:,:] := y[i,:,:];
          yy[2*i,:,:] := y[i,:,:];
        end for;
        tt[size(tt,1)] := t[size(t,1)];
        yy[size(tt,1),:,:] := y[size(t,1),:,:];

      // generate headings
        for i1 in 1:size(dss.B, 2) loop
          uNames[i1] := "u" + String(i1);
        end for;
        for i1 in 1:size(dss.C, 1) loop
          yNames[i1] := "y" + String(i1);
        end for;

        // for i1 in 1:size(dss.B, 2) loop
        //   uNames[i1] := if dss.uNames[i1] == "" then "u" + String(i1) else dss.uNames[
        //     i1];
        // end for;
        // for i1 in 1:size(dss.C, 1) loop
        //   yNames[i1] := if dss.yNames[i1] == "" then "y" + String(i1) else dss.yNames[
        //     i1];
        // end for;

        for i2 in 1:loops loop
          for i1 in 1:size(dss.C, 1) loop
            curve := Plot.Records.Curve(
              x=tt,
              y=yy[:, i1, i2],
              autoLine=true);

            diagram2[i1] := defaultDiagram;
            diagram2[i1].curve := {curve};
            diagram2[i1].heading := if response == TimeResponse.Initial then defaultDiagram.heading +" "+ yNames[i1] else defaultDiagram.heading + "  " + uNames[i2] + " -> " + yNames[i1];
            diagram2[i1].yLabel := yNames[i1];

          end for;

          if subPlots then
            Plot.diagramVector(diagram2, device);
          else
            for i1 in 1:size(dss.C, 1) loop
              Plot.diagram(diagram2[i1], device);
            end for;
          end if;
        end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>timeResponse</b>(dss);
   or
DiscreteStateSpace.Plot.<b>timeResponse</b>(
  dss,
  tSpan,
  response,
  x0,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the time response of a discrete state space system. The character of the time response if defined by the input <tt>response</tt>, i.e. Impulse, Step, Ramp, or Initial.
</p>

<h4>Example</h4>
<blockquote><pre>
  import Modelica_LinearSystems2.DiscreteStateSpace;

  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Real Ts = 0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.StepExact;
  DiscreteStateSpace dss=DiscreteStateSpace(ss,Ts,method);
  Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

<b>algorithm</b>
  DiscreteStateSpace.Plot.timeResponse(dss, response=response);
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.step\">step</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end timeResponse;

      encapsulated function impulse
        "Impulse response plot of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteStateSpace dss;
        input Real tSpan=0 "Simulation time span [s]";
        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Impulse response"));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse
          "Type of time response";
        Real tSpanVar;

      algorithm
          // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse(
          dss=dss,
          tSpan=tSpanVar,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>impulse</b>(dss);
   or
DiscreteStateSpace.Plot.<b>impulse</b>(
  dss,
  tSpan,
  x0,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the impulse responses of a state space system for each system corresponding to the transition matrix. It is based on <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Real Ts = 0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.ImpulseExact;
  DiscreteStateSpace dss=DiscreteStateSpace(dss,Ts,method);

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteStateSpace.Plot.impulse(dss)
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.step\">step</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end impulse;

      encapsulated function step
        "Step response plot of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteStateSpace dss;
        input Real tSpan=0 "Simulation time span [s]";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
               heading="Step response"));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step
          "Type of time response";

        Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

        Real tSpanVar;

      algorithm
        // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse(
          dss=dss,
          tSpan=tSpanVar,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>step</b>(dss);
   or
DiscreteStateSpace.Plot.<b>step</b>(
  dss,
  tSpan,
  x0,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the discrete step responses of a state space system for each system corresponding to the transition matrix. It is based on <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Real Ts = 0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.StepExact;
  DiscreteStateSpace dss=DiscreteStateSpace(dss,Ts,method);

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteStateSpace.Plot.step(dss, tSpan=3)
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end step;

      encapsulated function ramp
        "Ramp response plot of a discrete state space system"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteStateSpace dss;
        input Real tSpan=0 "Simulation time span [s]";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Ramp response"));
    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";

        Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

        Real tSpanVar;

      algorithm
        // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        DiscreteStateSpace.Plot.timeResponse(
          dss=dss,
          tSpan=tSpanVar,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>ramp</b>(ss);
   or
DiscreteStateSpace.Plot.<b>ramp</b>(
  dss,
  tSpan,
  x0,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the ramp responses of a discrete state space system for each system corresponding to the transition matrix. It is based on <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse\">timeResponse</a>. See also
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.step\">step</a> and
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.initialResponse\">initialResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[1.0,1.0,1.0],
    D=[0.0])

  Real Ts = 0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.RampExact;
  DiscreteStateSpace dss=DiscreteStateSpace(dss,Ts,method);

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteStateSpace.Plot.ramp(dss)
</pre></blockquote>
</html>"));
      end ramp;

      encapsulated function initialResponse
        "Initial condition response plot of a discrete state space system"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteStateSpace dss;
        input Real tSpan=0 "Simulation time span [s]";
        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial state vector";

        input Boolean subPlots=true
          "True, if all subsystem time responses are plotted in one window with subplots"
          annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO(defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
              heading="Initial response"));
    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";

        Real tSpanVar;

      algorithm
      // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;
        Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse(
          dss=dss,
          tSpan=tSpanVar,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteStateSpace.Plot.<b>initialResponse</b>(ss);
   or
DiscreteStateSpace.Plot.<b>initialResponse</b>(
  dss,
  tSpan,
  x0,
  defaultDiagram=<a href=\"Modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the initial responses of a discrete state space system for the initial state vector x0 for each system corresponding to the transition matrix. It is based on <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A=[-1.0,0.0,0.0; 0.0,-2.0,3.0; 0.0,-2.0,-3.0],
    B=[1.0; 1.0; 0.0],
    C=[0.0,1.0,1.0],
    D=[0.0])

  Real x0={1,0.5,0.5};

  Real Ts = 0.1;
  Modelica_LinearSystems2.Types.Method method=Modelica_LinearSystems2.Types.Method.StepExact;
  DiscreteStateSpace dss=DiscreteStateSpace(dss,Ts,method);

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteStateSpace.Plot.initial(dss, x0=x0)
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.step\">step</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Plot.ramp\">ramp</a>
</p>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of DiscreteStateSpace data record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function toDiscreteZerosAndPoles
        "Generate a discrete zeros-and-poles representation from a discrete SISO state space representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss "StateSpace object";
        output Modelica_LinearSystems2.DiscreteZerosAndPoles dzp;

    protected
        StateSpace ss=StateSpace(A=dss.A, B=dss.B, C=dss.C, D=dss.D);
        StateSpace ssm=StateSpace.Transformation.toIrreducibleForm(ss);
        Complex poles[:];
        Complex zeros[:];
        Complex cpoles[:];
        Complex czeros[:];
        Real gain;
        Complex frequency;
        Complex cfrequency;
        Complex Gq;
        Real As[:,:];
        Real pk;
        Integer i;
        Integer k;
        Boolean h;
        Real v;

      algorithm
        if Modelica.Math.Vectors.length(ssm.B[:, 1]) > 0 and
            Modelica.Math.Vectors.length(ssm.C[1, :]) > 0 then

          poles := Complex.Internal.eigenValues_dhseqr(ssm.A);//ssm.A is of upper Hessenberg form
          zeros := StateSpace.Internal.invariantZeros2(ssm);
          cpoles := fill(Complex(0),size(poles,1));
          czeros := fill(Complex(0),size(zeros,1));

          if size(ss.C, 1) <> 1 or size(ss.B, 2) <> 1 then
            assert(size(ss.B, 2) == 1, " function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is "
               + String(size(ss.B, 2)) + " instead of 1");
            assert(size(ss.C, 1) == 1, " function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is "
               + String(size(ss.C, 1)) + " instead of 1");
          end if;
          dzp := DiscreteZerosAndPoles(
              z=zeros,
              p=poles,
              k=1,
              Ts=dss.Ts, method=dss.method);
      // set frequency to a complex value which is whether pole nor zero
          for i in 1:size(poles,1) loop
            cpoles[i] := if Complex.'abs'(poles[i])>0 then Complex.log(poles[i])/dss.Ts else Complex(-100);
          end for;
          for i in 1:size(zeros,1) loop
            czeros[i] := if Complex.'abs'(zeros[i])>0 then Complex.log(zeros[i])/dss.Ts else Complex(-100);
          end for;

           v := sum(cat(1, czeros[:].re,  cpoles[:].re))/max(size(czeros,1)+size(cpoles,1),1) + 13/19;
      //     v := sum(cat(1, zeros[:].re,  poles[:].re))/max(size(zeros,1)+size(poles,1),1);
          frequency := Complex(v)*17/19;
          cfrequency := Complex.exp(frequency*dss.Ts);
      //    cfrequency := frequency;

          Gq := DiscreteZerosAndPoles.Analysis.evaluate(dzp, cfrequency);

          As := -ssm.A;
          for i in 1:size(As, 1) loop
            As[i, i] := As[i, i] + cfrequency.re;
          end for;

          pk := StateSpace.Internal.partialGain(As, ssm.B[:, 1]);
          gain := (ssm.C[1, size(As, 1)]*pk + ss.D[1, 1])/Gq.re;

          dzp := DiscreteZerosAndPoles(
              z=zeros,
              p=poles,
              k=gain,Ts=dss.Ts, method=dss.method);

        else
          dzp := DiscreteZerosAndPoles(
              z=fill(Complex(0), 0),
              p=fill(Complex(0), 0),
              k=scalar(dss.D),Ts=dss.Ts, method=dss.method);

        end if;
      //  dzp.uName := dss.uNames[1];
      //  dzp.yName := dss.yNames[1];

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = DiscreteStateSpace.Conversion.<b>toDiscreteZerosAndPoles</b>(dss)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a DiscreteZerosAndPoles record
</p>
<blockquote><pre>
           product(q + n1[i]) * product(q^2 + n2[i,1]*q + n2[i,2])
dzp = k * ---------------------------------------------------------
           product(q + d1[i]) * product(q^2 + d2[i,1]*q + d2[i,2])
</pre></blockquote>
<p>
of a system from discrete state space representation using the transformation algorithm described in [1].
</p>
<p>
The uncontrollable and unobservable parts are isolated and the eigenvalues and invariant zeros of the controllable and observable sub system are calculated.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
    A = [0.9048, 0.0,    0.0;
         0.0,    0.8187, 0.0;
         0.0,    0.0,    0.7408],
    B = [0.09516;
         0.09063;
         0.0],
    C = [1.0,1.0,1.0],
    D = [0.0],
    Ts = 0.1);

<b>algorithm</b>
  dzp:=Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(dss);

//                         q - 0.860735
//   dzp = 0.1858 -------------------------------
//                 (q - 0.904837)*(q - 0.818731)
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toDiscreteZerosAndPoles;

      encapsulated function toDiscreteZerosAndPolesMIMO
        "Generate a zeros-and-poles representation from a MIMO state space representation"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss "DiscreteStateSpace object";

        output DiscreteZerosAndPoles dzp[size(dss.C, 1),size(dss.B, 2)];

    protected
        DiscreteStateSpace dss_siso(
          redeclare Real A[size(dss.A, 1),size(dss.A, 2)],
          redeclare Real B[size(dss.B, 1),1],
          redeclare Real C[1,size(dss.C, 2)],
          redeclare Real D[1,1]);

        Integer ny=size(dss.C, 1);
        Integer nu=size(dss.B, 2);

      algorithm
        for ic in 1:ny loop
          for ib in 1:nu loop
            dss_siso := DiscreteStateSpace(
              A=dss.A,
              B=matrix(dss.B[:, ib]),
              C=transpose(matrix(dss.C[ic, :])),
              D=matrix(dss.D[ic, ib]),
              Ts=dss.Ts,
              B2=matrix(dss.B2[:, ib]),
              method=dss.method);
      //       dss_siso.uNames := {dss.uNames[ib]};
      //       dss_siso.yNames := {dss.yNames[ic]};
      //       dss_siso.xNames := dss.xNames;
            dzp[ic, ib] := DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(
              dss_siso);
          end for;
        end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = DiscreteStateSpace.Conversion.<b>toDiscreteZerosAndPolesMIMO</b>(dss)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a matrix of DiscreteZerosAndPoles records
</p>
<blockquote><pre>
           product(q + n1[i]) * product(q^2 + n2[i,1]*q + n2[i,2])
dzp = k * ---------------------------------------------------------
           product(q + d1[i]) * product(q^2 + d2[i,1]*q + d2[i,2])
</pre></blockquote>
<p>
of a system from discrete state space representation, i.e. isolating the uncontrollable and unobservable parts and the eigenvalues and invariant zeros of the controllable and observable sub systems are calculated. The algorithm applies the method described in [1] for each single-input-output pair.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace ss=Modelica_LinearSystems2.DiscreteStateSpace(
    A = [0.9048, 0.0,    0.0;
         0.0,    0.8187, 0.0;
         0.0,    0.0,    0.7408]

    B = [0.0,      0.09516;
         0.0906,   0.09063;
        -0.0864,   0.0],

    C = [0.0, 1.0, 1.0;
         1.0, 1.0, 1.0],

    D = [1.0, 0.0;
         0.0, 1.0],

    B2 = [0.0,  0.0;
          0.0,  0.0;
          0.0,  0.0],
    Ts = 0.1);

<b>algorithm</b>
  dzp:=Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPolesMIMO(dss);

// dzp = [1*(q^2 - 1.55531*q + 0.61012)/( (q - 0.818731)*(q - 0.740818) )
    Ts = 0.1
    method =StepExact,
 0.0906346/(q - 0.818731)
    Ts = 0.1
    method =StepExact;
0.0042407*(q + 0.846461)/( (q - 0.818731)*(q - 0.740818) )
    Ts = 0.1
    method =StepExact,
 1*(q - 0.870319)*(q - 0.667452)/( (q - 0.904837)*(q - 0.818731) )
    Ts = 0.1
    method =StepExact]
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toDiscreteZerosAndPolesMIMO;

      function toDiscreteTransferFunction
        "Generate a TransferFunction data record from a SISO DiscreteStateSpace data record"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteStateSpace dss "DiscreteStateSpace object";

        output DiscreteTransferFunction dtf "DiscreteTransferFunction object";

    protected
        DiscreteZerosAndPoles dzp=DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(dss);

      algorithm
        dtf := DiscreteZerosAndPoles.Conversion.toDiscreteTransferFunction(dzp);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<table>
<tr> <td align=right>  dtf </td><td align=center> =  </td>  <td> DiscreteStateSpace.Conversion.<b>toDiscreteTransferFunction</b>(dss)  </td> </tr>
</table>
<h4>Description</h4>
<p>
Computes a DiscreteTransferFunction record
<blockquote><pre>
           n(z)     b0 + b1*z + ... + bn*z^n
  dtf = -------- = --------------------------
           d(z)     a0 + a1*z + ... + an*z^n
 </pre></blockquote>

The algorithm uses <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles\">toDiscreteZerosAndPoles</a> to convert the
discrete state space system into a discrete zeros and poles representation first and after that <a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Conversion.toDiscreteTransferFunction\">DiscreteZerosAndPoles.Conversion.toDiscreteTransferFunction</a> to generate the transfer function.



<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
      A = [0.9048, 0.0,    0.0;
            0.0,   0.8187, 0.0;
            0.0,   0.0,    0.7408],
      B = [0.09516;
           0.09063;
           0.0],
      C = [1.0,1.0,1.0],
      D = [0.0],
      B2 = [0, 0;
            0, 0;
            0, 0],
      Ts = 0.1);

 <b>algorithm</b>

  dtf:=Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteTransferFunction(dss);

//             0.185797*z - 0.159922
//   dtf = -------------------------------
//           z^2 - 1.72357*z + 0.740818
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toDiscreteTransferFunction;

      function toDiscreteTransferFunctionMIMO
        "Generate a discrete transfer function of a MIMO system from discrete state space representation"
        import Modelica_LinearSystems2;

        import Modelica;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteStateSpace dss "DiscreteStateSpace object";

        output DiscreteTransferFunction dtf[size(dss.C, 1),size(dss.B, 2)]
              "Matrix of discrete transfer function objects";

    protected
        DiscreteZerosAndPoles dzp[:,:];
        parameter Integer m=size(dss.B, 2);
        parameter Integer p=size(dss.C, 1);

      algorithm
        dzp := Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPolesMIMO(dss);
        for i1 in 1:m loop
          for i2 in 1:p loop
            dtf[i2, i1] := DiscreteZerosAndPoles.Conversion.toDiscreteTransferFunction(dzp[i2, i1]);
          end for;
        end for;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<table>
<tr> <td align=right>  dtf </td><td align=center> =  </td>  <td> DiscreteStateSpace.Conversion.<b>toDiscreteTransferFunctionMIMO</b>(dss)  </td> </tr>
</table>
<h4>Description</h4>
<p>
Computes a matrix of DiscreteTransferFunction records
<blockquote><pre>
           n(z)     b0 + b1*z + ... + bn*z^n
  dtf = -------- = --------------------------
           d(z)     a0 + a1*z + ... + an*z^n
 </pre></blockquote>
with repetitive application of <a href=\"Modelica://Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteTransferFunction\">Conversion.toDiscreteTransferFunction</a>


<h4>Example</h4>
<blockquote><pre>
   Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(
   A = [0.9048, 0.0,    0.0;
          0.0,   0.8187, 0.0;
          0.0,   0.0,    0.7408]

   B = [0.0,      0.09516;
        0.0906,   0.09063;
       -0.0864,   0.0],

   C = [0.0, 1.0, 1.0;
        1.0, 1.0, 1.0],

   D = [1.0, 0.0;
        0.0, 1.0],

   B2 = [0.0,  0.0;
         0.0,  0.0;
         0.0,  0.0],
   Ts = 0.1);

<b>algorithm</b>
  dtf:=Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(dss);

// dtf = [(1*z^2 - 1.55531*z + 0.61012)/(z^2 - 1.55955*z + 0.606531)

 Ts = 0.1
 method =StepExact,
 0.0906346/(z - 0.818731)

 Ts = 0.1
 method =StepExact;
(0.0042407*z + 0.00358958)/(z^2 - 1.55955*z + 0.606531)

 Ts = 0.1
 method =StepExact,
 (1*z^2 - 1.53777*z + 0.580896)/(z^2 - 1.72357*z + 0.740818)

 Ts = 0.1
 method =StepExact]
</pre></blockquote>
</html>",   revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end toDiscreteTransferFunctionMIMO;

    end Conversion;

    encapsulated package Import
      "Package of functions to generate a DiscreteStateSpace data record from imported data"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function fromFile
        "Read a DiscreteStateSpace data record from mat-file"

        import Modelica;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2;

        input String fileName="dslin.mat"
            "Name of the state space system data file" annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                            caption="state space system data file")));
        input String matrixName="ABCD" "Name of the state space system matrix" annotation(Dialog);
    protected
        Integer xuy[3]=StateSpace.Internal.readSystemDimension(fileName, matrixName) annotation(__Dymola_allowForSize=true);
        Integer nx=xuy[1] annotation(__Dymola_allowForSize=true);
        Integer nu=xuy[2] annotation(__Dymola_allowForSize=true);
        Integer ny=xuy[3] annotation(__Dymola_allowForSize=true);

    public
        output DiscreteStateSpace result(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real B2[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";

    protected
        Real ABCD[nx + ny,nx + nu]=Modelica_LinearSystems2.Internal.Streams.readMatrixInternal(
            fileName,
            matrixName,
            nx + ny,
            nx + nu);
        Real B2[nx,nu]=Modelica_LinearSystems2.Internal.Streams.readMatrixInternal(
            fileName,
            "B2",
            nx,
            nu);
        Real Ts[1,1]=readMatrix(
            fileName,
            "Ts",
            1,
            1);

      algorithm
        result.A := ABCD[1:nx, 1:nx];
        result.B := ABCD[1:nx, nx + 1:nx + nu];
        result.B := B2;
        result.C := ABCD[nx + 1:nx + ny, 1:nx];
        result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        result.Ts := scalar(Ts);
        Modelica.Utilities.Streams.print("StateSpace record loaded from file: \"" +
          Modelica.Utilities.Files.fullPathName(fileName) + "\"");

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<table>
<tr> <td align=right>  dss </td><td align=center> =  </td>  <td> DiscreteStateSpace.Import.<b>fromFile</b>(fileName, matrixName)  </td> </tr>
</table>
<h4>Description</h4>
<p>
Reads and loads a discrete state space system from a mat-file <tt>fileName</tt>. The discrete System on the file must be described as:
</p>

<blockquote><pre>
<b>x</b>(Ts*(k+1))  = <b>A</b> * <b>x</b>(Ts*k) + <b>B</b> * <b>u</b>(Ts*k)
<b>y</b>(Ts*k)         = <b>C</b> * <b>x</b>(Ts*k) + <b>D</b> * <b>u</b>(Ts*k)
<b>x</b>_continuous(Ts*k) =  <b>x</b>(Ts*k) + <b>B2</b> * <b>u</b>(Ts*k)
</pre></blockquote>
<p>
with (for more details see <a href=\"modelica://Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromStateSpace\">DiscreteStateSpace.'constructor'.fromStateSpace</a>):
</p>
<ul>
<li> <b>Ts</b> - the sample time,</li>
<li> <b>k</b> - the index of the actual sample instance (k=0,1,2,3,...),</li>
<li> <b>t</b> - the time,</li>
<li> <b>u</b>(t) - the input vector,</li>
<li> <b>y</b>(t) - the output vector,</li>
<li> <b>x</b>(t) - the discrete state vector (x(t=Ts*0) is the initial state),</li>
<li> <b>x</b>_continuous(t) - the state vector of the continuous system
     from which the discrete block has been derived,</li>
<li> <b>A, B, C, D, B2</b> - matrices of appropriate dimensions.</li>
</ul>

<p>
The file must contain
</p>
<ul>
<li> the Real matrix [A, B; C, D]  with name \"matrixName\",</li>
<li> the Integer matrix \"nx[1,1]\" defining the number of states (that is the number of rows of the square matrix A),</li>
<li> the Real matrix B2 that has the same dimensions as B,</li>
<li> the Real matrix \"Ts[1,1]\" defining the sample time in [s] with which the continuous-time system was discretized to arrive at this discrete system</li>
</ul>

<h4>Example</h4>
<blockquote><pre>
<b>algorithm</b>
  file := Modelica.Utilities.Files.loadResource(\"modelica://Modelica_LinearSystems2/Resources/Data/dss.mat\")
  dss:=Modelica_LinearSystems2.DiscreteStateSpace.Import.fromFile(file)
//  dss=StateSpace(
      A=[-4.5, 1.5, 4.0; -4.0, 1.0, 4.0; -1.5, -0.5, 1],
      B=[2; 1; 2],
      C=[1, 0, 0],
      D=[0],
      B2=[0;0;0],
      Ts=0.2,
      method=Trapezoidal);
</pre></blockquote>
</html>"));
      end fromFile;

      function fromModel
        "Generate a DiscreteStateSpace data record by linearization of a modelica model"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input String modelName "Name of the Modelica model"
          annotation (Dialog(__Dymola_translatedModel(translate=true)));
        input Modelica.Units.SI.Time T_linearize=0
          "point in time of simulation to linearize the model";
        input String fileName="dslin" "Name of the result file";
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";

    protected
        String fileName2=fileName + ".mat";
        Boolean OK1=simulateModel(
        problem=modelName,
        startTime=0,
        stopTime=T_linearize);
        Boolean OK2=importInitial("dsfinal.txt");
        Boolean OK3=linearizeModel(
        problem=modelName,
        resultFile=fileName,
        startTime=T_linearize,
        stopTime=T_linearize + 3*Ts);

        Real nxMat[1,1]=readMatrix(
        fileName2,
        "nx",
        1,
        1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny,nx + nu]=readMatrix(
        fileName2,
        "ABCD",
        nx + ny,
        nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(
        fileName2,
        "xuyName",
        nx + nu + ny);

        StateSpace ss(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";
    public
        output DiscreteStateSpace result(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real B2[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= discrete model linearized at initial point";

      algorithm
        ss.A := ABCD[1:nx, 1:nx];
        ss.B := ABCD[1:nx, nx + 1:nx + nu];
        ss.C := ABCD[nx + 1:nx + ny, 1:nx];
        ss.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        ss.uNames := xuyName[nx + 1:nx + nu];
        ss.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        ss.xNames := xuyName[1:nx];

        result := DiscreteStateSpace(
          ss=ss,
          Ts=Ts,
          method=method);

        annotation (
          __Dymola_interactive=true,
          Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dss = DiscreteStateSpace.Import.<b>fromModel</b>(modelName, T_linearize, fileName, Ts, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Generate a discrete state space data record by linearization of
a model defined by modelName. The linearization is performed at time T_linearize
of the simulation. The result of linearization is transformed into a state space
record and then converted into a discrete state space record.
</p>

<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;

<b>algorithm</b>
  dss = Modelica_LinearSystems2.DiscreteStateSpace.Import.fromModel(modelName, T_linearize);

// ss.A  = [1, 0.1, 0.0338415578929376, 0.00169207789464688, -0.010114371760331, -0.000505718588016548;
            0, 1, 0.676831157858752, 0.0338415578929376, -0.202287435206619,   -0.010114371760331;
            0, 0, 0.892698457060726, 0.0946349228530364, -0.0895698633812754,  -0.00447849316906376;
            0, 0, -2.14603085878547, 0.892698457060726, -1.79139726762551, -0.0895698633812755;
            0, 0, 0.0738077919657481, 0.0036903895982874, 1.0110083777752, 0.10055041888876;
            0, 0, 1.47615583931496, 0.0738077919657481, 0.220167555503916, 1.0110083777752];

// ss.B= [0.00170323086692055;
          0.0165800882263292;
         -0.00215003506298196;
         -0.02103518146498;
          0.00152042385523347;
          0.0144812915324601];

// ss.C=identity(6),
// ss.D= [0.000437113227802044;
          0.00874226455604088;
         -0.000549137994799829;
         -0.0109827598973295;
          0.000398179639293453;
          0.00796359278610463];

ss.B2  = [0.000437113227802044;
          0.00874226455604088;
         -0.000549137994866478;
         -0.0109827598973295;
          0.000398179639305232;
          0.00796359278610463];
</pre></blockquote>
</html>"));
      end fromModel;

    end Import;

    encapsulated package Internal
      "Package of internal material of record DiscreteStateSpace (for advanced users only)"
      import Modelica;
      extends Modelica.Icons.Package;

      function timeResponseSamples
        "Estimate reasonable discretisation sample time and simulation time span for time response plot"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;

        input Modelica_LinearSystems2.DiscreteStateSpace dss;
        output Real tSpan "Time span";
    protected
        Modelica_LinearSystems2.Math.Complex eig[size(dss.A, 1)];
        Real realp[size(dss.A, 1)];
        Real sorted[size(dss.A, 1)];
        Real indices[size(dss.A, 1)];
        Integer i;
      algorithm
        eig := Modelica_LinearSystems2.DiscreteStateSpace.Analysis.eigenValues(dss);
        for i in 1:size(dss.A, 1) loop
          eig[i] := if Complex.'abs'(eig[i])>1e-10 then Complex.log(eig[i])/dss.Ts else Complex(-100);
        end for;

        //eig := Complex.log(eig)/dss.Ts;
        for i in 1:size(eig, 1) loop
          realp[i] := eig[i].re;
        end for;
        (sorted,indices) := Modelica.Math.Vectors.sort(realp);

        // Estimate simulation time span
        if sorted[end] < 0 then
          tSpan := -5/sorted[end];
        elseif sorted[end] > 0 then
          tSpan := 15/sorted[end];
        elseif sorted[end] == 0 then
          tSpan := 15000;
        end if;
        // Curb simulation time span to maximal 15000s
        if tSpan > 15000 then
          tSpan := 15000;
        end if;

      end timeResponseSamples;

      encapsulated function initialResponse1
        "Compute initial response of DiscreteStateSpace system"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss "Linear system in discrete state space form";
        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1)) "Initial system state";
        input Integer samples "Number of samples";
        output Real y[samples,size(dss.C, 1)]
          "System response (dimension: (input samples) x (number of outputs))";
        output Real x[samples,size(dss.A, 1)]
          "State trajectories (dimension: (input samples) x (number of states)";

    protected
        Integer i;
        Real new_x[size(dss.A, 1)];
        Real xi[size(dss.A, 1)]=x0;

      algorithm
        for i in 1:samples loop
          new_x := dss.A*xi;
          y[i, :] := dss.C*xi;
          x[i, :] := xi;
          xi := new_x;
        end for;
        annotation (Documentation(info="<html>
<p>
Computes the initial response of a system in discrete state space form:
</p>
<pre>     <b>x</b>(Ts*(k+1)) = <b>A</b> * <b>x</b>(Ts*k)
     <b>y</b>(Ts*k)     = <b>C</b> * <b>x</b>(Ts*k)
     <b>x</b>_continuous(Ts*k) = <b>x</b>(Ts*k)
</pre>
<p>
Note that the system input <b>u</b> is equal to zero.
</p>
</html>"));
      end initialResponse1;

      encapsulated function timeResponse1
        "Compute time response of DiscreteStateSpace system"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input DiscreteStateSpace dss "Linear system in discrete state space form";
        input Real u[:,size(dss.B, 2)]=ones(3, size(dss.B, 2))
          "System input (dimension: (input samples) x (number of inputs))";
        input Real x0[size(dss.A, 1)]=zeros(size(dss.A, 1))
          "Initial system state";
        output Real y[size(u, 1),size(dss.C, 1)]
          "System response (dimension: (input samples) x (number of outputs))";
        output Real x[size(u, 1),size(dss.A, 1)]
          "State trajectories (dimension: (input samples) x (number of states)";

    protected
        Integer samples=size(u, 1);
        Integer i;
        Real new_x[size(dss.A, 1)];
        Real xi[size(dss.A, 1)]=x0;

      algorithm
        for i in 1:samples loop
          new_x := dss.A*xi + dss.B*u[i, :];
          y[i, :] := dss.C*xi + dss.D*u[i, :];
          x[i, :] := xi;
          xi := new_x;
        end for;
        annotation (Documentation(info="<html>
<p>
Computes the time response of a system in discrete state space form:
</p>
<pre>     <b>x</b>(Ts*(k+1)) = <b>A</b> * <b>x</b>(Ts*k) + <b>B</b> * <b>u</b>(Ts*k)
     <b>y</b>(Ts*k)     = <b>C</b> * <b>x</b>(Ts*k) + <b>D</b> * <b>u</b>(Ts*k)
     <b>x</b>_continuous(Ts*k) = <b>x</b>(Ts*k) + <b>B2</b> * <b>u</b>(Ts*k)
</pre>
<p>
Note that the system input <b>u</b> must be sampled with the discrete system sample time Ts.
</p>
</html>"));
      end timeResponse1;

      encapsulated function assignOneOrTwoPoles
        "Algorithm to assign p (p = 1 or 2) eigenvalues"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Vectors;

        input Real F[:,size(F, 1)] "system matrix of order p=1 or p=2";
        input Real G[size(F, 1),:] "control input matrix p rows";
        input Complex gamma[size(F, 1)];
        input Real tolerance=Modelica.Constants.eps;
        output Real K[:,size(F, 1)] "feedback matrix p columns";

    protected
        Real Gamma[:,:];
        Integer rankGs;
        Real Fs[size(F, 1),size(F, 2)];
        Real Gs[size(G, 1),size(G, 2)];
        Real Gst[:,:]=transpose(G);
        Real Ks[:,size(F, 1)];
        Real c;
        Real s;
        Real r;
        Integer p=size(F,1);
        Real sigmaG[:];

        Real V[size(G, 2),size(G, 2)];
        Real U[size(F, 1),size(F, 2)];

        Real u1[:];
        Real u2[:];
        Integer i;
        Complex system_ev[:];

      algorithm
        assert(size(F, 1) >= size(gamma, 1),
          "\n In function DiscreteStateSpace.Internal.assignOneOrTwoPoles() matrix F is of size ["
           + String(size(F, 1)) + "," + String(size(F, 1)) + "] and " + String(
          size(F, 1)) + " demanded assigned poles are expected. However, " +
          String(size(gamma, 1)) + " poles are given");
      //assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),"A subsystem (F, G) in DiscreteStateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix ");
        if size(gamma, 1) == 1 then
          assert(gamma[1].im == 0, "\n In function DiscreteStateSpace.Internal.assignOneOrTwoPoles() matrix F has size [" + String(size(F, 1)) + "," + String(size(F, 1)) +
            "], therefore, the demanded assigned pole must be real. However, the imaginary part is "
             + String(gamma[1].im));
        elseif abs(gamma[1].im) > 0 or abs(gamma[2].im) > 0 then
          assert(gamma[1].re == gamma[2].re and gamma[1].im == -gamma[2].im,
            "\nThe assigned pole pair given in function DiscreteStateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = "
             + String(gamma[1]) + "\npole2 = " + String(gamma[2]) +
            ". \nTry\npole1 = " + String(gamma[1]) + "\npole2 = " + String(
            Complex.conj(gamma[1])) + "\ninstead");
        end if;

        if not Modelica.Math.Matrices.isEqual(
            G,
            zeros(size(G, 1), size(G, 2)),
            tolerance) then
          if size(G, 2) == 1 then
            V := [1];
            if size(G, 1) == 1 then
              U := [1];
            else
               // Givens
              r := sqrt(G[1, 1]^2 + G[2, 1]^2);
              c := G[1, 1]/r;
              s := G[2, 1]/r;
              U := [c,s; -s,c];
            end if;
            Gs := U*G;

            rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;
          else
           // size(G, 2)>1

            if size(G, 1) == 1 then // U=I, compute V by just one Householder transformation
              U := [1];
              u1 := cat(1, Vectors.householderVector(Gst[:, 1],
                           cat(1, {1}, zeros(size(G, 2) - 1))));// Householder vector
              Gst := Modelica_LinearSystems2.Math.Matrices.householderReflexion(Gst, u1);

              V := identity(size(G, 2)) - 2*matrix(u1)*transpose(matrix(u1))/(u1*u1);
              Gs := transpose(Gst);
              rankGs := if abs(Gs[1, 1]) > tolerance then 1 else 0;

            else
      // systems with p==2 and m>1 are transformed by svd
              (sigmaG,U,V) := Modelica.Math.Matrices.singularValues(G);
              rankGs := 0;
              i := size(sigmaG, 1);
              while i > 0 loop
                if sigmaG[i] > 1e-10 then
                  rankGs := i;
                  i := 0;
                end if;
                i := i - 1;
              end while;
              Gs := zeros(p, size(G, 2));
              for i in 1:rankGs loop
                Gs[i, i] := sigmaG[i];
              end for;

            end if;
            V := transpose(V);
          end if;

      // check controllability
          assert(not Modelica.Math.Matrices.isEqual(
            Gs,
            zeros(size(Gs, 1), size(Gs, 2)),
            tolerance), "A subsystem in DiscreteStateSpace.Internal.assignOneOrTwoPoles() is not controllable");

          Ks := fill(
            0,
            rankGs,
            size(F, 1));
          Fs := U*F*transpose(U);

          if size(F, 1) == 1 then
            Ks := matrix((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
          else
            if rankGs == size(F, 1) then

              // Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];
              //  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);
      //        Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,2],
      //        (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] - gamma[2].re)/Gs[1, 1]/Gs[2, 2];
      //        (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2] - gamma[2].re)/Gs[2, 2]];

      // since G1 is diagonal because of svd, Gs[1, 2] is zero

              Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1],  (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1];
              (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2] - gamma[2].re)/Gs[2, 2]];
            else

              Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1, 1];
              Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1, 2]*
                Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))/Fs[2,1]/Gs[1, 1];
              Ks := -Ks;
            end if;
          end if;

          K := V[:, 1:size(Ks, 1)]*Ks*U;

        else
          if p == 1 then
            Modelica.Utilities.Streams.print("\n A subsystem (F, G) in DiscreteStateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
        That is, "     + String(F[1, 1]) + " remains and " + String(gamma[1].re) + " cannot be realized");
          else
            system_ev := Complex.eigenValues(F);
            Modelica.Utilities.Streams.print("\n A subsystem (F, G) in DiscreteStateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
        That is, "     + String(system_ev[1].re) + (if abs(system_ev[1].im) > 0 then " + " else
                    " - ") + String(system_ev[1].im) + "j and " + String(system_ev[2].re)
               + (if abs(system_ev[2].im) > 0 then " + " else " - ") + String(
              system_ev[2].im) + "j remain and " + String(gamma[1].re) + (if abs(
              gamma[1].im) > 0 then (if gamma[1].im > 0 then " + " else " - " +
              String(gamma[1].im) + "j") else "" + " and ") + String(gamma[2].re) + (
              if abs(gamma[2].im) > 0 then (if gamma[2].im > 0 then " + " else " - " +
              String(gamma[2].im) + "j") else "") + " cannot be realized");
          end if;
          K := zeros(size(G, 2), size(F, 1));
        end if;

      end assignOneOrTwoPoles;
    end Internal;

  end DiscreteStateSpace;

  operator record DiscreteZerosAndPoles
    "Discrete zeros and poles description of a single input, single output system (data + operations)"
    extends Modelica.Icons.Record;

    Real k=1.0 "Multiplicative factor of transfer function"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real n1[:] "[p^0] coefficients of 1st order numerator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real n2[:,2] "[p,p^0] coefficients of 2nd order numerator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real d1[:] "[p^0] coefficients of 1st order denominator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
    Real d2[:,2] "[p,p^0] coefficients of 2nd order denominator polynomials"
      annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));

    Modelica.Units.SI.Time Ts "Sample time" annotation (Dialog(group=
            "Data used to construct discrete from continuous system"));

    Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));

  /* If the numerator polynomial has no coefficients, the transfer function
   is zero. The denominator polynomial must always have at
   least one coefficient, such as {1}
*/

    String uName="u" "Name of input signal" annotation(Dialog(group="Signal names"));
    String yName="y" "Name of output signal" annotation(Dialog(group="Signal names"));

    encapsulated operator 'constructor'
      "Collection of operators to construct a DiscreteZerosAndPoles data record"
      import Modelica_LinearSystems2;
      import Modelica;

      encapsulated function fromReal
        "Generate a DiscreteZerosAndPoles data record from a real value"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input Real r "Value of Real variable";
        input Modelica.Units.SI.Time Ts=0 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteZerosAndPoles dzp(
          redeclare Real n1[0],
          redeclare Real n2[0,2],
          redeclare Real d1[0],
          redeclare Real d2[0,2]) "= r";

      algorithm
        dzp.k := r;
        dzp.Ts := Ts;
        dzp.method := method;
        dzp.uName := uName;
        dzp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = 'constructor'.<b>fromReal</b>(r)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a DiscreteZerosAndPoles record zp from a Real value, i.e. a without dynamics:
</p>
<blockquote><pre>
y = r*u
</pre></blockquote>
<p>
Therefore, the record is defined by
</p>
<blockquote><pre>
  dzp.k = r;
  dzp.n1 = fill(0,1);
  dzp.n2 = fill(0,1,2);
  dzp.d1 = fill(0,1);
  dzp.d2 = fill(0,1,2);
</pre></blockquote>
</html>"));
      end fromReal;

      function fromZerosAndPoles
        "Generate a DiscreteZerosAndPoles data record from a continuous ZerosAndPoles represenation"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input ZerosAndPoles zp "continuous zeros and poles transfer function";
        input Modelica.Units.SI.Time Ts "Sample time" annotation (Dialog(group=
                "Data used to construct discrete from continuous system"));

        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));

        output DiscreteZerosAndPoles dzp;
    protected
        StateSpace ss = StateSpace(zp);
        Modelica_LinearSystems2.DiscreteStateSpace dss=
          Modelica_LinearSystems2.DiscreteStateSpace(ss,Ts,method);

      algorithm
        dzp := DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(dss);
        annotation (
          Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = 'constructor'.<b>fromZerosAndPoles</b>(zp, Ts, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a DiscreteZerosAndPoles record
</p>
<blockquote><pre>
           product(q + n1[i]) * product(q^2 + n2[i,1]*q + n2[i,2])
dzp = k * ---------------------------------------------------------
           product(q + d1[i]) * product(q^2 + d2[i,1]*q + d2[i,2])
</pre></blockquote>
<p>
from a continuous zeros-and-poles transfer function. The functions applies the discretization methods of
<a href=\"modelica://Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromStateSpace\">DiscreteStateSpace.'constructor'.fromStateSpace</a>, i.e,
the continuous zeros-and-poles representation is transformed to continuous state space first and then converted to a discrete state space system. Finally the
discrete zeros-and-poles transfer function is derived from DiscreteStateSpace by
<a href=\"modelica://Modelica_LinearSystems2.DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles\">DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  zp=Modelica_LinearSystems2.ZerosAndPoles(      n1={2},  d1={1},      d2=[1,1]);

  dzp=Modelica_LinearSystems2.DiscreteZerosAndPoles.'constructor'.fromZerosAndPoles(zp,0.1)

  //                          (q - 0.818182)*(q^2 + 2*q + 1)
  // dzp = 0.00248841 * ---------------------------------------------
  //                     (q - 0.904762)*(q^2 - 1.89549*q + 0.904988)
</pre></blockquote>
</html>"));
      end fromZerosAndPoles;

      encapsulated function fromPolesAndZeros
        "Generate a DiscreteZerosAndPoles data record from a set of zeros and poles"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica.Utilities.Streams.print;

        input Complex z[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
            "Zeros (Complex vector of numerator zeros)";
        input Complex p[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
            "Poles (Complex vector of denominator zeros)";
        input Real k=1.0 "Constant multiplied with transfer function";
          input Modelica.Units.SI.Time Ts "Sample time";
          input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteZerosAndPoles dzp(
          redeclare Real n1[Internal.numberOfRealZeros(z)],
          redeclare Real n2[integer((size(z, 1) - Internal.numberOfRealZeros(z))/2), 2],
          redeclare Real d1[Internal.numberOfRealZeros(p)],
          redeclare Real d2[integer((size(p, 1) - Internal.numberOfRealZeros(p))/2), 2])
          "ZerosAndPoles transfer functions of the zeros, poles and k";

    protected
        Integer n_n1=size(dzp.n1, 1);
        Integer n_d1=size(dzp.d1, 1);
        Integer n_n2=size(dzp.n2, 1);
        Integer n_d2=size(dzp.d2, 1);
        Integer i;
        Integer j;
        Complex z_reordered[size(z, 1)] "Reordered zeros";
        Complex p_reordered[size(p, 1)] "Reordered poles";
        Integer nz_real "Number of real zeros";
        Integer np_real "Number of real poles";
      algorithm
        //Extra input (string) added
        (z_reordered,nz_real) := Internal.reorderZeros(z, "");
        (p_reordered,np_real) := Internal.reorderZeros(p, "");

        // Numerator
        for i in 1:n_n1 loop
          dzp.n1[i] := -z_reordered[i].re;
        end for;

        j := 1;
        for i in n_n1 + 1:2:size(z, 1) loop
          dzp.n2[j, :] := {-2*z_reordered[i].re,z_reordered[i].re^2 + z_reordered[i].im
            ^2};
          j := j + 1;
        end for;

        // Denominator
        for i in 1:n_d1 loop
          dzp.d1[i] := -p_reordered[i].re;
        end for;

        j := 1;
        for i in n_d1 + 1:2:size(p, 1) loop
          dzp.d2[j, :] := {-2*p_reordered[i].re,p_reordered[i].re^2 + p_reordered[i].im
            ^2};
          j := j + 1;
        end for;

        dzp.Ts := Ts;
        dzp.method := method;
        dzp.k := k;
        dzp.uName := uName;
        dzp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = 'constructor'.<b>fromPolesAndZeros</b>(z, p, k, Ts, method)
dzp = 'constructor'.<b>fromPolesAndZeros</b>(z, p, k, Ts, method, uName, yName)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a DiscreteZerosAndPoles transfer function from denominator
and numerator zeros, as well as a gain.
</p>
<p>
Since only transfer functions with real coefficients are supported,
complex roots must be defined as conjugate complex pairs.
It is required that complex conjugate pairs must directly
follow each other as above. An error occurs if this is not the case.
</p>

<h4>Example</h4>
<blockquote><pre>
             (q + 0.1)
dzp = 4* -----------------
         (q + 1)*(q - 0.1)
</pre></blockquote>
<p>
is defined as
</p>
<blockquote><pre>
  <b>import</b> Modelica_LinearSystems2.Math.Complex;
  <b>import</b> Modelica_LinearSystems2.DiscreteZerosAndPoles;

  dzp = DiscreteZerosAndPoles(
          z = {Complex(-0.1,0)},
          p = {Complex(-1,0),
               Complex(0.1)},
               k=4);
</pre></blockquote>
</html>"));
      end fromPolesAndZeros;

      function fromDiscreteTransferFunction =
        Modelica_LinearSystems2.DiscreteTransferFunction.Conversion.toDiscreteZerosAndPoles
        "Generate a DiscreteZerosAndPoles data record from a discrete transfer function"
        annotation (Documentation(info="<html>
</html>"));

      encapsulated function fromFactorization
        "Generate a DiscreteZerosAndPoles data record from first and second order polynomials"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input Real n1[:]=fill(0, 0) "[p^0] coefficients of 1st order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real n2[:,2]=fill(
                0,
                0,
                2) "[p,p^0] coefficients of 2nd order numerator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real d1[:]=fill(0, 0)
          "[p^0] coefficients of 1st order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real d2[:,2]=fill(
                0,
                0,
                2) "[p,p^0] coefficients of 2nd order denominator polynomials"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Real k=1.0 "Multiplicative factor of transfer function"
          annotation(Dialog(group="y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u"));
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteZerosAndPoles dzp(
          redeclare Real n1[size(n1, 1)],
          redeclare Real n2[size(n2, 1),2],
          redeclare Real d1[size(d1, 1)],
          redeclare Real d2[size(d2, 1),2]) "ZerosAndPoles transfer function";
      algorithm
        dzp.n1 := n1;
        dzp.n2 := n2;
        dzp.d1 := d1;
        dzp.d2 := d2;
        dzp.k := k;
        dzp.Ts := Ts;
        dzp.method := method;
        dzp.uName := uName;
        dzp.yName := yName;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = 'constructor'.<b>fromFactorization</b>(n1, n2, d1, d2, k, Ts, method)
dzp = 'constructor'.<b>fromFactorization</b>(n1, n2, d1, d2, k, Ts, method, uName, yName)
</pre></blockquote>

<h4>Description</h4>
<p>
This function constructs a DiscreteZerosAndPoles transfer function from the real first and scond order polynomials of the numerator and the denominator, respectively.
</p>

<h4>Example</h4>
<blockquote><pre>
              (q + 0.1)
dzp = 4 * -----------------
          (q + 1)*(q - 0.1)
</pre></blockquote>
<p>
is defined as
</p>
<blockquote><pre>
  <b>import</b> Modelica_LinearSystems2.Math.Complex;
  <b>import</b> Modelica_LinearSystems2.DiscreteZerosAndPoles;

  dzp = DiscreteZerosAndPoles(n1={0.1},n2=fill(0,0,2), d1={1,-0.1}, d2=fill(0,0,2), k=4);

which is equal to

  dzp = DiscreteZerosAndPoles(n1={0.1},n2=fill(0,0,2), d1=fill(0,0), d2=[0.9, -0.1], k=4);
</pre></blockquote>
</html>"));
      end fromFactorization;

    end 'constructor';

    encapsulated operator '-'
      "Contains operators for subtraction of discrete zeros and poles descriptions"
      import Modelica;

      function subtract "Subtract two DiscreteZerosAndPoles (dzp1 - dzp2)"
        import Modelica;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input DiscreteZerosAndPoles dzp1;
        input DiscreteZerosAndPoles dzp2;

    protected
        Integer size_z1n1=size(dzp1.n1, 1);
        Integer size_z1d1=size(dzp1.d1, 1);
        Integer size_z1n2=size(dzp1.n2, 1);
        Integer size_z1d2=size(dzp1.d2, 1);
        Integer size_z2n1=size(dzp2.n1, 1);
        Integer size_z2d1=size(dzp2.d1, 1);
        Integer size_z2n2=size(dzp2.n2, 1);
        Integer size_z2d2=size(dzp2.d2, 1);
        Polynomial p1;
        Polynomial p2;
        Polynomial p3;
        Complex numZeros[:];
        Complex dummy[:]=fill(Complex(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
            size_z2d2));
        Real k;

        output DiscreteZerosAndPoles result "= dzp1-dzp2";
      algorithm
        assert(abs(dzp1.Ts-dzp2.Ts)<=Modelica.Constants.eps,"Two discrete zeros-and-poles systems must have the same sample time Ts for subtraction with \"-.subtract\".");
        result.Ts := dzp1.Ts;
         if dzp1 == dzp2 then
           result := DiscreteZerosAndPoles(0);
         else
          p1 := Polynomial(1);
          p2 := Polynomial(1);

          for i in 1:size_z1n1 loop
            p1 := p1*Polynomial({1,dzp1.n1[i]});
          end for;
          for i in 1:size_z1n2 loop
            p1 := p1*Polynomial(cat(1, {1}, dzp1.n2[i, :]));
          end for;
          for i in 1:size_z2d1 loop
            p1 := p1*Polynomial({1,dzp2.d1[i]});
          end for;
          for i in 1:size_z2d2 loop
            p1 := p1*Polynomial(cat(1, {1}, dzp2.d2[i, :]));
          end for;

          for i in 1:size_z2n1 loop
            p2 := p2*Polynomial({1,dzp2.n1[i]});
          end for;
          for i in 1:size_z2n2 loop
            p2 := p2*Polynomial(cat(1, {1}, dzp2.n2[i, :]));
          end for;
          for i in 1:size_z1d1 loop
            p2 := p2*Polynomial({1,dzp1.d1[i]});
          end for;
          for i in 1:size_z1d2 loop
            p2 := p2*Polynomial(cat(1, {1}, dzp1.d2[i, :]));
          end for;

          p3 := dzp1.k*p1 - dzp2.k*p2;
          k := 0;
          for i in size(p3.c, 1):-1:1 loop
            if abs(p3.c[i]) > Modelica.Constants.eps then
              k := p3.c[i];
            end if;
          end for;
          numZeros := Polynomial.roots(p3);
          result := DiscreteZerosAndPoles(numZeros, dummy, k, dzp1.Ts, dzp1.method);

          result.d1 := cat(1, dzp1.d1, dzp2.d1);
          result.d2 := cat(1, dzp1.d2, dzp2.d2);

        end if;
      end subtract;

      function negate "Unary minus (multiply transfer function by -1)"
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

       input DiscreteZerosAndPoles dzp;
       output DiscreteZerosAndPoles result(n1=dzp.n1, n2=dzp.n2, d1=dzp.d1, d2=dzp.d2, k=-dzp.k, Ts=dzp.Ts, method=dzp.method) "= -dzp";
      algorithm
      end negate;
      annotation (Documentation(info="<html>
<p>This package contains operators for subtraction of discrete zeros and poles records. </p>
</html>"));
    end '-';

    encapsulated operator '*'
      "Contains operators for multiplication of discrete zeros and poles records"
      import Modelica;

      function 'dzp*dzp'
        "Multiply two DiscreteZerosAndPoles transfer functions (dzp1 * dzp2)"

        import Modelica;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2;

        input DiscreteZerosAndPoles dzp1;
        input DiscreteZerosAndPoles dzp2;
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName=dzp1.uName "Input name";
        input String yName=dzp2.yName "Output name";

        output DiscreteZerosAndPoles result "= dzp1 * dzp2";
      algorithm
        assert(abs(dzp1.Ts-dzp2.Ts)<=Modelica.Constants.eps,"Two discrete zeros-and-poles systems must have the same sample time Ts for multiplication with \"*\".");
        result.Ts := dzp1.Ts;
        if dzp1 == DiscreteZerosAndPoles(0) or dzp2 == DiscreteZerosAndPoles(0) then
          result := DiscreteZerosAndPoles(0);
        else
          result.n1 := cat(
            1,
            dzp1.n1,
            dzp2.n1);
          result.n2 := cat(
            1,
            dzp1.n2,
            dzp2.n2);
          result.d1 := cat(
            1,
            dzp1.d1,
            dzp2.d1);
          result.d2 := cat(
            1,
            dzp1.d2,
            dzp2.d2);
          result.k := dzp1.k*dzp2.k;
        end if;
          result.Ts := dzp1.Ts;
          result.method := dzp1.method;
          result.uName := uName;
          result.yName := yName;

      end 'dzp*dzp';

      function 'r*dzp'
        "Multiply a real number with a discrete DiscreteZerosAndPoles transfer function  (r * dzp2)"

        import Modelica;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2;

        input Real r;
        input DiscreteZerosAndPoles dzp;
        input String uName=dzp.uName "Input name";
        input String yName=dzp.yName "Output name";

        output DiscreteZerosAndPoles result "= r * dzp1";
      algorithm
        if r == 0 or dzp == DiscreteZerosAndPoles(0) then
          result := DiscreteZerosAndPoles(0);
        else
          result := dzp;
          result.k := r*dzp.k;
        end if;
          result.Ts := dzp.Ts;
          result.method := dzp.method;
          result.uName := uName;
          result.yName := yName;

      end 'r*dzp';

      annotation (Documentation(info="<html>
<p>This package contains operators for multiplication of discrete zeros and poles records. </p>
</html>"));
    end '*';

    encapsulated operator function '/'
      "Divide two discrete transfer functions in zeros and poles representation (dzp1 / dzp2)"
      import Modelica;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;

      input DiscreteZerosAndPoles dzp1;
      input DiscreteZerosAndPoles dzp2;

      output DiscreteZerosAndPoles result "= dzp1/dzp2";

  protected
      Boolean dzp1IsReal=DiscreteZerosAndPoles.Internal.isReal(dzp1);
      Boolean dzp2IsReal=DiscreteZerosAndPoles.Internal.isReal(dzp2);

    algorithm
      assert(abs(dzp2.k) > 100*Modelica.Constants.small, "dzp2 in operator \"Modelica_LinearSystems2.TransferFunction.'/'()\" may not be zero");
    //   if max({size(dzp1.n1, 1),size(dzp1.n2, 1),size(dzp1.d1, 1),size(dzp1.d2, 1)}) >0 and
    //     max({size(dzp2.n1, 1),size(dzp2.n2, 1),size(dzp2.d1, 1),size(dzp2.d2, 1)}) > 0 then
      if not dzp1IsReal and not dzp2IsReal then
          assert(abs(dzp1.Ts - dzp2.Ts) <= Modelica.Constants.eps, "Two discrete zeros-and-poles systems must have the same sample time Ts for division with \"/\".");
      end if;
      result.Ts := if dzp1IsReal then dzp2.Ts else dzp1.Ts;
      result.method := if dzp1IsReal then dzp2.method else dzp1.method;

      if dzp1 == DiscreteZerosAndPoles(0) then
        result := DiscreteZerosAndPoles(0);
      else
        result.n1 := cat(
          1,
          dzp1.n1,
          dzp2.d1);
        result.n2 := cat(
          1,
          dzp1.n2,
          dzp2.d2);
        result.d1 := cat(
          1,
          dzp1.d1,
          dzp2.n1);
        result.d2 := cat(
          1,
          dzp1.d2,
          dzp2.n2);
        result.k := dzp1.k/dzp2.k;
      end if;
    end '/';

    encapsulated operator function '+'
      "Addition of to discrete transfer functions dzp1 + dzp2, i.e. parallel connection of two transfer functions (= inputs are the same, outputs of the two systems are added)"

      import Modelica;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.Math.Complex;

      input DiscreteZerosAndPoles dzp1;
      input DiscreteZerosAndPoles dzp2;

  protected
      Integer size_z1n1=size(dzp1.n1, 1);
      Integer size_z1d1=size(dzp1.d1, 1);
      Integer size_z1n2=size(dzp1.n2, 1);
      Integer size_z1d2=size(dzp1.d2, 1);
      Integer size_z2n1=size(dzp2.n1, 1);
      Integer size_z2d1=size(dzp2.d1, 1);
      Integer size_z2n2=size(dzp2.n2, 1);
      Integer size_z2d2=size(dzp2.d2, 1);
      Polynomial p1;
      Polynomial p2;
      Polynomial p3;
      Complex numZeros[:];
      Complex dummy[:]=fill(Complex(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
          size_z2d2));
      Real k;

      output DiscreteZerosAndPoles result "= dzp1+dzp2";

    algorithm
      if max({size(dzp1.n1,1),size(dzp1.n2,1),size(dzp1.d1,1),size(dzp1.d2,1)})>0 and max({size(dzp2.n1,1),size(dzp2.n2,1),size(dzp2.d1,1),size(dzp2.d2,1)})>0 then
        assert(abs(dzp1.Ts-dzp2.Ts)<=Modelica.Constants.eps,"Two discrete zeros-and-poles systems must have the same sample time Ts for addition with \"+\".");
      end if;
      result.Ts := dzp1.Ts;

      if dzp1 == -dzp2 then
        result := DiscreteZerosAndPoles(0,Ts = dzp1.Ts);
      else

        p1 := Polynomial(1);
        p2 := Polynomial(1);

        for i in 1:size_z1n1 loop
          p1 := p1*Polynomial({1,dzp1.n1[i]});
        end for;
        for i in 1:size_z1n2 loop
          p1 := p1*Polynomial(cat(
            1,
            {1},
            dzp1.n2[i, :]));
        end for;
        for i in 1:size_z2d1 loop
          p1 := p1*Polynomial({1,dzp2.d1[i]});
        end for;
        for i in 1:size_z2d2 loop
          p1 := p1*Polynomial(cat(
            1,
            {1},
            dzp2.d2[i, :]));
        end for;

        for i in 1:size_z2n1 loop
          p2 := p2*Polynomial({1,dzp2.n1[i]});
        end for;
        for i in 1:size_z2n2 loop
          p2 := p2*Polynomial(cat(
            1,
            {1},
            dzp2.n2[i, :]));
        end for;
        for i in 1:size_z1d1 loop
          p2 := p2*Polynomial({1,dzp1.d1[i]});
        end for;
        for i in 1:size_z1d2 loop
          p2 := p2*Polynomial(cat(
            1,
            {1},
            dzp1.d2[i, :]));
        end for;

        p3 := dzp1.k*p1 + dzp2.k*p2;
        k := p3.c[1];
        numZeros := Polynomial.roots(p3);
        result := DiscreteZerosAndPoles(numZeros, dummy, k, dzp1.Ts, dzp1.method);

        result.d1 := cat(
          1,
          dzp1.d1,
          dzp2.d1);
        result.d2 := cat(
          1,
          dzp1.d2,
          dzp2.d2);
      end if;

    end '+';

    encapsulated operator function '^'
      "Integer power of DiscreteZerosAndPoles (dzp^k)"

      import Modelica;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;

      input DiscreteZerosAndPoles dzp;
      input Integer k;

      output DiscreteZerosAndPoles result(
        redeclare Real n1[k*size(dzp.n1, 1)],
        redeclare Real n2[k*size(dzp.n2, 1),2],
        redeclare Real d1[k*size(dzp.d1, 1)],
        redeclare Real d2[k*size(dzp.d2, 1),2]) "= dzp^k";
  protected
      Integer size_n1=size(dzp.n1, 1);
      Integer size_d1=size(dzp.d1, 1);
      Integer size_n2=size(dzp.n2, 1);
      Integer size_d2=size(dzp.d2, 1);
    algorithm
      result.Ts := dzp.Ts;
      result.method := dzp.method;
      for i in 1:k loop
        result.n1[(i - 1)*size_n1 + 1:i*size_n1] := dzp.n1;
        result.d1[(i - 1)*size_d1 + 1:i*size_d1] := dzp.d1;
        result.n2[(i - 1)*size_n2 + 1:i*size_n2, :] := dzp.n2;
        result.d2[(i - 1)*size_d2 + 1:i*size_d2, :] := dzp.d2;
      end for;
      result.k := dzp.k^k;

    end '^';

    encapsulated operator function '=='
      "Check whether two discreteZerosAndPoles transfer functions are identical"
      import Modelica;
      import Modelica.Math;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;

      input DiscreteZerosAndPoles dzp1;
      input DiscreteZerosAndPoles dzp2;
      input Real eps(min=0) = 0
        "Two numbers n1 and n2 are identical if abs(n1-n2) <= eps";

      output Boolean result "= dzp1 == dzp2";
    algorithm
      result := Math.Vectors.isEqual(dzp1.n1,dzp2.n1,eps) and Math.Vectors.isEqual(dzp1.d1,dzp2.d1,eps) and Math.Matrices.isEqual(dzp1.n2,dzp2.n2,eps) and Math.Matrices.isEqual(dzp1.d2,dzp2.d2,eps) and (dzp1.k==dzp2.k) and abs(dzp1.Ts-dzp2.Ts)<=eps;

    end '==';

    encapsulated operator function 'String'
      "Transform DiscreteZerosAndPoles transfer function into a String representation"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;
      import Modelica_LinearSystems2.ZerosAndPoles;
      import Modelica_LinearSystems2.Utilities.Types.Method;

      input DiscreteZerosAndPoles dzp
        "DiscreteZerosAndPoles transfer function to be transformed in a String representation";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      input String name="q" "Independent variable name used for printing";
      output String s="";
  protected
      Integer num_order=size(dzp.n1, 1) + 2*size(dzp.n2, 1);
      Integer den_order=size(dzp.d1, 1) + 2*size(dzp.d2, 1);
    algorithm
      if num_order == 0 and den_order == 0 then
        s := String(dzp.k);

      else
         // construct string for multiplicative factor
        if dzp.k <> 1.0 or dzp.k == 1.0 and num_order == 0 then
          s := String(dzp.k);
          if num_order <> 0 then
            s := s + "*";
          end if;
        end if;

        if num_order <> 0 then
            // construct numerator string
          s := s + ZerosAndPoles.Internal.firstOrderToString(
                dzp.n1,
                significantDigits,
                name);
          if size(dzp.n2, 1) <> 0 then
            s := if size(dzp.n1, 1) > 0 then s + "*" +
              ZerosAndPoles.Internal.secondOrderToString(
                  dzp.n2,
                  significantDigits,
                  name) else s + ZerosAndPoles.Internal.secondOrderToString(
                  dzp.n2,
                  significantDigits,
                  name);
          end if;
        end if;

        if den_order <> 0 then
            // construct denominator string
          s := s + "/";
          if den_order > 1 then
            s := s + "( ";
          end if;
          s := s + ZerosAndPoles.Internal.firstOrderToString(
                dzp.d1,
                significantDigits,
                name);
          if size(dzp.d2, 1) <> 0 then
            if size(dzp.d1, 1) > 0 then
              s := s + "*";
            end if;
            s := s + ZerosAndPoles.Internal.secondOrderToString(
                  dzp.d2,
                  significantDigits,
                  name);
          end if;
          if den_order > 1 then
            s := s + " )";
          end if;
        end if;
      end if;
      s := s +"\n    Ts = " + String(dzp.Ts) + "\n    method ="+ Modelica_LinearSystems2.Internal.methodString(dzp.method);
      //    end toString;
    end 'String';

    encapsulated function q
      "Generate the DiscreteZerosAndPoles transfer function q"
      import Modelica;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteZerosAndPoles;

      input Modelica.Units.SI.Time Ts=0;
      output DiscreteZerosAndPoles dzp(
        redeclare Real n1[1],
        redeclare Real n2[0,2],
        redeclare Real d1[0],
        redeclare Real d2[0,2]);
    algorithm
      dzp.n1[1] := 0;
      dzp.Ts := Ts;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
q = DiscreteZerosAndPoles.<b>q</b>()
</pre></blockquote>

<h4>Description</h4>
<p>
Generate the complex Laplace variable q=exp(s*T) as a discrete zeros and poles transfer function. It can be used for generating like
</p>
<blockquote><pre>
DiscreteZerosAndPoles dzp = q/(q^2 + q + 1)/(q + 1)
</pre></blockquote>
</html>"));
    end q;

    encapsulated package Analysis
      "Package of functions to analyse discrete zeros-and-poles description represented by a DiscreteZerosAndPoles record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function timeResponse
        "Calculate the time response of a discrete zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        extends Modelica_LinearSystems2.Internal.timeResponseMask_zp_discrete;  // Input/Output declarations of discrete time response functions
        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step;
        input Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=zeros(DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))
          "Initial state vector";

    protected
        DiscreteStateSpace dss=DiscreteStateSpace(dzp);
        Real tSpanVar;

      algorithm
        // set sample time
          if tSpan == 0 then
            tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
          else
            tSpanVar := tSpan;
          end if;

          (y,t,x_discrete) := DiscreteStateSpace.Analysis.timeResponse(
              dss=dss,
              tSpan=tSpanVar,
              response=response,
              x0=x0);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x)=DiscreteZerosAndPoles.Analysis.<b>timeResponse</b>(dzp, tSpan, responseType, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the DiscreteZerosAndPoles record is transformed into discrete
state space representation which is given to DiscreteStateSpace.Analysis.timeResponse
to calculate the time response of the state space system. The type of the time
response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
Impulse \"Impulse response\",
Step \"Step response\",
Ramp \"Ramp response\",
Initial \"Initial condition response\"
</pre></blockquote>
<p>
Starting at x(t=0)=x0 and y(t=0)=C*x0 + D*u0, the outputs y and x are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  q=Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=1/(q^2 + q + 1)
  dzp.Ts=0.1;

  Real tSpan= 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[2]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.timeResponse(dzp,tSpan, response,x0);
//  y[:,1,1]={0, 0, 1, 0, 0}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0, 3.0, 0, 0}
</pre></blockquote>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse
        "Calculate the impulse time response of a discrete zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_zp_discrete;

    protected
        Real tSpanVar;
      algorithm

      // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dzp));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteZerosAndPoles.Analysis.timeResponse(
            dzp=dzp,
            tSpan=tSpanVar,
            response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
            x0=zeros(DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x)=DiscreteZerosAndPoles.Analysis.<b>impulseResponse</b>(dzp, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>impulseResponse</b> calculates the time response of
a DiscreteZerosAndPoles transfer function with impulse imput.
After transforming the DiscreteZerosAndPoles representation to
DiscreteStateSpace the values of the impulse response are calculated
starting from
<b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0 for each time step t=k*dt.
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.impulseResponse(dzp, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.timeResponse(dzp, tSpan, response=Types.TimeResponse.Impulse, x0=fill(0,DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=dzp=1/(q^2 + q + 1)
  dzp.Ts=0.1;

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.impulseResponse(dzp,tSpan);
//  y[:,1,1]={0, 0, 1, -1.0, 2.96059473233375E-016}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1]={0, 0, 3.0, -3.0, 8.88178419700125E-016}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.timeResponse\">DiscreteZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse
        "Calculate the step time response of a discrete zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_zp_discrete;

    protected
        Real tSpanVar;
      algorithm

      // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(DiscreteStateSpace(dzp));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteZerosAndPoles.Analysis.timeResponse(
              dzp=dzp,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x)=DiscreteZerosAndPoles.Analysis.<b>stepResponse</b>(dzp, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>stepResponse</b> calculates the step response of a DiscreteZerosAndPoles transfer function.
The system is transformed to a DiscreteStateSapce system and starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0,
the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.stepResponse(dzp, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.timeResponse(dzp, tSpan, response=Types.TimeResponse.Step, x0=fill(0,DiscreteZerosAndPoles.Analysis.denominatorDegree(zp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=dzp=1/(q^2 + q + 1)
  dzp.Ts=0.1;

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.stepResponse(dzp,tSpan);
//  y[:,1,1] = {0, 0, 1, 0, 2.96059473233375E-016}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0, 0, 3.0, 0, 8.88178419700125E-016}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.timeResponse\">DiscreteZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end stepResponse;

      encapsulated function rampResponse
        "Calculate the ramp time response of a discrete zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_zp_discrete;

    protected
        Real tSpanVar;
      algorithm

      // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dzp));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteZerosAndPoles.Analysis.timeResponse(
            dzp=dzp,
            tSpan=tSpanVar,
            response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
            x0=zeros(DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x)=DiscreteZerosAndPoles.Analysis.<b>rampResponse</b>(ss, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rampResponse</b> calculates the time response of a DiscreteZerosAndPoles transfer function for ramp imput u = t.
The system is transformed to DiscreteStateSpace state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.rampResponse(dzp, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.timeResponse(dzp, tSpan, response=Types.TimeResponse.Ramp, x0=fill(0,DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=dzp=1/(q^2 + q + 1)
  dzp.Ts=0.1;

  Real tSpan= 0.4;

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.rampResponse(dzp,tSpan);
//  y[:,1,1] = {0, 0, 0, 0.1, 0.1}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1 = {0, 0, 0, 0.3, 0.3}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.timeResponse\">DiscreteZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the initial time response of a discrete zeros-and-poles transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input Real x0[:]=fill(0, 0) "Initial state vector";

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_zp_discrete;

    protected
        Real tSpanVar;
      algorithm

      // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dzp));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteZerosAndPoles.Analysis.timeResponse(
            dzp=dzp,
            tSpan=tSpanVar,
            response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
            x0=x0);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x)=DiscreteZerosAndPoles.Analysis.<b>initialResponse</b>(zp, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>initialResponse</b> calculates the time response of a state space system for given initial condition and zero inputs.
The system is transformed a appropriate discrete state space system and, starting at <b>x</b>(t=0)=<b>0</b> and <b>y</b>(t=0)=<b>C</b>*<b>x</b>0 + <b>D</b>*<b>u</b>0, the outputs <b>y</b> and <b>x</b> are calculated for each time step t=k*dt.
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.initialResponse(x0, dzp, tSpan)
</pre></blockquote>
<p>
gives the same result as
</p>
<blockquote><pre>
DiscreteZerosAndPoles.Analysis.timeResponse(dzp, tSpan, response=Types.TimeResponse.Initial, x0=x0).
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=dzp=1/(p^2 + p + 1)
  dzp.Ts=0.1;
  Real tSpan= 0.4;
  Real x0[2] = {1,1};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  (y,t,x):=Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.initialResponse(x0,dzp,tSpan);
//  y[:,1,1 = {0.333333333333, 0.333333333333, -0.666666666667, 0.333333333333,  0.333333333333}
//         t={0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {1, 1, -2.0, 1.0, 1}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.timeResponse\">DiscreteZerosAndPoles.Analysis.timeResponse</a>
</p>
</html>"));
      end initialResponse;

      encapsulated function denominatorDegree
        "Return denominator degree of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteZerosAndPoles dzp
          "DiscreteZerosAndPoles transfer function of a system";
        output Integer result;
      algorithm
        result := size(dzp.d1, 1) + 2*size(dzp.d2, 1);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = DiscreteZerosAndPoles.Analysis.<b>denominatorDegree</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>denominatorDegree</b> calculates the degree of
the denominator polynomial constituted by the first and second order
polynomials of the DiscreteZeroAndPoles denominator.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles p = Modelica_LinearSystems2.DiscreteZerosAndPoles.p();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q+0.1)/(p^2 + 0.8*p+ 0.2);

  Real dDegree;

<b>algorithm</b>
  dDegree := DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp);
//  dDegree = 2
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.numeratorDegree\">DiscreteZerosAndPoles.Analysis.numeratorDegree</a>
</p>
</html>"));
      end denominatorDegree;

      encapsulated function numeratorDegree
        "Return numerator degree of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteZerosAndPoles dzp
          "DiscreteZerosAndPoles transfer function of a system";
        output Integer result;
      algorithm
        result := size(dzp.n1, 1) + 2*size(dzp.n2, 1);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = DiscreteZerosAndPoles.Analysis.<b>numeratorDegree</b>(zp)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>numeratorDegree</b> calculates the degree
of the numerator polynomial constituted by the first and second
order polynomials of the DiscreteZeroAndPoles numerator.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q+0.1)/(p^2 + 0.8*p - 0.2);

  Real nDegree;

<b>algorithm</b>
  nDegree := DiscreteZerosAndPoles.Analysis.numeratorDegree(dzp);
//  nDegree = 1
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.denominatorDegree\">DiscreteZerosAndPoles.Analysis.denominatorDegree</a>.
</p>
</html>"));
      end numeratorDegree;

      encapsulated function evaluate
        "Evaluate a DiscreteZerosAndPoles transfer function at a given value of q"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input DiscreteZerosAndPoles dzp
          "DiscreteZerosAndPoles transfer function of a system";
        input Complex q=Complex(0) "Complex value q where dzp is evaluated";
        input Real den_min=0 "|denominator(p)| is limited by den_min";
        output Complex y "= zp(p)";
    protected
        Complex j = Modelica_LinearSystems2.Math.Complex.j();
        Complex num;
        Complex den;
        Real abs_den;
      algorithm
        // Build numerator
        num := dzp.k+0*j;
        for i in 1:size(dzp.n1, 1) loop
           num := num*ZerosAndPoles.Internal.'p+a'(q, dzp.n1[i]);
        end for;
        for i in 1:size(dzp.n2, 1) loop
           num := num*ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'(q, dzp.n2[i, :]);
        end for;

        // Build denominator
        den := 1+0*j;
        for i in 1:size(dzp.d1, 1) loop
          den := den*ZerosAndPoles.Internal.'p+a'(q, dzp.d1[i]);
        end for;
        for i in 1:size(dzp.d2, 1) loop
          den := den*ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'(q, dzp.d2[i, :]);
        end for;

        // Build value of transfer function
        abs_den := Complex.'abs'(den);
        den := if abs_den >= den_min then den else -abs_den+0*j;
        y := num/den;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = DiscreteZerosAndPoles.Analysis.<b>evaluate</b>(dzp,q)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>evaluate</b> evaluates the DiscreteZerosAndPoles
transfer function at a given (complex) value of q.
The transfer function G(z)=N(q)/D(q) is evaluated by calculating the
numerator polynomial N(z) and the denominator polynomial D(q).
</p>

<h4>Example</h4>
<blockquote><pre>
  Complex j = Modelica_LinearSystems2.Math.Complex.j();
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q+1)/(q^2+q+1);

  Complex result;

<b>algorithm</b>
  result := Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.evaluate(dzp, j+1);
//  result = 0.538462 - 0.307692j
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.Math.Polynomial.evaluateComplex\">Math.Polynomial.evaluateComplex</a>
</p>
</html>"));
      end evaluate;

    end Analysis;

    encapsulated package Design
      "Package of functions to design discrete zeros-and-poles controllers and observers"
      import Modelica;
      extends Modelica.Icons.Package;

    end Design;

    encapsulated package Plot
      "Package of functions to plot discrete zeros and poles description responses"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function bode
        "Plot discrete zeros a-and-poles transfer function as bode plot"
        import Modelica;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Utilities.Plot;
        import Modelica.Units.SI;

        input DiscreteZerosAndPoles dzp
          "DiscreteZerosAndPoles function to be plotted";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true "True, if abszissa range is automatically determined";
        input SI.Frequency f_min(min=0) = 0.1 "Minimum frequency value, if autoRange = false"
          annotation(Dialog(enable=not autoRange));
        input SI.Frequency f_max(min=0) = 10 "Maximum frequency value, if autoRange = false"
          annotation(Dialog(enable=not autoRange));

        input Boolean magnitude=true "= true, to plot the magnitude of dzp"
          annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot the pase of dzp" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot(
            heading="Bode plot: " + String(dzp)));

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)"
          annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))"
          annotation(choices(checkBox=true),Dialog(enable=magnitude));

    protected
        SI.AngularVelocity w[nPoints];
        Complex z[nPoints];
        SI.Frequency f[nPoints];
        Modelica.Units.NonSI.Angle_deg phi[nPoints];
        Real A[nPoints];
        Boolean OK;
        Complex c;
        SI.Angle phi_old;
        Complex numZeros[:];
        Complex denZeros[:];
        Complex numZerosZ[:];
        Complex denZerosZ[:];
        ZerosAndPoles zp=ZerosAndPoles(k=dzp.k, n1=dzp.n1, n2=dzp.n2, d1=dzp.d1, d2=dzp.d2);

        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2[2];

      algorithm
        // Determine frequency vector f
        if autoRange then
           (numZerosZ,denZerosZ) := ZerosAndPoles.Analysis.zerosAndPoles(zp);
        else
          numZerosZ := fill(Complex(0), 0);
          denZerosZ := fill(Complex(0), 0);
        end if;

        numZeros := fill(Complex(0),0);
        denZeros := fill(Complex(0),size(denZerosZ,1));
        for i in 1:size(denZerosZ,1) loop
          denZeros[i] := Complex.log(denZerosZ[i])/dzp.Ts;
        end for;

        f := Internal.frequencyVector(
              nPoints,
              autoRange,
              f_min,
              f_max,
              numZeros,
              denZeros);

        // Compute magnitude/phase at the frequency points
        phi_old := 0.0;
        for i in 1:nPoints loop
          w[i] := Modelica.Units.Conversions.from_Hz(f[i]);
          z[i] := Complex.exp(Complex(0,w[i]*dzp.Ts));
          c := ZerosAndPoles.Analysis.evaluate(
                zp,
                z[i],
                1e-10);
          A[i] := Complex.'abs'(c);
          phi_old := Complex.arg(c, phi_old);
          phi[i] := Modelica.Units.Conversions.to_deg(phi_old);

          // Convert to other units, if required
          if not Hz then
             f[i] := w[i];
          end if;
          if dB then
             A[i] := 20*log10(A[i]);
          end if;
        end for;

        // Plot computed frequency response
        diagram2 := fill(defaultDiagram, 2);
        i := 0;
        if magnitude then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=A,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := if dB then "magnitude [dB]" else "magnitude";
          if phase then
             diagram2[i].xLabel:="";
          end if;
          if dB then
             diagram2[i].logY := false;
          end if;
        end if;

        if phase then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=phi,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := "phase [deg]";
          diagram2[i].logY := false;
          if magnitude then
            diagram2[i].heading:="";
         end if;
        end if;

        if not Hz then
          diagram2[i].xLabel:="Angular frequency [rad/s]";
        end if;

        if magnitude and phase then
          Plot.diagramVector(diagram2, device);
        else
          Plot.diagram(diagram2[1], device);
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>bode</b>(dzp)
   or
DiscreteZerosAndPoles.Plot.<b>bode</b>(
  dzp,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>() )
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a DiscreteZerosAndPoles transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/( (q - 0.8)*(q - 0.75) )

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.plotBode(dzp)
//  gives:
</pre></blockquote>

<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/dBbodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/dBodePhase.png\">
</p>
</html>"));
      end bode;

      encapsulated function timeResponse
        "Plot the time response of a system represented by a discrete zeros-and-poles transfer function. The response type is selectable"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.DiscreteZerosAndPoles dzp;
      //  input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "Type of time response";
        input Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=zeros(
          DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))
          "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Time response of  dzp = " + String(dzp)));

    protected
        Plot.Records.Curve curve;
        Plot.Records.Diagram diagram2;
        Real y[:,1,1] "Output response";
        Real t[:] "Time vector: (number of samples)";

        Real yy[:] "Output response";
        Real tt[:] "Time vector: (number of samples)";

      algorithm
        (y,t) := DiscreteZerosAndPoles.Analysis.timeResponse(
          dzp,
          tSpan,
          response,
          x0);

        tt := fill(0,2*size(t,1)-1);
        yy := fill(0,2*size(t,1)-1);

        for i in 1:size(t,1)-1 loop
          tt[2*i-1] := t[i];
          tt[2*i] := t[i+1];
          yy[2*i-1] := y[i,1,1];
          yy[2*i] := y[i,1,1];
        end for;
        tt[size(tt,1)] := t[size(t,1)];
        yy[size(tt,1)] := y[size(t,1),1,1];

        curve := Plot.Records.Curve(
          x=tt,
          y=yy,
          legend="y",
          autoLine=true);
        diagram2 := defaultDiagram;
        diagram2.curve := {curve};

        Plot.diagram(diagram2, device);
        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>timeResponse</b>(dzp);
   or
DiscreteZerosAndPoles.Plot.<b>timeResponse</b>(
  dzp,
  tSpan,
  response,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the time response of a discrete zeros and poles transfer
function. The character of the time response if defined by the input
<a href=\"modelica://Modelica_LinearSystems2.Types.TimeResponse\">response</a>,
i.e. Impulse, Step, Ramp, or Initial.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/( (q - 0.8)*(q - 0.75) )
  dzp.Ts = 0.1;

  Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;

<b>algorithm</b>
   Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse(dzp, tSpan=3, response=response)
//  gives:
</pre></blockquote>

<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/DiscreteZerosAndPoles/timeResponseDZP.png\">
</p>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end timeResponse;

      encapsulated function impulse
        "Impulse response plot of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteZerosAndPoles dzp "zeros-and-poles transfer function";
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Impulse response of  zp = "+String(dzp)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse "Type of time response";
        Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=zeros(
          DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))
          "Initial state vector";

      algorithm
      // set sample time
        Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse(
          dzp=dzp,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>impulse</b>(dzp)
   or
DiscreteZerosAndPoles.Plot.<b>impulse</b>(
  dzp,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the impulse response of a discrete zeros-and-poles transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/( (q - 0.8)*(q - 0.75) )
  dzp.Ts = 0.1;

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.impulse(dzp, tSpan=2)
//  gives:
</pre></blockquote>

<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/DiscreteZerosAndPoles/impulseResponseDZP.png\">
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end impulse;

      encapsulated function step
        "Step response plot of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteZerosAndPoles dzp;
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Step response of  dzp = "+ String(dzp)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=zeros(
          DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))
          "Initial state vector";
      algorithm
        DiscreteZerosAndPoles.Plot.timeResponse(
          dzp=dzp,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>step</b>(dzp)
   or
DiscreteZerosAndPoles.Plot.<b>step</b>(
  dzp,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the step response of a transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/((q - 0.8)*(q - 0.75));
  dzp.Ts = 0.1;

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.step(dzp, tSpan=3)
  // gives:
</pre></blockquote>

<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/DiscreteZerosAndPoles/stepResponseDZP.png\">
</p>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.ramp\">ramp</a>,
<a href=\"Modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end step;

      encapsulated function ramp
        "Ramp response plot of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteZerosAndPoles dzp;
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Ramp response of  dzp = " + String(dzp)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";

        Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=zeros(
          DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp))
          "Initial state vector";
      algorithm
        Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse(
          dzp=dzp,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>ramp</b>(dzp)
   or
DiscreteZerosAndPoles.Plot.<b>ramp</b>(
  dzp,
  tSpan,
  x0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the ramp response of a zeros-and-poles transfer function. It is based on
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles p = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/( (q - 0.8)*(q - 0.75) )
  dzp.Ts = 0.1;

<b>algorithm</b>
  Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.ramp(dzp)
  //  gives:
</pre></blockquote>
<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/DiscreteZerosAndPoles/rampResponseDZP.png\">
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.initialResponse\">initialResponse</a>
</p>
</html>"));
      end ramp;

      encapsulated function initialResponse
        "Initial condition response plot of a discrete zeros-and-poles transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.DiscreteZerosAndPoles dzp;
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";
        input Real y0 "Initial output (for initial condition plot)";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Initial response of  dzp = " + String(dzp) + "  with y0 = " + String(y0)));

    protected
        Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(dzp);
        Real x0[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)]=
            Modelica.Math.Matrices.equalityLeastSquares(
            dss.A,
            fill(0, size(dss.B, 1)),
            dss.C,
            vector(y0)) "Initial state vector (for initial condition plot)";
      algorithm
        Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse(
              dzp=dzp,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
DiscreteZerosAndPoles.Plot.<b>initialResponse</b>(zp)
   or
DiscreteZerosAndPoles.Plot.<b>initialResponse</b>(
  zp,
  tSpan,
  y0,
  columnLabels,
  defaultDiagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros\">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>())
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the initial response, i.e. the zeros input response of a zeros and poles transfer function. It is based on <a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.timeResponse\">timeResponse</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q^2 - 1.5*q + 0.6)/( (q - 0.8)*(q - 0.75) )
  Real y0=1;
  dzp.Ts = 0.02;

  Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.initialResponseZP(dzp, y0=y0, tSpan=1)
  // gives:
</pre></blockquote>

<p>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/DiscreteZerosAndPoles/initialResponseDZP.png\">
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.impulse\">impulse</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.step\">step</a>,
<a href=\"modelica://Modelica_LinearSystems2.DiscreteZerosAndPoles.Plot.ramp\">ramp</a>
</p>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of DiscreteZerosAndPoles data record"
      import Modelica_LinearSystems2;
      import Modelica;
      extends Modelica.Icons.Package;

      function toDiscreteTransferFunction
        "Generate a DiscreteTransferFunction object from a DiscreteZerosAndPoles object"

        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.Math.Complex;

        input DiscreteZerosAndPoles dzp
          "DiscreteZerosAndPoles transfer function of a system";
        output Modelica_LinearSystems2.DiscreteTransferFunction dtf;

    protected
        ZerosAndPoles zp=ZerosAndPoles(k=dzp.k, n1=dzp.n1, n2=dzp.n2, d1=dzp.d1, d2=dzp.d2);
        Real k;
        Complex z[:];
        Complex p[:];
        Polynomial pn;
        Polynomial pd;
      algorithm
        (z,p,k) := ZerosAndPoles.Analysis.zerosAndPoles(zp);
        pn := Polynomial(z)*Polynomial(k);
        pd := Polynomial(p);
        dtf.n := pn.c;
        dtf.d := pd.c;
        dtf.Ts := dzp.Ts;
        dtf.method := dzp.method;
        dtf.uName := dzp.uName;
        dtf.yName := dzp.yName;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dtf = DiscreteZerosAndPoles.Conversion.<b>toDiscreteTransferFunction</b>(dzp)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a DiscreteTransferFunction record
</p>
<blockquote><pre>
       n(z)     b0 + b1*z + ... + bn*z^n
dtf = ------ = --------------------------
       d(z)     a0 + a1*z + ... + an*z^n
</pre></blockquote>
<p>
from a DiscreteZerosAndPoles record representated by first and second order numerator and denominator polynomials. The poles and zeros and the gain <tt>k</tt> are computed (<a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Analysis.zerosAndPoles\">zerosAndPoles</a>) and are used as inputs in the DiscreteTransferFunction constructor.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp = 1/(q + 3)/(q + 1)

<b>algorithm</b>
  dtf:=Modelica_LinearSystems2.DiscreteZerosAndPoles.Conversion.toDiscreteTransferFunction(dzp);
//  dtf = 1/(z^2 + 4*z + 3)
</pre></blockquote>
</html>"));
      end toDiscreteTransferFunction;

      function toDiscreteStateSpace
        "Transform a DiscreteZerosAndPoles object into a DiscreteStateSpace object"
        //encapsulated function fromZerosAndPoles
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.Math.Vectors;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteZerosAndPoles dzp
          "ZerosAndPoles transfer function of a system";
        output DiscreteStateSpace dss(
          redeclare Real A[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp),
            DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)],
          redeclare Real B[DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp),1],
          redeclare Real C[1,DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp)],
          redeclare Real D[1,1]) "Transfer function in StateSpace SISO form";

    protected
        Real A[2,2] "system matrix of partial 2nd order system";
        Real B[2,1] "input matrix of partial 2nd order system";
        Real C[1,2] "output matrix of partial 2nd order system";
        Real D[1,1] "feedthrough matrix of partial 2nd order system";
        Real a "system 'matrix' of partial 1st order system";
        Real b "input 'matrix' of partial 1st order system";
        Real c "output 'matrix' of partial 1st order system";
        Real d "feedthrough 'matrix' of partial 1st order system";
        Real aa "a2 + a1 +1";
        Real bb "b2 + b1 +1";
        Integer nx=max(DiscreteZerosAndPoles.Analysis.numeratorDegree(dzp),DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp));
        Integer n_num1=size(dzp.n1, 1);
        Integer n_num2=size(dzp.n2, 1);
        Integer n_den1=size(dzp.d1, 1);
        Integer n_den2=size(dzp.d2, 1);
        Integer n_num=n_num1 + 2*n_num2;
        Integer n_den=n_den1 + 2*n_den2;

        Integer i_d=if n_num2 > n_den2 then 2*(n_num2 - n_den2) + 1 else 1;
        Integer i_k=if n_num2 > n_den2 then n_den2 - (n_num2 - n_den2) else n_den2;
        Integer i;
        Integer ili=if max(n_den2, n_num2) > 0 then i_d else  max(2, i_d);
        Real num[nx,2]=[dzp.n2; [dzp.n1,zeros(n_num1)]; zeros(max(0,nx - n_num2 - n_num1), 2)]
          "Numerator matrix, in order that indices are defined in all situations in all if clauses";
        Real den[nx,2]=[dzp.d2; [dzp.d1,zeros(n_den1)]; zeros(max(0,nx - n_den2 - n_den1), 2)]
          "Denominator matrix, in order that indices are defined in all situations in all if clauses";
        Real k[i_k + n_den1](each fixed=false)
          "Additional factors of the first and second order blocks, in order that the gain of the blocks is 1";
        Real k_total;
        Real eps=1e-5;//100*Modelica.Constants.eps;

        Boolean dZero=true;

      algorithm
        assert(n_num <= n_den,
          "DiscreteZerosAndPoles transfer function is not proper as required from StateSpace system:\n"
           + "  numerator degree (= " + String(n_num) +
          ") <= denominator degree (= " + String(n_den) + ") required.");

        if n_den > 0 then
          for i in 1:max(n_den2, n_num2) loop
            // State space systems of order 2
            if i <= n_den2 then
              if i <= n_num2 then
                  // State space system in form (1)
                k[i] := DiscreteZerosAndPoles.Internal.scaleFactor2(
                    num[i, 1],
                    num[i, 2],
                    den[i, 1],
                    den[i, 2],eps);
              elseif 2*(i - n_num2) <= n_num1 then
                  // State space system in form (1) with 2 first order numerator polynomials
                k[i] := DiscreteZerosAndPoles.Internal.scaleFactor2(
                    num[2*(i - n_num2)-1, 1] + num[2*(i - n_num2), 1],
                    num[2*(i - n_num2)-1, 1]*num[2*(i - n_num2), 1],
                    den[i, 1],
                    den[i, 2],eps);
              elseif  2*(i-n_num2) -1== n_num1 then
                  // State space system in form (2) with 1 first order numerator polynomial
                k[i] := DiscreteZerosAndPoles.Internal.scaleFactor2(
                    0,
                    num[2*i-n_num2-1, 1],
                    den[i, 1],
                    den[i, 2],eps);
               else
                  // State space system in form (3)
                k[i] := DiscreteZerosAndPoles.Internal.scaleFactor2(
                    0,
                    0,
                    den[i, 1],
                    den[i, 2],eps);
              end if;
            else
               // State space system in form (1) with 2 first order denominator polynomials

              k[i] := DiscreteZerosAndPoles.Internal.scaleFactor2(
                  num[i, 1],
                  num[i, 2],
                  den[2*(i - n_den2)-1, 1] + den[2*(i - n_den2), 1],
                  den[2*(i - n_den2)-1, 1]*den[2*(i - n_den2), 1],eps);
            end if;
          end for;

          for i in i_d:n_den1 loop
            // State space systems of order 1
            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := DiscreteZerosAndPoles.Internal.scaleFactor1(num[max(1, n_num2 + 2*(n_den2 -
                n_num2) + i), 1], den[n_den2 + i, 1],eps);
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
               // State space system in form (4)
              k[i_k + i] := DiscreteZerosAndPoles.Internal.scaleFactor1(num[max(1, n_num2 + i - i_d + 1),
                1], den[n_den2 + i, 1],eps);
            else
               // State space system in form (5)
              k[i_k + i] := DiscreteZerosAndPoles.Internal.scaleFactor1(0, den[n_den2 + i, 1],eps);
            end if;
          end for;

          k_total := dzp.k/product(k);

          dss.A := zeros(nx, nx);
          dss.B := zeros(nx, 1);
          dss.C := zeros(1, nx);
          dss.D := zeros(1, 1);

        // Calculation of matrices A, B, C, D
        //first elements of A, B, C and D

          if max(n_den2, n_num2) > 0 then

            A[1, :] := {0,1};
            B[1, 1] := 0;
                // Construct state space systems of order 2
            if 1 <= n_den2 then
              aa := num[1, 2] + num[1, 1] +1;
              bb := den[1, 2] + den[1, 1] +1;
              A[2, :] := {-den[1, 2],-den[1, 1]};
              B[2, 1] := if abs(bb)>eps and abs(aa)>eps then bb else 1;
              if 1 <= n_num2 then
                     // State space system in form (1)
                C := if abs(bb)>eps and abs(aa)>eps then k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]]/bb else k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;

              elseif 1 - n_num2 + 1 <= n_num1 then
                     // State space system in form (1) with 2 first order numerator polynomials
                aa := num[1, 1]*num[2, 1] + num[1, 1] + num[2, 1];
                B[2, 1] := if abs(bb)>eps  and abs(aa)>eps then bb else 1;
                C := if abs(bb)>eps and abs(aa)>eps then k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]]/bb else k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]];
                D := [k[1]];
                dZero := false;
              elseif 1 - n_num2 == n_num1 then
                     // State space system in form (2) with 1 first order numerator polynomial
                aa := num[1, 1] + 1;
                B[2, 1] := if abs(bb)>eps  and abs(aa)>eps then bb else 1;
                C := if abs(bb)>eps  and abs(aa)>eps then k[1]*[num[1, 1],1]/bb else k[1]*[num[1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                     // State space system in form (3)
                B[2, 1] := if abs(bb)>eps  and abs(aa)>eps then bb else 1;
                C := if abs(bb)>eps  and abs(aa)>eps then  k[1]*[1,0]/bb else k[1]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;
           else
                  // State space system in form (1) with 2 first order denominator polynomials
              bb := den[1, 1] + den[2, 1] + den[1, 1]*den[2, 1] + 1;
              A[2, :] := {-(den[1, 1]*den[2, 1]),-(den[1, 1] + den[2, 1])};
              B[2, 1] := if abs(bb)>eps then bb else 1;
              C := if abs(bb)>eps then  k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])]/bb else k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])];
              D := [k[1]];
              dZero := false;
            end if;

            dss.A[1:2, 1:2] := A;
            dss.B[1:2, 1] := vector(B);
            dss.C[1, 1:2] := vector(C);
            dss.D := D;

          else
            aa := num[1,1]+1;
            bb := den[1,1]+1;
            a := -den[1, 1];
            if 1 <= n_num1 then
              // State space system in form (4)
              b := if abs(bb)>eps then bb else num[1,1]-den[1,1];
              c := if abs(bb)>eps then k[1]*(num[1, 1] - den[1, 1])/bb else k[1];
              d := k[1];
              dZero := false;
            else
             // State space system in form (5)
              b := if abs(bb)>eps then bb else if n_num1>0 then num[1,1]-den[1,1] else 1;
              c := if abs(bb)>eps then k[1]/bb else k[1];
              d := 0;
              dZero := dZero and true;
            end if;
            dss.A[1, 1] := a;
            dss.B[1, 1] := b;
            dss.C[1, 1] := c;
            dss.D[1, 1] := d;

          end if;
        /// for i=2 to degree(system)
          A[1, :] := {0,1};
          B[1, 1] := 0;
          for i in 2:max(n_den2, n_num2) loop
               // Construct state space systems of order 2
            if i <= n_den2 then
              aa := num[i, 2] + num[i, 1] +1;
              bb := den[i, 2] + den[i, 1] +1;
              A[2, :] := {-den[i, 2],-den[i, 1]};
              B[2, 1] := if abs(bb)>eps and abs(aa)>eps then bb else 1;

              if i <= n_num2 then
                     // State space system in form (1)

                C := if abs(bb)>eps and abs(aa)>eps then k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]]/bb else k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;

              elseif 2*(i - n_num2) <= n_num1 then

                // State space system in form (1) with 2 first order numerator polynomials
                aa := num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] + num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] + 1;
                C := if abs(bb)>eps and abs(aa)>eps then k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]]/bb else k[i]*[num[2*i-n_num2-1, 1]*num[2*i-n_num2, 1] - den[i, 2],num[2*i-n_num2-1, 1] + num[2*i-n_num2, 1] - den[i, 1]];
                D := [k[i]];
                dZero := false;

              elseif 2*(i-n_num2) -1== n_num1 then
              // State space system in form (2) with 1 first order numerator polynomial
                aa := num[2*i-n_num2-1, 1]+1;
              B[2, 1] := if abs(bb)>eps and abs(aa)>eps then bb else 1;
                C := if abs(bb)>eps and abs(aa)>eps then k[i]*[num[2*i-n_num2-1, 1],1]/bb else k[i]*[num[2*i-n_num2-1, 1],1];
                D := [0];
                dZero := dZero and true;
              else
                // State space system in form (3)
                B[2, 1] := if abs(bb)>eps then bb else 1;
                C := if abs(bb)>eps then k[i]*[1,0]/bb else k[i]*[1,0];
                D := [0];
                dZero := dZero and true;
              end if;

            else
                  // State space system in form (1) with 2 first order denominator polynomials
              bb := den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1] + den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1] + 1;
              A[2, :] := {-(den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),-(den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])};
              B[2, 1] := if abs(bb)>eps then bb else 1;
        //      C := if abs(bb)>eps then k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])]/den[max(2*(i-n_den2)-1,i), 1]/bb else k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])];
              C := if abs(bb)>eps then k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])]/bb else k[i]*[num[max(2*(i-n_num2),i), 2] - (den[max(2*(i-n_den2)-1,i), 1]*den[max(2*(i-n_den2),i), 1]),num[max(2*(i-n_num2),i), 1] - (den[max(2*(i-n_den2)-1,i), 1] + den[max(2*(i-n_den2),i), 1])];
              D := [k[i]];
              dZero := false;
            end if;
            dss.A[2*i, 1:2*i - 2] := B[2, 1]*dss.C[1, 1:2*i - 2];
            dss.A[2*i - 1:2*i, 2*i - 1:2*i] := A;
            dss.B[2*i, 1] := if dZero then 0 else B[2, 1]*dss.D[1, 1];
            dss.C[1, 1:2*i - 2] := if dZero then fill(0, 2*i - 2) else D[1, 1]*dss.C[
              1, 1:2*i - 2];
            dss.C[1, 2*i - 1:2*i] := vector(C);
            dss.D := D*dss.D;
          end for;
        //  for i in max(2,i_d):n_den1 loop
          for i in ili:n_den1 loop
               // Construct state space systems of order 1
            bb :=  den[n_den2 + i, 1] + 1;
            a := if abs(den[n_den2 + i, 1])>eps then -den[n_den2 + i, 1] else 0.0;

            if n_num2 <= n_den2 and 2*(n_den2 - n_num2) + i <= n_num1 then
                  // State space system in form (4)

              c := if abs(bb)>eps then k[i_k + i]*(num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1] -  den[n_den2 + i, 1])/bb else 1.0;
        //      b := if abs(bb)>eps then bb else num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1];
              b := if abs(bb)>eps then bb else num[max(1, n_num2 + 2*(n_den2 - n_num2) + i), 1]-  den[n_den2 + i, 1];
              d := k[i_k + i];
              dZero := false;
            elseif n_num2 > n_den2 and i - i_d + 1 <= n_num1 then
            // State space system in form (4)
              c := if abs(bb)>eps then k[i_k + i]*(num[max(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1])/bb else 1.0;
        //      b := if abs(bb)>eps then bb else num[max(1, n_num2 + i - i_d + 1), 1];
              b := if abs(bb)>eps then bb else num[max(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1];
              d := k[i_k + i];
              dZero := false;
            else
             // State space system in form (5)
              c := if abs(bb)>eps then k[i_k + i]/bb else k[i_k + i];
             b := if abs(bb)>eps then bb else 1;
        //      b := if abs(bb)>eps then den[n_den2 + i, 1] else 1;
              d := 0;
              dZero := dZero and true;
            end if;

      //###############################
      //        c := if abs(bb)>eps then k[1]*(num[1, 1] - den[1, 1])/bb else k[1];
      //        b := if abs(bb)>eps then bb else num[1,1]-den[1,1];
      //        d := k[1];
      //        dZero := false;
      //      else
      //       // State space system in form (5)
      //        c := if abs(bb)>eps then k[1]/bb else k[1];
      //        b := if abs(bb)>eps then bb else if n_num1>0 then num[1,1]-den[1,1] else 1;
      //        d := 0;
      //        dZero := dZero and true;
      //###############################

            dss.A[2*n_den2 + i, 1:2*n_den2 + i - 1] := b*dss.C[1, 1:2*n_den2 + i - 1];
            dss.A[2*n_den2 + i, 2*n_den2 + i] := a;
            dss.B[2*n_den2 + i, 1] := if dZero then 0 else b*dss.D[1, 1];
            dss.C[1, 1:2*n_den2 + i - 1] := if dZero then fill(0, 2*n_den2 + i - 1) else
                    d*dss.C[1, 1:2*n_den2 + i - 1];
            dss.C[1, 2*n_den2 + i] := c;
            dss.D := if dZero then [0] else d*dss.D;

            end for;

          dss.C := k_total*dss.C;
          dss.D := k_total*dss.D;
        else
          dss := DiscreteStateSpace(dzp.k);
        end if;

        dss.Ts := dzp.Ts;
        dss.method := dzp.method;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dss = DiscreteZerosAndPoles.Conversion<b>toDiscreteStateSpace</b>(dzp)
</pre></blockquote>

<h4>Description</h4>
<p>
This function transforms a discrete zeros-poles-gain system representation into the corresponding discrete state space representation.
To achieve well numerical condition the DiscreteZerosAndPoles transfer function is transformed into discrete state space
form by creating first and second order blocks that are connected
together in series. Every block is represented in controller
canonical form and scaled such that the gain from the input
of this block to its output is one (i.e. y(p=0) = u(p=0)),
if this is possible.
</p>
<p>
The construction of the state space blocks is the same as of the corresponding continuous transformation ( <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace\">ZerosAndPoles.Conversion.toStateSpace()</a>),
except for that the first order and second order systems are scaled by
</p>
<blockquote><pre>
       1 + n1
k_2 = --------
       1 + d1
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>
       1 + n2 + n2
k_2 = -------------
       1 + d2 + d2
</pre></blockquote>
<p>
respectiively.
</p>
<p>
See <a href=\"modelica://Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace\">ZerosAndPoles.Conversion.toStateSpace()</a> for more information.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteZerosAndPoles q = Modelica_LinearSystems2.DiscreteZerosAndPoles.q();
  Modelica_LinearSystems2.DiscreteZerosAndPoles dzp=(q+1)/(q^2 + q + 1);

<b>algorithm</b>
  dss := Modelica_LinearSystems2.DiscreteZerosAndPoles.Conversion.toDiscreteStateSpace(dzp);
// dss.A = [0, 1; -1, -1],
// dss.B = [0; 3],
// dss.C = [0.333, 0.333],
// dss.D = [0],
// dss.B2 = [0; 0],
</pre></blockquote>
</html>"));
      end toDiscreteStateSpace;

    end Conversion;

    encapsulated package Import
      "Package of functions to generate a DiscreteZerosAndPoles data record from imported data"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function fromFile
        "Generate a DiscreteZerosAndPoles data record by reading the polynomial coefficients or zeros and poles from a file"
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica;
        import Modelica_LinearSystems2.DataDir;

        input String fileName=DataDir + "dzp.mat" "Name of the discrete zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption="state space system data file")));

    protected
        Integer n1n2d1d2[4]=if ZerosAndPoles.Internal.checkRepresentation(
            fileName) then ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp(
            fileName) else ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc(
            fileName) annotation(__Dymola_allowForSize=true);
        Integer n1=n1n2d1d2[1] annotation(__Dymola_allowForSize=true);
        Integer n2=n1n2d1d2[2] annotation(__Dymola_allowForSize=true);
        Integer d1=n1n2d1d2[3] annotation(__Dymola_allowForSize=true);
        Integer d2=n1n2d1d2[4] annotation(__Dymola_allowForSize=true);
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2] annotation(__Dymola_allowForSize=true);
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4] annotation(__Dymola_allowForSize=true);
    public
        output DiscreteZerosAndPoles dzp(n1=fill(0, n1), n2=fill(0, n2, 2), d1=fill(0, d1), d2=fill(0, d2, 2));
      algorithm
      //Whenever this function becomes operational the code must be rewritten if fromFile_pc2 and fromFile_zp2 are in the 'constructor'

        dzp := if ZerosAndPoles.Internal.checkRepresentation(fileName) then DiscreteZerosAndPoles.Internal.fromFile_zp( fileName) else DiscreteZerosAndPoles.Internal.fromFile_pc(
          fileName);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<table>
<tr> <td align=right>  dzp </td><td align=center> =  </td>  <td> DiscreteZerosAndPoles.Import.<b>fromFile</b>(fileName)  </td> </tr>
</table>
<h4>Description</h4>
<p>
Reads and loads a discrete zeros-and-poles transfer function from a mat-file <tt>fileName</tt>. The file must contain the sample time Ts and either the set of variables n1, n2, d1, d2, and k with
the associated first and second order polynomials or the variables p, z, and k with the poles and zeros, written in two column arrays with real and imaginary in the first and
second column respectively. The variable k is the real gain in both cases.


<h4>Example</h4>
<blockquote><pre>


<b>algorithm</b>
  dzp:=Modelica_LinearSystems2.DiscreteZerosAndPoles.Import.fromFile(DataDir + "      /dzp.mat " );
//  zp = (q^2 + 2*q + 3)/(q + 2)/(q^2 + 2*q + 2)
</pre></blockquote>
</html>"));
      end fromFile;

      function fromModel
        "Generate a DiscreteZerosAndPoles data record from a state space representation resulted from linearization of a model"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input String modelName "Name of the Modelica model" annotation(Dialog(__Dymola_translatedModel(translate=true)));
        input Real T_linearize=0
          "point in time of simulation to linearize the model";
        input String fileName="dslin" "Name of the result file";
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";

    protected
        String fileName2=fileName + ".mat";
        Boolean OK1=simulateModel(problem=modelName, startTime=0, stopTime=T_linearize);
        Boolean OK2=importInitial("dsfinal.txt");
        Boolean OK3=linearizeModel(problem=modelName, resultFile=fileName, startTime=T_linearize, stopTime=T_linearize + 1);
        Real nxMat[1,1]=readMatrix(fileName2, "nx", 1, 1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny,nx + nu]=readMatrix(fileName2, "ABCD", nx + ny, nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(fileName2, "xuyName", nx + nu + ny);

        StateSpace ss(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";
        DiscreteStateSpace dss(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu],
          redeclare Real B2[nx,nu]) "= model linearized at initial point";
        DiscreteStateSpace dss_siso(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,1],
          redeclare Real C[1,nx],
          redeclare Real D[1,1],
          redeclare Real B2[nx,1]) "= model linearized at initial point";

          DiscreteZerosAndPoles dummy;

    public
        output DiscreteZerosAndPoles dzp[:,:];//=fill(dummy,ny,nu);
      algorithm
        ss.A := ABCD[1:nx, 1:nx];
        ss.B := ABCD[1:nx, nx + 1:nx + nu];
        ss.C := ABCD[nx + 1:nx + ny, 1:nx];
        ss.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        ss.uNames := xuyName[nx + 1:nx + nu];
        ss.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        ss.xNames := xuyName[1:nx];

        dss := DiscreteStateSpace(ss, Ts=Ts, method=method);

        dzp := DiscreteStateSpace.Conversion.toDiscreteZerosAndPolesMIMO(dss);

      //   for ic in 1:ny loop
      //     for ib in 1:nu loop
      //       dss_siso := DiscreteStateSpace(
      //         A=dss.A,
      //         B=matrix(dss.B[:, ib]),
      //         C=transpose(matrix(dss.C[ic, :])),
      //         D=matrix(dss.D[ic, ib]),
      //         B2=matrix(dss.B2[:, ib]),
      //         Ts=dss.Ts,
      //         method=dss.method);
      //       dzp[ic, ib] := DiscreteStateSpace.Conversion.toDiscreteZerosAndPoles(
      //         dss_siso);
      //     end for;
      //   end for;

      //
      // //    zp := StateSpace.Conversion.toZerosAndPolesMIMO(result);
      //     for i in 1:ny loop
      //       for j in 1:nu loop
      //         dzp[i,j] := DiscreteZerosAndPoles(zp=zp[i,j], Ts=Ts, method=method);
      //       end for;
      //     end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = DiscreteZerosAndPoles.Import.<b>fromModel</b>(modelName, T_linearize, fileName, Ts, method)
</pre></blockquote>

<h4>Description</h4>
<p>
Generate a matrix of DiscreteZerosAndPoles data records by
linearization of a model defined by modelName. The linearization
is performed at time T_linearize of the simulation. The system is
genrated by using <a href=\"modelica://Modelica_LinearSystems2.StateSpace.Import.fromFile\">StateSpace.Import.fromModel</a>
followed by a conversion from state space to discrete zeros-and-poles
transfer function representation.
</p>

<h4>Example</h4>
<blockquote><pre>
  String modelName = &quot;Modelica_LinearSystems2.Utilities.Plants.DoublePendulum&quot;;
  Real T_linearize = 5;
  Modelica.Units.SI.Time Ts=0.01;

<b>algorithm</b>
  dzp = Modelica_LinearSystems2.DiscreteZerosAndPoles.Import.fromModel(modelName=modelName, T_linearize=T_linearize, Ts=Ts);

//  dzp [4.48586e-006*(q^2 - 2.03695*q + 1.0381)*(q^2 - 1.9622*q + 0.963301)*(q^2 + 2*q + 1)/( (q - 1)^2*(q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal;
 //
 //    0.000897172*(q + 1)*(q^2 - 2.03695*q + 1.0381)*(q^2 - 1.9622*q + 0.963301)/( (q - 1)*(q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal;
 //
 //    -5.60444e-006*(q^2 - 1.99889*q + 1)*(q^2 + 2*q + 1)/( (q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal;
 //
 //    -0.00112089*(q - 1)*(q + 1)*(q^2 - 1.99889*q + 1)/( (q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal;
 //
 //    4.16386e-006*(q^2 - 1.99989*q + 1)*(q^2 + 2*q + 1)/( (q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal;
 //
 //    0.000832773*(q - 1)*(q + 1)*(q^2 - 1.99989*q + 1)/( (q^2 - 2.03237*q + 1.03391)*(q^2 - 1.96572*q + 0.967206) )
 //    Ts = 0.01
 //    method = Trapezoidal]
</pre></blockquote>
</html>"));
      end fromModel;

    end Import;

    encapsulated package Internal
      "Package of internal material of record DiscreteZerosAndPoles (for advanced users only)"

      import Modelica;
      import Modelica_LinearSystems2;
      extends Modelica.Icons.Package;

      function numberOfRealZeros2 "Calculate number of real zeros"
        import Modelica;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Modelica_LinearSystems2.DiscreteTransferFunction dtf
          "DiscreteTransferFunction";
        output Integer result=Internal.numberOfRealZeros(Polynomial.roots(Polynomial(dtf.n)));
      algorithm
      end numberOfRealZeros2;

      function numberOfRealPoles "Calculate number of real poles"
        import Modelica;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Modelica_LinearSystems2.DiscreteTransferFunction dtf
          "TransferFunction";
        output Integer result=Internal.numberOfRealZeros(Polynomial.roots(Polynomial(
            dtf.d)));
      algorithm
      end numberOfRealPoles;

      encapsulated function scaleFactor1
        "Return scale factor for first order block"
        import Modelica;
        input Real n "(z+n)/(z+d)";
        input Real d "(z+n)/(z+d)";
        input Real small=100*Modelica.Constants.eps;
        output Real k
          "= (d+1)/(n+1), if d+1, n+1 are not zero, otherwise special cases";
      algorithm
          k := if abs(d+1) > small  and abs(n+1) > small then abs(d+1)/abs(n+1) else 1;
      end scaleFactor1;

      function scaleFactor2 "Return scale factor for second order block"
        import Modelica;
        input Real n1 "(z^2 + n1*z + n2)/(z^2 + d1*z + d2)";
        input Real n2 "(z^2 + n1*z + n2)/(z^2 + d1*z + d2)";
        input Real d1 "(z^2 + n1*z + n2)/(z^2 + d1*z + d2)";
        input Real d2 "(z^2 + n1*z + n2)/(z^2 + d1*z + d2)";
        input Real small=100*Modelica.Constants.eps;
        output Real k
          "= (d2+d1+1)/(n2+n1+1), if numerator and denominator are not zero, otherwise special cases";
      algorithm
        k := if abs(d2+d1+1) > small and abs(n2+n1+1) > small then (d2+d1+1)/(n2+n1+1) else 1;
      end scaleFactor2;

      function findMatrixName
        "Find out whether matrix matName exists in file filename"
        input String filename;
        input String matName="z";

        output Integer m;

      external "C" m = findMatrixName(
            filename,
            matName,
            "NoClass") annotation (Include="#include <matrixop.h>
#include <matrixop.c>


#if !defined(DYMOLA_DSPACE) && !defined(NO_FILE)
#include <amat.h>
#include <sprwat.h>
#endif

extern int findMatrixName(const char* fil,const char* matname, char *noClass) {
int found=0;


#if !defined(DYMOLA_DSPACE) && !defined(NO_FILE)
{
        AmatGetFile afile;
        Amatrix amatrix;

        int ret=amatGetOpen((char*)fil,noClass,(char*)0,&afile);

        Assert(ret==0,amatError);
        for(;ret==0 && !found;)
{
                amatInit(&amatrix);
                ret=amatGetMatrix(&afile, &amatrix);
                if (ret<=1 && strcmp(matname,amatrix.name)==0)
                  found=1;
                else
                  found=0;

                amatDel(&amatrix);
        }
        amatGetClose(&afile);
}
#else
        Assert(false, 'nn');
#endif
        return found;
}");
      end findMatrixName;

      function fromRealAndImag
        "Generate a complex vector from a real part vector and imaginary part vector "

        import Modelica_LinearSystems2.Math.Complex;

        input Real real[:];
        input Real imag[size(real, 1)];
        output Complex result[size(real, 1)] "Number of real zeros";
      algorithm
        for i in 1:size(real, 1) loop
          result[i].re := real[i];
          result[i].im := imag[i];
        end for;
      end fromRealAndImag;

      encapsulated function fromFile_pc
        "Generate a DiscreteZerosAndPoles data record by reading the polynomial coefficients from a file (default file name is pc.mat)"
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica;

        input String fileName="pc.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption="state space system data file")));

    protected
        Integer n1n2d1d2[4]=ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc(fileName);
        Integer n1=n1n2d1d2[1];
        Integer n2=n1n2d1d2[2];
        Integer d1=n1n2d1d2[3];
        Integer d2=n1n2d1d2[4];
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    public
        output DiscreteZerosAndPoles dzp(
          n1=fill(0, n1),
          n2=fill(0, n2, 2),
          d1=fill(0, d1),
          d2=fill(0, d2, 2));

    protected
        Integer n1_2=if n1 > 0 then 1 else 0 "second dimension of n1-matrix";
        Integer n2_2=if n2 > 0 then 2 else 0 "second dimension of n2-matrix";
        Integer d1_2=if d1 > 0 then 1 else 0 "second dimension of d1-matrix";
        Integer d2_2=if d2 > 0 then 2 else 0 "second dimension of d2-matrix";

        Real k=scalar(readMatrix(
              fileName,
              "k",
              1,
              1));
        Real n1Vector[n1]=vector(readMatrix(
              fileName,
              "n1",
              n1,
              n1_2)) "coefficients of first order numenator polynomials";
        Real n2Matrix[n2,n2_2]=readMatrix(
              fileName,
              "n2",
              n2,
              n2_2) "coefficients of second order denominator polynomials";
        Real d1Vector[d1]=vector(readMatrix(
              fileName,
              "d1",
              d2,
              d1_2)) "coefficients of first order denominator polynomials";
        Real d2Matrix[d2,d2_2]=readMatrix(
              fileName,
              "d2",
              d2,
              d2_2) "coefficients of second order numenator polynomials";
        Real Ts[1,1]=readMatrix(fileName, "Ts", 1, 1);

      algorithm
        dzp.k := k;
        dzp.n1 := if n1 > 0 then n1Vector else fill(0, 0);
        dzp.n2 := if n2 > 0 then n2Matrix else fill(0, 0, 2);
        dzp.d1 := if d1 > 0 then d1Vector else fill(0, 0);
        dzp.d2 := if d2 > 0 then d2Matrix else fill(0, 0, 2);
        dzp.Ts := scalar(Ts);

      end fromFile_pc;

      encapsulated function fromFile_zp
        "Generate a DiscreteZerosAndPoles data record by reading poles and zeros from a file (default file name is zp.mat)"

        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.ZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.Math.Complex;

        input String fileName="dzp.mat" "Name of the zeros and poles data file"
          annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)", caption="state space system data file")));
    protected
        Integer n1n2d1d2[4]=
          ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp(fileName);
        Integer n1=n1n2d1d2[1];
        Integer n2=n1n2d1d2[2];
        Integer d1=n1n2d1d2[3];
        Integer d2=n1n2d1d2[4];
        Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
        Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    public
        output DiscreteZerosAndPoles dzp(
          n1=fill(0, n1),
          n2=fill(0, n2, 2),
          d1=fill(0, d1),
          d2=fill(0, d2, 2));

    protected
        Integer z_2=if zSize > 0 then 2 else 0 "second dimension of zeros-matrix";
        Integer p_2=if pSize > 0 then 2 else 0 "second dimension of poles-matrix";

        Real k=scalar(readMatrix(
              fileName,
              "k",
              1,
              1));
        Real zerosMatrix[zSize,z_2]=readMatrix(
              fileName,
              "z",
              zSize,
              z_2) "zeros in rows of real parts and imaginary parts";
        Real polesMatrix[pSize,p_2]=readMatrix(
              fileName,
              "p",
              pSize,
              p_2) "poles in rows of real parts and imaginary parts";
        Real Ts[1,1]=readMatrix(fileName, "Ts", 1, 1);

        Complex zeros[:]=if zSize > 0 then ZerosAndPoles.Internal.fromRealAndImag(
            zerosMatrix[:, 1], zerosMatrix[:, z_2]) else fill(Complex(0), 0);
        Complex poles[:]=if pSize > 0 then ZerosAndPoles.Internal.fromRealAndImag(
            polesMatrix[:, 1], polesMatrix[:, p_2]) else fill(Complex(0), 0);

      algorithm
        dzp := DiscreteZerosAndPoles(
            k=k,
            z=zeros,
            p=poles,
            Ts=scalar(Ts));
      end fromFile_zp;

      function isReal "Check of dzp whether it is a real number"
        extends Modelica.Icons.Function;

        import Modelica_LinearSystems2.DiscreteZerosAndPoles;

        input DiscreteZerosAndPoles dzp;
        output Boolean isReal;

      algorithm
        isReal := size(dzp.n1,1)+size(dzp.n2,1)+size(dzp.d1,1)+size(dzp.d2,1)==0;

      end isReal;
    end Internal;

    annotation (
      defaultComponentName="filter",
      Documentation(info="<html>
<p>
This record defines a discrete transfer function by its zeros, poles and a gain:
</p>
<pre>         product(q - z[i])
  y = k*------------------- * u
         product(q - n[i])
</pre>
<p>
where z[:] is a Complex vector of zeros, n[:] is a Complex
vector of poles and k is an additional multiplicative factor.
The elements of the two Complex vectors must either be real
numbers or conjugate complex pairs (in order that their product
results in a polynomial with Real coefficients).
</p>
<p>
In the record, the zeros and poles are transformed
into a product of first and second order polynomials.

</p>
<p>
A DiscreteZeroAndPole transfer function is internally stored by the coefficients
of first and second order polynomials, and by an additional
multiplicative factor k:
</p>
<pre>         product(q + n1[i]) * product(q^2 + n2[i,1]*q + n2[i,2])
  y = k*---------------------------------------------------------
         product(q + d1[i]) * product(q^2 + d2[i,1]*q + d2[i,2])
</pre>
<p>
Note, the degrees of the numerator and denominator
polynomials are given as:
</p>
<pre>
   degree of numerator   = size(n1,1) + 2*size(n2,1);
   degree of denominator = size(d1,1) + 2*size(d2,1);
</pre>
<p>
Example:
</p>
<pre>                          (q+0.5)
  dzp = 4* -------------------------------------
           (p - 0.5)*(p - (0.6+j*0.3))*(p - (0.6-j*0.3))
</pre>
<p>
with j = Complex.j(); is defined as
</p>
<pre>
   <b>import</b> Modelica_LinearSystems2.Math.Complex;
   <b>import</b> Modelica_LinearSystems2.DiscreteZerosAndPoles;
   j = Complex.j();

   dzp = ZerosAndPoles(z = {Complex(-0.5)},
                       p = {Complex(0.5),
                            0.6+j*0.3,
                            0.6-j*0.3},
                            k=4);
</pre>
</html>"));
  end DiscreteZerosAndPoles;

  operator record DiscreteTransferFunction
    "Discrete transfer function description of a single input, single output system (data + operations)"
    extends Modelica.Icons.Record;

    import Modelica_LinearSystems2.Math.Polynomial;
    import Modelica_LinearSystems2;

    Real n[:] "Coefficients of numerator polynomial (in descending order)" annotation(Dialog(group="y = n*{z^m, ... , z, 1} / (d*{z^r, ... , z, 1}) * u"));
    Real d[:] "Coefficients of denominator polynomial (in descending order)" annotation(Dialog(group="y = n*{z^m, ... , z, 1} / (d*{z^r, ... , z, 1}) * u"));

    Modelica.Units.SI.Time Ts "Sample time" annotation (Dialog(group=
            "Data used to construct discrete from continuous system"));

    Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));

    String uName="u" "Name of input signal" annotation(Dialog(group="Signal names"));
    String yName="y" "Name of output signal" annotation(Dialog(group="Signal names"));

  /* If the numerator polynomial has no coefficients, the transfer function
   is zero. The denominator polynomial must always have at
   least one coefficient, such as {1}
*/

    encapsulated operator 'constructor'
      "Collection of operators to construct a DiscreteTransferFunction data record"
      import Modelica;
      import Modelica_LinearSystems2.TransferFunction;

      encapsulated function fromReal
        "Generate a DiscreteTransferFunction data record from a real value"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input Real r "Value of Real variable";
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteTransferFunction dtf(n={r}, d={1});

      algorithm
        dtf.Ts := Ts;
        dtf.method := method;
        dtf.uName := uName;
        dtf.yName := yName;
      end fromReal;

      encapsulated function fromZerosAndPoles
        "Generate a DiscreteStateSpace data record from a set of zeros and poles"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex z[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
          "Zeros (Complex vector of numerator zeros)";
        input Complex p[:]=fill(Modelica_LinearSystems2.Math.Complex(0), 0)
          "Poles (Complex vector of denominator zeros)";
        input Real k=1.0 "Constant multiplied with transfer function";
        input Modelica.Units.SI.Time Ts "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteTransferFunction dtf(redeclare Real n[size(z, 1)+1], redeclare Real
                 d[                                                                          size(p, 1)+1])
          "TransferFunction built by ZerosAndPoles object";

    protected
        Polynomial pn=k*Polynomial(z);
        Polynomial pd=Polynomial(p);
      algorithm

        dtf.n := pn.c;
        dtf.d := pd.c;
        dtf.Ts := Ts;
        dtf.method := method;
        dtf.uName := uName;
        dtf.yName := yName;

        annotation (Documentation(info="<html>
</html>"));
      end fromZerosAndPoles;

      encapsulated function fromArrays
        "Generate a DiscreteTransferFunction data record from numerator and denominator array"
        import Modelica;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2;

        input Real n[:] "Coefficients of numerator polynomial";
        input Real d[:] "Coefficients of denominator polynomial";
        input Modelica.Units.SI.Time Ts "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";

        input String uName = "" "Input name";
        input String yName = "" "Output name";
        output DiscreteTransferFunction dtf(redeclare Real n[size(n, 1)], redeclare Real d[size(d, 1)])
          "Transfer function";

      algorithm
        // This is the constructor algorithm
        assert(size(d, 1) > 0, "Input denominator d must have at least one element, however\n"
          + "d is an empty vector");
        dtf.n := n;
        dtf.d := d;
        dtf.Ts := Ts;
        dtf.method := method;
        dtf.uName := uName;
        dtf.yName := yName;
      end fromArrays;

      function fromPolynomials
        "Generate a DiscreteTransferFunction data record from a numerator and denominator polynomial"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial n "Numerator polynomial";
        input Polynomial d "Denominator polynomial";
        input Modelica.Units.SI.Time Ts "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";
        input String uName="" "input name";
        input String yName="" "output name";
        output DiscreteTransferFunction dtf(n=n.c, d=d.c, Ts=Ts, method=method, uName=uName, yName=yName);

      algorithm
      end fromPolynomials;

      function fromTransferFunction
        "Generate a DiscreteTransferFunction data record from a continuous Transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input TransferFunction tf "continuous transfer function";
        input Modelica.Units.SI.Time Ts "Sample time" annotation (Dialog(group=
                "Data used to construct discrete from continuous system"));

        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method" annotation (Dialog(group="Data used to construct discrete from continuous system"));

        output DiscreteTransferFunction dtf;
    protected
        StateSpace ss = StateSpace(tf);
        DiscreteStateSpace dss=DiscreteStateSpace(ss,Ts,method);

      algorithm
        dtf := DiscreteStateSpace.Conversion.toDiscreteTransferFunction(dss);
      end fromTransferFunction;
    end 'constructor';

    encapsulated operator '*'
      "Contains operators for multiplication of discrete transfer functions"
      import Modelica;

      function 'dtf*dtf' "Multiply two discrete transfer functions (dtf1 * dtf2)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf1 "Transfer function system 1";
        input DiscreteTransferFunction dtf2 "Transfer function system 1";
        output DiscreteTransferFunction result;

      algorithm
        assert(abs(dtf1.Ts - dtf2.Ts) <= Modelica.Constants.eps, "Two discrete transfer function systems must have the same sample time Ts for subtraction with \"+\".");
        result := DiscreteTransferFunction(Polynomial(dtf1.n)*Polynomial(dtf2.n),Polynomial(dtf1.d)*Polynomial(dtf2.d), Ts=dtf1.Ts, method=dtf1.method);
      end 'dtf*dtf';

      function 'r*dtf'
        "Multiply a real number with a DiscreteTransferFunctions (r * dtf2)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input Real r "Real number";
        input DiscreteTransferFunction dtf "Transfer function system 1";
        output DiscreteTransferFunction result=dtf;

      algorithm
        result.n := r*dtf.n;
      end 'r*dtf';

      annotation (Documentation(info="<html>
<p>This package contains operators for multiplication of discrete fransfer function records. </p>
</html>"));
    end '*';

    encapsulated operator '-'
      "Contains operators for subtraction of discrete transfer functions"
      import Modelica;

      function subtract "Subtract two discrete transfer functions (dtf1 - dtf2)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf1;
        input DiscreteTransferFunction dtf2;

        output DiscreteTransferFunction result;

    protected
        Polynomial n=Polynomial(dtf1.n)*Polynomial(dtf2.d) - Polynomial(dtf2.n)*Polynomial(dtf1.d);
        Polynomial d=Polynomial(dtf1.d)*Polynomial(dtf2.d);

      algorithm
        if size(dtf1.n,1)>1 and size(dtf2.n,1)>1 then
          assert(abs(dtf1.Ts - dtf2.Ts) <= Modelica.Constants.eps, "Two discrete transfer function systems must have the same sample time Ts for subtraction with \"-.subtract\".");
        end if;
        result := DiscreteTransferFunction(n=n.c, d=d.c, Ts=dtf1.Ts, method=dtf1.method);
      end subtract;

      function negate "Unary minus (multiply discrete transfer function by -1)"
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf;
        output DiscreteTransferFunction result(n=-dtf.n, d=dtf.d, Ts=dtf.Ts, method=dtf.method) "= -dtf";
      algorithm
      end negate;
      annotation (Documentation(info="<html>
<p>This package contains operators for subtraction of discrete fransfer function records. </p>
</html>"));
    end '-';

    encapsulated operator '/'
      "Contains operators for division of discrete transfer functions"
      import Modelica;

      encapsulated function 'dtf/dtf'
        "Divide two discrete transfer functions (dtf1 / dtf2)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf1 "Transfer function system 1";
        input DiscreteTransferFunction dtf2 "Transfer function system 2";
        output DiscreteTransferFunction result;

      algorithm
        assert(abs(dtf1.Ts - dtf2.Ts) <= Modelica.Constants.eps, "Two discrete transfer function systems must have the same sample time Ts for subtraction with \"/\".");
        result := DiscreteTransferFunction(Polynomial(dtf1.n)*Polynomial(dtf2.d),Polynomial(dtf1.d)*
          Polynomial(dtf2.n),Ts=dtf1.Ts, method=dtf1.method);
      end 'dtf/dtf';

      function 'r/dtf'
        "Divide a real number by  discrete transfer functions (r / dtf2)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input Real r "Real number";
        input DiscreteTransferFunction dtf "Transfer function system";
        output DiscreteTransferFunction result;

      algorithm
        result := DiscreteTransferFunction(r*dtf.d,dtf.n,Ts=dtf.Ts, method=dtf.method);
      end 'r/dtf';

      annotation (Documentation(info="<html>
<p>This package contains operators for division of discrete fransfer function records. </p>
</html>"));
    end '/';

    encapsulated operator '+'
      "Contains operators for addition of discrete transfer functions"
      import Modelica;

      function 'dtf+dtf'
        "Parallel connection of two discrete transfer functions (= inputs are the same, outputs of the two systems are added)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf1 "Transfer function system 1";
        input DiscreteTransferFunction dtf2 "Transfer function system 2";
        output DiscreteTransferFunction result;

      algorithm
        assert(abs(dtf1.Ts - dtf2.Ts) <= Modelica.Constants.eps,
          "Two discrete transfer function systems must have the same sample time Ts for subtraction with \"+\".");
        result := DiscreteTransferFunction(Polynomial(dtf1.n)*Polynomial(dtf2.d) + Polynomial(dtf2.n)*Polynomial(dtf1.d), Polynomial(dtf1.d)*Polynomial(dtf2.d), Ts=dtf1.Ts, method=dtf1.method);
      end 'dtf+dtf';

      function 'dtf+r' "Add a real number to a DiscreteTransferFunction"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf "Transfer function system";
        input Real r "Real number";
        output DiscreteTransferFunction result;
    protected
        DiscreteTransferFunction dtfr=DiscreteTransferFunction(r, Ts=dtf.Ts, method=dtf.method);
      algorithm
        result := dtf+dtfr;
      end 'dtf+r';
      annotation (Documentation(info="<html>
<p>This package contains operators for addition of discrete fransfer function records. </p>
</html>"));
    end '+';

    encapsulated operator function '^'
      "Integer power of DiscreteTransferFunction (dtf1^k)"
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteTransferFunction;
      import Modelica_LinearSystems2.TransferFunction;

      input DiscreteTransferFunction dtf "Transfer function";
      input Integer k(min=0) = 1 "Integer exponent";
      output DiscreteTransferFunction result;

  protected
      TransferFunction tf=(Polynomial(dtf.n)^k)/(Polynomial(dtf.d)^k);

    algorithm
      result := DiscreteTransferFunction(n=tf.n, d=tf.d, Ts=dtf.Ts, method=dtf.method);
    end '^';

    encapsulated operator function '=='
      "Check whether two discrete transfer functions are identical"

      import Modelica;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteTransferFunction;

      input DiscreteTransferFunction dtf1 "Transfer function system 1";
      input DiscreteTransferFunction dtf2 "Transfer function system 1";
      input Real eps(min=0) = 0
        "Two coefficients c1 and c2 of the two transfer functions are identical if abs(c1-c2) <= eps";

      output Boolean result "= dtf1 == dtf2";
    algorithm
      result := (Polynomial(dtf1.n) == Polynomial(dtf2.n)) and (Polynomial(dtf1.d) == Polynomial(dtf2.d) and abs(dtf1.Ts - dtf2.Ts) <= Modelica.Constants.eps);
    end '==';

    encapsulated operator function 'String'
      "Transform DiscreteTransferFunction into a String representation"
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteTransferFunction;

      input DiscreteTransferFunction dtf
        "Discrete transfer function to be transformed in a String representation";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      input String name="z" "Independent variable name used for printing";
      output String z="";
  protected
      Integer n_num=size(dtf.n, 1) - 1;
      Integer n_den=size(dtf.d, 1) - 1;
      Boolean numParenthesis;
    algorithm
      if n_num == -1 then
        z := "0";
      else
        numParenthesis := n_num > 0 and not (n_den == 0 and dtf.d[1] == 1);
        if numParenthesis then
          z := "(";
        end if;
        z := z + String(
          Polynomial(dtf.n),
          significantDigits,
          name);

        if numParenthesis then
          z := z + ")";
        end if;
        if n_den > 0 or dtf.d[1] <> 1 then
          if n_den > 0 then
            z := z + "/(";
          else
            z := z + "/";
          end if;

          z := z + String(
            Polynomial(dtf.d),
            significantDigits,
            name);

          if n_den > 0 then
            z := z + ")";
          end if;
        end if;
      end if;
      z := z + "\n\n Ts = " + String(dtf.Ts) + "\n method =" +
        Modelica_LinearSystems2.Internal.methodString(dtf.method);

    end 'String';

    encapsulated function z "Generate the discrete transfer function z"
      import Modelica;
      import Modelica_LinearSystems2.Math.Polynomial;
      import Modelica_LinearSystems2.DiscreteTransferFunction;
      input Modelica.Units.SI.Time Ts=0;
      output DiscreteTransferFunction dtf(n={1,0}, d={1},Ts=Ts) "z";
    algorithm

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
z = DiscreteTransferFunction.<b>z</b>()
</pre></blockquote>

<h4>Description</h4>
<p>
Generate the complex variable z=exp(T*s) as a DiscreteTransferFunction. It can be used for generating like
</p>
<blockquote><pre>
DiscreteTransferFunction dtf = z/(3*z^2 + 2*z +2)
</pre></blockquote>
</html>"));
    end z;

    encapsulated package Analysis
      "Package of functions to analyse discrete transfer function represented by a DiscreteTransferFunction record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function timeResponse
        "Calculate the time response of a discrete transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        extends Modelica_LinearSystems2.Internal.timeResponseMask_tf_discrete;// Input/Output declarations of discrete time response functions
        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step;
        input Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=zeros(DiscreteTransferFunction.Analysis.denominatorDegree(dtf))
          "Initial state vector";

    protected
        DiscreteStateSpace dss=DiscreteStateSpace(dtf);
        Real tSpanVar;

      algorithm
        // set sample time
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(dss);
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) := DiscreteStateSpace.Analysis.timeResponse(
          dss=dss,
          tSpan=tSpanVar,
          response=response,
          x0=x0);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = DiscreteTransferFunction.Analysis.<b>timeResponse</b>(dtf, tSpan, responseType, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the discrete transfer function representation is transformed into a discrete state space representation which is given to DiscreteStateSpace.Analysis.timeResponse and the time response of the state space system is calculated. The type of the time response is defined by the input <b>responseType</b>, i.e.
</p>
<blockquote><pre>
Impulse \"Impulse response\",
Step \"Step response\",
Ramp \"Ramp response\",
Initial \"Initial condition response\"
</pre></blockquote>
<p>
The outputs y and x are calculated from the system equations of the discrete state space system for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real tSpan= 0.4;
  Modelica_LinearSystems2.Types.TimeResponse response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  dtf.Ts:=0.1;
  (y,t,x):=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.timeResponse(dtf,tSpan,response,x0);
//  y[:,1,1] = {0.00237529691211404, 0.0116282350020595, 0.0293927396867651, 0.0546913271597482, 0.0865678034508828}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0.0, 0.0, 1.0, 2.89548693586698, 5.58336953639396}
</pre></blockquote>
</html>"));
      end timeResponse;

      encapsulated function impulseResponse
        "Calculate the impulse time response of a discrete transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_tf_discrete;

    protected
        Real tSpanVar;
      algorithm
        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dtf));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteTransferFunction.Analysis.timeResponse(
              dtf=dtf,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse,
              x0=zeros(DiscreteTransferFunction.Analysis.denominatorDegree(dtf)));

        annotation(__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = DiscreteTransferFunction.Analysis.<b>impulseResponse</b>(dtf, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the discrete transfer function representation is transformed into discrete state space representation which is given to DiscreteStateSpace.Analysis.timeResponse
and the impulse response of the discrete state space system is calculated. The type of the time response is defined by the input <b>responseType</b>, i.e. in this case
</p>
<blockquote><pre>
Impulse \"Impulse response\",
</pre></blockquote>
<p>
The outputs y and x of the discrete state space systrem are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real tSpan= 0.4;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  dtf.Ts:=0.1;
  (y,t,x):=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.impulseResponse(dtf,tSpan,response,x0);
//  y[:,1,1] = {0.00237529691211404, 0.00925293808994548, 0.0177645046847056, 0.0252985874729831, 0.0318764762911345}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0.0, 0.0, 1.0, 1.89548693586698, 2.68788260052697}
</pre></blockquote>
</html>"));
      end impulseResponse;

      encapsulated function stepResponse
        "Calculate the step time response of a discrete transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        extends Modelica_LinearSystems2.Internal.timeResponseMask_tf_discrete;
    protected
        Real tSpanVar;
      algorithm
        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dtf));
        else
          tSpanVar := tSpan;
        end if;

        (y,t,x_discrete) :=DiscreteTransferFunction.Analysis.timeResponse(
              dtf=dtf,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step,
              x0=zeros(DiscreteTransferFunction.Analysis.denominatorDegree(dtf)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = DiscreteTransferFunction.Analysis.<b>stepResponse</b>(dtf, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the discrete transfer function representation is transformed into discrete state space representation which is given to DiscreteStateSpace.Analysis.timeResponse
and the step response of the discrete state space system is calculated. The type of the time response is defined by the input <b>responseType</b>, i.e. in this case
</p>
<blockquote><pre>
Step \"Step response\",
</pre></blockquote>
<p>
The outputs y and x of the discrete state space systrem are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real tSpan= 0.4;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  dtf.Ts:=0.1;
  (y,t,x):=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.stepResponse(dtf,tSpan,response,x0);
//  y[:,1,1] = {0.00237529691211404, 0.0116282350020595, 0.0293927396867651, 0.0546913271597482, 0.0865678034508828}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0.0, 0.0, 1.0, 2.89548693586698, 5.58336953639396}
</pre></blockquote>
</html>"));
      end stepResponse;

      encapsulated function rampResponse
        "Calculate the ramp time response of a discrete transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;

      // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_tf_discrete;

    protected
        Real tSpanVar;
      algorithm
        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dtf));
        else
          tSpanVar := tSpan;
        end if;
        (y,t,x_discrete) :=DiscreteTransferFunction.Analysis.timeResponse(
              dtf=dtf,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp,
              x0=zeros(DiscreteTransferFunction.Analysis.denominatorDegree(dtf)));

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = DiscreteTransferFunction.Analysis.<b>rampResponse</b>(dtf, tSpan, x0)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the discrete transfer function representation is transformed into discrete state space representation which is given to DiscreteStateSpace.Analysis.timeResponse
and the ramp response of the discrete state space system is calculated. The type of the time response is defined by the input <b>responseType</b>, i.e. in this case
</p>
<blockquote><pre>
Ramp \"Ramp response\",
</pre></blockquote>
<p>
The outputs y and x of the discrete state space systrem are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real tSpan= 0.4;
  Real x0[1]={0,0};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  dtf.Ts:=0.1;
  (y,t,x):=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.rampResponse(dtf,tSpan,response,x0);
//  y[:,1,1] = {0.0, 0.000237529691211404, 0.00140035319141736, 0.00433962716009387, 0.00980875987606869}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {0.0, 0.0, 0.0, 0.1, 0.389548693586699}
</pre></blockquote>
</html>"));
      end rampResponse;

      encapsulated function initialResponse
        "Calculate the initial time response of a discrete transfer function"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;

        input Real x0[:]=fill(0,0) "Initial state vector";

      // Input/Output declarations of time response functions:
        extends Modelica_LinearSystems2.Internal.timeResponseMask_tf_discrete;

    protected
        Real tSpanVar;
      algorithm
        // set simulation time span
        if tSpan == 0 then
          tSpanVar := DiscreteStateSpace.Internal.timeResponseSamples(
            DiscreteStateSpace(dtf));
        else
          tSpanVar := tSpan;
        end if;
        (y,t,x_discrete) :=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.timeResponse(
              dtf=dtf,
              tSpan=tSpanVar,
              response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial,
              x0=x0);

        annotation(__Dymola_interactive=true, Documentation(info="<html>
 <h4>Syntax</h4>
<blockquote><pre>
(y, t, x) = DiscreteTransferFunction.Analysis.<b>initialResponse</b>(x0, dtf, tSpan)
</pre></blockquote>

<h4>Description</h4>
<p>
First, the discrete transfer function representation is transformed into discrete state space representation which is given to DiscreteStateSpace.Analysis.timeResponse
and the initial response of the discrete state space system for initial state x0 is calculated. The type of the time response is defined by the input <b>responseType</b>, i.e. in this case
</p>
<blockquote><pre>
Initial \"Initial response\",
</pre></blockquote>
<p>
The outputs y and x of the discrete state space systrem are calculated for each time step t=k*dt.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real tSpan= 0.4;
  Real x0[1]={1,2};

  Real y[5,1,1];
  Real t[5];
  Real x[5,1,1]

<b>algorithm</b>
  dtf.Ts:=0.1;
  (y,t,x):=Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.initialResponse(x0,dtf,tSpan,response,x0);
//  y[:,1,1] = {0.0187315575967189, 0.0271552102903869, 0.0345205091861731, 0.0408580313775029, 0.0462052138701078}
//         t = {0, 0.1, 0.2, 0.3, 0.4}
//  x[:,1,1] = {1.0, 2.0, 2.88598574821853, 3.66037203581564, 4.3264045475288}
</pre></blockquote>
</html>"));
      end initialResponse;

      encapsulated function denominatorDegree
        "Return denominator degree of a discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input DiscreteTransferFunction dtf
          "Discrete transfer function of a system";
        output Integer result;

      algorithm
        result := size(dtf.d,1)-1;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = DiscreteTransferFunction.Analysis.<b>denominatorDegree</b>(dtf)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>denominatorDegree</b> calculates the degree of the denominator polynomial of a discrete transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction  dtf=(0.0023753*z^2 + 0.00475059*z + 0.0023753)/(z^2 - 1.89549*z + 0.904988);

  Real dDegree;

<b>algorithm</b>
  dDegree := DiscreteTransferFunction.Analysis.denominatorDegree(dtf);
//  dDegree = 2
</pre></blockquote>
</html>"));
      end denominatorDegree;

    end Analysis;

    encapsulated package Plot
      "Package of functions to plot discrete transfer function responses"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function bode "Plot discrete transfer function as bode plot"
        import Modelica;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Utilities.Plot;
        import Modelica.Units.SI;

        input DiscreteTransferFunction dtf
          "DiscreteTransfer function to be plotted";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input SI.Frequency f_min(min=0) = 0.1
          "Minimum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));
        input SI.Frequency f_max(min=0) = 10
          "Maximum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));

        input Boolean magnitude=true "= true, to plot the magnitude of tf"
          annotation(choices(checkBox=true));
        input Boolean phase=true "= true, to plot the pase of tf" annotation(choices(checkBox=true));

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot(heading="Bode plot: "
               + String(dtf)));

        input Boolean Hz=true
          "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
        input Boolean dB=false
          "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));

    protected
        SI.AngularVelocity w[nPoints];
        Complex z[nPoints];
        SI.Frequency f[nPoints];
        Modelica.Units.NonSI.Angle_deg phi[nPoints];
        Real A[nPoints];
        Boolean OK;
        Complex c;
        SI.Angle phi_old;
        Complex numZeros[:];
        Complex denZeros[:];
        Complex numZerosZ[:];
        Complex denZerosZ[:];
        TransferFunction tf=TransferFunction(n=dtf.n, d=dtf.d);

        Plot.Records.Curve curves[2];
        Integer i;
        Plot.Records.Diagram diagram2[2];

      algorithm
        // Determine frequency vector f
        if autoRange then
          (numZerosZ,denZerosZ) := TransferFunction.Analysis.zerosAndPoles(tf);
        else
          numZerosZ := fill(Complex(0), 0);
          denZerosZ := fill(Complex(0), 0);
        end if;

        numZeros := fill(Complex(0),0);
        // numZeros := fill(Complex(0),size(numZerosZ,1));
        // for i in 1:size(numZerosZ,1) loop
        //   numZeros[i] := Complex.log(numZerosZ[i])/dtf.Ts;
        // end for;

        denZeros := fill(Complex(0),size(denZerosZ,1));
        for i in 1:size(denZerosZ,1) loop
          denZeros[i] := Complex.log(denZerosZ[i])/dtf.Ts;
        end for;

        f := Internal.frequencyVector(
              nPoints,
              autoRange,
              f_min,
              f_max,
              numZeros,
              denZeros);

        // Compute magnitude/phase at the frequency points
        phi_old := 0.0;
        for i in 1:nPoints loop
          w[i] := Modelica.Units.Conversions.from_Hz(f[i]);
          z[i] := Complex.exp(Complex(0,w[i]*dtf.Ts));
          c := TransferFunction.Analysis.evaluate(
                tf,
                z[i],
                1e-10);
          A[i] := Complex.'abs'(c);
          phi_old := Complex.arg(c, phi_old);
          phi[i] := Modelica.Units.Conversions.to_deg(phi_old);

          // Convert to other units, if required
          if not Hz then
             f[i] := w[i];
          end if;
          if dB then
             A[i] := 20*log10(A[i]);
          end if;
        end for;

        // Plot computed frequency response
        diagram2 := fill(defaultDiagram, 2);
        i := 0;
        if magnitude then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=A,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := if dB then "magnitude [dB]" else "magnitude";
          if phase then
             diagram2[i].xLabel:="";
          end if;
          if dB then
             diagram2[i].logY := false;
          end if;
        end if;

        if phase then
          i := i + 1;
          curves[i] := Plot.Records.Curve(
                x=f,
                y=phi,
                autoLine=true);
          diagram2[i].curve := {curves[i]};
          diagram2[i].yLabel := "phase [deg]";
          diagram2[i].logY := false;
          if magnitude then
            diagram2[i].heading:="";
         end if;
        end if;

        if not Hz then
           diagram2[i].xLabel:="Angular frequency [rad/s]";
        end if;

        if magnitude and phase then
          Plot.diagramVector(diagram2, device);
        else
          Plot.diagram(diagram2[1], device);
        end if;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end bode;

      encapsulated function timeResponse
        "Plot the time response of a system represented by a discrete transfer function. The response type is selectable"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.DiscreteTransferFunction dtf;
      //  input Real dt=0 "Sample time [s]";
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "Type of time response";
        input Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=zeros(
            DiscreteTransferFunction.Analysis.denominatorDegree(dtf))
          "Initial state vector";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
              Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading="Time response of  dtf = "
               + String(dtf)));

    protected
        Plot.Records.Curve curve;
        Plot.Records.Diagram diagram2;
        Real y[:,1,1] "Output response";
        Real t[:] "Time vector: (number of samples)";

        Real yy[:] "Output response";
        Real tt[:] "Time vector: (number of samples)";

      algorithm
        (y,t) := DiscreteTransferFunction.Analysis.timeResponse(
          dtf,
          tSpan,
          response,
          x0);

        tt := fill(0,2*size(t,1)-1);
        yy := fill(0,2*size(t,1)-1);

        for i in 1:size(t,1)-1 loop
          tt[2*i-1] := t[i];
          tt[2*i] := t[i+1];
          yy[2*i-1] := y[i,1,1];
          yy[2*i] := y[i,1,1];
        end for;
        tt[size(tt,1)] := t[size(t,1)];
        yy[size(tt,1)] := y[size(t,1),1,1];

        curve := Plot.Records.Curve(
          x=tt,
          y=yy,
          legend="y",
          autoLine=true);
        diagram2 := defaultDiagram;
        diagram2.curve := {curve};

        Plot.diagram(diagram2, device);
        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end timeResponse;

      encapsulated function impulse
        "Impulse response plot of a discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteTransferFunction dtf "zeros-and-poles transfer function";
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(defaultDiagram=
             Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(heading="Impulse response of  zp = "
               + String(dtf)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Impulse "Type of time response";

        Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=zeros(
             DiscreteTransferFunction.Analysis.denominatorDegree(dtf))
          "Initial state vector";
      algorithm
        // set sample time
        Modelica_LinearSystems2.DiscreteTransferFunction.Plot.timeResponse(
            dtf=dtf,
            tSpan=tSpan,
            response=response,
            x0=x0,
            defaultDiagram=defaultDiagram,
            device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end impulse;

      encapsulated function step
        "Step response plot of a discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;
        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteTransferFunction dtf;
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Step response of  dtf = " + String(dtf)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Step "type of time response";
        Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=zeros(
            DiscreteTransferFunction.Analysis.denominatorDegree(dtf))
          "Initial state vector";

      algorithm
        DiscreteTransferFunction.Plot.timeResponse(
          dtf=dtf,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end step;

      encapsulated function ramp
        "Ramp response plot of a discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input DiscreteTransferFunction dtf;
        input Real tSpan=0 "Simulation time span [s]";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Ramp response of  dtf = " + String(dtf)));

    protected
        Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Ramp "type of time response";
        Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=zeros(
            DiscreteTransferFunction.Analysis.denominatorDegree(dtf))
          "Initial state vector";
      algorithm
        Modelica_LinearSystems2.DiscreteTransferFunction.Plot.timeResponse(
          dtf=dtf,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end ramp;

      encapsulated function initialResponse
        "Initial condition response plot of a discrete transfer function"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Utilities.Types.TimeResponse;

        import Modelica_LinearSystems2.Utilities.Plot;

        input Modelica_LinearSystems2.DiscreteTransferFunction dtf;
        input Real tSpan=0 "Simulation time span [s]";

        input Modelica_LinearSystems2.Utilities.Types.TimeResponse response=Modelica_LinearSystems2.Utilities.Types.TimeResponse.Initial "type of time response";
        input Real y0 "Initial output (for initial condition plot)";

        extends Modelica_LinearSystems2.Internal.PartialPlotFunction(
          defaultDiagram=Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse(
            heading="Initial response of  dtf = " + String(dtf) + " with y0 = " + String(y0)));

    protected
        Modelica_LinearSystems2.DiscreteStateSpace dss=Modelica_LinearSystems2.DiscreteStateSpace(dtf);
        Real x0[DiscreteTransferFunction.Analysis.denominatorDegree(dtf)]=
            Modelica.Math.Matrices.equalityLeastSquares(
            dss.A,
            fill(0, size(dss.B, 1)),
            dss.C,
            vector(y0)) "Initial state vector (for initial condition plot)";
      algorithm
        Modelica_LinearSystems2.DiscreteTransferFunction.Plot.timeResponse(
              dtf=dtf,
              tSpan=tSpan,
              response=response,
              x0=x0,
              defaultDiagram=defaultDiagram,
              device=device);

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end initialResponse;

    end Plot;

    encapsulated package Conversion
      "Package of functions for conversion of DiscreteTransferFunction data record"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function toDiscreteZerosAndPoles
        "Generate a DiscreteZerosAndPoles object from a DiscreteTransferFunction object"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteZerosAndPoles;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.Math.Complex;

        input DiscreteTransferFunction dtf "transfer function of a system";
        output Modelica_LinearSystems2.DiscreteZerosAndPoles dzp(
          redeclare Real n1[DiscreteZerosAndPoles.Internal.numberOfRealZeros2(dtf)],
          redeclare Real n2[integer((size(dtf.n, 1) - 1 -
        DiscreteZerosAndPoles.Internal.numberOfRealZeros2(dtf))/2),2],
          redeclare Real d1[DiscreteZerosAndPoles.Internal.numberOfRealPoles(dtf)],
          redeclare Real d2[integer((size(dtf.d, 1) - 1 -
        DiscreteZerosAndPoles.Internal.numberOfRealPoles(dtf))/2),2]);
    protected
        TransferFunction tf=TransferFunction(n=dtf.n, d=dtf.d);
        Complex z[:];
        Complex p[:];
        Real k;
      algorithm
        (z,p,k) := TransferFunction.Analysis.zerosAndPoles(tf);
        dzp := DiscreteZerosAndPoles(
              z,
              p,
              k,
              dtf.Ts,
              dtf.method,
              uName=dtf.uName,
              yName=dtf.yName);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dzp = DiscreteTransferFunction.Conversion.<b>toDiscreteZerosAndPoles</b>(tf)
</pre></blockquote>

<h4>Description</h4>
<p>
Computes a DiscreteZerosAndPoles record
<blockquote><pre>
           product(q + n1[i]) * product(q^2 + n2[i,1]*q + n2[i,2])
dzp = k * ---------------------------------------------------------
           product(q + d1[i]) * product(q^2 + d2[i,1]*q + d2[i,2])
</pre></blockquote>
<p>
of a discrete transfer function representated by numerator and denominator
polynomial. The poles and zeros and the gain <tt>k</tt> are computed from
the DiscreteTransferFunction-input and are used as inputs the
DiscreteZerosAndPoles constructor.
</p>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf = 1/(z^2 + 3*z + 2)


<b>algorithm</b>
  dzp = Modelica_LinearSystems2.DiscreteTransferFunction.Conversion.toDiscreteZerosAndPoles(dtf);
//  dzp = 1/( (z + 1)*(z + 2) )
</pre></blockquote>
</html>"));
      end toDiscreteZerosAndPoles;

      function toDiscreteStateSpace
        "Convert a DiscreteTransferFunction into a DiscreteStateSpace representation"
        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.TransferFunction;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica.Math.Vectors;

        input DiscreteTransferFunction dtf
          "discrete transfer function of a system";
        output DiscreteStateSpace dss(
          redeclare Real A[DiscreteTransferFunction.Analysis.denominatorDegree(dtf),DiscreteTransferFunction.Analysis.denominatorDegree(dtf)],
          redeclare Real B[DiscreteTransferFunction.Analysis.denominatorDegree(dtf),1],
          redeclare Real B2[DiscreteTransferFunction.Analysis.denominatorDegree(dtf),1],
          redeclare Real C[1,DiscreteTransferFunction.Analysis.denominatorDegree(dtf)],
          redeclare Real D[1,1]) "Discrete state space record";

    protected
        Integer na=DiscreteTransferFunction.Analysis.denominatorDegree(dtf) + 1;
        Integer nb=size(dtf.n,1);//numerator degree
        Integer nx=na - 1;
        TransferFunction tf=TransferFunction(n=dtf.n, d=dtf.d);
        Real a[na]=Vectors.reverse(tf.d) "Reverse element order of tf.a";
        Real b[na];//=vector([Vectors.reverse(tf.n); zeros(na - nb, 1)]);
        Real d;//=b[na]/a[na];
      algorithm
        assert(nb<=na,"DiscreteTransferFunction\n" +String(dtf) +"\nis acausal and cannot be transformed to DiscreteStaeSpace in function \"Conversion.toDiscreteStateSpace()\"");
        b := vector([Vectors.reverse(tf.n); zeros(na - nb, 1)]);
        d := b[na]/a[na];
        if nx == 0 then
          dss.A := fill(0, 0, nx);
          dss.B := fill(0, 0, 1);
          dss.B2 := fill(0, 0, 1);
          dss.C := fill(0, 1, 0);
        else
          dss.A[1:nx - 1, 1:nx] := [zeros(nx - 1, 1),identity(nx - 1)];
          dss.A[nx, 1:nx] := -a[1:na - 1]/a[na];
          dss.B := [zeros(nx - 1, 1); 1/a[na]];
          dss.B2 := fill(0,nx,1);
          dss.C := {b[1:nx] - d*a[1:nx]};
        end if;

        dss.D := [d];
        dss.Ts := dtf.Ts;
        dss.method := dtf.method;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
dss = DiscreteTransferFunction.Conversion<b>toDiscreteStateSpace</b>(dtf)
</pre></blockquote>

<h4>Description</h4>
<p>
Transforms a discrete transfer function into discrete state space representation.
There are an infinite number of possible realizations.
Here, the transfer function is transformed into
controller canonical form, i.e. the transfer function
</p>
<blockquote><pre>
     b4*z^4 + b3*z^3 + b2*z^2 + b1*z + b0
y = -------------------------------------- * u
     a4*z^4 + a3*z^3 + a2*z^2 + a1*z + a0
</pre></blockquote>
<p>
is transformed into:
</p>
<blockquote><pre>
<b>x</b>_k+1 = <b>A</b>*<b>x</b>_k + <b>B</b>*<b>u</b>_k;
 <b>y</b>_k  = <b>C</b>*<b>x</b>_k + <b>D</b>*<b>u</b>_k;
with
  <b>A</b> = [   0  ,    1  ,    0  ,    0;
          0  ,    0  ,    1  ,    0:
          0  ,    0  ,    0  ,    1;
       -a0/a4, -a1/a4, -a2/a4, -a3/a4];

  <b>B</b> = [  0;
         0;
         0;
        1/a4];
  <b>C</b> = [b0-b4*a0/a4, b1-b4*a1/a4, b2-b4*a2/a4, b3-b4*a3/a4];
  <b>D</b> = [b4/a4];
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  DiscreteTransferFunction z = Modelica_LinearSystems2.DiscreteTransferFunction.z();
  Modelica_LinearSystems2.DiscreteTransferFunction dtf=(z+1)/(z^3 + z^2 + z + 1);

<b>algorithm</b>
  dss := Modelica_LinearSystems2.DiscreteTransferFunction.Conversion.toDiscreteStateSpace(dtf);
// ss.A = [0, 1, 0; 0, 0, 1; -1, -1, -1],
// ss.B = [0; 0; 1],
// ss.C = [1, 1, 0],
// ss.D = [0],
// ss.B2 = [0; 0; 0],
</pre></blockquote>
</html>"));
      end toDiscreteStateSpace;

    end Conversion;

    encapsulated package Import
      "Package of functions to generate a DiscreteTransferFunction data record from imported data"
      import Modelica;
      extends Modelica.Icons.Package;

      encapsulated function fromFile
        "Generate a DiscreteTransferFunction data record by reading numenator coefficients and denominator coefficients from a file (default file name is tf.mat)"

        import Modelica_LinearSystems2.DiscreteTransferFunction;
        import Modelica_LinearSystems2.Math.Polynomial;
        input String fileName="dtf.mat" "Name of the transfer function data file" annotation(Dialog(loadSelector(filter="MAT files (*.mat);; All files (*.*)",
                            caption="transfer function data file")));
        input String numName="n" "Name of the numenator of the transfer function";
        input String denName="d"
          "Name of the denominator of the transfer function";

    protected
        Integer numSize[2]=readMatrixSize(fileName, numName) annotation(__Dymola_allowForSize=true);
        Integer denSize[2]=readMatrixSize(fileName, denName) annotation(__Dymola_allowForSize=true);

        Real num[numSize[1],numSize[2]]=readMatrix(
              fileName,
              numName,
              numSize[1],
              numSize[2]) "numenator coefficients";
        Real den[denSize[1],denSize[2]]=readMatrix(
              fileName,
              denName,
              denSize[1],
              denSize[2]) "denominator coefficients";
        Integer ns2=numSize[2] annotation(__Dymola_allowForSize=true);
        Integer ds2=denSize[2] annotation(__Dymola_allowForSize=true);
        Real Ts[1,1]=readMatrix(fileName, "Ts", 1, 1);

    public
        output DiscreteTransferFunction dtf(n=fill(0,ns2),d=fill(0,ds2))
          "Discrete transfer function";

      algorithm
        dtf.n := vector(num);
        dtf.d := vector(den);
        dtf.uName := numName;
        dtf.yName := denName;
        dtf.Ts := scalar(Ts);

        annotation (Documentation(info="<html>
</html>"));
      end fromFile;

      function fromModel
        "Generate a DiscreteTransferFunction record array from a state space representation resulted from linearization of a model"

        import Modelica;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.StateSpace;
        import Modelica_LinearSystems2.DiscreteStateSpace;
        import Modelica_LinearSystems2.DiscreteTransferFunction;

        input String modelName "Name of the Modelica model" annotation(Dialog(__Dymola_translatedModel(translate=true)));
        input Real T_linearize=0 "Point in time of simulation to linearize the model";
        input String fileName="dslin" "Name of the result file";
        input Modelica.Units.SI.Time Ts=1 "Sample time";
        input Modelica_LinearSystems2.Utilities.Types.Method method=Modelica_LinearSystems2.Utilities.Types.Method.Trapezoidal "Discretization method";

    protected
        String fileName2=fileName + ".mat";
        Boolean OK1=simulateModel(problem=modelName, startTime=0, stopTime=T_linearize);
        Boolean OK2=importInitial("dsfinal.txt");
        Boolean OK3=linearizeModel(problem=modelName, resultFile=fileName, startTime=T_linearize, stopTime=T_linearize + 1);
        Real nxMat[1,1]=readMatrix(fileName2, "nx", 1, 1);
        Integer ABCDsizes[2]=readMatrixSize(fileName2, "ABCD");
        Integer nx=integer(nxMat[1, 1]);
        Integer nu=ABCDsizes[2] - nx;
        Integer ny=ABCDsizes[1] - nx;
        Real ABCD[nx + ny,nx + nu]=readMatrix(fileName2, "ABCD", nx + ny, nx + nu);
        String xuyName[nx + nu + ny]=readStringMatrix(fileName2, "xuyName", nx + nu + ny);

        StateSpace ss(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu]) "= model linearized at initial point";
        DiscreteStateSpace dss(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,nu],
          redeclare Real C[ny,nx],
          redeclare Real D[ny,nu],
          redeclare Real B2[nx,nu]) "= model linearized at initial point";
        DiscreteStateSpace dss_siso(
          redeclare Real A[nx,nx],
          redeclare Real B[nx,1],
          redeclare Real C[1,nx],
          redeclare Real D[1,1],
          redeclare Real B2[nx,1]) "= model linearized at initial point";

    public
        output DiscreteTransferFunction dtf[:,:];

      algorithm
        ss.A := ABCD[1:nx, 1:nx];
        ss.B := ABCD[1:nx, nx + 1:nx + nu];
        ss.C := ABCD[nx + 1:nx + ny, 1:nx];
        ss.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
        ss.uNames := xuyName[nx + 1:nx + nu];
        ss.yNames := xuyName[nx + nu + 1:nx + nu + ny];
        ss.xNames := xuyName[1:nx];

        dss := DiscreteStateSpace(ss, Ts=Ts, method=method);
        dtf := DiscreteStateSpace.Conversion.toDiscreteTransferFunctionMIMO(dss);

        //   for ic in 1:ny loop
        //     for ib in 1:nu loop
        //       dss_siso := DiscreteStateSpace(
        //         A=dss.A,
        //         B=matrix(dss.B[:, ib]),
        //         C=transpose(matrix(dss.C[ic, :])),
        //         D=matrix(dss.D[ic, ib]),
        //         B2=matrix(dss.B2[:, ib]),
        //         Ts=dss.Ts,
        //         method=dss.method);
        //         dtf[ic, ib] := DiscreteStateSpace.Conversion.toDiscreteTransferFunction(dss_siso);
        //     end for;
        //   end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
</html>"));
      end fromModel;

    end Import;

  end DiscreteTransferFunction;

  package Math "Package of additional functions for Modelica.Math"
    extends Modelica.Icons.Package;

    operator record Complex "Record defining a Complex number"

      Real re "Real part of complex number" annotation(Dialog);
      Real im "Imaginary part of complex number" annotation(Dialog);

      encapsulated package Examples
        "Package of examples to demonstrate the usage of complex numbers"

        import Modelica;
        extends Modelica.Icons.ExamplesPackage;

        function addTwoComplexNumbers "Show how to add 2 complex number"
          import Modelica_LinearSystems2.Math.Complex;
          import Modelica.Utilities.Streams;

          output Boolean ok;
      protected
          Complex j = Complex.j();
          Complex c1=2+3*j;
          Complex c2=3+4*j;
          Complex c3;
        algorithm

          Streams.print("c1 = " + String(c1));
          Streams.print("c2 = " + String(c2));

          c3 := c1 + c2;
          Streams.print("c3 = c1 + c2 = " + String(c3));
          ok := true;
        end addTwoComplexNumbers;
      end Examples;

      encapsulated package Vectors
        "Package of functions operating on vectors of complex numbers"
        extends Modelica.Icons.Package;
        import Modelica;

        function print "Print vector"
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Math.Complex;

          input String name="" "Name of complex vector";
          input Complex c[:] "Complex vector to be printed";

          input String fileName=""
            "Print to fileName; empty fileName prints to the log window";

        algorithm
          print(name + " =", fileName);
          for i in 1:size(c, 1) loop
            print("   " + String(c[i]), fileName);
          end for;
        end print;

        function printHTML
          "Print complex vector as HTML in sorted form (vector is expected to have pure real and/or conjugate complex values (so poles and/or zeros)"
          import Modelica.Utilities.Files;
          import Modelica.Utilities.Streams;
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Math.Complex;
          import Modelica_LinearSystems2;

          input Complex c[:] "Complex vector to be printed";
          input String heading="Zeros" "Heading above the table";
          input String name="zeros" "Heading of value column";
          input Boolean sort=true
            "= true, if values are sorted, otherwise no sorting";
          input Boolean ascending = true
            "= true if ascending order, otherwise descending order for sorting";
          input Boolean sortFrequency=true
            "= true, if sorting is first for imaginary then for real value, otherwise sorting is for absolute value";
      protected
          Integer nc = size(c,1);
          Complex cSorted[size(c,1)];
          Integer cIndex[size(c,1)];
          String tempFile = "TemporaryForPrint.html";
          Integer nReal;

          encapsulated function printTable
            "Print the table with eigenvalues in html format on file"
            import Modelica;
            import Modelica.Utilities.Strings;
            import Modelica_LinearSystems2;
            import Modelica.Utilities.Streams.print;
            import Modelica_LinearSystems2.Internal.Eigenvalue;
            import Modelica_LinearSystems2.Math.Complex;

            input Complex systemZeros[:];
            input Integer nReal;
            input String tempFile;
        protected
            Integer nz=size(systemZeros, 1);

            String number;
            Real timeConstant;
            Real freq;
            Real damp;

          algorithm
            for i in 1:nReal loop
              // Build eigenvalue number

              number := String(
                      i,
                      minimumLength=7,
                      leftJustified=false);
              timeConstant := if abs(systemZeros[i].re) > 10*Modelica.Constants.eps
                 then 1/abs(systemZeros[i].re) else 1/(10*Modelica.Constants.eps);

              print(
                "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
                 + number + " </td>" + "\n  <td> &nbsp; " + String(systemZeros[i].re,
                format="14.4e") + " </td>" + "\n  <td> &nbsp; " + String(
                timeConstant, format="9.4f") + " </td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; --- </td>\n</tr>",
                tempFile);

            end for;

            for i in nReal + 1:2:nz loop
              number := String(i) + "/" + String(i + 1);
              number := Strings.repeat(max(0, 7 - Strings.length(number))) + number;

              // Determine frequency and number of corresponding zero
              (freq,damp) := Complex.frequency(systemZeros[i]);

              print(
                "<tr style=\"background-color:white\">\n  <td style=\"text-align:left\"> &nbsp; "
                 + number + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
                 + String(systemZeros[i].re, format="14.4e") + " &plusmn; " +
                String(systemZeros[i].im, format="12.4e") + "j </td>" +
                "\n  <td style=\"text-align:center\"> &nbsp; --- </td>" +
                "\n  <td style=\"text-align:left\"> &nbsp; " + String(freq, format=
                "9.4f") + " </td>" + "\n  <td style=\"text-align:left\"> &nbsp; "
                 + String(damp, format="9.4f") + " </td>\n</tr>", tempFile);

            end for;

            print("</table>\n", tempFile);
          end printTable;
        algorithm
          if size(c,1) < 1 then
             return;
          end if;

          // Sort complex vector
          if sort then
            (cSorted,cIndex) := Complex.Vectors.sortComplex(c,ascending,sortFrequency);
          else
            cSorted :=c;
            cIndex :=1:nc;
          end if;

          // Number of real zeros
          nReal := Modelica_LinearSystems2.Internal.numberOfRealZeros(cSorted);

          // Remove temporary file, if it exists
          Files.removeFile(tempFile);

          // Print heading
          // Following doesn't work in Dymola
          //Streams.print("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">", tempFile);
          print("<html>", tempFile);
          print("<style type=\"text/css\">", tempFile);
          print("* { font-size: 10pt; font-family: Arial,sans-serif; }", tempFile);
          print("</style>", tempFile);

          print("<table style=\"background-color:rgb(100, 100, 100); margin:20px 0 20px 20px;\" "
                 + "cellpadding=\"3\" border=\"0\" cellspacing=\"1\">", tempFile);
          print("<caption>" + heading + "</caption>", tempFile);
          print("<tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">" +
                "\n  <td> number </td>\n  <td>" + name + "</td>\n  <td> time constant [s] </td>" +
                "\n  <td> freq. [Hz] </td>\n  <td> damping </td>\n</tr>", tempFile);

          // Print values of complex vector
          printTable(cSorted, nReal, tempFile);

          // Print end of file
          print("</html>", tempFile);

          // Read file into output window and remove temporary file
          Streams.readFile(tempFile);
          Files.removeFile(tempFile);
        end printHTML;

      function length "Return length of a complex vector"
          import Modelica_LinearSystems2.Math.Complex;
        input Complex v[:] "Vector";
        output Real result "Length of vector v";

      algorithm
        result := sqrt(sum(v[i].re^2 + v[i].im^2 for i in 1:size(v,1)));
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>length</b>(v);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call \"<code>Vectors.<b>length</b>(v)</code>\" returns the
<b>Euclidean length</b> \"<code>sqrt(v*v)</code>\" of vector v.
The function call is equivalent to Vectors.norm(v). The advantage of
length(v) over norm(v) is that function length(..) is implemented
in one statement and therefore the function is usually automatically
inlined. Further symbolic processing is therefore possible, which is
not the case with function norm(..).
</p>

<h4>Example</h4>
<blockquote><pre>
v = {2, -4, -2, -1};
<b>length</b>(v);  // = 5
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica.Math.Vectors.length\">Vectors.length</a>
</p>
</html></html>"));
      end length;

      function norm "Returns the norm of a complex vector"
          import Modelica;
          import Modelica_LinearSystems2.Math.Complex;
        input Complex v[:] "Vector";
        input Real p(min=1) = 2
            "Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)";
        output Real result "p-norm of vector v";

      algorithm
        if p == 2 then
          result:= sqrt(sum(v[i].re^2 + v[i].im^2 for i in 1:size(v,1)));
        elseif p == Modelica.Constants.inf then
          result:= Complex.'max'(v);
        elseif p == 1 then
          result:= sum(Complex.'abs'(v[i]) for i in 1:size(v,1));
        else
          result:=(sum(Complex.'abs'(v[i])^p for i in 1:size(v, 1)))^(1/p);
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>norm</b>(v);
Vectors.<b>norm</b>(v,p=2);   // 1 &le; p &le; &#8734;
</pre></blockquote>

<h4>Description</h4>
<p>
The function call \"<code>Vectors.<b>norm</b>(v)</code>\" returns the
<b>Euclidean norm</b> \"<code>sqrt(v*v)</code>\" of vector v.
With the optional
second argument \"p\", any other p-norm can be computed:
</p>
<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Math/vectorNorm.png\" alt=\"function Vectors.norm\">
</blockquote>
<p>
Besides the Euclidean norm (p=2), also the 1-norm and the
infinity-norm are sometimes used:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>1-norm</b></td>
      <td>= sum(abs(v))</td>
      <td><b>norm</b>(v,1)</td>
  </tr>
  <tr><td><b>2-norm</b></td>
      <td>= sqrt(v*v)</td>
      <td><b>norm</b>(v) or <b>norm</b>(v,2)</td>
  </tr>
  <tr><td><b>infinity-norm</b></td>
      <td>= max(abs(v))</td>
      <td><b>norm</b>(v,Modelica.Constants.<b>inf</b>)</td>
  </tr>
</table>
<p>
Note, for any vector norm the following inequality holds:
</p>
<blockquote><pre>
<b>norm</b>(v1+v2,p) &le; <b>norm</b>(v1,p) + <b>norm</b>(v2,p)
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  v = {2, -4, -2, -1};
  <b>norm</b>(v,1);    // = 9
  <b>norm</b>(v,2);    // = 5
  <b>norm</b>(v);      // = 5
  <b>norm</b>(v,10.5); // = 4.00052597412635
  <b>norm</b>(v,Modelica.Constants.inf);  // = 4
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"Modelica://Modelica.Math.Matrices.norm\">Matrices.norm</a>
</p>
</html>"));
      end norm;

      function normalize
          "Return normalized complex vector such that length = 1 and prevent zero-division for zero vector"
          import Modelica;
          import Modelica_LinearSystems2.Math.Complex;

        input Complex v[:] "Vector";
        input Real eps = 100*Modelica.Constants.eps "if |v| < eps then result = v";
        output Complex result[size(v, 1)] "Input vector v normalized to length=1";

      protected
        Real length_v = Complex.Vectors.length(v);
        Complex j = Complex.j();
      algorithm
        if length_v >= eps then
           for i in 1:size(v,1) loop
              result[i] :=v[i].re/length_v + (v[i].im/length_v)*j;
           end for;
        else
           result :=v;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>normalize</b>(v);
   or
Vectors.<b>normalize</b>(v,eps=100*Modelica.Constants.eps);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call \"<code>Vectors.<b>normalize</b>(v)</code>\" returns the
<b>unit vector</b> \"<code>v/length(v)</code>\" of vector v.
If length(v) is close to zero (more precisely, if length(v) &lt; eps),
v is returned in order to avoid
a division by zero. For many applications this is useful, because
often the unit vector <b>e</b> = <b>v</b>/length(<b>v</b>) is used to compute
a vector x*<b>e</b>, where the scalar x is in the order of length(<b>v</b>),
i.e., x*<b>e</b> is small, when length(<b>v</b>) is small and then
it is fine to replace <b>e</b> by <b>v</b> to avoid a division by zero.
</p>
<p>
Since the function is implemented in one statement,
it is usually inlined and therefore symbolic processing is
possible.
</p>

<h4>Example</h4>
<blockquote><pre>
  <b>normalize</b>({1,2,3});  // = {0.267, 0.534, 0.802}
  <b>normalize</b>({0,0,0});  // = {0,0,0}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.length\">Modelica.Math.Vectors.length</a>
</p>
</html>"));
      end normalize;

      function sortComplex "Sort elements of complex vector"
          import Modelica_LinearSystems2.Math.Complex;
        input Complex v[:] "Vector to be sorted";
        input Boolean ascending = true
            "= true if ascending order, otherwise descending order";
        input Boolean sortFrequency=true
            "True, if sorting is first for imaginary then for real value, otherwise sorting is for absolute value";
        output Complex sorted_v[size(v,1)] = v "Sorted vector";
        output Integer indices[size(v,1)] = 1:size(v,1) "sorted_v = v[indices]";

        /* shellsort algorithm; should be improved later */
      protected
        Integer gap;
        Integer i;
        Integer j;
        Complex wv;
        Integer wi;
        Integer nv = size(v,1);
        Boolean swap;
        Integer k1;
        Integer k2;
      algorithm
        gap := div(nv,2);

        while gap > 0 loop
           i := gap;
           while i < nv loop
              j := i-gap;
              if j>=0 then
                 k1 := j+1;
                 k2 := j + gap + 1;
                 if sortFrequency then
                    if ascending then
                       swap := abs(sorted_v[k1].im) >  abs(sorted_v[k2].im) or
                               abs(sorted_v[k1].im) == abs(sorted_v[k2].im) and
                               (sorted_v[k1].re  > sorted_v[k2].re or
                                sorted_v[k1].re  == sorted_v[k2].re and sorted_v[k1].im < sorted_v[k2].im);
                    else
                       swap := abs(sorted_v[k1].im) <  abs(sorted_v[k2].im) or
                               abs(sorted_v[k1].im) == abs(sorted_v[k2].im) and
                               (sorted_v[k1].re  < sorted_v[k2].re or
                                sorted_v[k1].re  == sorted_v[k2].re and sorted_v[k1].im < sorted_v[k2].im);
                    end if;
                 else
                    if ascending then
                       swap := Complex.'abs'(sorted_v[k1]) > Complex.'abs'(sorted_v[k2]);
                    else
                       swap := Complex.'abs'(sorted_v[k1]) < Complex.'abs'(sorted_v[k2]);
                    end if;
                 end if;
              else
                 swap := false;
              end if;

              while swap loop
                 wv := sorted_v[j+1];
                 wi := indices[j+1];
                 sorted_v[j+1] := sorted_v[j+gap+1];
                 sorted_v[j+gap+1] := wv;
                 indices[j+1] := indices[j+gap+1];
                 indices[j+gap+1] := wi;
                 j := j - gap;
                 if j >= 0 then
                    k1 := j+1;
                    k2 := j + gap + 1;
                    if sortFrequency then
                       if ascending then
                          swap := abs(sorted_v[k1].im) >  abs(sorted_v[k2].im) or
                                  abs(sorted_v[k1].im) == abs(sorted_v[k2].im) and
                                  (sorted_v[k1].re  > sorted_v[k2].re or
                                   sorted_v[k1].re  == sorted_v[k2].re and sorted_v[k1].im < sorted_v[k2].im);
                       else
                          swap := abs(sorted_v[k1].im) <  abs(sorted_v[k2].im) or
                                  abs(sorted_v[k1].im) == abs(sorted_v[k2].im) and
                                  (sorted_v[k1].re  < sorted_v[k2].re or
                                   sorted_v[k1].re  == sorted_v[k2].re and sorted_v[k1].im < sorted_v[k2].im);
                       end if;
                    else
                       if ascending then
                          swap := Complex.'abs'(sorted_v[k1]) > Complex.'abs'(sorted_v[k2]);
                       else
                          swap := Complex.'abs'(sorted_v[k1]) < Complex.'abs'(sorted_v[k2]);
                       end if;
                    end if;
                 else
                    swap := false;
                 end if;
              end while;
              i := i + 1;
           end while;
           gap := div(gap,2);
        end while;
        annotation (Documentation(info="<html>
  <h4>Syntax</h4>
  <blockquote><pre>
             sorted_v = Vectors.<b>sort</b>(v);
  (sorted_v, indices) = Vectors.<b>sort</b>(v, ascending=true);
  </pre></blockquote>
  <h4>Description</h4>
  <p>
  Function <b>sort</b>(..) sorts a Real vector v
  in ascending order and returns the result in sorted_v.
  If the optional argument \"ascending\" is <b>false</b>, the vector
  is sorted in descending order. In the optional second
  output argument the indices of the sorted vector with respect
  to the original vector are given, such that sorted_v = v[indices].
  </p>
  <h4>Example</h4>
  <blockquote><pre>
    (v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
         -> v2 = {-1, 2, 3, 6, 8}
            i2 = {1, 5, 3, 4, 2}
  </pre></blockquote>
  </html>"));
      end sortComplex;

      function multiply "Scalar product of two complex vectors"
        extends Modelica.Icons.Function;
          import Modelica_LinearSystems2.Math.Complex;
          import Modelica;

        input Complex v1[:];
        input Complex v2[size(v1,1)];
        output Complex result=Complex(0);

      algorithm
        for i in 1:size(v1,1) loop
          result := result + v1[i]*v2[i];
        end for;

      end multiply;

          function reverse
          "Reverse vector elements (e.g. v[1] becomes last element)"
            extends Modelica.Icons.Function;

          import Modelica;
          import Modelica_LinearSystems2.Math.Complex;

            input Complex v[:] "Vector";
            output Complex result[size(v, 1)]
            "Elements of vector v in reversed order";

          algorithm
            result := {v[end-i+1] for i in 1:size(v,1)};
          annotation (Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>reverse</b>(v);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call &quot;Vectors.<b>reverse</b>(v)&quot; returns the complex vector elements in reverse order.
</p>

<h4>Example</h4>
<blockquote><pre>
<b>reverse</b>({1,2,3,4});
  // = {4,3,2,1}
</pre></blockquote>
</html>"));
          end reverse;

        annotation (Documentation(info="<html>
<p>
This package provides functions operating on vectors of complex numbers.
</p>
</html>"));
      end Vectors;

      encapsulated package Matrices
        "Package of functions operating on matrices of complex numbers"
        extends Modelica.Icons.Package;
        import Modelica;
        import Modelica_LinearSystems2;

        function print "Print matrix"
          import Modelica_LinearSystems2.StateSpace;
          import Modelica.Utilities.Strings;
          import Modelica_LinearSystems2.Math.Complex;

          input Complex M[:,:];
          input Integer significantDigits=6
            "Number of significant digits that are shown";
          input String name="M" "Independent variable name used for printing";
          output String s="";
      protected
          String blanks=Strings.repeat(significantDigits);
          String space=Strings.repeat(8);
          String space2=Strings.repeat(3);
          Integer r=size(M, 1);
          Integer c=size(M, 2);

        algorithm
          if r == 0 or c == 0 then
            s := name + " = []";
          else
            s := "\n" + name + " = \n";
            for i in 1:r loop
              s := s + space;
              for j in 1:c loop
                if Complex.'abs'(M[i, j]) >= 0 then
                  s := s + " ";
                end if;
                s := s + String(M[i, j], significantDigits=significantDigits) +
                  Strings.repeat(significantDigits + 8 - Strings.length(String(Complex.'abs'(M[i,j]))));

              end for;
              s := s + "\n";
            end for;

          end if;
        end print;

        encapsulated function matMatMul "Multiply two complex matrices"
          import Modelica_LinearSystems2.Math.Complex;

          input Complex m1[:,:] "Complex matrix 1";
          input Complex m2[size(m1, 2),:] "Complex matrix 2";
          output Complex m3[size(m1, 1),size(m2, 2)] "= m1*m2";
        //   Complex j=Complex.j();
        //   Real m1Re[size(m1,1),size(m1,2)]=Re(m1);
        //   Real m1Im[size(m1,1),size(m1,2)]=Im(m1);
        //   Real m2Re[size(m2,1),size(m2,2)]=Re(m2);
        //   Real m2Im[size(m2,1),size(m2,2)]=Im(m2);
      protected
          Integer l1;
          Integer l2;
        algorithm
        //  m3 := m1[:, :].re*m2[:, :].re - m1[:, :].im*m2[:, :].im + j*(m1[:, :].re*m2[:,:].im + m1[:, :].im*m2[:, :].re);
        //  m3 :=m1Re*m2Re - m1Im*m2Im + j*(m1Re*m2Im + m1Im*m2Re);

         for l1 in 1:size(m1,1) loop
           for l2 in 1:size(m2,2) loop
             m3[l1,l2] := Complex.Vectors.multiply(m1[l1,:],m2[:,l2]);
           end for;
           end for;

        end matMatMul;

        encapsulated function matVecMul
          "Multiply a complex matrices with a complex vector"
          import Modelica_LinearSystems2.Math.Complex;
        //  import Re = Modelica_LinearSystems2.Math.Complex.real;
        //  import Im = Modelica_LinearSystems2.Math.Complex.imag;

          input Complex m[:,:] "Complex matrix";
          input Complex vi[size(m, 2)] "Complex vector";
          output Complex vo[size(m, 1)] "= m*vi";
        //   Complex j=Complex.j();
        //   Real Rem[size(m, 1),size(m, 2)]=Re(m);
        //   Real Imm[size(m, 1),size(m, 2)]=Im(m);
        //   Real Revi[size(vi, 1)]=Re(vi);
        //   Real Imvi[size(vi, 1)]=Im(vi);
      protected
          Integer l1;

        algorithm
        //  vo := Rem*Revi - Imm*Imvi + j*(Rem*Imvi + Imm*Revi);

        //    for l1 in 1:size(m, 1) loop
        //      vo[l1] := Complex(0);
        //      for l2 in 1:size(m, 2) loop
        //        vo[l1] := vo[l1] + m[l1, l2]*vi[l2];
        //      end for;//l2
        //    end for;  //l1

        for l1 in 1:size(m, 1) loop
          vo[l1] := Complex.Vectors.multiply(m[l1,:],vi);
        end for;

        end matVecMul;

        annotation (Documentation(info="<html>
<p>
This package provides functions operating on matrices of complex numbers.
</p>
</html>"));
      end Matrices;

      encapsulated operator 'constructor'
        "Collection of operators to construct a Complex number data record"
        import Modelica;

        function fromReal "Generate a complex number record from a real value"
          import Modelica_LinearSystems2.Math.Complex;
          input Real re "Real part of complex number";
          input Real im=0 "Imaginary part of complex number";
          output Complex result(re=re, im=im) "Complex number";
        algorithm

          annotation(Inline=true);
        end fromReal;
        annotation (Documentation(info="<html>
<p>This package contains the default constructors for a data record of complex number. </p>
</html>"));
      end 'constructor';

      encapsulated operator '-'
        "Collection of operators for subtraction of complex numbers"
        import Modelica;

        function negate "Unary minus (multiply complex number by -1)"
          import Modelica_LinearSystems2.Math.Complex; // changed to Modelica_LinearSystems2
          input Complex c1 "Complex number";
          output Complex c2 "= -c1";
        algorithm
          c2 := Complex(-c1.re, -c1.im);
          annotation(Inline=true);
        end negate;

        function subtract "Subtract two complex numbers"
          import Modelica_LinearSystems2.Math.Complex;// changed to Modelica_LinearSystems2
          input Complex c1 "Complex number 1";
          input Complex c2 "Complex number 2";
          output Complex c3 "= c1 - c2";
        algorithm
          c3 := Complex(c1.re - c2.re, c1.im - c2.im);
          annotation(Inline=true);
        end subtract;
        annotation (Documentation(info="<html>
<p>
This package contains operators for subtraction of complex numbers.
</p>
</html>"));
      end '-';

      encapsulated operator function '+' "Add two complex numbers"
        import Modelica_LinearSystems2.Math.Complex;

          input Complex c1 "Complex number 1";
          input Complex c2 "Complex number 2";
          output Complex c3 "= c1 + c2";
      algorithm
        c3 := Complex(c1.re + c2.re, c1.im + c2.im);
        annotation(Inline=true);
      end '+';

      encapsulated operator function '*' "Multiply two complex numbers"
        import Modelica_LinearSystems2.Math.Complex;

          input Complex c1 "Complex number 1";
          input Complex c2 "Complex number 2";
          output Complex c3 "= c1*c2";
      algorithm
          c3 := Complex(c1.re*c2.re - c1.im*c2.im, c1.re*c2.im + c1.im*c2.re);
        annotation(Inline=true);
      end '*';

      encapsulated operator function '/' "Divide two complex numbers (c1 / c2)"
        import Modelica_LinearSystems2.Math.Complex;

          input Complex c1 "Complex number 1";
          input Complex c2 "Complex number 2";
          output Complex c3 "= c1/c2";
      algorithm
          c3 := Complex((c1.re*c2.re + c1.im*c2.im)/(c2.re^2 + c2.im^2), (-c1.re*c2.im + c1.im*c2.re)/(c2.re^2 + c2.im^2));
        annotation(Inline=true);
      end '/';

      encapsulated operator function '=='
        "Test whether two complex numbers are identical"
        import Modelica_LinearSystems2.Math.Complex;
          input Complex c1 "Complex number 1";
          input Complex c2 "Complex number 2";
          output Boolean result "c1 == c2";
      algorithm
          result := c1.re == c2.re and c1.im == c2.im;
        annotation(Inline=true);
      end '==';

      encapsulated operator function 'String'
        "Transform Complex number into a String representation"
        import Modelica_LinearSystems2.Math.Complex;
          input Complex c
          "Complex number to be transformed in a String representation";
          input String name="j"
          "Name of variable representing sqrt(-1) in the string";
          input Integer significantDigits=6
          "Number of significant digits that are shown";
          output String s="";
      algorithm
          s := String(c.re, significantDigits=significantDigits);
          if c.im <> 0 then
            if c.im > 0 then
              s := s + " + ";
            else
              s := s + " - ";
            end if;
            s := s + String(abs(c.im), significantDigits=significantDigits) + "*" + name;
          end if;
        //    end toString;
      end 'String';

      encapsulated function j "Returns sqrt(-1)"
        import Modelica_LinearSystems2.Math.Complex;

        output Complex c "= sqrt(-1)";
      algorithm
        c := Complex(0,1);
        annotation(Inline=true);
      end j;

      encapsulated function 'abs' "Absolute value of complex number"
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c "Complex number";
        output Real result "= abs(c)";
      algorithm
        result := (c.re^2 + c.im^2)^0.5; //changed from sqrt
        annotation(Inline=true);
      end 'abs';

      encapsulated function 'sqrt' "Square root of complex number"
        import Modelica.Math;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c1 "Complex number";
        output Complex c2 "= sqrt(c1)";
      algorithm
        c2 := Complex(sqrt(Complex.'abs'(c1))*Math.cos(Complex.arg(c1)/2), sqrt(
          Complex.'abs'(c1))*Math.sin(Complex.arg(c1)/2));
        annotation(Inline=true);
      end 'sqrt';

    encapsulated function 'max' "Return maximum element of complex vector"
        import Modelica_LinearSystems2.Math.Complex;

      input Complex v[:] "Vector";
      output Real result "Element of v with largest absolute value";
      output Integer index "v[index] has the largest absolute value";

    protected
      Real absv_i;
    algorithm
      if size(v,1) > 0 then
         result := Complex.'abs'(v[1]);
         index  := 1;
         for i in 2:size(v,1) loop
            absv_i :=Complex.'abs'(v[i]);
            if absv_i > result then
               result := absv_i;
               index := i;
            end if;
         end for;
      else
         result := 0;
         index  := 0;
      end if;
      annotation (Documentation(info="<html>
</html>"));
    end 'max';

      encapsulated function exp "Exponential of complex number"
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica.Math;

        input Complex c1 "Complex number";
        output Complex c2 "= exp(c1)";
      algorithm
         c2 := Complex(Math.exp(c1.re)*Math.cos(c1.im), Math.exp(c1.re)*Math.sin(c1.im));
        annotation(Inline=true);
      end exp;

      encapsulated function log "Logarithm of complex number"

        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c1 "Complex number";
        output Complex c2 "= log(c1)";
      algorithm
        c2 := Complex(Modelica.Math.log(Complex.'abs'(c1)), Complex.arg(c1));
        annotation(Inline=true);
      end log;

      encapsulated function sin "Sine of complex number"

        import Modelica_LinearSystems2.Math.Complex;

        input Complex c1 "Complex number";
        output Complex c2 "sin(c1)";

      algorithm
         c2 := (Complex.exp(Complex(-c1.im, +c1.re)) - Complex.exp(Complex(+c1.im, -c1.re)))/
          Complex(0, 2);

        annotation(Inline=true);
      end sin;

      encapsulated function cos "Cosine of complex number"
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c1 "Complex number";
        output Complex c2 "= cos(c1)";

      algorithm
       c2 := (Complex.exp(Complex(-c1.im, +c1.re)) + Complex.exp(Complex(+c1.im, -c1.re)))/2;
        annotation(Inline=true);
      end cos;

      encapsulated function arg "Phase angle of complex number"
        import Modelica;
        import Modelica_LinearSystems2.Math;
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c "Complex number";
        input Modelica.Units.SI.Angle phi0=0
          "phase angle phi shall be in the range: -pi < phi-phi0 < pi";
        output Modelica.Units.SI.Angle phi "= phase angle of c";

      algorithm
        phi := Modelica.Math.atan3(
            c.im,
            c.re,
            phi0);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
   Complex.<b>arg</b>(c);
   Complex.<b>arg</b>(c, phi0=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Complex.<b>arg</b>(c)</code>\" returns the
phase angle phi of the Complex number c in the range
-pi &lt; phi &lt; pi.<br>
The function call \"<code>Complex.<b>arg</b>(c,phi0)</code>\" returns the
phase angle phi of the Complex number c in the range
-pi &lt; phi - phi0 &lt; pi.
</p>
<h4>Example</h4>
<blockquote><pre>
  Complex.<b>arg</b>( Complex(1,0.5), 4*pi );  // = 4*pi+pi/4 = 13.351...
</pre></blockquote>
</html>"),         Inline=true);
      end arg;

      encapsulated function conj "Conjugate of complex number"
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c1 "Complex number";
        output Complex c2 "= c1.re - j*c1.im";
      algorithm
        c2 := Complex(c1.re, -c1.im);
        annotation(Inline=true);
      end conj;

      encapsulated function real "Real part of complex number"
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c "Complex number";
        output Real r "= c.re ";
      algorithm
        r := c.re;
        annotation(Inline=true);
      end real;

      encapsulated function imag "Imaginary part of complex number"
        import Modelica_LinearSystems2.Math.Complex;

        input Complex c "Complex number";
        output Real r "= c.im ";
      algorithm
        r := c.im;
        annotation(Inline=true);
      end imag;

      encapsulated function eigenValues
        "Compute eingenvalues of a matrix A, using lapack routine dgeevx"

        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx;

        input Real A[:,size(A, 1)] "Real matrix";
        output Complex eigval[size(A, 1)]
          "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";

    protected
        Integer nx=size(A, 1) "Number of states";

        Real alphaReal[nx];
        Real alphaImag[nx];

        Integer info;

      algorithm
       // Compute eigenvalues
        if size(A, 1) > 0 then
           (alphaReal,alphaImag,,,,info) := dgeevx(A);
           assert(info == 0,
             "Failed to compute eigenvalues with function eigenValues_dgeevx(..)");

           for i in 1:nx loop
             eigval[i].re := alphaReal[i];
             eigval[i].im := alphaImag[i];
           end for;
        end if;
        annotation (Documentation(info="<html>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<pre>
   der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
        <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre>
<p>
The invariant zeros of this system are defined as the variables
z that make the following matrix singular:
</p>
<pre>
    | <b>A</b> <b>B</b> |     | <b>I</b> <b>0</b> |
    |     | - z*|     |
    | <b>C</b> <b>D</b> |     | <b>0</b> <b>0</b> |
</pre>
<p>
where <b>I</b> is the identity matrix of the same size as <b>A</b>
and <b>0</b> are zero matrices of appropriate dimensions.
</p>
<p>
Currently, there is the restriction that the number of
inputs and the number of outputs must be identical.
</p>
</html>"));
      end eigenValues;

      encapsulated function eigenVectors
        "Calculate the rigth eigenvectors of a linear state space system and write them columnwise in a matrix."
        import Modelica;
        import Modelica.Math.Matrices.LAPACK;
        import Modelica_LinearSystems2.Math.Complex;

        input Real A[:,size(A, 1)] "real square matrix";
        output Complex eigvec[size(A, 1),size(A, 2)] "eigen values of the system";
        output Complex eigval[size(A, 1)]=fill(Complex(0), size(A, 1))
          "eigen values of the system";
    protected
        Integer info;
        Real eigvecRe[size(A, 1),size(A, 2)];
        Real eigvalRe[size(A, 1)]=fill(0, size(A, 1));
        Real eigvalIm[size(A, 1)]=fill(0, size(A, 1));
        Integer n=size(A, 1);
        Integer i;
        Complex j=Complex.j();
      algorithm
        if size(A, 1) > 0 then

          (eigvalRe,eigvalIm,eigvecRe,info) := LAPACK.dgeev(A);
          for i in 1:size(A, 1) loop
            eigval[i].re := eigvalRe[i];
            eigval[i].im := eigvalIm[i];
          end for;

          assert(info == 0, "Calculating the eigen values with function
  \"StateSpace.Analysis.eigenVectors\" is not possible, since the
  numerical algorithm does not converge.");

          i := 1;
          while i <= n loop
            if abs(eigvalIm[i]) > 0 then
              for ii in 1:n loop
                eigvec[ii, i] := eigvecRe[ii, i] + j*eigvecRe[ii, i + 1];
                eigvec[ii, i + 1] := eigvecRe[ii, i] - j*eigvecRe[ii, i + 1];
              end for;
              i := i + 2;
            else
              for ii in 1:n loop
                eigvec[ii, i] := Complex(1)*eigvecRe[ii, i];
              end for;
              i := i + 1;
            end if;
          end while;

        end if;

        annotation (Documentation(info="<html>
  <h4>Syntax</h4>
  <table>
  <tr> <td align=right>  (eigenvectors, eigenvalues) </td><td align=center> =  </td>  <td> StateSpace.Analysis.<b>eigenVectors</b>(ss, onlyEigenvectors)  </td> </tr>
  </table>
  <h4>Description</h4>
  <p>
  Calculate the eigenvectors and optionally (onlyEigenvectors=false) the eigenvalues of a state space system. The output <tt>eigenvectors</tt> is a matrix with the same dimension as matrix <b>ss.A</b>. Just like in <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Modelica.Math.Matrices.eigenValues</a>, if the i-th eigenvalue has an imaginary part, then <tt>eigenvectors</tt>[:,i] is the real and <tt>eigenvectors</tt>[:,i+1] is the imaginary part of the eigenvector of the i-th eigenvalue.<br>
  The eigenvalues are returned as a complex vector <tt>eigenvalues</tt>.


  </p>

  <h4>Example</h4>
  <blockquote><pre>
     Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
        A=[-1,1;-1,-1],
        B=[1;1],
        C=[1,1],
        D=[0]);

     Real eigenvectors[2,2];
     Complex eigenvalues[2];

  <b>algorithm</b>
    (eigenvectors, eigenvalues) = Modelica_LinearSystems2.StateSpace.Analysis.eigenVectors(ss, true);
  // eigenvectors = [0.707, 0; 0, 0.707]
  // eigenvalues = {-1 + 1j, -1 - 1j}

            |0.707 |         | 0.707 |
  i.e. v1 = |      |,   v2 = |       |
            |0.707i|         |-0.707i|
  </pre></blockquote>


  </html>"));
      end eigenVectors;

      encapsulated function frequency
        "Frequency and damping of conjugated complex pole pair"
        import Modelica;
        import Modelica_LinearSystems2.Math;
        import Modelica_LinearSystems2.Math.Complex;
        input Complex c "Complex number";
        output Modelica.Units.SI.Frequency f "Frequency of c (= c.im in Hz)";
        output Real damping "Damping of c (= c.re/c.im)";

    protected
        Real abs_ev=(c.re^2 + c.im^2)^0.5;
      algorithm
        f := if abs(c.im) > 10*Modelica.Constants.eps then abs_ev/(2*Modelica.Constants.pi) else 0;
        damping := if abs(c.im) > 10*Modelica.Constants.eps then if abs_ev > Modelica.Constants.eps then -c.re/abs_ev else 0.0 else
          1.0;
        annotation(Inline=true);
      end frequency;

      encapsulated package Internal
        "Package of internal functions operating on complex number (for advanced users only)"
        extends Modelica.Icons.Package;
        import Modelica;

        function eigenValues_dhseqr
          "Compute eingenvalues of a upper Hessenberg matrix using lapack routine DHSEQR"

          import Modelica;
          import Modelica_LinearSystems2.Math.Complex;
          import
            Modelica_LinearSystems2.Math.Matrices.Internal.eigenvaluesHessenberg;

          input Real H[:,size(H, 1)] "Real upper Hessenberg matrix";
          output Complex zeros[size(H, 1)]
            "Finite, invariant zeros of ss; size(Zeros,1) <= size(ss.A,1)";

      protected
          Integer nx=size(H, 1) "Number of states";
          Real alphaReal[nx];
          Real alphaImag[nx];
          Integer info;

        algorithm
          (alphaReal,alphaImag,info) := eigenvaluesHessenberg(H);
          assert(info == 0,
            "Failed to compute eigenvalues with function Internal.eigenValues_dhseqr(..)");

          for i in 1:nx loop
            zeros[i].re := alphaReal[i];
            zeros[i].im := alphaImag[i];
          end for;

        end eigenValues_dhseqr;

        function C_transpose "Computes the transposed matrix of a complex matrix"
          extends Modelica.Icons.Function;

          import Modelica_LinearSystems2.Math.Complex;


          input Complex C[:,:];
          output Complex CT[size(C, 2),size(C, 1)];
      protected
          Complex j=Complex.j();
          Integer l1;
          Integer l2;
        algorithm
        //  CT := Complex(1)*transpose(C[:,:].re)-j*transpose(C[:,:].im);// too slow
          for l1 in 1:size(C, 1) loop
            for l2 in 1:size(C, 2) loop
        //      CT[l2, l1] := Re(C[l1, l2]) - j*Im(C[l1, l2]);
              CT[l2, l1] := Complex.conj(C[l1,l2]);
            end for;
          end for;

        end C_transpose;

        function frobeniusNorm "Return the Frobenius norm of a matrix"
          extends Modelica.Icons.Function;
          import Modelica_LinearSystems2.Math.Complex;
          input Complex A[:,:] "Input matrix";
          output Real result=0.0 "frobenius norm of matrix A";
        algorithm
          for i1 in 1:size(A, 1) loop
            for i2 in 1:size(A, 2) loop
              result := result + Complex.real(A[i1, i2]*Complex.conj(A[i1, i2]));
            end for;
          end for;
          result := sqrt(result);
        end frobeniusNorm;

        annotation (Documentation(info="<html>
<p>
Generally, the functions in this package should not be used by the user.
</p>
<p>
This package contains functions which cannot be used in an arbitrary
way and require particular knowledge.
Therefore, only advanced users should deal with such a functions.
</p>
</html>"));
      end Internal;

      annotation (
        Documentation(info="<html>
<p>
This record defines a complex number consisting of a real
and an imaginary part. Additionally, various utility functions
are provided in the record to operate on instances of this record.
Example (note: \"j\" in the comments is defined as j=sqrt(-1)):
</p>
<pre>
   <b>import</b> Modelica.Utilities.Streams;
   <b>import</b> Modelica_LinearSystems2.Math.Complex;
   Complex c1=Complex(re=2, im=3) \"= 2 + 3j\";
   Complex c2=Complex(3,4) \"= 3 + 4j\";
 <b>algorithm</b>
   c3 := Complex.'+'(c1, c2) \"= c1 + c2\";
   Streams.print(\"c3 = \" + Complex.'String'(c3));
   Streams.print(\"c3 = \" + Complex.'String'(c3,\"i\"));
   // This gives the following print-out:
   c3 = 5 + 7j
   c3 = 5 + 7i
</pre>
<p>
The utility functions are written in such a way that it
is convenient to work with them, once operator overloading
is provided in Modelica and Modelica tools. Example:
</p>
<pre>
   // Assume operator overloading is available (this is not yet the case):
   Complex j  = Complex.j();
   Complex c4 = -2 + 5*j;
   // A Modelica tool will transform the statement of c4 into
   Complex c4 = Complex.'+'( Complex.(-2,0), Complex.'*'(Complex(5,0),j)));
</pre>
<p>
The utility functions are implemented so that they can be easily
inlined by a tool. In such a case, the above statement will
not lead to any overhead.
</p>
</html>"));
    end Complex;

    operator record Polynomial "Record defining the data for a polynomial"

      Real c[:] "Polynomial coefficients (c[1]*x^n + ... c[n]*x + c[n+1])"
        annotation (Dialog);

      encapsulated package Examples
        "Package of examples to demonstrate the usage of polynomials"
        extends Modelica.Icons.ExamplesPackage;
        import Modelica;

        function polynomialOperations1
          "Demonstrate basic algebraic operations on polynomials"
          import Modelica.Utilities.Streams.print;
          import Modelica_LinearSystems2.Math.Polynomial;

          output Boolean ok;

      protected
          Polynomial t=Polynomial.x();
          Polynomial p;
        algorithm
          p := t^2 + 8*t + 16;

          print("y1 = " + String(p, name="t"));
          print("y2 = " + String(p*p, name="t"));
          ok := true;
        end polynomialOperations1;

        function polynomialOperations2
          "Demonstrate differentiation and integration of polynomials"
          import Modelica;
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica_LinearSystems2.TransferFunction;
          import Modelica.Utilities.Streams.print;

          output Boolean ok;
      protected
          Polynomial p=Polynomial({6,4,-3}) "6*x^2 + 4*x - 3";
          Polynomial int_p;
          Polynomial der_p;
          TransferFunction tf;
          Real x;
          Real int_val1;
          Real int_val2;
          Real der_val1;
          Real der_val2;
          Real der_val3;
          Real der_val4;
        algorithm
          print("Show integration and differentation of y = " + String(p));
          int_p := Polynomial.integral(p);
          der_p := Polynomial.derivative(p);

          print("  Integral of polynomial  : " + String(int_p));
          print("  Derivative of polynomial: " + String(der_p));

          print(
            "Compute derivatives and integral directly and via polynomials above (for p(x=2)):");
          x := 2;
          int_val1 := Polynomial.integralValue(p, x);
          int_val2 := Polynomial.evaluate(int_p, x);
          print("      integralValue(p,x) = " + String(int_val1) +
            ", evaluate(integral(p),x) = " + String(int_val2));

          der_val1 := Polynomial.derivativeValue(p, x);
          der_val2 := Polynomial.evaluate(der_p, x);
          print("    derivativeValue(p,x) = " + String(der_val1) +
            ", evaluate(derivative(p),x) = " + String(der_val2));
          der_val3 := Polynomial.derivativeValue(
                p,
                x,
                2);
          der_val4 := Polynomial.evaluate(Polynomial.derivative(der_p), x);
          print("  derivativeValue(p,x,2) = " + String(der_val3) +
            ", evaluate(derivative(derivative(p)),x) = " + String(der_val4));
          tf := der_p/int_p;
          print("  derivative/integral of polynomial = " + String(tf, name="x"));
          ok := true;
        end polynomialOperations2;

        function PascalTriangle "Generate and print Pascals triangle"
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica.Utilities.Streams.print;

          output Boolean ok;
      protected
          Polynomial p=Polynomial.x();
          Polynomial p1;
        algorithm
          p1 := p + 1;
          print("Pascals triangle up to order 20:");
          for i in 0:20 loop
            print("  " + String(p1^i));
          end for;
          ok := true;
        end PascalTriangle;

        function plotPolynomial
          "Demonstrate plotting of polynomial with automatic range and legend determination"
          import Modelica_LinearSystems2;
          import Modelica_LinearSystems2.Math;
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica_LinearSystems2.Math.Complex;

          output Boolean ok;

      protected
          Complex j=Modelica_LinearSystems2.Math.Complex.j();
          Complex c[:]={-2 + 0*j,Complex(0),2 + 0*j,7 + j,7 - j};
          Polynomial p=Polynomial(c);
        algorithm
          Polynomial.plot(p);
          ok := true;
          annotation (__Dymola_interactive=true);
        end plotPolynomial;
      end Examples;

      encapsulated operator 'constructor'
        "Collection of operators to construct a Polynomial data record"
        import Modelica;

        function fromVector
          "Generate a Polynomial data record from a vector of coefficients"
          import Modelica;
          import Modelica_LinearSystems2.Math.Polynomial;

          input Real c[:] "Coefficients of polynomial in descending order";
          output Polynomial p(redeclare Real c[size(c, 1)]) "Polynomial";
        algorithm
          p.c := c;
        end fromVector;

        function fromReal "Generate a Polynomial data record from a real value"
          import Modelica;
          import Modelica_LinearSystems2.Math.Polynomial;

          input Real r "Value of Real variable";
          output Polynomial p(redeclare Real c[1]);
        algorithm
          p.c := {r};
        end fromReal;

        function fromZeros "Generate a Polynomial data record from given zeros"
          import Modelica;
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica.Utilities.Streams;
          import Modelica_LinearSystems2.Math.Complex;

          input Complex roots[:]
            "Zeros of polynomial (must be real or conjugate complex pairs)";
          output Polynomial p(redeclare Real c[size(roots, 1) + 1])
            "Polynomial that corresponds to the zeros";

      protected
          Integer nr=size(roots, 1) "Number of roots";
          Integer nc=nr + 1 "Length of coefficient vector";
          Integer nn;
          Integer i;
        algorithm
          p.c[nc] := 1;
          i := 1;
          nn := 1;
          while i <= nr loop
            // Determine whether zero is real or conjugate complex
            if roots[i].im == 0.0 then
              // real root
              p.c := Polynomial.Internal.mult(
                    p.c,
                    nn,
                    {1,-roots[i].re},
                    nc);

              i := i + 1;
              nn := nn + 1;
            else
              // complex root; check that it is a conjugate complex pair
              assert(i < nr, "Roots do not define a real valued polynomial\n" +
                "(roots[" + String(nr) + "] is complex without complex conjugate)");
              assert(roots[i].re == roots[i + 1].re,
                "No conjugate complex zero pair\n" + "  roots[" + String(i) +
                "].re = " + String(roots[i].re) + "\n" + "  roots[" + String(i + 1)
                 + "].re = " + String(roots[i].re) + "\n" +
                "and the two values should be identical since conjugate complex pair required.");
              assert(roots[i].im == -roots[i + 1].im,
                "No conjugate complex zero pair\n" + "  roots[" + String(i) +
                "].im = " + String(roots[i].im) + "\n" + "  roots[" + String(i + 1)
                 + "].im = " + String(roots[i + 1].im) + "\n" +
                "and the two values should be identical with opposite sign, since conjugate complex pair required.");
              p.c := Polynomial.Internal.mult(
                    p.c,
                    nn,
                    {1,-2*roots[i].re,roots[i].re^2 + roots[i].im^2},
                    nc);
              i := i + 2;
              nn := nn + 2;
            end if;
          end while;
          annotation (Documentation(info="<html>
<p>
This function constructs a polynomial from given zeros
(also called roots). The zeros are defined as a vector
of Complex numbers. Since only polynomials with real coefficients are supported,
complex zeros must be defined as conjugate complex pairs.
It is required that complex conjugate pairs must directly
follow each other. An error occurs if this is not the case.
Example:
</p>
<p>
The polynomial
</p>
<pre>
 y = (s - 1)*(s - (2+3j))*(s - (2-3j))
</pre>
<p>
with j=sqrt(-1), is defined as
</p>
<pre>
  p = Polynomial.fromZeros( {Complex(1),
                             Complex(2,  3),
                             Complex(2, -3)} );
      // = x^3 - 5*x^2 + 17*x - 13
</pre>
</html>"));
        end fromZeros;

        annotation (Documentation(info="<html>
<p>This package contains the default constructors for a data record of polynomial. </p>
</html>"));
      end 'constructor';

      encapsulated operator '-'
        "Collection of operators for subtraction of polynomials"
        import Modelica;

        encapsulated function negate "Unary minus (multiply polynomial by -1)"

          import Modelica_LinearSystems2.Math.Polynomial;
          input Polynomial p;
          output Polynomial result(redeclare Real c[size(p.c, 1)]) "= -p";
        algorithm
          result.c := -p.c;
        end negate;

        encapsulated function subtract "Subtract two polynomials (p1 - p2)"
          import Modelica_LinearSystems2.Math.Polynomial;

          input Polynomial p1;
          input Polynomial p2;
          output Polynomial result(redeclare Real c[max(size(p1.c, 1), size(p2.c, 1))])
            "= p1 - p2";
        algorithm
          // Auxiliary variables not used, to enforce function inlining
          result.c := cat(
                1,
                zeros(max(size(p1.c, 1), size(p2.c, 1)) - size(p1.c, 1)),
                p1.c) - cat(
                1,
                zeros(max(size(p1.c, 1), size(p2.c, 1)) - size(p2.c, 1)),
                p2.c);
        end subtract;
        annotation (Documentation(info="<html>
<p>
This package contains operators for subtraction of Polynomial data records.
</p>
</html>"));
      end '-';

      encapsulated operator function '+' "Add two polynomials (p1 + p2)"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p1;
        input Polynomial p2;
        output Polynomial result(redeclare Real c[max(size(p1.c, 1), size(p2.c, 1))])
          "= p1 + p2";
      algorithm
        // Auxiliary variables not used, to enforce function inlining
        result.c := cat(
            1,
            zeros(max(size(p1.c, 1), size(p2.c, 1)) - size(p1.c, 1)),
            p1.c) + cat(
            1,
            zeros(max(size(p1.c, 1), size(p2.c, 1)) - size(p2.c, 1)),
            p2.c);
      end '+';

      encapsulated operator function '*' "Multiply two polynomials (p1 * p2)"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p1;
        input Polynomial p2;
        output Polynomial result(redeclare Real c[size(p1.c, 1) + size(p2.c, 1) - 1])
          "= p1 * p2";
    protected
        Integer n1=size(p1.c, 1);
        Integer n2=size(p2.c, 1);
        Integer n3=n1 + n2 - 1;
        Real ck;
      algorithm
        for k in 1:n3 loop
          ck := 0.0;
          for j in max(1, k + 1 - n2):min(k, n1) loop
            ck := ck + p1.c[j]*p2.c[k + 1 - j];
          end for;
          result.c[k] := ck;
        end for;
      end '*';

      encapsulated operator function '/' "Divide two polynomials (p1 / p2)"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.TransferFunction;

        input Polynomial p1;
        input Polynomial p2;

        output TransferFunction tf(n=p1.c, d=p2.c);
        //only for tfpoly
      algorithm

        assert(size(p2.c, 1) > 0,
          "Denominator polynomial p2 must have at least one element, however\n" +
          "denominator is an empty polynomial. This is not allowed for p1/p2.");

      end '/';

      encapsulated operator function '^' "Integer power of polynomial (p^n)"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica.Utilities.Streams.print;

        input Polynomial p;
        input Integer n(min=0) = 1 "p^n shall be computed";
        output Polynomial result(redeclare Real c[max((size(p.c, 1) - 1)*n + 1, 1)])
          "= p^n";
    protected
        Integer n_p=size(p.c, 1);
        Integer n_power_p=max((n_p - 1)*n + 1, 1);
      algorithm
        if n == 0 then
          result.c := {1};
        else
          result.c[n_power_p - n_p + 1:n_power_p] := p.c;
          for i in 2:n loop
            result.c := Polynomial.Internal.mult(
                result.c,
                (n_p - 1)*(i - 1) + 1,
                p.c,
                n_power_p);
          end for;
        end if;
      end '^';

      encapsulated operator function '=='
        "Check whether two polynomials are identical"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p1;
        input Polynomial p2;
        input Real eps(min=0) = 0
          "Two coefficients c1 and c2 of the two polynomials are identical if abs(c1-c2) <= eps";
        output Boolean same "=true, if identical";
    protected
        Integer n1=size(p1.c, 1);
        Integer n2=size(p2.c, 1);
      algorithm
        if n1 == n2 then
          same := true;
          for i in 1:n1 loop
            if abs(p1.c[i] - p2.c[i]) > eps then
              same := false;
            end if;
          end for;
        else
          same := false;
        end if;
      end '==';

      encapsulated operator function 'String'
        "Transform Polynomial into a String representation"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2;
        import Modelica;

        input Polynomial p
          "Polynomial to be transformed in a String representation";
        input Integer significantDigits=6
          "Number of significant digits that are shown";
        input String name="x" "Independent variable name used for printing";
        output String s="";
    protected
        Boolean outputCoefficient;
        Integer power;
        Real ci;
        String v;
        Integer n=size(p.c, 1);
        Boolean first=true;
      algorithm
        if n == 0 then
          s := "0";
        else
          for i in 1:n loop
            if p.c[i] <> 0 or i == n then
              power := n - i;
              ci := p.c[i];
              if first then
                first := false;
              else
                if ci > 0 then
                  s := s + " + ";
                elseif ci < 0 then
                  s := s + " - ";
                  ci := abs(ci);
                end if;
              end if;

              outputCoefficient := power == 0 or abs(ci - 1) > Modelica.Constants.eps;
              if outputCoefficient then
                s := s + String(ci, significantDigits=significantDigits);
              end if;
              if outputCoefficient and power >= 1 then
                s := s + "*";
              end if;
              if name == "" then
                v := "?";
              else
                v := name;
              end if;
              if power >= 2 then
                s := s + v + "^" + String(power);
              elseif power == 1 then
                s := s + v;
              end if;
            end if;
          end for;
        end if;
      end 'String';

      encapsulated function x "Generate a base polynomial y=x"
        import Modelica_LinearSystems2.Math.Polynomial;

        output Polynomial p(redeclare Real c[2]) "Polynomial";
      algorithm
        p.c := {1,0};
      end x;

      encapsulated function fitting
        "Computes a Polynomial that fits a set of data points in a least-squares sense"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Real x[:] "Abscissa data values";
        input Real y[size(x, 1)] "Ordinate data values";
        input Integer order(min=1)
          "Order of desired polynomial that fits the data points (x,y)";
        output Polynomial p(redeclare Real c[order + 1])
          "Polynomial that fits the date points in a least squares sense";

    protected
        Real V[size(x, 1), order + 1] "Vandermonde matrix";
      algorithm
        // Construct Vandermonde matrix
        V[:, order + 1] := ones(size(x, 1));
        for j in order:-1:1 loop
          V[:, j] := {x[i]*V[i, j + 1] for i in 1:size(x, 1)};
        end for;

        // Solve least squares problem
        p.c := Modelica.Math.Matrices.leastSquares(V, y);
        annotation (Documentation(info="<html>
<p>
Polynomial.fitting(x,y,order) computes a Polynomial
y=p(x) of degree &quot;order&quot; that fits the data &quot;p(x[i]) - y[i]&quot;
in a least squares sense.
</p>
</html>"));
      end fitting;

      encapsulated function degree "Return degree of polynomial"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p;
        output Integer result "Degree of polynomial p";

      algorithm
        result := size(p.c, 1) - 1;
      end degree;

      encapsulated function degree2 "Return degree of polynomial"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p;
        output Integer result "Degree of polynomial p";
    protected
        Integer s;
      algorithm
        s := size(p.c, 1);
        for i in 1:s loop
          // added correct code for degree calculation
          if p.c[i] <> 0 then
            result := s - i;
            break;
          end if;
        end for;
      end degree2;

      encapsulated function plot "Plot polynomial y=p(x)"

        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica.Utilities.Strings;
        import Modelica_LinearSystems2.Math.Complex;

        input Polynomial p "Polynomial to be plotted";
        input Integer nPoints(min=2) = 200 "Number of points";
        input Boolean autoLabel=true "True, if automatically selected labels";
        input String xLabel="" "Abszissa description, if autoLabel = false";
        input String yLabel="" "Ordinate description, if autoLabel = false";
        input Boolean autoRange=true
          "True, if abszissa range is automatically determined";
        input Real x_min=-1.0 "Minimum abszissa value, if autoRange = false";
        input Real x_max=1.0 "Maximum abszissa value, if autoRange = false";
    protected
        Real x_min2;
        Real x_max2;
        Real dx;
        Real x[nPoints];
        Real y[nPoints];
        Boolean OK;
        String yLabel2;
        Complex p_zeros[:];
        Complex pd_zeros[:];
        Complex points[:];
        String argument="x";
      algorithm
        /* Determine suitable x_min and x_max:
        Plotted range should contain roots and extrema
     */

        if autoRange then

          x_min2 := -1;
          x_max2 := +1;
          if size(p.c, 1) > 1 then
            p_zeros := Polynomial.roots(p);
            pd_zeros := Polynomial.roots(Polynomial.derivative(p));
            points := cat(
                1,
                p_zeros[:],
                pd_zeros[:]);

            x_min2 := points[1].re;
            x_max2 := points[1].re;
            for i in 2:size(points, 1) loop
              x_min2 := min(x_min2, points[i].re);
              x_max2 := max(x_max2, points[i].re);
            end for;

            if x_max2 > x_min2 then
              x_min2 := x_min2 - 0.1*(x_max2 - x_min2);
              x_max2 := x_max2 + 0.1*(x_max2 - x_min2);
            else
              x_min2 := x_min2 - 1;
              x_max2 := x_max2 + 1;
            end if;
          end if;
        else
          x_min2 := x_min;
          x_max2 := x_max;
        end if;

        // Compute polynomial values
        dx := (x_max2 - x_min2)/(nPoints - 1);
        x := x_min2:dx:x_max2;
        y := Polynomial.evaluate(p, x);

        // Determine labels
        if autoLabel then
          yLabel2 := String(p);
          if Strings.length(yLabel2) >= 100 then
            yLabel2 := Strings.substring(
                yLabel2,
                1,
                96) + " ...";
          end if;
        else
          yLabel2 := yLabel;
        end if;

        // Plot Polynomial
        OK := plotArray(
            x,
            y,
            legend=yLabel2);

      equation

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<p>
Plots the given polynomial. If default arguments are used, as in:
</p>
<pre>
    Polynomial p = Polynomial({1,2,3});
    Polynomial.plotPolynomial(p);
</pre>
<p>
then the abszissa range is determined in such a way that all
roots (i.e., p(x)=0) and all extrema (i.e, pd=derivative(p), pd(x)=0)
are in the plotted range. As default legend, the String representation
of the polynomial is used as generated by Polynomial.'String'(..).
</p>
</html>"));
      end plot;

      encapsulated function derivative "Derivative of Polynomial"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p;
        output Polynomial der_p(redeclare Real c[size(p.c, 1) - 1])
          "Derivative of Polynomial p";
    protected
        Integer n=size(p.c, 1);
      algorithm
        for j in 1:n - 1 loop
          der_p.c[j] := p.c[j]*(n - j);
        end for;
      end derivative;

      encapsulated function integral "Indefinite integral of Polynomial"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial";
        output Polynomial integral_p(redeclare Real c[size(p.c, 1) + 1])
          "Indefinite integral of polynomial p";
    protected
        Integer n=size(p.c, 1) + 1 "Number of coefficients of integral";
      algorithm
        for j in 1:n - 1 loop
          integral_p.c[j] := p.c[j]/(n - j);
        end for;
        integral_p.c[n] := 0;
      end integral;

      encapsulated function evaluate
        "Evaluate a Polynomial at a given (Real) abszissa value"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial to be evaluated";
        input Real x "Abszissa value";
        output Real y "Value of polynomial at x";

    protected
        Integer n=size(p.c, 1);
      algorithm
        y := p.c[1];
        for j in 2:n loop
          y := p.c[j] + x*y;
        end for;
        annotation (derivative(zeroDerivative=p) = Polynomial.evaluate_der);
      end evaluate;

      encapsulated function evaluateMatrix
        "Evaluate a Polynomial with a matrix argument"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial to be evaluated";
        input Real X[:, size(X, 1)] "Square matrix argument";
        output Real Y[size(X, 1), size(X, 2)] "Value of polynomial at X";

    protected
        Integer n=size(p.c, 1);
      algorithm
        Y := zeros(size(X, 1), size(X, 2));
        for j in 1:n loop
          Y := X*Y + diagonal(p.c[j]*ones(size(X, 1)));
        end for;
        annotation (Documentation(info="<html>
<p>
Evaluates the given polynomial <i>p</i> of order <i>n</i> with its coefficients c[i] so that
</p>
<pre>
    <b>Y</b> = p.c[1]*<b>X</b>^n + p.c[2]*<b>X</b>^(n-1) + ... + p.c[n]*<b>X</b> + p.c[n+1]*<b>I</b>
</pre>
<p>
Note that the matrix <b>X</b> must be square.
Horner's method is used for polynomial evaluation.
</p>
</html>"));
      end evaluateMatrix;

      encapsulated function evaluateComplex
        "Evaluate a Polynomial at a given (Complex) abszissa value"
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial to be evaluated";
        input Complex x "Complex abszissa value";
        output Complex y "Complex value of polynomial at x";
    protected
        Integer n=size(p.c, 1);
      algorithm
        // Horners scheme for complex numbers
        y := Complex(p.c[1], 0);
        for j in 2:n loop
          y := Complex(p.c[j], 0) + x*y;
        end for;
      end evaluateComplex;

      encapsulated function derivativeValue
        "Integral of polynomial p(x) from x_low to x_high"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica.Utilities.Streams.print;

        input Polynomial p "Polynomial";
        input Real x "Abszissa value";
        input Integer i(min=1) = 1
          "i-th derivative to be evaluated; i=1 is first derivative";
        output Real der_y "Value of i-th derivative of polynomial at x";
        // annotation(derivative(zeroDerivative=p, zeroDerivative=i)=Polynomial.Internal.derivativeValue_der);
    protected
        Integer n=size(p.c, 1);
      algorithm
        if i > n - 1 then
          der_y := 0.0;
        else
          der_y := p.c[1]*product(n - k for k in 1:i);
          for j in 2:n - i loop
            der_y := p.c[j]*product(n - j + 1 - k for k in 1:i) + x*der_y;
          end for;
        end if;
      end derivativeValue;

      encapsulated function integralValue
        "Integral of polynomial p(x) from x_low to x_high"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial to be integrated";
        input Real x_high "High integrand value";
        input Real x_low=0 "Low integrand value, default 0";
        output Real integral=0.0 "Integral of polynomial p from x_low to x_high";

    protected
        Integer n=size(p.c, 1) "Order of integrated polynomial";
        Real y_low=0 "value at lower integrand";
      algorithm
        for j in 1:n loop
          integral := x_high*(p.c[j]/(n - j + 1) + integral);
          y_low := x_low*(p.c[j]/(n - j + 1) + y_low);
        end for;
        integral := integral - y_low;
        annotation (derivative(zeroDerivative=p) = Polynomial.integralValue_der);
      end integralValue;

      encapsulated function roots
        "Determine zeros of polynomial, i.e., points x with p(x)=0"
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input Polynomial p "Polynomial";
        input Boolean printRoots=false "True, if roots shall be pretty printed";
        output Complex result[:]=fill(Complex(0, 0), Polynomial.numberOfRoots(p))
          "Roots of polynomial";

      algorithm
        result := Polynomial.rootsOfNonZeroHighestCoefficientPolynomial(p,
          Polynomial.numberOfRoots(p));
        if printRoots then
          Complex.Vectors.print("", result);
        end if;
        annotation (Documentation(info="<html>
<p>
The roots of the given polynomial are determined and are returned as
a vector of Complex elements.
</p>
</html>"));
      end roots;

      encapsulated function numberOfRoots "Determine number of roots of polynomial"
        import Modelica_LinearSystems2.Math.Polynomial;
        input Polynomial p "Polynomial";
        output Integer result "Number of roots of p";
    protected
        Integer nc=size(p.c, 1);
        Integer i;
      algorithm
        if nc <= 1 then
          // no roots
          result := 0;
        else
          // Remove all leading zero coefficients
          i := 1;
          result := 0;
          while i <= nc - 1 loop
            if p.c[i] <> 0.0 then
              result := nc - i;
              i := nc;
            else
              i := i + 1;
            end if;
          end while;
        end if;
      end numberOfRoots;

      encapsulated function rootsOfNonZeroHighestCoefficientPolynomial
        "Determine zeros of polynomial where highest coefficient of polynomial is not zero"
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2;
        import Modelica_LinearSystems2.Math.Polynomial;
        import Modelica_LinearSystems2.Math.Complex;

        input Polynomial p "Polynomial";
        input Integer numberOfRoots "Number of roots of polynomial";
        output Complex result[:]=fill(Complex(0, 0), numberOfRoots)
          "Roots of polynomial";
    protected
        Integer nc=size(p.c, 1);
        Integer i_start=nc - numberOfRoots;
        Integer n=numberOfRoots;
        Real A[n, n] "Companion matrix";
        Real ev[n, 2] "Eigen values";
        Complex j=Modelica_LinearSystems2.Math.Complex.j();
      algorithm
        assert(numberOfRoots >= 0 and numberOfRoots < nc,
          "Argument numberOfRoots (= " + String(numberOfRoots) +
          ") is not in the range\n" + "0 <= numberOfRoots <= " + String(nc - 1));
        assert(p.c[i_start] <> 0, "p.c[" + String(i_start) +
          "] = 0. Probably wrong argument numberOfRoots (=" + String(numberOfRoots)
           + ")");

        if numberOfRoots > 0 then
          // companion matrix
          A[1, :] := -p.c[i_start + 1:nc]/p.c[i_start];
          A[2:n, :] := [identity(n - 1), zeros(n - 1)];

          // roots are eigenvalues of companion matrix
          //    ev := Matrices.eigenValues(A);
          (ev[:, 1],ev[:, 2]) := Matrices.Internal.eigenvaluesHessenberg(A);
          for i in 1:n loop
            result[i] := ev[i, 1] + j*ev[i, 2];
          end for;
        end if;
      end rootsOfNonZeroHighestCoefficientPolynomial;

      encapsulated function evaluate_der
        "Evaluate derivative of polynomial at a given abszissa value"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial";
        input Real x "Abszissa value";
        input Real dx "Derivative of abszissa value, der(x)";
        output Real dy "Derivative value of polynomial at x";
    protected
        Integer n=size(p.c, 1);
      algorithm
        dy := p.c[1]*(n - 1);
        for j in 2:n - 1 loop
          dy := p.c[j]*(n - j) + x*dy;
        end for;
        dy := dy*dx;
      end evaluate_der;

      encapsulated function integralValue_der
        "Evaluate derivative of integral of polynomial p(x) from x_low to x_high, assuming only x_high as time-dependent (Leibniz rule)"
        import Modelica_LinearSystems2.Math.Polynomial;

        input Polynomial p "Polynomial";
        input Real x_high "High integrand value";
        input Real x_low=0 "Low integrand value, default 0";
        input Real dx_high "High integrand value";
        input Real dx_low=0 "Low integrand value, default 0";
        output Real dintegral=0.0 "Integral of polynomial p from u_low to u_high";
      algorithm
        dintegral := Polynomial.evaluate(p, x_high)*dx_high;
      end integralValue_der;

      encapsulated package Internal
        "Internal library of record Polynomial (should not be directly used by user)"
        import Modelica;
        import Modelica_LinearSystems2.Math.Polynomial;
        extends Modelica.Icons.Package;

        function mult
          "Multiply two polynomials (polynomials are defined by vectors)"
          import Modelica.Utilities.Streams.print;

          input Real p1[:];
          input Integer n1
            "Number of coefficients of p1 to be used, i.e., (end-n1+1:end)";
          input Real p2[:];
          input Integer n3_max "Dimension of output vector";
          output Real p3[n3_max];
      protected
          Integer n1_max=size(p1, 1);
          Integer n2=size(p2, 1);
          Integer n3=n1 + n2 - 1;
          Real ck;
        algorithm
          for k in 1:n3 loop
            ck := 0.0;
            for j in max(1, k + 1 - n2):min(k, n1) loop
              ck := ck + p1[n1_max - n1 + j]*p2[k + 1 - j];
            end for;
            p3[n3_max - n3 + k] := ck;
          end for;
        end mult;
      end Internal;

      annotation (defaultComponentName="polynomial", Documentation(info="<html>
<p>
This record defines a polynomial, e.g., y = 2*x^2 + 3*x + 1. The general form is:
</p>
<pre>
   y = c[1]*x^n + c[2]*x^(n-1) + ... + c[n]*x + c[n+1];
</pre>
<p>
In the record, the coefficients c[i] are stored. Usually, the record is not directly accessed. Instead, a polynomial is generated with the functions provided in the record such as Polynomial.base(..),
Polynomial.fitting(..).
Several functions are provided that operate on polynomials.
</p>
</html>"));
    end Polynomial;

    function isEqual
      "Determine whether two Real numbers are numerically identical (up to machine precision)"
      extends Modelica.Icons.Function;
      input Real u1 "First scalar";
      input Real u2 "Second scalar";
      input Real eps(min=0) = 0.0
        "The two scalars are identical if abs(u1-u2) <= eps";
      output Boolean result "True, if abs(u1-u2) <= eps";
    algorithm
      result :=abs(u1 - u2) <= eps;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = <b>isEqual</b>(r1, r2);
result = <b>isEqual</b>(r1, r2, eps=0.0);
</pre></blockquote>

<h4>Description</h4>

<p>
The function call &quot;<code>isEqual(r1, r2)</code>&quot; returns <b>true</b>,
if the two Real numbers r1 and r2 are the same up to a given precision eps.
(result = abs(r1-r2) &le; eps). Otherwise the function
returns <b>false</b>. With the optional third argument <b>eps</b>
the range can be defined, in which two Real numbers are treated as identical.
The default is &quot;eps = 0&quot;. Another useful value is, e.g.,
&quot;eps = 10*Modelica.Constants.eps&quot;.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real r1 = 3;
  Real r2 = 3;
  Real r3 = 3.0001;
  Boolean result;
<b>algorithm</b>
  result := isEqual(r1,r2);          // = <b>true</b>
  result := isEqual(r1,r3);          // = <b>false</b>
  result := isEqual(r1,r3, eps=0.1); // = <b>true</b>
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.isEqual\">Vectors.isEqual</a>,
<a href=\"modelica://Modelica.Math.Matrices.isEqual\">Matrices.isEqual</a>,
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">Strings.isEqual</a>
</p>
</html>"));
    end isEqual;

    package Matrices "Package of functions operating on matrices"
      extends Modelica.Icons.Package;

      package LAPACK "Package of LAPACK functions"
        extends Modelica.Icons.Package;

        function dgeev
          "Compute the eigenvalues and the (real) left and right eigenvectors of matrix A"

          input Real A[:,size(A, 1)];

          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(A, 1)]
            "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real lEigenVectors[size(A, 1),size(A, 1)]
            "left eigenvectors of matrix A";
          output Real rEigenVectors[size(A, 1),size(A, 1)]
            "right eigenvectors of matrix A";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lwork=4*n;
          Real work[lwork];

        external "Fortran 77" dgeev(
            "V",
            "V",
            n,
            A,
            n,
            alphaReal,
            alphaImag,
            lEigenVectors,
            n,
            rEigenVectors,
            n,
            work,
            size(work, 1),
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEEV computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = 'N': left eigenvectors of A are not computed;
           = 'V': left eigenvectors of A are computed.

   JOBVR   (input) CHARACTER*1
           = 'N': right eigenvectors of A are not computed;
           = 'V': right eigenvectors of A are computed.

   N       (input) INTEGER
           The order of the matrix A. N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = 'N', VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL >= 1; if
           JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = 'N', VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR >= 1; if
           JOBVR = 'V', LDVR >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,3*N), and
           if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
           performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors have been computed;
                 elements i+1:N of WR and WI contain eigenvalues which
                 have converged.

   =====================================================================
"));
        end dgeev;

        function dgeev_eigenValues "Compute the eigenvalues of matrix A"

          input Real A[:,size(A, 1)];

          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(A, 1)]
            "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lwork=4*n;
          Real work[lwork];
          Real lEigenVectors[1];
          Real rEigenVectors[1];

        external "Fortran 77" dgeev(
            "N",
            "N",
            n,
            A,
            n,
            alphaReal,
            alphaImag,
            lEigenVectors,
            n,
            rEigenVectors,
            n,
            work,
            size(work, 1),
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEEV computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = 'N': left eigenvectors of A are not computed;
           = 'V': left eigenvectors of A are computed.

   JOBVR   (input) CHARACTER*1
           = 'N': right eigenvectors of A are not computed;
           = 'V': right eigenvectors of A are computed.

   N       (input) INTEGER
           The order of the matrix A. N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = 'N', VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL >= 1; if
           JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = 'N', VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR >= 1; if
           JOBVR = 'V', LDVR >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,3*N), and
           if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
           performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors have been computed;
                 elements i+1:N of WR and WI contain eigenvalues which
                 have converged.

   =====================================================================
"));
        end dgeev_eigenValues;

        function dgeevx
          "Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx (includes balancing of A)"

          input Real A[:,size(A, 1)];
          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(A, 1)]
            "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real lEigenVectors[size(A, 1),size(A, 1)]
            "left eigenvectors of matrix A";
          output Real rEigenVectors[size(A, 1),size(A, 1)]
            "right eigenvectors of matrix A";
          output Real AS[size(A, 1),size(A, 2)]=A
            "AS iss the real Schur form of the balanced version of the input matrix A";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer ilo;
          Integer ihi;
          Real scale[n];
          Real abnrm;
          Real rconde[n];
          Real rcondv[n];
          Integer lwork=n*(n + 6);
          Integer iwork[2*n-2]; // Not referenced, but necessary for call
          Real work[lwork];

        external "Fortran 77" dgeevx(
            "B",
            "V",
            "V",
            "E",
            n,
            AS,
            n,
            alphaReal,
            alphaImag,
            lEigenVectors,
            n,
            rEigenVectors,
            n,
            ilo,
            ihi,
            scale,
            abnrm,
            rconde,
            rcondv,
            work,
            lwork,
            iwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   Optionally also, it computes a balancing transformation to improve
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
   SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
   (RCONDE), and reciprocal condition numbers for the right
   eigenvectors (RCONDV).

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Balancing a matrix means permuting the rows and columns to make it
   more nearly upper triangular, and applying a diagonal similarity
   transformation D * A * D**(-1), where D is a diagonal matrix, to
   make its rows and columns closer in norm and the condition numbers
   of its eigenvalues and eigenvectors smaller.  The computed
   reciprocal condition numbers correspond to the balanced matrix.
   Permuting rows and columns will not change the condition numbers
   (in exact arithmetic) but diagonal scaling will.  For further
   explanation of balancing, see section 4.10.2 of the LAPACK
   Users' Guide.

   Arguments
   =========

   BALANC  (input) CHARACTER*1
           Indicates how the input matrix should be diagonally scaled
           and/or permuted to improve the conditioning of its
           eigenvalues.
           = 'N': Do not diagonally scale or permute;
           = 'P': Perform permutations to make the matrix more nearly
                  upper triangular. Do not diagonally scale;
           = 'S': Diagonally scale the matrix, i.e. replace A by
                  D*A*D**(-1), where D is a diagonal matrix chosen
                  to make the rows and columns of A more equal in
                  norm. Do not permute;
           = 'B': Both diagonally scale and permute A.

           Computed reciprocal condition numbers will be for the matrix
           after balancing and/or permuting. Permuting does not change
           condition numbers (in exact arithmetic), but balancing does.

   JOBVL   (input) CHARACTER*1
           = 'N': left eigenvectors of A are not computed;
           = 'V': left eigenvectors of A are computed.
           If SENSE = 'E' or 'B', JOBVL must = 'V'.

   JOBVR   (input) CHARACTER*1
           = 'N': right eigenvectors of A are not computed;
           = 'V': right eigenvectors of A are computed.
           If SENSE = 'E' or 'B', JOBVR must = 'V'.

   SENSE   (input) CHARACTER*1
           Determines which reciprocal condition numbers are computed.
           = 'N': None are computed;
           = 'E': Computed for eigenvalues only;
           = 'V': Computed for right eigenvectors only;
           = 'B': Computed for eigenvalues and right eigenvectors.

           If SENSE = 'E' or 'B', both left and right eigenvectors
           must also be computed (JOBVL = 'V' and JOBVR = 'V').

   N       (input) INTEGER
           The order of the matrix A. N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.  If JOBVL = 'V' or
           JOBVR = 'V', A contains the real Schur form of the balanced
           version of the input matrix A.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues will appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = 'N', VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL >= 1; if
           JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = 'N', VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR >= 1, and if
           JOBVR = 'V', LDVR >= N.

   ILO,IHI (output) INTEGER
           ILO and IHI are integer values determined when A was
           balanced.  The balanced A(i,j) = 0 if I > J and
           J = 1,...,ILO-1 or I = IHI+1,...,N.

   SCALE   (output) DOUBLE PRECISION array, dimension (N)
           Details of the permutations and scaling factors applied
           when balancing A.  If P(j) is the index of the row and column
           interchanged with row and column j, and D(j) is the scaling
           factor applied to row and column j, then
           SCALE(J) = P(J),    for J = 1,...,ILO-1
                    = D(J),    for J = ILO,...,IHI
                    = P(J)     for J = IHI+1,...,N.
           The order in which the interchanges are made is N to IHI+1,
           then 1 to ILO-1.

   ABNRM   (output) DOUBLE PRECISION
           The one-norm of the balanced matrix (the maximum
           of the sum of absolute values of elements of any column).

   RCONDE  (output) DOUBLE PRECISION array, dimension (N)
           RCONDE(j) is the reciprocal condition number of the j-th
           eigenvalue.

   RCONDV  (output) DOUBLE PRECISION array, dimension (N)
           RCONDV(j) is the reciprocal condition number of the j-th
           right eigenvector.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.   If SENSE = 'N' or 'E',
           LWORK >= max(1,2*N), and if JOBVL = 'V' or JOBVR = 'V',
           LWORK >= 3*N.  If SENSE = 'V' or 'B', LWORK >= N*(N+6).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (2*N-2)
           If SENSE = 'N' or 'E', not referenced.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors or condition numbers
                 have been computed; elements 1:ILO-1 and i+1:N of WR
                 and WI contain eigenvalues which have converged.

   =====================================================================
"));
        end dgeevx;

        function dgeevx_eigenValues
          "Compute the eigenvalues of matrix A, using lapack routine dgeevx (with balancing)"

          input Real A[:,size(A, 1)];
          output Real alphaReal[size(A, 1)]
            "Real parts of eigenvalues (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(A, 1)]
            "Imaginary part of eigenvalues (eigenvalue=(alphaReal+i*alphaImag))";
          output Integer info "=0: success";
      protected
          Real Awork[size(A,1), size(A,1)] = A;
          Real abnrm[size(A, 1)];
          Integer n=size(A, 1);
          Integer ilo;
          Integer ihi;
          Real scale[size(A, 1)];
          Real rconde[size(A, 1)];
          Real rcondv[size(A, 1)];
          Integer lwork=2*n*(n + 6);
          Integer iwork[2*size(A, 1)-2]; // Not referenced, but necessary for call
          Real work[lwork];

        external "Fortran 77" dgeevx(
            "B",
            "N",
            "N",
            "N",
            size(A, 1),
            Awork,
            size(A, 1),
            alphaReal,
            alphaImag,
            rconde,
            size(A, 1),
            rcondv,
            size(A, 1),
            ilo,
            ihi,
            scale,
            abnrm,
            rconde,
            rcondv,
            work,
            lwork,
            iwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   Optionally also, it computes a balancing transformation to improve
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
   SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
   (RCONDE), and reciprocal condition numbers for the right
   eigenvectors (RCONDV).

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Balancing a matrix means permuting the rows and columns to make it
   more nearly upper triangular, and applying a diagonal similarity
   transformation D * A * D**(-1), where D is a diagonal matrix, to
   make its rows and columns closer in norm and the condition numbers
   of its eigenvalues and eigenvectors smaller.  The computed
   reciprocal condition numbers correspond to the balanced matrix.
   Permuting rows and columns will not change the condition numbers
   (in exact arithmetic) but diagonal scaling will.  For further
   explanation of balancing, see section 4.10.2 of the LAPACK
   Users' Guide.

   Arguments
   =========

   BALANC  (input) CHARACTER*1
           Indicates how the input matrix should be diagonally scaled
           and/or permuted to improve the conditioning of its
           eigenvalues.
           = 'N': Do not diagonally scale or permute;
           = 'P': Perform permutations to make the matrix more nearly
                  upper triangular. Do not diagonally scale;
           = 'S': Diagonally scale the matrix, i.e. replace A by
                  D*A*D**(-1), where D is a diagonal matrix chosen
                  to make the rows and columns of A more equal in
                  norm. Do not permute;
           = 'B': Both diagonally scale and permute A.

           Computed reciprocal condition numbers will be for the matrix
           after balancing and/or permuting. Permuting does not change
           condition numbers (in exact arithmetic), but balancing does.

   JOBVL   (input) CHARACTER*1
           = 'N': left eigenvectors of A are not computed;
           = 'V': left eigenvectors of A are computed.
           If SENSE = 'E' or 'B', JOBVL must = 'V'.

   JOBVR   (input) CHARACTER*1
           = 'N': right eigenvectors of A are not computed;
           = 'V': right eigenvectors of A are computed.
           If SENSE = 'E' or 'B', JOBVR must = 'V'.

   SENSE   (input) CHARACTER*1
           Determines which reciprocal condition numbers are computed.
           = 'N': None are computed;
           = 'E': Computed for eigenvalues only;
           = 'V': Computed for right eigenvectors only;
           = 'B': Computed for eigenvalues and right eigenvectors.

           If SENSE = 'E' or 'B', both left and right eigenvectors
           must also be computed (JOBVL = 'V' and JOBVR = 'V').

   N       (input) INTEGER
           The order of the matrix A. N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.  If JOBVL = 'V' or
           JOBVR = 'V', A contains the real Schur form of the balanced
           version of the input matrix A.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues will appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = 'N', VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL >= 1; if
           JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = 'N', VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR >= 1, and if
           JOBVR = 'V', LDVR >= N.

   ILO,IHI (output) INTEGER
           ILO and IHI are integer values determined when A was
           balanced.  The balanced A(i,j) = 0 if I > J and
           J = 1,...,ILO-1 or I = IHI+1,...,N.

   SCALE   (output) DOUBLE PRECISION array, dimension (N)
           Details of the permutations and scaling factors applied
           when balancing A.  If P(j) is the index of the row and column
           interchanged with row and column j, and D(j) is the scaling
           factor applied to row and column j, then
           SCALE(J) = P(J),    for J = 1,...,ILO-1
                    = D(J),    for J = ILO,...,IHI
                    = P(J)     for J = IHI+1,...,N.
           The order in which the interchanges are made is N to IHI+1,
           then 1 to ILO-1.

   ABNRM   (output) DOUBLE PRECISION
           The one-norm of the balanced matrix (the maximum
           of the sum of absolute values of elements of any column).

   RCONDE  (output) DOUBLE PRECISION array, dimension (N)
           RCONDE(j) is the reciprocal condition number of the j-th
           eigenvalue.

   RCONDV  (output) DOUBLE PRECISION array, dimension (N)
           RCONDV(j) is the reciprocal condition number of the j-th
           right eigenvector.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.   If SENSE = 'N' or 'E',
           LWORK >= max(1,2*N), and if JOBVL = 'V' or JOBVR = 'V',
           LWORK >= 3*N.  If SENSE = 'V' or 'B', LWORK >= N*(N+6).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (2*N-2)
           If SENSE = 'N' or 'E', not referenced.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           > 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors or condition numbers
                 have been computed; elements 1:ILO-1 and i+1:N of WR
                 and WI contain eigenvalues which have converged.

   =====================================================================
"));
        end dgeevx_eigenValues;

        function dgehrd
          "Reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q' * A * Q = H"

          input Real A[:,size(A, 2)];
          input Integer ilo=1
            "lowest index where the original matrix had been Hessenbergform";
          input Integer ihi=size(A, 1)
            "highest index where the original matrix had been Hessenbergform";
          output Real Aout[size(A, 1),size(A, 2)]=A
            "contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q";
          output Real tau[max(size(A, 1),1) - 1]
            "scalar factors of the elementary reflectors";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lda=max(1, n);
          Integer lwork=max(1, n);
          Real work[lwork];

        external "Fortran 77" dgehrd(
            n,
            ilo,
            ihi,
            Aout,
            lda,
            tau,
            work,
            lwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEHRD reduces a real general matrix A to upper Hessenberg form H by
   an orthogonal similarity transformation:  Q' * A * Q = H .

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix A.  N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
           set by a previous call to DGEBAL; otherwise they should be
           set to 1 and N respectively. See Further Details.
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N general matrix to be reduced.
           On exit, the upper triangle and the first subdiagonal of A
           are overwritten with the upper Hessenberg matrix H, and the
           elements below the first subdiagonal, with the array TAU,
           represent the orthogonal matrix Q as a product of elementary
           reflectors. See Further Details.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,N).

   TAU     (output) DOUBLE PRECISION array, dimension (N-1)
           The scalar factors of the elementary reflectors (see Further
           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
           zero.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The length of the array WORK.  LWORK >= max(1,N).
           For optimum performance LWORK >= N*NB, where NB is the
           optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.

   Further Details
   ===============

   The matrix Q is represented as a product of (ihi-ilo) elementary
   reflectors

      Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Each H(i) has the form

      H(i) = I - tau * v * v'

   where tau is a real scalar, and v is a real vector with
   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   exit in A(i+2:ihi,i), and tau in TAU(i).

   The contents of A are illustrated by the following example, with
   n = 7, ilo = 2 and ihi = 6:

   on entry,                        on exit,

   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   (                         a )    (                          a )

   where a denotes an element of the original matrix A, h denotes a
   modified element of the upper Hessenberg matrix H, and vi denotes an
   element of the vector defining H(i).

   =====================================================================
"));
        end dgehrd;

        function dgeqrf "Computes a QR factorization without pivoting"

          input Real A[:,:];
          input Integer lwork1=size(A, 2)
            "size of work array; should be optimized with Modelica_LinearSystems2.Math.Matrices.Internal.dgeqp3_workdim";
          output Real Aout[size(A, 1),size(A, 2)]=A
            "the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors";
          output Real tau[min(size(A, 1), size(A, 2))]
            "scalar factors of the elementary reflectors";
          output Integer info;
          output Real work[max(lwork1, 3*size(A, 2) + 1)];
      protected
          Integer m=size(A, 1);
          Integer n=size(A, 2);
          Integer lda=max(1, m);
          Integer lwork2=if lwork1 == -1 then -1 else max(1, lwork1);

        external "Fortran 77" dgeqrf(
            m,
            n,
            Aout,
            lda,
            tau,
            work,
            lwork2,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGEQRF computes a QR factorization of a real M-by-N matrix A:
   A = Q * R.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix A.  M >= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit, the elements on and above the diagonal of the array
           contain the min(M,N)-by-N upper trapezoidal matrix R (R is
           upper triangular if m >= n); the elements below the diagonal,
           with the array TAU, represent the orthogonal matrix Q as a
           product of min(m,n) elementary reflectors (see Further
           Details).

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max(1,M).

   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
           The scalar factors of the elementary reflectors (see Further
           Details).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,N).
           For optimum performance LWORK >= N*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value

   Further Details
   ===============

   The matrix Q is represented as a product of elementary reflectors

      Q = H(1) H(2) . . . H(k), where k = min(m,n).

   Each H(i) has the form

      H(i) = I - tau * v * v'

   where tau is a real scalar, and v is a real vector with
   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   and tau in TAU(i).

   =====================================================================  "));
        end dgeqrf;

        function dgesvx
          "Solve real system of linear equations op(A) * X = B, op(A) is A or A' according to the boolean input transposed"
          extends Modelica.Icons.Function;
          input Real A[:,size(A, 1)] "Matrix A[n,n]";
          input Real B[size(A, 1),:] "Matrix B[n,nrhs]";
          input Boolean transposed=true
            "True, if matrix A is transformed on input, i.e. system is A**T * X = B";
          output Real X[size(A, 1),size(B, 2)] "Matrix X[n,nrhs]";
          output Integer info "Info: =0: successful exit, otherwise see documentation";
          output Real rcond
            "Estimate of the reciprocal condition number of the matrix A after equilibration";

      protected
          String transA= if transposed then "T" else "N";
          String equed; // Is output since FACT = 'N', i.e. first parameter = 'N'
          Integer n=size(A, 1);
          Integer nrhs=size(B, 2);
          Real Awork[n,n]=A;
          Real Bwork[n,nrhs]=B;
          Real AF[n,n]; // If FACT = 'N', returns the factors L and U from the factorization A = P*L*U of the original matrix A
          Real R[n];
          Real C[n];
          Real ferr[nrhs];
          Real berr[nrhs];
          Real work[4*n];
          Integer ipiv[n];
          Integer iwork[n];

        external "FORTRAN 77" dgesvx(
            "N",
            transA,
            n,
            nrhs,
            Awork,
            n,
            AF,
            n,
            ipiv,
            equed,
            R,
            C,
            B,
            n,
            X,
            n,
            rcond,
            ferr,
            berr,
            work,
            iwork,
            info) annotation (Library="lapack");
          annotation (Documentation(info="Lapack documentation (April 2012):

   Purpose:
   ========

   DGESVX uses the LU factorization to compute the solution to a real
   system of linear equations
      A * X = B,
   where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
  
   Error bounds on the solution and a condition estimate are also
   provided.

   Description:
   ============

   The following steps are performed:
  
   1. If FACT = 'E', real scaling factors are computed to equilibrate
      the system:
         TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
         TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
         TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
      Whether or not the system will be equilibrated depends on the
      scaling of the matrix A, but if equilibration is used, A is
      overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
      or diag(C)*B (if TRANS = 'T' or 'C').
  
   2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
      matrix A (after equilibration if FACT = 'E') as
         A = P * L * U,
      where P is a permutation matrix, L is a unit lower triangular
      matrix, and U is upper triangular.
  
   3. If some U(i,i)=0, so that U is exactly singular, then the routine
      returns with INFO = i. Otherwise, the factored form of A is used
      to estimate the condition number of the matrix A.  If the
      reciprocal of the condition number is less than machine precision,
      INFO = N+1 is returned as a warning, but the routine still goes on
      to solve for X and compute error bounds as described below.
  
   4. The system of equations is solved for X using the factored form
      of A.
  
   5. Iterative refinement is applied to improve the computed solution
      matrix and calculate error bounds and backward error estimates
      for it.
  
   6. If equilibration was used, the matrix X is premultiplied by
      diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
      that it solves the original system before equilibration.

   Arguments:
   ==========
  
   FACT   (input) CHARACTER*1
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored.
          = 'F':  On entry, AF and IPIV contain the factored form of A.
                  If EQUED is not 'N', the matrix A has been
                  equilibrated with scaling factors given by R and C.
                  A, AF, and IPIV are not modified.
          = 'N':  The matrix A will be copied to AF and factored.
          = 'E':  The matrix A will be equilibrated if necessary, then
                  copied to AF and factored.

   TRANS  (input) CHARACTER*1
          Specifies the form of the system of equations:
          = 'N':  A * X = B     (No transpose)
          = 'T':  A**T * X = B  (Transpose)
          = 'C':  A**H * X = B  (Transpose)

   N      (input) INTEGER
          The number of linear equations, i.e., the order of the
          matrix A.  N >= 0.

   NRHS   (input) INTEGER
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS >= 0.

   A      (input, output) DOUBLE PRECISION array, dimension (LDA,N)
          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
          not 'N', then A must have been equilibrated by the scaling
          factors in R and/or C.  A is not modified if FACT = 'F' or
          'N', or if FACT = 'E' and EQUED = 'N' on exit.

          On exit, if EQUED .ne. 'N', A is scaled as follows:
          EQUED = 'R':  A := diag(R) * A
          EQUED = 'C':  A := A * diag(C)
          EQUED = 'B':  A := diag(R) * A * diag(C).

   LDA    (input) INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).

   AF     (input, output) DOUBLE PRECISION array, dimension (LDAF,N)
          If FACT = 'F', then AF is an input argument and on entry
          contains the factors L and U from the factorization
          A = P*L*U as computed by DGETRF.  If EQUED .ne. 'N', then
          AF is the factored form of the equilibrated matrix A.

          If FACT = 'N', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the original matrix A.

          If FACT = 'E', then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the equilibrated matrix A (see the description of A for
          the form of the equilibrated matrix).

   LDAF   (input) INTEGER
          The leading dimension of the array AF.  LDAF >= max(1,N).

   IPIV   (input, output) INTEGER array, dimension (N)
          If FACT = 'F', then IPIV is an input argument and on entry
          contains the pivot indices from the factorization A = P*L*U
          as computed by DGETRF; row i of the matrix was interchanged
          with row IPIV(i).

          If FACT = 'N', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the original matrix A.

          If FACT = 'E', then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the equilibrated matrix A.

   EQUED  (input, output) CHARACTER*1
          Specifies the form of equilibration that was done.
          = 'N':  No equilibration (always true if FACT = 'N').
          = 'R':  Row equilibration, i.e., A has been premultiplied by
                  diag(R).
          = 'C':  Column equilibration, i.e., A has been postmultiplied
                  by diag(C).
          = 'B':  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C).
          EQUED is an input argument if FACT = 'F'; otherwise, it is an
          output argument.

   R      (input, output) DOUBLE PRECISION array, dimension (N)
          The row scale factors for A.  If EQUED = 'R' or 'B', A is
          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
          is not accessed.  R is an input argument if FACT = 'F';
          otherwise, R is an output argument.  If FACT = 'F' and
          EQUED = 'R' or 'B', each element of R must be positive.

   C      (input, output) DOUBLE PRECISION array, dimension (N)
          The column scale factors for A.  If EQUED = 'C' or 'B', A is
          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
          is not accessed.  C is an input argument if FACT = 'F';
          otherwise, C is an output argument.  If FACT = 'F' and
          EQUED = 'C' or 'B', each element of C must be positive.

   B      (input, output) DOUBLE PRECISION array, dimension (LDB,NRHS)
          On entry, the N-by-NRHS right hand side matrix B.
          On exit,
          if EQUED = 'N', B is not modified;
          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
          diag(R)*B;
          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
          overwritten by diag(C)*B.

   LDB    (input) INTEGER
          The leading dimension of the array B.  LDB >= max(1,N).

   X      (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
          to the original system of equations.  Note that A and B are
          modified on exit if EQUED .ne. 'N', and the solution to the
          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
          and EQUED = 'R' or 'B'.

   LDX    (input) INTEGER
          The leading dimension of the array X.  LDX >= max(1,N).

   RCOND  (output) DOUBLE PRECISION
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO > 0.

   FERR   (output) DOUBLE PRECISION array, dimension (NRHS)
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error.

   BERR   (output) DOUBLE PRECISION array, dimension (NRHS)
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution).

   WORK   (output) DOUBLE PRECISION array, dimension (4*N)
          On exit, WORK(1) contains the reciprocal pivot growth
          factor norm(A)/norm(U). The \"max absolute element\" norm is
          used. If WORK(1) is much less than 1, then the stability
          of the LU factorization of the (equilibrated) matrix A
          could be poor. This also means that the solution X, condition
          estimator RCOND, and forward error bound FERR could be
          unreliable. If factorization fails with 0<INFO<=N, then
          WORK(1) contains the reciprocal pivot growth factor for the
          leading INFO columns of A.

   IWORK  (output) INTEGER array, dimension (N)

   INFO   (output) INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value
          > 0:  if INFO = i, and i is
                <= N:  U(i,i) is exactly zero.  The factorization has
                       been completed, but the factor U is exactly
                       singular, so the solution and error bounds
                       could not be computed. RCOND = 0 is returned.
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest.

   =====================================================================  "));
        end dgesvx;

        function dggev "Compute generalized eigenvalues for a (A,B) system"

          input Real A[:,size(A, 1)];
          input Real B[size(A, 1),size(A, 1)];
          input Integer nA=size(A,1);
          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)";
          output Real alphaImag[size(A, 1)] "Imaginary part of alpha";
          output Real beta[size(A, 1)] "Denominator of eigenvalue";
          output Real lEigenVectors[size(A, 1),size(A, 1)]
            "left eigenvectors of matrix A";
          output Real rEigenVectors[size(A, 1),size(A, 1)]
            "right eigenvectors of matrix A";

          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lwork=max(1,8*n);
          Real Awork[n,n]=A;
          Real Bwork[n,n]=B;
          Real work[lwork];
          Integer lda=max(1,n);

        external "Fortran 77" dggev(
            "V",
            "V",
            nA,
            Awork,
            lda,
            Bwork,
            lda,
            alphaReal,
            alphaImag,
            beta,
            lEigenVectors,
            lda,
            rEigenVectors,
            lda,
            work,
            lwork,
            info) annotation(Library = {"lapack"});
          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
   the generalized eigenvalues, and optionally, the left and/or right
   generalized eigenvectors.

   A generalized eigenvalue for a pair of matrices (A,B) is a scalar
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
   singular. It is usually represented as the pair (alpha,beta), as
   there is a reasonable interpretation for beta=0, and even for both
   being zero.

   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    A * v(j) = lambda(j) * B * v(j).

   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    u(j)**H * A  = lambda(j) * u(j)**H * B .

   where u(j)**H is the conjugate-transpose of u(j).

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = 'N':  do not compute the left generalized eigenvectors;
           = 'V':  compute the left generalized eigenvectors.

   JOBVR   (input) CHARACTER*1
           = 'N':  do not compute the right generalized eigenvectors;
           = 'V':  compute the right generalized eigenvectors.

   N       (input) INTEGER
           The order of the matrices A, B, VL, and VR.  N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the matrix A in the pair (A,B).
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of A.  LDA >= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the matrix B in the pair (A,B).
           On exit, B has been overwritten.

   LDB     (input) INTEGER
           The leading dimension of B.  LDB >= max(1,N).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
   BETA    (output) DOUBLE PRECISION array, dimension (N)
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then
           the j-th eigenvalue is real; if positive, then the j-th and
           (j+1)-st eigenvalues are a complex conjugate pair, with
           ALPHAI(j+1) negative.

           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
           may easily over- or underflow, and BETA(j) may even be zero.
           Thus, the user should avoid naively computing the ratio
           alpha/beta.  However, ALPHAR and ALPHAI will be always less
           than and usually comparable with norm(A) in magnitude, and
           BETA always less than and usually comparable with norm(B).

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           u(j) = VL(:,j), the j-th column of VL. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVL = 'N'.

   LDVL    (input) INTEGER
           The leading dimension of the matrix VL. LDVL >= 1, and
           if JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           v(j) = VR(:,j), the j-th column of VR. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVR = 'N'.

   LDVR    (input) INTEGER
           The leading dimension of the matrix VR. LDVR >= 1, and
           if JOBVR = 'V', LDVR >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,8*N).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           = 1,...,N:
                 The QZ iteration failed.  No eigenvectors have been
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                 should be correct for j=INFO+1,...,N.
           > N:  =N+1: other than QZ iteration failed in DHGEQZ.
                 =N+2: error return from DTGEVC.

   =====================================================================
"));
        end dggev;

        function dggev_eigenValues
          "Compute only generalized eigenvalues for a (A,B) system"

          input Real A[:,size(A, 1)];
          input Real B[size(A, 1),size(A, 1)];
          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)";
          output Real alphaImag[size(A, 1)] "Imaginary part of alpha";
          output Real beta[size(A, 1)] "Denominator of eigenvalue";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lda=max(1,n);
          Integer lwork=max(1,2*8*n);
          Real Awork[n,n]=A;
          Real Bwork[n,n]=B;
          Real work[lwork];
          Real lEigenVectors[1];
          Real rEigenVectors[1];

        external "Fortran 77" dggev(
            "N",
            "N",
            size(A,1),
            Awork,
            lda,
            Bwork,
            lda,
            alphaReal,
            alphaImag,
            beta,
            lEigenVectors,
            1,
            rEigenVectors,
            1,
            work,
            lwork,
            info) annotation(Library = {"lapack"});
          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
   the generalized eigenvalues, and optionally, the left and/or right
   generalized eigenvectors.

   A generalized eigenvalue for a pair of matrices (A,B) is a scalar
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
   singular. It is usually represented as the pair (alpha,beta), as
   there is a reasonable interpretation for beta=0, and even for both
   being zero.

   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    A * v(j) = lambda(j) * B * v(j).

   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    u(j)**H * A  = lambda(j) * u(j)**H * B .

   where u(j)**H is the conjugate-transpose of u(j).

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = 'N':  do not compute the left generalized eigenvectors;
           = 'V':  compute the left generalized eigenvectors.

   JOBVR   (input) CHARACTER*1
           = 'N':  do not compute the right generalized eigenvectors;
           = 'V':  compute the right generalized eigenvectors.

   N       (input) INTEGER
           The order of the matrices A, B, VL, and VR.  N >= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the matrix A in the pair (A,B).
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of A.  LDA >= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the matrix B in the pair (A,B).
           On exit, B has been overwritten.

   LDB     (input) INTEGER
           The leading dimension of B.  LDB >= max(1,N).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
   BETA    (output) DOUBLE PRECISION array, dimension (N)
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then
           the j-th eigenvalue is real; if positive, then the j-th and
           (j+1)-st eigenvalues are a complex conjugate pair, with
           ALPHAI(j+1) negative.

           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
           may easily over- or underflow, and BETA(j) may even be zero.
           Thus, the user should avoid naively computing the ratio
           alpha/beta.  However, ALPHAR and ALPHAI will be always less
           than and usually comparable with norm(A) in magnitude, and
           BETA always less than and usually comparable with norm(B).

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           u(j) = VL(:,j), the j-th column of VL. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVL = 'N'.

   LDVL    (input) INTEGER
           The leading dimension of the matrix VL. LDVL >= 1, and
           if JOBVL = 'V', LDVL >= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           v(j) = VR(:,j), the j-th column of VR. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVR = 'N'.

   LDVR    (input) INTEGER
           The leading dimension of the matrix VR. LDVR >= 1, and
           if JOBVR = 'V', LDVR >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,8*N).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value.
           = 1,...,N:
                 The QZ iteration failed.  No eigenvectors have been
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                 should be correct for j=INFO+1,...,N.
           > N:  =N+1: other than QZ iteration failed in DHGEQZ.
                 =N+2: error return from DTGEVC.

   =====================================================================
"));
        end dggev_eigenValues;

        function dhgeqz "Compute generalized eigenvalues for a (A,B) system"

          input Real A[:,size(A, 1)];
          input Real B[size(A, 1),size(A, 1)];
          output Real alphaReal[size(A, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)";
          output Real alphaImag[size(A, 1)] "Imaginary part of alpha";
          output Real beta[size(A, 1)] "Denominator of eigenvalue";

          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer ilo=1;
          Integer ihi=n;
          Integer lwork=max(1,3*n);
          Real work[lwork];
          Real Awork[n,n]=A;
          Real Bwork[n,n]=B;
          Integer lda=max(1, n);
          Real Q[1,1]=fill(
              0,
              1,
              n);

        external "Fortran 77" dhgeqz(
            "E",
            "N",
            "N",
            n,
            ilo,
            ihi,
            Awork,
            lda,
            Bwork,
            lda,
            alphaReal,
            alphaImag,
            beta,
            Q,
            1,
            Q,
            1,
            work,
            lwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DHGEQZ implements a single-/double-shift version of the QZ method for
   finding the generalized eigenvalues

   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation

        det( A - w(i) B ) = 0

   In addition, the pair A,B may be reduced to generalized Schur form:
   B is upper triangular, and A is block upper triangular, where the
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
   complex generalized eigenvalues (see the description of the argument
   JOB.)

   If JOB='S', then the pair (A,B) is simultaneously reduced to Schur
   form by applying one orthogonal tranformation (usually called Q) on
   the left and another (usually called Z) on the right.  The 2-by-2
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
   of A will be reduced to positive diagonal matrices.  (I.e.,
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
   B(j+1,j+1) will be positive.)

   If JOB='E', then at each iteration, the same transformations
   are computed, but they are only applied to those parts of A and B
   which are needed to compute ALPHAR, ALPHAI, and BETAR.

   If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the orthogonal
   transformations used to reduce (A,B) are accumulated into the arrays
   Q and Z s.t.:

        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*

   Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix
        Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),
        pp. 241--256.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = 'E': compute only ALPHAR, ALPHAI, and BETA.  A and B will
                  not necessarily be put into generalized Schur form.
           = 'S': put A and B into generalized Schur form, as well
                  as computing ALPHAR, ALPHAI, and BETA.

   COMPQ   (input) CHARACTER*1
           = 'N': do not modify Q.
           = 'V': multiply the array Q on the right by the transpose of
                  the orthogonal tranformation that is applied to the
                  left side of A and B to reduce them to Schur form.
           = 'I': like COMPQ='V', except that Q will be initialized to
                  the identity first.

   COMPZ   (input) CHARACTER*1
           = 'N': do not modify Z.
           = 'V': multiply the array Z on the right by the orthogonal
                  tranformation that is applied to the right side of
                  A and B to reduce them to Schur form.
           = 'I': like COMPZ='V', except that Z will be initialized to
                  the identity first.

   N       (input) INTEGER
           The order of the matrices A, B, Q, and Z.  N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows and
           columns 1:ILO-1 and IHI+1:N.
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the N-by-N upper Hessenberg matrix A.  Elements
           below the subdiagonal must be zero.
           If JOB='S', then on exit A and B will have been
              simultaneously reduced to generalized Schur form.
           If JOB='E', then on exit A will have been destroyed.
              The diagonal blocks will be correct, but the off-diagonal
              portion will be meaningless.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max( 1, N ).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the N-by-N upper triangular matrix B.  Elements
           below the diagonal must be zero.  2-by-2 blocks in B
           corresponding to 2-by-2 blocks in A will be reduced to
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
           positive.)
           If JOB='S', then on exit A and B will have been
              simultaneously reduced to Schur form.
           If JOB='E', then on exit B will have been destroyed.
              Elements corresponding to diagonal blocks of A will be
              correct, but the off-diagonal portion will be meaningless.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB >= max( 1, N ).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAR(1:N) will be set to real parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAI(1:N) will be set to imaginary parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   BETA    (output) DOUBLE PRECISION array, dimension (N)
           BETA(1:N) will be set to the (real) diagonal elements of B
           that would result from reducing A and B to Schur form and
           then further reducing them both to triangular form using
           unitary transformations s.t. the diagonal of B was
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.
           (Note that BETA(1:N) will always be non-negative, and no
           BETAI is necessary.)

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
           If COMPQ='N', then Q will not be referenced.
           If COMPQ='V' or 'I', then the transpose of the orthogonal
              transformations which are applied to A and B on the left
              will be applied to the array Q on the right.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.  LDQ >= 1.
           If COMPQ='V' or 'I', then LDQ >= N.

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
           If COMPZ='N', then Z will not be referenced.
           If COMPZ='V' or 'I', then the orthogonal transformations
              which are applied to A and B on the right will be applied
              to the array Z on the right.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.  LDZ >= 1.
           If COMPZ='V' or 'I', then LDZ >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           < 0: if INFO = -i, the i-th argument had an illegal value
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO+1,...,N should be correct.
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO-N+1,...,N should be correct.
           > 2*N:     various \"impossible\" errors.

   Further Details
   ===============

   Iteration counters:

   JITER  -- counts iterations.
   IITER  -- counts iterations run since ILAST was last
             changed.  This is therefore reset only when a 1-by-1 or
             2-by-2 block deflates off the bottom.

   =====================================================================
"));
        end dhgeqz;

        function dhseqr
          "Compute eingenvalues of a matrix A using lapack routine DHSEQR for Hessenberg form matrix"
          input Real H[:,size(H, 1)];
          input Integer lwork=max(1, size(H, 1));
          input Boolean eigenValuesOnly=true;
          input String compz="N";
          input Real Z[:,:]=H;
          output Real alphaReal[size(H, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(H, 1)]
            "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Integer info;
          output Real Ho[:,:]=H;
          output Real Zo[:,:]=Z;
          output Real work[max({lwork, size(H, 1),1})];

      protected
          Integer n=size(H, 1);
          String job=if eigenValuesOnly then "E" else "S";
          Integer ilo=1;
          Integer ihi=n;
          Integer ldh=max(n, 1);
          Integer lw=if lwork == -1 then -1 else max(lwork, size(H, 1));

        external "Fortran 77" dhseqr(
            job,
            compz,
            n,
            ilo,
            ihi,
            Ho,
            ldh,
            alphaReal,
            alphaImag,
            Zo,
            ldh,
            work,
            lw,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DHSEQR computes the eigenvalues of a real upper Hessenberg matrix H
   and, optionally, the matrices T and Z from the Schur decomposition
   H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur
   form), and Z is the orthogonal matrix of Schur vectors.

   Optionally Z may be postmultiplied into an input orthogonal matrix Q,
   so that this routine can give the Schur factorization of a matrix A
   which has been reduced to the Hessenberg form H by the orthogonal
   matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = 'E':  compute eigenvalues only;
           = 'S':  compute eigenvalues and the Schur form T.

   COMPZ   (input) CHARACTER*1
           = 'N':  no Schur vectors are computed;
           = 'I':  Z is initialized to the unit matrix and the matrix Z
                   of Schur vectors of H is returned;
           = 'V':  Z must contain an orthogonal matrix Q on entry, and
                   the product Q*Z is returned.

   N       (input) INTEGER
           The order of the matrix H.  N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that H is already upper triangular in rows
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
           set by a previous call to DGEBAL, and then passed to SGEHRD
           when the matrix output by DGEBAL is reduced to Hessenberg
           form. Otherwise ILO and IHI should be set to 1 and N
           respectively.
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)
           On entry, the upper Hessenberg matrix H.
           On exit, if JOB = 'S', H contains the upper quasi-triangular
           matrix T from the Schur decomposition (the Schur form);
           2-by-2 diagonal blocks (corresponding to complex conjugate
           pairs of eigenvalues) are returned in standard form, with
           H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) < 0. If JOB = 'E',
           the contents of H are unspecified on exit.

   LDH     (input) INTEGER
           The leading dimension of the array H. LDH >= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           The real and imaginary parts, respectively, of the computed
           eigenvalues. If two eigenvalues are computed as a complex
           conjugate pair, they are stored in consecutive elements of
           WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
           WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in the
           same order as on the diagonal of the Schur form returned in
           H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
           diagonal block, WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and
           WI(i+1) = -WI(i).

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
           If COMPZ = 'N': Z is not referenced.
           If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
           contains the orthogonal matrix Z of the Schur vectors of H.
           If COMPZ = 'V': on entry Z must contain an N-by-N matrix Q,
           which is assumed to be equal to the unit matrix except for
           the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
           Normally Q is the orthogonal matrix generated by DORGHR after
           the call to DGEHRD which formed the Hessenberg matrix H.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.
           LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value
           > 0:  if INFO = i, DHSEQR failed to compute all of the
                 eigenvalues in a total of 30*(IHI-ILO+1) iterations;
                 elements 1:ilo-1 and i+1:n of WR and WI contain those
                 eigenvalues which have been successfully computed.

   =====================================================================  "));
        end dhseqr;

        function dorghr
          "Generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD"

          input Real A[:,size(A, 1)] "Square matrix A";
          input Integer ilo=1
            "lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD";
          input Integer ihi=size(A, 1)
            "highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD";
          input Real tau[max(0,size(A, 1) - 1)]
            "scalar factors of the elementary reflectors";
          output Real Aout[size(A, 1),size(A, 2)]=A
            "Orthogonal matrix as a result of elementary reflectors";
          output Integer info;
      protected
          Integer n=size(A, 1);
          Integer lda=max(1, n);
          Integer lwork=max(1, 3*n);
          Real work[lwork];

        external "Fortran 77" dorghr(
            n,
            ilo,
            ihi,
            Aout,
            lda,
            tau,
            work,
            lwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DORGHR generates a real orthogonal matrix Q which is defined as the
   product of IHI-ILO elementary reflectors of order N, as returned by
   DGEHRD:

   Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix Q. N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           ILO and IHI must have the same values as in the previous call
           of DGEHRD. Q is equal to the unit matrix except in the
           submatrix Q(ilo+1:ihi,ilo+1:ihi).
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the vectors which define the elementary reflectors,
           as returned by DGEHRD.
           On exit, the N-by-N orthogonal matrix Q.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA >= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (N-1)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEHRD.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK >= IHI-ILO.
           For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================
"));
        end dorghr;

        function dtrsen "DTRSEN reorders the real Schur factorization of a real matrix"

          input String job="N";
          input String compq="V";
          input Boolean select[:];//= fill(false,size(T,2));
          input Real T[:,:];
          input Real Q[:,size(T, 2)];

      protected
          Integer n=size(T, 2);
          Integer ldt=max(1, n);
          Integer ldq=if compq == "V" then n else 1;
          Integer lwork=if job == "N" then max(1, n) else if job == "E" then n*n else 2
              *n*n;
          Real work[lwork];
          Integer liwork=if job == "N" or job == "E" then 1 else n*n;
          Integer iwork[liwork];

      public
          output Real To[:,:]=T;
          output Real Qo[:,:]=Q;
          output Real wr[size(T, 2)];
          output Real wi[size(T, 2)];
          output Integer m;
          output Real s;
          output Real sep;
          output Integer info;

        external "Fortran 77" dtrsen(
            job,
            compq,
            select,
            n,
            To,
            ldt,
            Qo,
            ldq,
            wr,
            wi,
            m,
            s,
            sep,
            work,
            lwork,
            iwork,
            liwork,
            info) annotation(Library = {"lapack"});

          annotation (Documentation(info="Lapack documentation:

   Purpose
   =======

   DTRSEN reorders the real Schur factorization of a real matrix
   A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
   the leading diagonal blocks of the upper quasi-triangular matrix T,
   and the leading columns of Q form an orthonormal basis of the
   corresponding right invariant subspace.

   Optionally the routine computes the reciprocal condition numbers of
   the cluster of eigenvalues and/or the invariant subspace.

   T must be in Schur canonical form (as returned by DHSEQR), that is,
   block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
   2-by-2 diagonal block has its diagonal elemnts equal and its
   off-diagonal elements of opposite sign.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           Specifies whether condition numbers are required for the
           cluster of eigenvalues (S) or the invariant subspace (SEP):
           = 'N': none;
           = 'E': for eigenvalues only (S);
           = 'V': for invariant subspace only (SEP);
           = 'B': for both eigenvalues and invariant subspace (S and
                  SEP).

   COMPQ   (input) CHARACTER*1
           = 'V': update the matrix Q of Schur vectors;
           = 'N': do not update Q.

   SELECT  (input) LOGICAL array, dimension (N)
           SELECT specifies the eigenvalues in the selected cluster. To
           select a real eigenvalue w(j), SELECT(j) must be set to
           .TRUE.. To select a complex conjugate pair of eigenvalues
           w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
           either SELECT(j) or SELECT(j+1) or both must be set to
           .TRUE.; a complex conjugate pair of eigenvalues must be
           either both included in the cluster or both excluded.

   N       (input) INTEGER
           The order of the matrix T. N >= 0.

   T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
           On entry, the upper quasi-triangular matrix T, in Schur
           canonical form.
           On exit, T is overwritten by the reordered matrix T, again in
           Schur canonical form, with the selected eigenvalues in the
           leading diagonal blocks.

   LDT     (input) INTEGER
           The leading dimension of the array T. LDT >= max(1,N).

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
           On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
           On exit, if COMPQ = 'V', Q has been postmultiplied by the
           orthogonal transformation matrix which reorders T; the
           leading M columns of Q form an orthonormal basis for the
           specified invariant subspace.
           If COMPQ = 'N', Q is not referenced.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.
           LDQ >= 1; and if COMPQ = 'V', LDQ >= N.

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           The real and imaginary parts, respectively, of the reordered
           eigenvalues of T. The eigenvalues are stored in the same
           order as on the diagonal of T, with WR(i) = T(i,i) and, if
           T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
           WI(i+1) = -WI(i). Note that if a complex eigenvalue is
           sufficiently ill-conditioned, then its value may differ
           significantly from its value before reordering.

   M       (output) INTEGER
           The dimension of the specified invariant subspace.
           0 < = M <= N.

   S       (output) DOUBLE PRECISION
           If JOB = 'E' or 'B', S is a lower bound on the reciprocal
           condition number for the selected cluster of eigenvalues.
           S cannot underestimate the true reciprocal condition number
           by more than a factor of sqrt(N). If M = 0 or N, S = 1.
           If JOB = 'N' or 'V', S is not referenced.

   SEP     (output) DOUBLE PRECISION
           If JOB = 'V' or 'B', SEP is the estimated reciprocal
           condition number of the specified invariant subspace. If
           M = 0 or N, SEP = norm(T).
           If JOB = 'N' or 'E', SEP is not referenced.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.
           If JOB = 'N', LWORK >= max(1,N);
           if JOB = 'E', LWORK >= M*(N-M);
           if JOB = 'V' or 'B', LWORK >= 2*M*(N-M).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (LIWORK)
           IF JOB = 'N' or 'E', IWORK is not referenced.

   LIWORK  (input) INTEGER
           The dimension of the array IWORK.
           If JOB = 'N' or 'E', LIWORK >= 1;
           if JOB = 'V' or 'B', LIWORK >= M*(N-M).

           If LIWORK = -1, then a workspace query is assumed; the
           routine only calculates the optimal size of the IWORK array,
           returns this value as the first entry of the IWORK array, and
           no error message related to LIWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           < 0: if INFO = -i, the i-th argument had an illegal value
           = 1: reordering of T failed because some eigenvalues are too
                close to separate (the problem is very ill-conditioned);
                T may have been partially reordered, and WR and WI
                contain the eigenvalues in the same order as in T; S and
                SEP (if requested) are set to zero.

   Further Details
   ===============

   DTRSEN first collects the selected eigenvalues by computing an
   orthogonal transformation Z to move them to the top left corner of T.
   In other words, the selected eigenvalues are the eigenvalues of T11
   in:

                 Z'*T*Z = ( T11 T12 ) n1
                          (  0  T22 ) n2
                             n1  n2

   where N = n1+n2 and Z' means the transpose of Z. The first n1 columns
   of Z span the specified invariant subspace of T.

   If T has been obtained from the real Schur factorization of a matrix
   A = Q*T*Q', then the reordered real Schur factorization of A is given
   by A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span
   the corresponding invariant subspace of A.

   The reciprocal condition number of the average of the eigenvalues of
   T11 may be returned in S. S lies between 0 (very badly conditioned)
   and 1 (very well conditioned). It is computed as follows. First we
   compute R so that

                          P = ( I  R ) n1
                              ( 0  0 ) n2
                                n1 n2

   is the projector on the invariant subspace associated with T11.
   R is the solution of the Sylvester equation:

                         T11*R - R*T22 = T12.

   Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
   the two-norm of M. Then S is computed as the lower bound

                       (1 + F-norm(R)**2)**(-1/2)

   on the reciprocal of 2-norm(P), the true reciprocal condition number.
   S cannot underestimate 1 / 2-norm(P) by more than a factor of
   sqrt(N).

   An approximate error bound for the computed average of the
   eigenvalues of T11 is

                          EPS * norm(T) / S

   where EPS is the machine precision.

   The reciprocal condition number of the right invariant subspace
   spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
   SEP is defined as the separation of T11 and T22:

                      sep( T11, T22 ) = sigma-min( C )

   where sigma-min(C) is the smallest singular value of the
   n1*n2-by-n1*n2 matrix

      C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )

   I(m) is an m by m identity matrix, and kprod denotes the Kronecker
   product. We estimate sigma-min(C) by the reciprocal of an estimate of
   the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
   cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).

   When SEP is small, small changes in T can cause large changes in
   the invariant subspace. An approximate bound on the maximum angular
   error in the computed right invariant subspace is

                       EPS * norm(T) / SEP

   =====================================================================  "));
        end dtrsen;
        annotation (Documentation(info="<html>
<p>
This package contains functions to call routines from software library
<a href=\"http://www.netlib.org/lapack/\">LAPACK </a>
(Linear Algebra PACKage) aimed for numerical linear algebra. The library is
provided by <a href=\"http://www.netlib.org/\">Netlib Repository</a>.
</p>
</html>"));
      end LAPACK;

      function care "Solution of continuous-time algebraic Riccati equations"
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Complex;

        input Real A[:,size(A, 1)];
        input Real B[size(A, 1),:];
        input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2));
        input Real Q[size(A, 1),size(A, 1)]=identity(size(A, 1));
        input Boolean refine = false;
    protected
        Integer n=size(A, 1);
        Real G[size(A, 1),size(A, 1)]=B*Modelica.Math.Matrices.solve2(R, transpose(B));
        Real H[2*size(A, 1),2*size(A, 1)]=[A,-G; -Q,-transpose(A)];
        Real H_RSF[2*size(A, 1),2*size(A, 1)]=H;
        Real Z[size(H, 1),size(H, 2)];
        Real Z11[size(A, 1),size(A, 2)];
        Real Z21[size(A, 1),size(A, 2)];
        Real alphaReal[size(H, 1)] "Real part of eigenvalue=alphaReal+i*alphaImag";
        Real alphaImag[size(H, 1)]
          "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";
        Integer info;
        Integer evSize;
        Complex xc[2];
    public
        output Real X[size(A, 1),size(A, 2)] "Stabilizing solution of CARE";
        output Complex ev[size(A, 1)] "Eigenvalues of the closed loop system";

      algorithm
        if n > 1 then
          (H_RSF,Z,alphaReal,alphaImag) := Modelica.Math.Matrices.realSchur(H);
          (H_RSF,Z,alphaReal,alphaImag) := Matrices.Internal.reorderRSF(
            true,
            H_RSF,
            Z,
            alphaReal,
            alphaImag);
          evSize := size(ev, 1);
          for i in 1:evSize loop
            ev[i] := Complex(alphaReal[i], alphaImag[i]);
          end for;

          Z11 := Z[1:n, 1:n];
          Z21 := Z[n + 1:2*n, 1:n];
          if size(Z11, 1) > 0 then
      //  X := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));
            (X,info) := Matrices.LAPACK.dgesvx(Z11, transpose(Z21));
            //this function does not need to transpose Z11 as solve2 does
            X := transpose(X);
            assert(info == 0,
              "Solving a linear system of equations with function \"Matrices.LAPACK.dgesvx\" is not possible, because the system has either no or infinitely many solutions (input A is singular).");
            if refine then
              X := Matrices.Internal.carenls(A, B, R, Q, X);
            end if;
          else
            X := fill(0,size(Z21, 1),size(Z11, 1));
          end if;

        elseif n == 1 then
      //    xc := Polynomial.roots(Polynomial({-G[1, 1],2*A[1, 1],Q[1, 1]}));
      //    X := matrix(-abs(xc[1].re));

          X := matrix((A[1,1]-sqrt(A[1,1]*A[1,1]+G[1,1]*Q[1,1]))/G[1,1]);
          if X[1,1]*G[1,1]<A[1,1] then
            X:=matrix((A[1, 1] + sqrt(A[1, 1]*A[1, 1] + G[1, 1]*Q[1, 1]))/G[1, 1]);
          end if;
        else
          X := fill(0, 0, 0);
        end if;

        annotation (Documentation(info="<html>
<p>
Function <b>care</b> computes the solution <b>X</b> of the continuous-time
algebraic Riccati equation
</p>
<blockquote><pre>
<b>Q</b> + <b>A</b>'*<b>X</b> + <b>X</b>*<b>A</b> - <b>X</b>*<b>G</b>*<b>X</b> = <b>0</b>
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
<b>G</b> = <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'
</pre></blockquote>
<p>
using the Schur vector approach proposed by Laub [1].
</p>
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is
symmetric, nonsingular and positive definite, (<b>A</b>,<b>B</b>) is stabilizable
and (<b>A</b>,<b>Q</b>) is detectable.
<b>
The assumptions are not checked in this function!
</b>
</p>
<p>
The assumptions guarantee that Hamiltonian matrix
</p>
<blockquote><pre>
<b>H</b> = [<b>A</b>, -<b>G</b>; -<b>Q</b>, -<b>A</b>']
</pre></blockquote>
<p>
has no pure imaginary eigenvalue and can be put to an ordered real Schur form
</p>
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>S</b> = [<b>S</b>11, <b>S</b>12; <b>0</b>, <b>S</b>22]
</pre></blockquote>
<p>
with orthogonal similarity transformation <b>U</b>. <b>S</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
</p>
<blockquote><pre>
<b>A</b> - <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b>
</pre></blockquote>
<p>
If <b>U</b> is partitioned to
</p>
<blockquote><pre>
<b>U</b> = [<b>U</b>11, <b>U</b>12; <b>U</b>21, <b>U</b>22]
</pre></blockquote>
<p>
with dimenstions according to <b>S</b>, the solution <b>X</b> can be calculated by
</p>
<blockquote><pre>
<b>X</b>*<b>U</b>11 = <b>U</b>21.
</pre></blockquote>
<p>
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
</p>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Laub A.J. (1979):</dt>
<dd> <b>A Schur Method for Solving Algebraic Riccati equations</b>.
     IEEE Trans. Auto. Contr., AC-24, pp. 913-921.<br>&nbsp;</dd>
</dl>
</html>",     revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end care;

      function dare "Solution of discrete-time algebraic Riccati equations"
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Complex;

        input Real A[:,size(A, 1)];
        input Real B[size(A, 1),:];
        input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2));
        input Real Q[size(A, 1),size(A, 1)]=identity(size(A, 1));
        input Boolean refine = false;

    protected
        Integer n=size(A, 1);
        Real G[size(A, 1),size(A, 1)]=B*MatricesMSL.solve2(R, transpose(B));
        Real AT[:,:]=transpose(A);
        Real LU[n,n];
        Integer p[n];
        Real H[2*n,2*n];
        Real H11[n,n];
        Real H12[n,n];
        Real H21[n,n];
        Real H22[n,n];
      //  Real invAT[:,:]=transpose(MatricesMSL.inv(A));
      //  Real H[:,:]=[A + G*invAT*Q,-G*invAT; -invAT*Q,invAT];
        Real H_RSF[2*n,2*n];
        Real Z[size(H, 1),size(H, 2)];
        Real Z11[size(A, 1),size(A, 2)];
        Real Z21[size(A, 1),size(A, 2)];
        Real alphaReal[size(H, 1)] "Real part of eigenvalue=alphaReal+i*alphaImag";
        Real alphaImag[size(H, 1)]
          "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";

        Integer info;
        Integer evSize;
        Complex j = Modelica_LinearSystems2.Math.Complex.j();

    public
        output Real X[size(A, 1),size(A, 2)]
          "Orthogonal matrix of the Schur vectors associated to ordered rsf";
        output Complex ev[size(A, 1)] "Eigenvalues of the closed loop system";

      algorithm
        (LU,p) := MatricesMSL.LU(AT);
        H21 := MatricesMSL.LU_solve2(LU,p,-Q);
        H22 := MatricesMSL.LU_solve2(LU,p,identity(n));
        (LU,p) := MatricesMSL.LU(A);
        H12 := MatricesMSL.LU_solve2(LU,p,-G);
        H12 := transpose(H12);
        H11 := A - H12*Q;
        H := [H11, H12; H21, H22];
        (H_RSF,Z,alphaReal,alphaImag) := Matrices.rsf(H);// put H to Schur form
        (H_RSF,Z,alphaReal,alphaImag) := Matrices.Internal.reorderRSF(
          false,
          H_RSF,
          Z,
          alphaReal,
          alphaImag);// ordered Schur form

          evSize := size(ev, 1);
        for i in 1:evSize loop
          ev[i] := alphaReal[i] + j*alphaImag[i];
        end for;

        Z11 := Z[1:n, 1:n];
        Z21 := Z[n + 1:2*n, 1:n];
        if size(Z11, 1) > 0 then
      //  X := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));
          (X,info) := Matrices.LAPACK.dgesvx(Z11, transpose(Z21));//function does not need to transpose Z11 as solve2 does
          X := transpose(X);
          assert(info == 0, "Solving a linear system of equations with function
\"Matrices.LAPACK.dgesvx\" is not possible, because the system has either
no or infinitely many solutions (input A is singular).");

          if refine then
            X := Matrices.Internal.darenls(A, B, R, Q, X);
          end if;
        else
          X := fill(0,size(Z21, 1),size(Z11, 1));
        end if;

        annotation (Documentation(info="<html>
<p>
Function <b>dare</b> computes the solution <b>X</b> of the discrete-time
algebraic Riccati equation
</p>
<blockquote><pre>
<b>X</b> = <b>A</b>'*<b>X</b>*<b>A</b> - <b>A</b>'*<b>X</b>*<b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>*<b>B</b>'*<b>X</b>*<b>A</b> + <b>Q</b>
</pre></blockquote>
<p>
using the Schur vector approach proposed by Laub [1].
</p>
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b>
is symmetric, nonsingular and positive definite, (<b>A</b>,<b>B</b>) is stabilizable
and (<b>A</b>,<b>Q</b>) is detectable.
<b>The assumptions are not checked in this function</b>
</p>

<p>
The assumptions guarantee that the Hamiltonian matrix
</p>
<blockquote><pre>
<b>H</b> = [<b>A</b><sup>-1</sup>, -<b>A</b><sup>-1</sup>*<b>G</b>; <b>Q</b>*<b>A</b><sup>-1</sup>, <b>A</b>' + <b>Q</b>*<b>A</b><sup>-1</sup>*<b>G</b> ]
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
<b>G</b> = <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'
</pre></blockquote>
<p>
has no eigenvalue on the unit circle and can be put
to an ordered real Schur form
</p>
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>X</b> = [<b>S11</b>, <b>S12</b>; <b>0</b>, <b>S22</b>]
</pre></blockquote>
<p>
with orthogonal similarity transformation <b>U</b>. <b>X</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
</p>
<blockquote><pre>
<b>A</b> - <b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>  *<b>B</b>'*<b>X</b>*<b>A</b>
</pre></blockquote>
<p>
If <b>U</b> is partitioned to
</p>
<blockquote><pre>
<b>U</b> = [<b>U11</b>, <b>U12</b>; <b>U21</b>, <b>U22</b>]
</pre></blockquote>
<p>
according to <b>X</b>, the solution <b>X</b> can be calculated by
</p>
<blockquote><pre>
<b>X</b>*<b>U11</b> = <b>U21</b>.
</pre></blockquote>

<p>
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix
of <b>H</b>), dorghr (to calculate the orthogonal matrix from the elementary reflectors
as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to
calculate the eigenvalues of the closed loop system) and dtrsen (to compute the ordered
real Schur form and matrix <b>U</b>).
</p>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Laub A.J. (1979):</dt>
<dd> <b>A Schur Method for Solving Algebraic Riccati equations</b>.
     IEEE Trans. Auto. Contr., AC-24, pp. 913-921.<br>&nbsp;</dd>
</dl>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end dare;

      function dlyapunov
        "Solution of continuous-time Lyapunov equation A'X*A - X = C"
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica.Math.Matrices.solve;

        input Real A[:,size(A, 1)];
        input Real C[size(A, 1),size(A, 2)];
        input Real eps=Modelica.Math.Matrices.norm(A,1)*10*Modelica.Constants.eps;

    protected
        Integer n=size(A, 1);
        Real R[size(A, 1),size(A, 2)] "rsf of A', i.e. R=U'A'U";
        Real U[size(A, 1),size(A, 2)] "transformation matrix U for R=U'A'U";
        Real C2[size(A, 1),size(A, 2)];
        Real R22[size(A, 1),size(A, 2)];
        Real R11[size(A, 1),size(A, 2)];
        Integer k;

      //  Real Y[size(A, 1),size(A, 2)];
        Real bk1[size(A, 1)];
        Real bk[size(A, 1)];
        Real yk[size(A, 1)];
        Boolean crit;

    public
        output Real X[size(A, 1),size(A, 2)] "solution of the Lyapunov equation";

      algorithm
           X := zeros(n, n);
      //    Y := zeros(n,n);
          k := n;
        if n > 1 then
          (R,U) := Matrices.rsf(transpose(A));
          C2 := transpose(U)*C*U;

        while k > 0 loop

      //      bk := C2[:,k] - R*Y[:,k+1:n]*R[k,k+1:n];
            bk := C2[:,k] - R*X[:,k+1:n]*R[k,k+1:n];
            crit :=  if k>1 then abs(R[k,k-1])<eps else false;
         if (k==1 or crit) then
            R22 := R[k,k]*R;
            for i in 1:n loop
              R22[i,i] := R22[i,i]-1.0;
            end for;
      //      Y[:,k] := solve(R22,bk);
            X[:,k] := solve(R22,bk);
            k:=k-1;
         else
      //       bk1:=C2[:,k-1]-R*Y[:,k+1:n]*R[k-1,k+1:n];
             bk1:=C2[:,k-1]-R*X[:,k+1:n]*R[k-1,k+1:n];
             R11 := R[k-1,k-1]*R;
             R22 :=  R[k,k]*R;
             for i in 1:n loop
               R11[i,i] := R11[i,i] -1.0;
               R22[i,i] := R22[i,i] -1.0;
             end for;
             yk :=solve([R11,  R[k-1,k]*R; R[k,k-1]*R,  R22], cat(1,bk1,bk));
      //       Y[:,k-1]:=yk[1:n];
      //       Y[:,k]:=yk[n + 1:2*n];
             X[:,k-1]:=yk[1:n];
             X[:,k]:=yk[n + 1:2*n];
             k:=k-2;
         end if;
         end while;

      // transform X corresponding to the original form
      //    X := U*Y*transpose(U);
          X := U*X*transpose(U);

        elseif n == 1 then
          X[1, 1] := C[1, 1]/(A[1, 1]*A[1, 1]-1);
        else
          X := fill(0, 0, 0);
        end if;

        annotation (Documentation(info="<html>
<p>
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time
Lyapunov equation
</p>
<blockquote><pre>
<b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
<p>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
</p>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Bartels, R.H. and Stewart G.W. (1972):</dt>
<dd> <b>Algorithm 432: Solution of the matrix equation AX + XB = C</b>.
     Comm. ACM., Vol. 15, pp. 820-826.<br>&nbsp;</dd>
</dl>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end dlyapunov;

      function eigenValues
        "Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix (matrix is balanced before eigenvalues are computed)"

        extends Modelica.Icons.Function;

        input Real A[:, size(A, 1)] "Matrix";
        output Real eigenvalues[size(A, 1), 2]
          "Eigenvalues of matrix A (Re: first column, Im: second column)";

        output Real leftEigenvectors[size(A,1), size(A,2)]
          "Real-valued eigenvector matrix";
       output Real rightEigenvectors[size(A,1), size(A,2)]
          "Real-valued eigenvector matrix";

    protected
        Integer info;
        Boolean onlyEigenvalues = false;
      algorithm
      if size(A,1) > 0 then
        if onlyEigenvalues then
            (eigenvalues[:, 1],eigenvalues[:, 2],info) :=
              Modelica.Math.Matrices.LAPACK.dgeev_eigenValues(A);
           rightEigenvectors :=zeros(size(A, 1), size(A, 1));
           leftEigenvectors :=zeros(size(A, 1), size(A, 1));
        else
            (eigenvalues[:, 1],eigenvalues[:, 2],leftEigenvectors,rightEigenvectors,,info) := Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx(A);
        end if;
        assert(info == 0, "Calculating the eigenvalues with function
\"Matrices.eigenvalues\" is not possible, since the
numerical algorithm does not converge.");
      end if;
        annotation (
          Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the eigenvalues and
optionally the (right) eigenvectors of a square matrix
<b>A</b>. The first column of \"eigenvalues\" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function
<a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues
such that
</p>
<blockquote><pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors),
</pre></blockquote>
<p>
provided the eigenvector matrix \"eigenvectors\" can be inverted
(an inversion is possible, if all eigenvalues are different
and no eigenvalue is zero).
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real eval;

<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0;
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre></blockquote>
<p>
i.e., matrix <b>A</b> has the 3 real eigenvalues -0.618, 8, 1.618.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
<a href=\"modelica://Modelica.Math.Matrices.singularValues\">Matrices.singularValues</a>
</p>
</html>"));
      end eigenValues;

      function eigenValuesAsRealMatrix
        "Return eigenvalues for a real, nonsymmetric matrix in a Real representation (computation with optional balancing)"

        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)] "Matrix";
        input Boolean balance=true
          "=true, if A is balanced (pre-scaled) before computation of the eigen values";
        output Real eigenvalues[size(A, 1), 2]
          "Eigenvalues of matrix A (Re: first column, Im: second column)";
    protected
        Integer info;
      algorithm
        if size(A, 1) > 0 then
          if balance then
            (eigenvalues[:, 1],eigenvalues[:, 2],info) :=
               Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx_eigenValues(A);
          else
            (eigenvalues[:, 1],eigenvalues[:, 2],info) :=
               Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev_eigenValues(A);
          end if;
          assert(info == 0, "Calculating the eigen values with function
\"eigenvaluesAsRealMatrix\" is not possible, since the
numerical algorithm does not converge.");
        end if;
        annotation (Documentation(info="<HTML>
<h4>Syntax</h4>
<blockquote><pre>
eigenvalues = Matrices.<b>eigenValuesAsRealMatrix</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues of a square matrix
<b>A</b>. The first column of \"eigenvalues\" contains the real and the
second column contains the imaginary part of the eigenvalues.
Before calculating the eigenvalues, matrix A is permuted and scaled (balanced)
to improve the computation. For details see the
<a href=\"http://www.netlib.org/lapack/lug/node94.html\">lapack documentation</a>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real eval[3,2];
<b>algorithm</b>
  eval := Matrices.eigenValuesAsRealMatrix(A);  // eval = [ 8.0  , 0;
                                                //         -0.618, 0;
                                                //          1.618, 0];
</pre>
</blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues 8.0, -0.618, 1.618.
</p>
</html>"));
      end eigenValuesAsRealMatrix;

      function generalizedEigenvaluesTriangular
        "Compute invariant zeros of linear state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form"

        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        input Real A[:,size(A, 1)];
        input Real B[size(A, 1),size(A, 1)];
        output Real alphaReal[size(A, 1)]
          "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)";
        output Real alphaImag[size(A, 1)] "Imaginary part of alpha";
        output Real beta[size(A, 1)] "Denominator of eigenvalue";

        output Integer info;

      algorithm
        (alphaReal,alphaImag,beta,info) := LAPACK.dhgeqz(A, B);
        assert(info == 0, "Failed to compute eigenvalues with function dhgeqz(..)");
        annotation (Documentation(info="This function is an interface to LAPACK routine DHGEQZ to calculate invariant
zeros of systems with generalized system matrices of upper Hessenberg form.
DHGEQZ is described below:



     Purpose
   ==========================================================

   DHGEQZ implements a single-/double-shift version of the QZ method for
   finding the generalized eigenvalues

   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation

        det( A - w(i) B ) = 0

   In addition, the pair A,B may be reduced to generalized Schur form:
   B is upper triangular, and A is block upper triangular, where the
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
   complex generalized eigenvalues (see the description of the argument
   JOB.)

   If JOB='S', then the pair (A,B) is simultaneously reduced to Schur
   form by applying one orthogonal tranformation (usually called Q) on
   the left and another (usually called Z) on the right.  The 2-by-2
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
   of A will be reduced to positive diagonal matrices.  (I.e.,
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
   B(j+1,j+1) will be positive.)

   If JOB='E', then at each iteration, the same transformations
   are computed, but they are only applied to those parts of A and B
   which are needed to compute ALPHAR, ALPHAI, and BETAR.

   If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the orthogonal
   transformations used to reduce (A,B) are accumulated into the arrays
   Q and Z s.t.:

        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*

   Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix
        Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),
        pp. 241--256.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = 'E': compute only ALPHAR, ALPHAI, and BETA.  A and B will
                  not necessarily be put into generalized Schur form.
           = 'S': put A and B into generalized Schur form, as well
                  as computing ALPHAR, ALPHAI, and BETA.

   COMPQ   (input) CHARACTER*1
           = 'N': do not modify Q.
           = 'V': multiply the array Q on the right by the transpose of
                  the orthogonal tranformation that is applied to the
                  left side of A and B to reduce them to Schur form.
           = 'I': like COMPQ='V', except that Q will be initialized to
                  the identity first.

   COMPZ   (input) CHARACTER*1
           = 'N': do not modify Z.
           = 'V': multiply the array Z on the right by the orthogonal
                  tranformation that is applied to the right side of
                  A and B to reduce them to Schur form.
           = 'I': like COMPZ='V', except that Z will be initialized to
                  the identity first.

   N       (input) INTEGER
           The order of the matrices A, B, Q, and Z.  N >= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows and
           columns 1:ILO-1 and IHI+1:N.
           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the N-by-N upper Hessenberg matrix A.  Elements
           below the subdiagonal must be zero.
           If JOB='S', then on exit A and B will have been
              simultaneously reduced to generalized Schur form.
           If JOB='E', then on exit A will have been destroyed.
              The diagonal blocks will be correct, but the off-diagonal
              portion will be meaningless.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA >= max( 1, N ).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the N-by-N upper triangular matrix B.  Elements
           below the diagonal must be zero.  2-by-2 blocks in B
           corresponding to 2-by-2 blocks in A will be reduced to
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
           positive.)
           If JOB='S', then on exit A and B will have been
              simultaneously reduced to Schur form.
           If JOB='E', then on exit B will have been destroyed.
              Elements corresponding to diagonal blocks of A will be
              correct, but the off-diagonal portion will be meaningless.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB >= max( 1, N ).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAR(1:N) will be set to real parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAI(1:N) will be set to imaginary parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   BETA    (output) DOUBLE PRECISION array, dimension (N)
           BETA(1:N) will be set to the (real) diagonal elements of B
           that would result from reducing A and B to Schur form and
           then further reducing them both to triangular form using
           unitary transformations s.t. the diagonal of B was
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.
           (Note that BETA(1:N) will always be non-negative, and no
           BETAI is necessary.)

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
           If COMPQ='N', then Q will not be referenced.
           If COMPQ='V' or 'I', then the transpose of the orthogonal
              transformations which are applied to A and B on the left
              will be applied to the array Q on the right.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.  LDQ >= 1.
           If COMPQ='V' or 'I', then LDQ >= N.

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
           If COMPZ='N', then Z will not be referenced.
           If COMPZ='V' or 'I', then the orthogonal transformations
              which are applied to A and B on the right will be applied
              to the array Z on the right.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.  LDZ >= 1.
           If COMPZ='V' or 'I', then LDZ >= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK >= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           < 0: if INFO = -i, the i-th argument had an illegal value
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO+1,...,N should be correct.
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO-N+1,...,N should be correct.
           > 2*N:     various \"impossible\" errors.

   Further Details
   ===============

   Iteration counters:

   JITER  -- counts iterations.
   IITER  -- counts iterations run since ILAST was last
             changed.  This is therefore reset only when a 1-by-1 or
             2-by-2 block deflates off the bottom.

   =====================================================================
"));
      end generalizedEigenvaluesTriangular;

      function householderReflexion
        "Reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u"
        import Modelica.Math.Vectors.length;

        input Real A[:,:] "Rectangular matrix";
        input Real u[size(A, 1)] "Householder vector";

        output Real RA[size(A, 1),size(A, 2)] "Reflexion of A";

    protected
        Integer n=size(A, 2);
        Real h;
        Real lu=length(u)*length(u);

      algorithm
        for i in 1:n loop
          h := scalar(2*transpose(matrix(u))*A[:, i]/lu);
          RA[:, i] := A[:, i] - h*u;
        end for;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderReflection</b>(A,u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the Housholder reflection (transformation)
</p>
<blockquote>
<b>Ar</b> = <b>Q</b>*<b>A</b>
</blockquote>
<p>
with
</p>
<blockquote>
<b>Q</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>)
</blockquote>
<p>
where <b>u</b>*<b>u</b> is housholder vector, i.e. the normal vector of the reflection plane.
</p>
<p>
Householder reflection is widely used in numerical linear algebra, e.g. to perform QR decompositions.
</p>

<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];

  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u={ = {0.763, 0.646, 0}
  Ar=householderReflexion(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.Utilities.householderSimilarityTransformation\">Matrices.housholderSimilarityTransformation</a>
</p>
</html>"));
      end householderReflexion;

      function householderSimilarityTransformation
        "Calculate the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u'"

        import Modelica.Math.Vectors.length;

        input Real A[:,size(A, 1)] "Square matrix A";
        input Real u[size(A, 1)] "Householder vector";
        output Real SAS[size(A, 1),size(A, 1)];

    protected
        Integer na=size(A, 1);
        Real S[:,:]=-2*matrix(u)*transpose(matrix(u))/(length(u)*length(u))
          "Symmetric matrix";
        Integer i;
      algorithm
        for i in 1:na loop
          S[i, i] := 1.0 + S[i, i];
        end for;
        SAS := S*A*S;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderSimilarityTransformation</b>(A,u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the Housholder similarity transformation
</p>
<blockquote>
  <b>As</b> = <b>S</b>*<b>A</b>*<b>S</b>
</blockquote>
<p>
with
</p>
<blockquote>
  <b>S</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>

<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};

  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}
  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.Utilities.householderReflection\">Matrices.housholderReflection</a>
</p>
</html>"));
      end householderSimilarityTransformation;

      function lyapunov
        "Solution of continuous-time Lyapunov equation X*A + A'*X = C"
        import MatricesMSL = Modelica.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices;

        input Real A[:,size(A, 1)];
        input Real C[size(A, 1),size(A, 2)];
        input Real eps=MatricesMSL.norm(A,1)*10*Modelica.Constants.eps;

    protected
        Integer n=size(A, 1);
        Real R[size(A, 1),size(A, 2)] "rsf of A', i.e. R=U'A'U";
        Real U[size(A, 1),size(A, 2)] "transformation matrix U for R=U'A'U";
        Real C2[size(A, 1),size(A, 2)];
        Real R11[size(A, 1),size(A, 2)];
        Real R22[size(A, 1),size(A, 2)];
        Real R12[size(A, 1),size(A, 2)];
        Real R21[size(A, 1),size(A, 2)];
        Real R2[2*size(A, 1),2*size(A, 2)];
        Real I[size(A, 1),size(A, 1)]=identity(size(A, 1));
        Real x[2*size(A,1)];
        Real c[2*size(A,1)];
        Real CC[size(A,1),2];
        Integer k;

    public
        output Real X[size(A, 1),size(A, 2)] "solution of the Lyapunov equation";

      algorithm
        if n > 1 then
          (R,U) := Matrices.rsf(transpose(A));
          C2 := transpose(U)*C*U;
          X := zeros(n, n);

      // Calculate the last 1 or 2 columns of X
          R22 := R;
          for i1 in 1:n loop
            R22[i1, i1] := R[i1, i1] + R[n, n];
          end for;
          if abs(R[n, n - 1]) < eps then
            X[:, n] := MatricesMSL.solve(R22, C2[:, n]);
            k := n - 1;
          else
            R11 := R;
            R12 := zeros(n, n);
            R21 := zeros(n, n);
            for i1 in 1:n loop
              R11[i1, i1] := R[i1, i1] + R[n - 1, n - 1];
              R12[i1, i1] := R[n - 1, n];
              R21[i1, i1] := R[n, n - 1];
            end for;

      // solve 2nx2n equation for 2x2 Schur bump with Kronecker product and vec operator approach
            R2 := [R11,R12; R21,R22];
            c := cat(1, C2[:, n - 1], C2[:, n]);
            x := MatricesMSL.solve(R2, c);
            X[:, n - 1] := x[1:n];
            X[:, n] := x[n + 1:2*n];
            k := n - 2;
          end if;

      // Calculate the rest of X

          while k > 1 loop
            R22 := R;
            for i1 in 1:n loop
              R22[i1, i1] := R[i1, i1] + R[k, k];
            end for;
            if abs(R[k, k - 1]) < eps then
              //real eigenvalue
      //        X[:, k] := MatricesMSL.solve(R22, C2[:, k] - vector(X[:, k + 1:n]*transpose(matrix(R[k, k + 1:n]))));
              X[:, k] := MatricesMSL.solve(R22, C2[:, k] - vector(X[:, k + 1:n]*matrix(R[k, k + 1:n])));
              k := k - 1;
            else
             // conjugated complex eigenvalues
              R11 := R;
              R12 := zeros(n, n);
              R21 := zeros(n, n);
              for i1 in 1:n loop
                R11[i1, i1] := R[i1, i1] + R[k - 1, k - 1];
                R12[i1, i1] := R[k - 1, k];
                R21[i1, i1] := R[k, k - 1];
              end for;
              R2 := [R11,R12; R21,R22];
              CC := C2[:,k-1:k] - X[:,k+1:n]*transpose(R[k-1:k,k+1:n]);
              c := cat(1, CC[:, 1], CC[:, 2]);
              x := MatricesMSL.solve(R2, c);
              X[:, k - 1] := x[1:n];
              X[:, k] := x[n + 1:2*n];

              k := k - 2;
            end if;
          end while;// k=1 or k=0

      // if k=1 the first column (if there exist a real eigenvalue) has to be calculated separately
          if k == 1 then
            R22 := R;
            for i1 in 1:n loop
              R22[i1, i1] := R[i1, i1] + R[1, 1];
            end for;
            X[:, 1] := MatricesMSL.solve(R22, C2[:, 1] - vector(X[:, 2:n]*matrix(R[1, 2:n])));
          end if;

      // transform X corresponding to the original form
          X := U*X*transpose(U);

        elseif n == 1 then
          X[1, 1] := C[1, 1]/(2*A[1, 1]);
        else
          X := fill(0, 0, 0);
        end if;

        annotation (Documentation(info="<html>
<p>
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time Lyapunov equation
</p>
<blockquote><pre>
<b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
<p>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
</p>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Bartels, R.H. and Stewart G.W. (1972):</dt>
<dd> <b>Algorithm 432: Solution of the matrix equation AX + XB = C</b>.
     Comm. ACM., Vol. 15, pp. 820-826.<br>&nbsp;</dd>
</dl>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
      end lyapunov;

      function orthogonalQ
        "Generates a real orthogonal matrix Q defined as the product of IHI-ILO elementary reflectors"
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        input Real A[:,size(A, 1)];
        input Real tau[size(A, 1) - 1] "Scalar factors of the elementary reflectors";
        input Integer ilo=1
          "Lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD";
        input Integer ihi
          "Highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD";

        output Real Q[size(A, 1),size(A, 2)]
          "Orthogonal matrix as a result of elementary reflectors";
        output Integer info;

      algorithm
        (Q,info) := LAPACK.dorghr(
          A,
          ilo,
          ihi,
          tau);
        annotation (Documentation(info="<html>
<p>
This function generates a real orthogonal matrix Q which is defined as the product
of IHI-ILO elementary reflectors of order N, as returned by DGEHRD.
</p>

<pre>
Lapack documentation:

   Purpose
   =======

   DORGHR generates a real orthogonal matrix Q which is defined as the
   product of IHI-ILO elementary reflectors of order N, as returned by
   DGEHRD:

   Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix Q. N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           ILO and IHI must have the same values as in the previous call
           of DGEHRD. Q is equal to the unit matrix except in the
           submatrix Q(ilo+1:ihi,ilo+1:ihi).
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the vectors which define the elementary reflectors,
           as returned by DGEHRD.
           On exit, the N-by-N orthogonal matrix Q.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA &gt;= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (N-1)
           TAU(i) must contain the scalar factor of the elementary
   ), as returned by DGEHRD.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= IHI-ILO.
           For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================

</pre>
</html>"));
      end orthogonalQ;

      function printMatrixInHtml
        "Print a matrix in html format on file (without html/body heading)"
        import Modelica.Utilities.Strings;
        import Modelica.Utilities.Streams.print;

        input Real M[:,:] "Real matrix";
        input String name="" "Matrix name used for printing";
        input String fileName="log.html"
          "Name of file to be printed in (incl. file extension)";
        input String format=".6g" "Format of numbers (e.g. \"20.8e\")";
        input Boolean printIndices=true
          "=true, if row and column indices shall be printed, otherwise they are not printed";
    protected
        Integer r=size(M, 1);
        Integer c=size(M, 2);

      algorithm
        if r == 0 or c == 0 then
           if name == "" then
              print("<p>&nbsp;&nbsp;&nbsp;[&nbsp;], empty matrix: " + String(r)+" by "+String(c) + "</p>\n", fileName);
           else
              print("<p>&nbsp;&nbsp;&nbsp;" + name + "&nbsp;=&nbsp;[&nbsp;], empty matrix: " + String(r)+" by "+String(c) + "</p>\n", fileName);
           end if;
        else
           // Print "name = "
           if name <> "" then
              print("<table border=\"0\">\n<tr>\n  <td valign=\"middle\">" +
                    "&nbsp;&nbsp;&nbsp;" + name + "</td>\n  <td valign=\"middle\">=</td>\n  <td>", fileName);
           end if;

           // Print table heading
           print("    <table style=\"background-color:rgb(100, 100, 100);\" cellpadding=\"3\" border=\"0\" cellspacing=\"1\">",
                 fileName);
           if printIndices then
              print(  "\n    <tr style=\"background-color:rgb(230, 230, 230); text-align:center;\">"
                    + "\n      <td> </td>", fileName);

              for j in 1:c loop
                 print("      <td align=\"center\">" + String(j) + "</td>", fileName);
              end for;
              print("    </tr>", fileName);
           end if;

           // Print matrix elements
           for i in 1:r loop
              print("    <tr style=\"background-color:white\">\n", fileName);
              if printIndices then
                 print("      <td align=\"right\" style=\"background-color:rgb(230, 230, 230);\">"
                       + String(i) + "</td>", fileName);
              end if;

              for j in 1:c loop
                 print("      <td align=\"right\">" + String(M[i, j],format=format) + "</td>", fileName);
              end for;

              print("    </tr>", fileName);
           end for;

           // Print row closing tags
           print("    </table>", fileName);
           if name <> "" then
              print("  </td>\n</tr>\n</table>", fileName);
           end if;
        end if;

        annotation (Documentation(info="<html>

</html>",       revisions="<html>
</html>"));
      end printMatrixInHtml;

      function QR
        "QR decomposition of a rectangular matrix without column pivoting (A = Q*R). Return the full square Q-matrix"

        input Real A[:,:] "Rectangular matrix with size(A,1) >= size(A,2)";
        output Real Q[size(A, 1),size(A, 2)]
          "Rectangular matrix with orthonormal columns such that Q*R=A[:,p]";
        output Real R[min(size(A, 1), size(A, 2)),size(A, 2)]
          "Square upper triangular matrix";

        output Real tau[min(size(A, 1), size(A, 2))];
        output Real Q2[size(A,1),size(A, 1)];
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer minrowcol=min(nrow, ncol);
        Integer lwork=3*max(1,max(nrow,ncol));//Internal.dgeqrf_workdim(A);

      algorithm
        if minrowcol > 0 then

          (Q,tau) := Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf(A, lwork);

        // determine R
          R := zeros(minrowcol, ncol);
          for i in 1:minrowcol loop
            for j in i:ncol loop
              R[i, j] := Q[i, j];
            end for;
          end for;

          //Q2 := Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr(Q, tau);// would return the economic size Q matrix

          Q2 := Modelica_LinearSystems2.Math.Matrices.Internal.multiplyWithOrthogonalQ_qr(identity(size(A, 1)), Q, tau, "L", "N");

        else
          Q := fill(1, size(A, 1), size(A, 2));
          R := fill(0, min(size(A, 1), size(A, 2)), size(A, 2));
        end if;

        annotation ( Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<b>QR</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
</p>
</blockquote>
<p>
where <b>Q</b> is a rectangular matrix that has orthonormal columns and
has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
<b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
vector. Matrix <b>R</b> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <b>R</b> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <b>R</b> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
small elements and can be treated as being zero.
This allows to, e.g., estimate the row-rank
of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
<b>R</b> can be partitioned in two parts
</p>
<blockquote>
<pre>
   <b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
                 <b>0</b>,  <b>0</b>]
</pre>
</blockquote>
<p>
where <b>R</b><sub>1</sub> is a regular, upper triangular matrix.
</p>
<p>
Note, the solution is computed with the LAPACK functions \"dgeqp3\"
and \"dorgqr\", i.e., by Housholder transformations with
column pivoting. If <b>Q</b> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<b>algorithm</b>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
</html>"));
      end QR;

      function rsf "Computes the real Schur form (RSF) of a square matrix"
        import Modelica_LinearSystems2.Math.Matrices;
        import Modelica_LinearSystems2.Math.Matrices.Internal;
        import Modelica_LinearSystems2.Math.Matrices.LAPACK;
        input Real A[:,size(A, 1)];

    protected
        Integer n=size(A, 1);
        Integer i;
        Integer lwork;
        Real tau[max(0, size(A, 1) - 1)];

        Real Aout[size(A, 1),size(A, 2)];
        Real H[size(A, 1),size(A, 2)] "Upper Hessenberg form of A";
        Real Q[size(A, 1),size(A, 2)]
          "Represents the Hessenberg transformation as a product of the elementary reflectors";
        Integer info1;
        Integer info2;

    public
        output Real T[size(A, 1),size(A, 2)];
        output Real Z[size(A, 1),size(A, 2)];
        output Real alphaReal[size(A, 1)]
          "Real part of eigenvalue=alphaReal+i*alphaImag";
        output Real alphaImag[size(A, 1)]
          "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";

      algorithm
        if size(A, 1) > 1 then

      // dgehrd reduces a real matrix A to upper Hessenberg form Aout by an orthogonal
      // similarity transformation:  Q' * A * Q = Aout. Q can be computed from
      // Aout and tau (dorghr)

          (Aout,tau,info1) := LAPACK.dgehrd(
            A,
            1,
            n);
          assert(info1 == 0, "The " + String(-info1) +
            "'th argument of LAPACK.dgehrd had an illegal value");
      // dorghr to compute Q

          (Q,info1) := LAPACK.dorghr(
            Aout,
            1,
            n,
            tau);
          assert(info1 == 0, "The " + String(-info1) +
            "'th argument of LAPACK.dorghr had an illegal value");

          H[1:2, :] := Aout[1:2, :];
          for i in 3:n loop
            H[i, i - 1:n] := Aout[i, i - 1:n];
          end for;
      // dhseqr computes the eigenvalues of a real upper Hessenberg matrix H,
      // the Schur form T of H that is also the Schur form of A as well as the matrix
      // Z containing the Schur vectors to get A = Q*H*Q' = (Z)*T*(Z)'

          lwork := max(Internal.dhseqr_workdim(H), 1);
          (alphaReal,alphaImag,info2,T,Z) := LAPACK.dhseqr(
            H,
            lwork,
            false,
            "V",
            Q);
          assert(info2 == 0, "The output info of LAPACK.dhseqr should be zero, else if\n
     info < 0:  if info = -i, the i-th argument of LAPACK.dhseqr had an illegal value\n
     info > 0:  if INFO = i, LAPACK.dhseqr failed to compute all of the
                 eigenvalues in a total of 30*n iterations;\n
                 elements 1:n-1 and i+1:n of WR and WI contain those
                 eigenvalues which have been successfully computed.\n");
        else
          T := A;
          if size(A, 1) > 0 then
            Z := [1];
            alphaReal := {1};
            alphaImag := {0};
          else
            Z := fill(
              1,
              0,
              0);
            alphaReal := fill(1, 0);
            alphaImag := fill(0, 0);
          end if;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(T, Z, alphaReal, alphaImag) = Matrices.<b>rsf</b>(A)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rsf</b> (real Schur form) calculates the real Schur form af
a real square matrix <b>A</b>, i.e.
</p>
<blockquote>
  <b>A</b> = <b>Z</b>*<b>T</b>*<b>Z</b><sup>T</sup>
</blockquote>
<p>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.
<b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.
The 1x1 blocks contains the real eigenvalues of&nbsp;a. The 2x2 blocks are matrices with
the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues
are the elements of the diagonal.
</p>
<p>
The calculation is performed stepwise using several lapack routines.
First, lapack.dgehrd reduces matrix <b>A</b> is to upper Hessenberg form
<b>H</b>=<b>Q'AQ</b>, whereas <b>Q</b> is computed by lapack.dodrghr.
Finally, lapack.dhseqr transforms <b>H</b> to <b>T</b>. The eigenvalues
of <b>A</b> are calculated straightforward from <b>T</b>.
</p>
<p>
Function <b>rsf</b> does not apply lapack.dgees, a routine to directly compute
the real Schur from.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
  Real T[3,3];
  Real Z[3,3];
  Real alphaReal[3];
  Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.Math.Matrices.rsf2\">Math.Matrices.rsf2</a>
</p>
</html>"));
      end rsf;

      package Internal
      "Package of internal functions operating on matrices (for advanced users only)"
        extends Modelica.Icons.Package;

        function carenls
          "Newton's method with exact line search for solving continuous algebraic riccati equation"
          extends Modelica.Icons.Function;

          import Modelica_LinearSystems2.Math.Matrices;
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica_LinearSystems2.Math.Complex;

          input Real A[:,size(A, 1)];
          input Real B[size(A, 1),:];
          input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2));
          input Real Q[size(A, 1),size(A, 2)]=identity(size(A, 1));
          input Real X0[size(A, 1),size(A, 2)];
          input Real eps=Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm(
                                                A)*1e-9;

          output Real X[size(X0, 1),size(X0, 2)];
          output Real r;

      protected
          Integer n=size(A, 1);
          Real G[size(A, 1),size(A, 2)]=B*Modelica.Math.Matrices.solve2(R, transpose(B));
          Real Xk[size(X, 1),size(X, 2)];
          Real Ak[size(A, 1),size(A, 2)];
          Real Rk[size(A, 1),size(A, 2)];
          Real Nk[size(A, 1),size(A, 2)];
          Real Vk[size(A, 1),size(A, 2)];
          Real tk;
          Integer k;
          Complex xc[2];
          Boolean stop;

        algorithm
          if n > 1 then
            k := 0;
            stop := false;
            Xk := X0;
            while (not stop and k<10) loop
              k := k + 1;
              Ak := A - G*Xk;
              Rk := transpose(A)*Xk + Xk*A + Q - Xk*G*Xk;
              Nk := Matrices.lyapunov(Ak, -Rk);
              Vk := Nk*G*Nk;
              tk := Modelica_LinearSystems2.Math.Matrices.Internal.findLocal_tk(
                                                   Rk, Vk);
              stop := eps > Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm(
                                                   tk*Nk)/Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm(
                                                                                 Xk);
              Xk := Xk + tk*Nk;
            end while;
            X := Xk;
            r := Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm(
                                        X*A + transpose(A)*X - X*G*X + Q);

          elseif n == 1 then
            xc := Polynomial.roots(Polynomial({-G[1, 1],2*A[1, 1],Q[1, 1]}));
            X := matrix(-abs(xc[1].re));
            r := 0;
          else
            X := fill(0, 0, 0);
            r := 0;
          end if;

          annotation (Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
        end carenls;

        function darenls
          "Newton's method with exact line search for solving continuous algebraic riccati equation"
          extends Modelica.Icons.Function;

          import Modelica_LinearSystems2.Math.Matrices;
          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica_LinearSystems2.Math.Complex;

          input Real A[:,size(A, 1)];
          input Real B[size(A, 1),:];
          input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2));
          input Real Q[size(A, 1),size(A, 2)]=identity(size(A, 1));
          input Real X0[size(A, 1),size(A, 2)];
          input Real eps=Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm(
                                                A)*1e-9;

          output Real X[size(X0, 1),size(X0, 2)];
          output Real r;

      protected
          Integer n=size(A, 1);
          Real Xk[size(X, 1),size(X, 2)];
          Real Ak[size(A, 1),size(A, 2)];
          Real Rk[size(A, 1),size(A, 2)];
          Real Nk[size(A, 1),size(A, 2)];
          Real Hk[size(B, 2),size(B, 1)];
          Real Sk[size(B, 1),size(B, 1)];
          Real Vk[size(A, 1),size(A, 2)];
          Real tk;
          Integer k;
          Real AT[size(A, 2),size(A, 2)]=transpose(A);
          Real BT[size(B, 2),size(B, 1)]=transpose(B);

          Boolean stop;

        algorithm
          if n > 0 then
            k := 0;
            stop := false;
            Xk := X0;
            while (not stop and k<10) loop
              k := k + 1;
              Hk := Modelica.Math.Matrices.solve2(R+BT*Xk*B,BT);
              Ak := A-B*Hk*Xk*A;

              Rk:=AT*Xk*A - Xk + Q - AT*Xk*B*Hk*Xk*A;

              Nk := Matrices.dlyapunov(Ak, -Rk);
        //  Modelica_LinearSystems2.Math.Matrices.printMatrix(Nk,6,"Nk");

              Sk := B*Hk;
              Vk :=transpose(Ak)*Nk*Sk*Nk*Ak;
        //   Modelica_LinearSystems2.Math.Matrices.printMatrix(Vk,6,"Vk");
              tk := Matrices.Internal.findLocal_tk(Rk, Vk);
              stop := eps > Matrices.Internal.frobeniusNorm(tk*Nk)/Matrices.Internal.frobeniusNorm(Xk);
              Xk := Xk + tk*Nk;

            end while;
            X := Xk;
            r := Matrices.Internal.frobeniusNorm(AT*X*A - X +Q - AT*X*B*Modelica.Math.Matrices.solve2(R+BT*X*B,BT)*X*A);
          else
            X := fill(0, 0, 0);
            r := 0;
          end if;

          annotation (Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
        end darenls;

        function dhseqr_workdim
          "Calculate the optimal size of the WORK array in dhseqr"
          import Modelica_LinearSystems2.Math.Matrices.LAPACK;

          input Real H[:,:];

          output Integer lwork;
          output Integer info;

      protected
          Real work[:];

        algorithm
          if min(size(H, 1), size(H, 2)) > 0 then
            (,,info,,,work) := LAPACK.dhseqr(H, -1);
            lwork := integer(work[1]);
          else
            lwork := 1;
          end if;

        end dhseqr_workdim;

        function eigenvaluesHessenberg
          "Compute eigenvalues of an upper Hessenberg form matrix"
          import Modelica_LinearSystems2.Math.Matrices.Internal;
          import Modelica_LinearSystems2.Math.Matrices.LAPACK;
          input Real H[:,size(H, 1)];

          output Real alphaReal[size(H, 1)]
            "Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Real alphaImag[size(H, 1)]
            "Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))";
          output Integer info=0;
      protected
          Integer n=size(H, 1);
          Integer ilo=1;
          Integer ihi=n;
          Integer lwork=Internal.dhseqr_workdim(H);
          Real work[lwork];
          Real Z[n,n]=fill(
                0,
                n,
                n);

        algorithm
          if size(H, 1) > 0 then
            (alphaReal,alphaImag,info) := LAPACK.dhseqr(H, lwork);
          else
            alphaReal := fill(0, size(H, 1));
            alphaImag := fill(0, size(H, 1));
          end if;

          annotation (Documentation(info="<html>
This function uses DHSEQR Lapack-routine to calculate the eigenvalues of an upper Hessenberg form <b>H</b>.
Therefore, <b>H</b> is reduced to Schur form <b>T</b>. The eigenvalues are obtained from the diagonal of <b>T</b>.

<p>
See Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr for details
</p>
</html>"));
        end eigenvaluesHessenberg;

        function findLocal_tk
          "Find a local minimizer tk to define the length of the step tk*Nk in carenls or darenls"
          extends Modelica.Icons.Function;

          import Modelica_LinearSystems2.Math.Polynomial;
          import Modelica_LinearSystems2.Math.Complex;

          input Real Rk[:,size(Rk, 2)];
          input Real Vk[size(Rk, 1),size(Rk, 2)];
        //   input Real G[size(Rk, 1),size(Rk, 2)];
        //   input Real Nk[size(Rk, 1),size(Rk, 2)];

          output Real tk;

        //  Real Vk[size(Rk, 1),size(Rk, 2)];
      protected
          Real alpha_k;
          Real beta_k;
          Real gamma_k;
          Complex p[3];
          Boolean h;

        algorithm
        //  Vk := Nk*G*Nk;
          alpha_k := Modelica.Math.Matrices.trace(Rk*Rk);
          beta_k := Modelica.Math.Matrices.trace(Rk*Vk);
          gamma_k := Modelica.Math.Matrices.trace(Vk*Vk);

          if gamma_k > Modelica.Constants.eps then
            p := Polynomial.roots(Polynomial({4*gamma_k,6*beta_k,2*(alpha_k - 2*beta_k),
              -2*alpha_k}));
            h := false;
            for i1 in 1:3 loop
              if (abs(Complex.imag(p[i1])) < Modelica.Constants.eps) then
                if (abs(Complex.real(p[i1]) - 1) <= 1) then
                  tk := Complex.real(p[i1]);
                  h := true;
                end if;
              end if;
            end for;
            if not h then
              tk := 1;
            end if;

          else
            tk := 1;
          end if;

          annotation (Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
        end findLocal_tk;

        function hohoTrafoLowerHess
          "Compute the similarity transformation S*A*S of matrix A with householder matrix S = I - 2u*u' to compute a lower Hessenberg form"

          import Modelica.Math.Vectors.length;

          input Real A[:,size(A, 1)];
          input Real u[size(A, 1)] "householder vector";
          input Integer r;
          output Real SAS[size(A, 1),size(A, 1)];

      protected
          Integer na=size(A, 1);
          Real S[:,:]=-2*matrix(u)*transpose(matrix(u))/(length(u)*length(u)); //S=u*u'/u'*u
          Integer i;

          Real P[na - r,na - r];
          Real A11[na - r,na - r]=A[1:na - r, 1:na - r];
          Real A21[r,na - r]=A[na - r + 1:na, 1:na - r];
          Real A22[r,r]=A[na - r + 1:na, na - r + 1:na];
          Real alpha;

        algorithm
          for i in 1:na loop
            S[i, i] := 1.0 + S[i, i];   //S=I-2u*u'
          end for;

          P := S[1:na - r, 1:na - r];
          alpha := P[na - r, :]*A[1:na - r, na - r + 1];

          SAS := [P*A11*P,[zeros(na - r - 1, r); matrix(alpha),zeros(1, r - 1)]; A21*P,
            A22];

          annotation (Documentation(info="<html>
This function calculates one step in the calculation of lower Hessenberg form. Therein it calculates the (n-r+1)'th column of the Hessenberg matrix which is of shape {fill(1,n-r-1),x,x}.
</html>"));
        end hohoTrafoLowerHess;

        function multiplyWithOrthogonalQ_qr
          "Overwrites the general real M-by-N matrix C with Q * C or C * Q or Q' * C or C * Q', where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf"

          input Real C[:,:];
          input Real Q[:,:];
          input Real tau[:];
          input String side="L";
          input String trans="N";

          output Real Cout[size(C, 1),size(C, 2)]=C
            "contains Q*C or Q**T*C or C*Q**T or C*Q";
          output Integer info;
      protected
          Integer m=size(C, 1);
          Integer n=size(C, 2);
          Integer k=size(tau, 1);
          Integer lda=if side == "L" then max(1, m) else max(1, n);
          Integer ldc=max(1, m);
          Integer lwork=if side == "L" then 3*max(1, n) else 3*max(1, m);
          Real work[lwork];

        external "Fortran 77" dormqr(
              side,
              trans,
              m,
              n,
              k,
              Q,
              lda,
              tau,
              Cout,
              ldc,
              work,
              lwork,
              info)
                  annotation(Library = {"lapack"});

          annotation (Documentation(info="   Purpose
   =======

   DORMQR overwrites the general real M-by-N matrix C with

                   SIDE = 'L'     SIDE = 'R'
   TRANS = 'N':      Q * C          C * Q
   TRANS = 'T':      Q**T * C       C * Q**T

   where Q is a real orthogonal matrix defined as the product of k
   elementary reflectors

         Q = H(1) H(2) . . . H(k)

   as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
   if SIDE = 'R'.

   Arguments
   =========

   SIDE    (input) CHARACTER*1
           = 'L': apply Q or Q**T from the Left;
           = 'R': apply Q or Q**T from the Right.

   TRANS   (input) CHARACTER*1
           = 'N':  No transpose, apply Q;
           = 'T':  Transpose, apply Q**T.

   M       (input) INTEGER
           The number of rows of the matrix C. M >= 0.

   N       (input) INTEGER
           The number of columns of the matrix C. N >= 0.

   K       (input) INTEGER
           The number of elementary reflectors whose product defines
           the matrix Q.
           If SIDE = 'L', M >= K >= 0;
           if SIDE = 'R', N >= K >= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,K)
           The i-th column must contain the vector which defines the
           elementary reflector H(i), for i = 1,2,...,k, as returned by
           DGEQRF in the first k columns of its array argument A.
           A is modified by the routine but restored on exit.

   LDA     (input) INTEGER
           The leading dimension of the array A.
           If SIDE = 'L', LDA >= max(1,M);
           if SIDE = 'R', LDA >= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (K)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEQRF.

   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
           On entry, the M-by-N matrix C.
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

   LDC     (input) INTEGER
           The leading dimension of the array C. LDC >= max(1,M).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.
           If SIDE = 'L', LWORK >= max(1,N);
           if SIDE = 'R', LWORK >= max(1,M).
           For optimum performance LWORK >= N*NB if SIDE = 'L', and
           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
           blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           < 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================  "));
        end multiplyWithOrthogonalQ_qr;

        function reorderRSF
          "Reorders a real Schur factorization according to a given pattern of the eigenvalues"

          import Modelica_LinearSystems2.Math.Matrices.LAPACK;

          input Boolean iscontinuous;
          input Real T[:,:];
          input Real Q[:,size(T, 2)];
          input Real alphaReal[size(T, 1)]
            "Real part of eigenvalue=alphaReal+i*alphaImag";
          input Real alphaImag[size(T, 1)]
            "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";

          output Real To[size(T, 1),size(T, 2)];
          output Real Qo[size(T, 1),size(T, 2)];
          output Real wr[size(T, 2)];
          output Real wi[size(T, 2)];

      protected
          Integer n=size(T, 2);
          Boolean select[size(T, 2)]=fill(false, size(T, 2));
          Integer i;
        algorithm
          if iscontinuous then
            for i in 1:n loop
              if alphaReal[i] < 0 then
                select[i] := true;
              end if;
            end for;
          else
            for i in 1:n loop
              if alphaReal[i]^2 + alphaImag[i]^2 < 1 then
                select[i] := true;
              end if;
            end for;
          end if;

          (To,Qo,wr,wi) := LAPACK.dtrsen(
              "E",
              "V",
              select,
              T,
              Q);

        end reorderRSF;

        function reorderRSFc
          "Reorders a real Schur factorization for poleAssignmentMI design for continuous systems"

          import Modelica_LinearSystems2.Math.Matrices.LAPACK;

          input Real T[:,:] "upper quasi-triangular matrix in Schur canonical form";
          input Real Q[:,size(T, 2)] "matrix of Schur vectors";
          input Real alphaReal[size(T, 1)]
            "Real part of eigenvalue=alphaReal+i*alphaImag";
          input Real alphaImag[size(T, 1)]
            "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";
          input Real alpha
            "maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm";

          output Real To[size(T, 1),size(T, 2)];
          output Real Qo[size(T, 1),size(T, 2)];
          output Real wr[size(T, 2)];
          output Real wi[size(T, 2)];

      protected
          Integer n=size(T, 2);
          Boolean select[n]=fill(false, n);
          Integer i;
        algorithm
          for i in 1:n loop
            if alphaReal[i] < alpha then
              select[i] := true;
            end if;
          end for;

          (To,Qo,wr,wi) := LAPACK.dtrsen(
              "E",
              "V",
              select,
              T,
              Q);

        end reorderRSFc;

        function reorderRSFd
          "Reorders a real Schur factorization for poleAssignmentMI design for discrete systems"

          import Modelica_LinearSystems2.Math.Matrices.LAPACK;

          input Real T[:,:] "upper quasi-triangular matrix in Schur canonical form";
          input Real Q[:,size(T, 2)] "matrix of Schur vectors";
          input Real alphaReal[size(T, 1)]
            "Real part of eigenvalue=alphaReal+i*alphaImag";
          input Real alphaImag[size(T, 1)]
            "Imaginary part of eigenvalue=(alphaReal+i*alphaImag";
          input Real alpha
            "maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm";

          output Real To[size(T, 1),size(T, 2)];
          output Real Qo[size(T, 1),size(T, 2)];
          output Real wr[size(T, 2)];
          output Real wi[size(T, 2)];

      protected
          Integer n=size(T, 2);
          Boolean select[n]=fill(false, n);
          Integer i;
        algorithm
          for i in 1:n loop
            if alphaReal[i]^2+alphaImag[i]^2 < alpha^2 then
              select[i] := true;
            end if;
          end for;

          (To,Qo,wr,wi) := LAPACK.dtrsen(
              "E",
              "V",
              select,
              T,
              Q);

        end reorderRSFd;

        function frobeniusNorm "Return the Frobenius norm of a matrix"
          extends Modelica.Icons.Function;
          input Real A[:,:] "Input matrix";
          output Real result=if min(size(A))>0 then sqrt(sum(A.*A)) else -1e100
            "frobenius norm of matrix A";

        algorithm
          annotation (Documentation(revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
        end frobeniusNorm;
        annotation (Documentation(info="<html>
<p>
Generally, the functions in this package should not be used by the user.
</p>
<p>
This package contains functions which cannot be used in an arbitrary
way and require particular knowledge.
Therefore, only advanced users should deal with contained classes.
</p>
</html>"));
      end Internal;
      annotation (
        Documentation(info="<html>
<p>
This package provides functions operating on matrices, see also
<a href=\"Modelica://Modelica.Math.Matrices\">Matrices</a>.
</p>
</html>"));
    end Matrices;

    package Vectors "Package of functions operating on vectors"
      extends Modelica.Icons.Package;

      function householderReflexion
        "Reflect vector a on a plane with orthogonal vector u"
        import Modelica_LinearSystems2.Math.Vectors;

        input Real a[:];
        input Real u[size(a, 1)] "Householder vector";
        output Real ra[size(u, 1)] "Reflexion of a";

    protected
        Real norm_a=Modelica.Math.Vectors.length(a);
        Real h=2*u*a;

      algorithm
        ra := a - h*u;

      // this function is mainly used in the fromStateSpace transformations.
      // In this context the calculation of invariant zeros is very susceptible with subject to
      // elements of the output vector are zero or not. Therefore, values close to zero are set to zero.
        for i in 1:size(ra, 1) loop
          ra[i] := if abs(ra[i]) >= norm_a*1e-12 then ra[i] else 0;
        end for;

        annotation (Documentation(info="<html>
</html>"));
      end householderReflexion;

      function householderReflexion_e1
        "Reflect vector a to the unity vector e_1={1,0,...,0}"
        import Modelica_LinearSystems2.Math.Vectors;

        input Real a[:];
        input Real u[size(a, 1)] "householder vector";
        output Real ra[size(u, 1)] "reflexion of a";

    protected
        Integer n=size(u, 1);

      algorithm
        ra := cat(
          1,
          {a[1] - 2*u[1]*(u*a)},
          fill(0, n - 1));

      end householderReflexion_e1;

      function householderReflexion_en
        "Reflect vector a to the unity vector e_n={0, ..., 0, 1}"
        import Modelica_LinearSystems2.Math.Vectors;

        input Real a[:];
        input Real u[size(a, 1)] "householder vector";
        output Real ra[size(u, 1)] "reflexion of a";

    protected
        Integer n=size(u, 1);

      algorithm
        ra := cat(
          1,
          fill(0, n - 1),
          {a[n] - 2*u[n]*(u*a)});

      end householderReflexion_en;

      function householderVector
        "Calculate a normalized householder vector to reflect vector a onto vector b"

        import Modelica.Math.Vectors.norm;
        import Modelica.Math.Vectors.length;

        input Real a[:] "Real vector to be reflected";
        input Real b[size(a, 1)] "Real vector b vector a is mapped onto";
        output Real u[size(a, 1)] "Housholder vector to map a onto b";
    protected
        Real norm_a=norm(a,2);
        Real norm_b=norm(b,2);
        Real alpha;

      algorithm
        assert(norm_b > 0, "Vector b in function housholderVector is zero vector, but at least one element should be different from zero");
        assert(norm_a > 0, "Vector a in function housholderVector is zero vector, but at least one element should be different from zero");
        alpha := if norm(a + norm_a/norm_b*b,2) > norm(a - norm_a/norm_b*b,2) then norm_a/norm_b else -norm_a/norm_b;
        u := (a + alpha*b)/length(a + alpha*b);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>householderVector</b>(a,b);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call \"<code>householderVector(a, b)</code>\" returns the normalized Householder vector
<b>u</b> for Householder reflection of input vector <b>a</b> onto vector <b>b</b>, i.e. Householder vector <b>u</b> is the normal
vector of the reflection plane. Algebraically, the reflection is performed by transformation matrix <b>Q</b>
</p>
<blockquote>
  <b>Q</b> = <b>I</b> - 2*<b>u</b>*<b>u</b>',
</blockquote>
<p>
i.e., vector <b>a</b> is mapped to
</p>
<blockquote>
  <b>a</b> -> <b>Q</b>*<b>a</b>=c*<b>b</b>
</blockquote>
<p>
with scalar c, |c| = ||<b>a</b>|| / ||<b>b</b>||. <b>Q</b>*<b>a</b> is the reflection of <b>a</b> about the hyperplane orthogonal to <b>u</b>.
<b>Q</b> is an orthogonal matrix, i.e.
</p>
<blockquote>
<b>Q</b> = inv(<b>Q</b>) = <b>Q</b>'.
</blockquote>

<h4>Example</h4>
<blockquote><pre>
  a = {2, -4, -2, -1};
  b = {1, 0, 0, 0};

  u = <b>householderVector</b>(a,b);
    // {0.837, -0.478, -0.239, -0.119}
    // Computation (identity(4) - 2*matrix(u)*transpose(matrix(u)))*a results in
    // {-5, 0, 0, 0} = -5*b
</pre></blockquote>
</html>"));
      end householderVector;

      function printStringVectorInHtml
        "Print a string vector in html format on file (without html/body heading)"
        import Modelica.Utilities.Strings;
        import Modelica.Utilities.Streams.print;

        input String s[:] "String vector";
        input String name="" "Vector name used for printing";
        input String fileName="log.html";
        input Boolean printIndices=true
          "=true, if row indices shall be printed, otherwise they are not printed";
    protected
        Integer r=size(s, 1);
        Boolean siExist=false;
      algorithm
        // Check whether all entries are an empty string
        for i in 1:r loop
           siExist := siExist or (s[i] <> "");
        end for;

        if not siExist then
           if name == "" then
              print("<p>&nbsp;&nbsp;&nbsp;[&nbsp;], empty vector</p>\n", fileName);
           else
              print("<p>&nbsp;&nbsp;&nbsp;" + name + "&nbsp;=&nbsp;[&nbsp;], empty vector</p>\n", fileName);
           end if;
        else
           // Print "name = "
           if name <> "" then
              print("<table border=\"0\">\n<tr>\n  <td valign=\"middle\">" +
                    "&nbsp;&nbsp;&nbsp;" + name + "</td>\n  <td valign=\"middle\">=</td>\n  <td>", fileName);
           end if;

           // Print table heading
           print("    <table style=\"background-color:rgb(100, 100, 100);\" cellpadding=\"3\" border=\"0\" cellspacing=\"1\">",
                 fileName);

           // Print vector elements
           for i in 1:r loop
              print("    <tr style=\"background-color:white\">", fileName);
              if printIndices then
                 print("      <td align=\"right\" style=\"background-color:rgb(230, 230, 230);\">" + String(i) + "</td>", fileName);
              end if;
              print("      <td align=\"left\">" + s[i] + "</td>\n    </tr>", fileName);
           end for;

           // Print row closing tags
           print("    </table>", fileName);
           if name <> "" then
              print("  </td>\n</tr>\n</table>", fileName);
           end if;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>printStringVectorInHtml</b>(s, name, fileName, printIndices);
</pre></blockquote>

<h4>Description</h4>
<p>
Print vector of strings <code>s</code> called <code>name</code> into
a file <code>fileName</code> in HTML format.
Optionally, row indices are printed as well.
</p>

<h4>Example</h4>
<blockquote><pre>
s = {\"w\", \"3\", \"alpha\"};
<b>printStringVectorInHtml</b>(s, \"myVec\", \"log.html\", true);
</pre></blockquote>
<p>
saves following HTML code in the file <em>log.html</em>:
</p>
<blockquote><pre>
&lt;table border=\"0\"&gt;
&lt;tr&gt;
  &lt;td valign=\"middle\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;myVec&lt;/td&gt;
  &lt;td valign=\"middle\"&gt;=&lt;/td&gt;
  &lt;td&gt;
    &lt;table style=\"background-color:rgb(100, 100, 100);\" cellpadding=\"3\" border=\"0\" cellspacing=\"1\"&gt;
    &lt;tr style=\"background-color:white\"&gt;
      &lt;td align=\"right\" style=\"background-color:rgb(230, 230, 230);\"&gt;1&lt;/td&gt;
      &lt;td align=\"left\"&gt;w&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr style=\"background-color:white\"&gt;
      &lt;td align=\"right\" style=\"background-color:rgb(230, 230, 230);\"&gt;2&lt;/td&gt;
      &lt;td align=\"left\"&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr style=\"background-color:white\"&gt;
      &lt;td align=\"right\" style=\"background-color:rgb(230, 230, 230);\"&gt;3&lt;/td&gt;
      &lt;td align=\"left\"&gt;alpha&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</pre></blockquote>
</html>",       revisions="<html>
</html>"));
      end printStringVectorInHtml;
      annotation (
        Documentation(info="<html>
<p>
This package provides functions operating on vectors, see also
<a href=\"Modelica://Modelica.Math.Vectors\">Vectors</a>.
</p>
</html>"));
    end Vectors;
    annotation (
      Documentation(info="<html>
<p>
This package contains functions operating on
<a href=\"modelica://Modelica_LinearSystems2.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica_LinearSystems2.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica_LinearSystems2.Math.Complex\">complex</a>, and
<a href=\"modelica://Modelica_LinearSystems2.Math.Polynomial\">polynomial</a>.
</p>
</html>"));
  end Math;

  package Utilities "Package of utility elements used in the library"
    extends Modelica.Icons.Package;

    package Plot "Package of functions for generation of 2D-plots"
      extends Modelica.Icons.Package;

      function diagram "Plot one diagram"
        import Modelica_LinearSystems2.Utilities.Plot.Types;
        import Modelica_LinearSystems2.Utilities.Plot.Internal;

        input Modelica_LinearSystems2.Utilities.Plot.Records.Diagram diagram
          "Diagram to be shown" annotation(Dialog);
        input Modelica_LinearSystems2.Utilities.Plot.Records.Device device=
          Modelica_LinearSystems2.Utilities.Plot.Records.Device()
          "Properties of device where figure is shown" annotation(Dialog);
    protected
        Real mmToPixel= device.windowResolution/25.4;
        Real position[4];
        Integer style;
        Integer nCurves=size(diagram.curve,1);
        Boolean OK;
        Integer id;
      algorithm
        position := {device.xTopLeft,
                     device.yTopLeft,
                     device.diagramWidth,
                     diagram.heightRatio*device.diagramWidth}*mmToPixel;

        id:= createPlot(id=-1,
                        position=integer(position),
                        erase=true,
                        autoscale=true,
                        autoerase=false,
                        subPlot=1,
                        heading=diagram.heading,
                        grid=diagram.grid,
                        logX=diagram.logX,
                        logY=diagram.logY,
                        bottomTitle=diagram.xLabel,
                        leftTitle=diagram.yLabel,
                        color=device.autoLineColor,
                        legend=diagram.legend,
                        legendHorizontal=diagram.legendHorizontal,
                        legendFrame=diagram.legendFrame,
                        legendLocation=Integer(diagram.legendLocation));

        for i in 1:nCurves loop
          /*
    if diagram.curve[i].autoLine or
       diagram.curve[i].lineSymbol==Types.PointSymbol.None then
       style :=0;
    elseif diagram.curve[i].linePattern==Types.LinePattern.None then
       style :=-(diagram.curve[i].lineSymbol - 1);
    else
       style :=diagram.curve[i].lineSymbol - 1;
    end if;

    OK :=plotArray(diagram.curve[i].x,
                   diagram.curve[i].y,
                   legend=diagram.curve[i].legend,
                   style=style,
                   id=id);
    */

          if diagram.curve[i].autoLine then
            OK :=plotArray(diagram.curve[i].x,
                           diagram.curve[i].y,
                           legend=diagram.curve[i].legend,
                           id=id,
                           erase=false);
          else
            OK := plotArray(
              diagram.curve[i].x,
              diagram.curve[i].y,
              legend=diagram.curve[i].legend,
              color=diagram.curve[i].lineColor,
              pattern=Internal.convertToDymolaPattern(diagram.curve[i].linePattern),
              marker=Internal.convertToDymolaMarker(diagram.curve[i].lineSymbol),
              thickness=diagram.curve[i].lineThickness,
              id=id,
              erase=false);
          end if;
        end for;

        annotation (__Dymola_interactive = true, Documentation(info="<html>
<p>
This function plots a set of 2-dimensional curves in a diagram.
For an overview, see the documentation of package
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot\">Modelica_LinearSystems2.Utilities.Plot</a>.
</p>

<p>
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Examples.plotTwoSineDifferentStyles\">Example</a>:
</p>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/plotTwoSineDifferentStyles.png\">
</blockquote>
</html>"));
      end diagram;

      function diagramVector "Plot several diagrams in vector layout"
        input Modelica_LinearSystems2.Utilities.Plot.Records.Diagram diagram[:]
          "Properties of a set of diagrams (vector layout)"
          annotation(Dialog);
        input Modelica_LinearSystems2.Utilities.Plot.Records.Device device=
          Modelica_LinearSystems2.Utilities.Plot.Records.Device()
          "Properties of device where figure is shown" annotation(Dialog);

        import Modelica_LinearSystems2.Utilities.Plot.Internal;
    protected
        Real mmToPixel= device.windowResolution/25.4;
        Integer position[4];
        Integer style;
        Integer nDiagrams=size(diagram,1);
        Integer figureHeight;
        Integer height[nDiagrams];
        Boolean OK;
        Integer id;

        function round "Round to nearest Integer"
           input Real r;
           output Integer i;
        algorithm
           i :=if r > 0 then integer(floor(r + 0.5)) else integer(ceil(r - 0.5));
        end round;
      algorithm
        id := -1;

        // Determine total size of window
        figureHeight := 0;
        for i in 1:nDiagrams loop
          height[i]    := round(diagram[i].heightRatio*device.diagramWidth*mmToPixel);
          figureHeight := figureHeight + height[i];
        end for;

        position := {round(device.xTopLeft*mmToPixel),
                     round(device.yTopLeft*mmToPixel),
                     round(device.diagramWidth*mmToPixel),
                     figureHeight};

        // Determine position and size of sub-figures
        for i in 1:nDiagrams loop
          if i > 1 then
            position[4] := height[i];
          end if;

          id:= createPlot(id=id,
                          position=position,
                          erase=true,
                          autoscale=true,
                          autoerase=false,
                          subPlot=i,
                          heading=diagram[i].heading,
                          grid=diagram[i].grid,
                          logX=diagram[i].logX,
                          logY=diagram[i].logY,
                          bottomTitle=diagram[i].xLabel,
                          leftTitle=diagram[i].yLabel,
                          color=device.autoLineColor,
                          legend=diagram[i].legend,
                          legendHorizontal=diagram[i].legendHorizontal,
                          legendFrame=diagram[i].legendFrame,
                          legendLocation=Integer(diagram[i].legendLocation));

          for j in 1:size(diagram[i].curve,1) loop
            if diagram[i].curve[j].autoLine then
              OK :=plotArray(diagram[i].curve[j].x,
                             diagram[i].curve[j].y,
                             legend=diagram[i].curve[j].legend,
                             id=id,
                             erase=false);
            else
              OK :=plotArray(diagram[i].curve[j].x,
                             diagram[i].curve[j].y,
                             legend=diagram[i].curve[j].legend,
                             color=diagram[i].curve[j].lineColor,
                             pattern=Internal.convertToDymolaPattern(diagram[i].curve[j].linePattern),
                             marker=Internal.convertToDymolaMarker(diagram[i].curve[j].lineSymbol),
                             thickness=diagram[i].curve[j].lineThickness,
                             id=id,
                             erase=false);
            end if;
          end for;
        end for;

        annotation (__Dymola_interactive=true, Documentation(info="<html>
<p>
This function plots a set of 2-dimensional curves in a set of diagrams
using a vector layout. For an overview, see the documentation of package
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot\">Modelica_LinearSystems2.Utilities.Plot</a>.
</p>


<p>
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Examples.showSinesInVectorDiagrams\">Example</a>:
</p>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/showSinesInVectorDiagram.png\">
</blockquote>
</html>"));
      end diagramVector;

      package Types
      "Package of type definitions used for the plotting functions"
        extends Modelica.Icons.Package;

        type DrawingUnit_mm "Drawing unit specifing the nominal size in [mm]"
           extends Modelica.Icons.TypeReal(final quantity="Length", final unit="mm");
          annotation (Documentation(info="<html>
<p>
All size information for plotting, such as width or height
of a window or the thickness of a line, are defined by type <b>DrawingUnit_mm</b>. The
recommended interpretation is that the DrawingUnit is the unscaled size in a document or
on printer in [mm]. For example, if the width of a diagram is 120,
and the diagram is pasted into a Word or PowerPoint document,
then the width of the diagram in the document is 120 mm.
</p>
</html>"));
        end DrawingUnit_mm;

        type ImageResolution_dpi
          "Resolution of image in pixel per inch (screen) or dots per inch (printer)"
           extends Modelica.Icons.TypeReal(final quantity="ImageResolution");

          annotation (Documentation(info="<html>
<p>\"ImageResolution_dpi\" defines the mapping of a length coordinate to the resolution of the output device. The resolution [dpi] is defined as \"dots-per-inch\" and therefore a length L_mm defined in [mm] is mapped to a length L_dot in dots (or pixel) with the formula: </p>

<pre>   L_dot = round(ImageResolution_dpi/25.4 * L_mm)
</pre>

<p>where function round(..) rounds to the nearest integer. Typical values are \"96 dpi\" (for screen) or \"600 dpi\" for printer. For example if an \"ImageResolution = 96 dpi\" shall be used for a screen, then 1 mm is mapped to 4 pixel. </p>
</html>"));
        end ImageResolution_dpi;

        type LinePattern = enumeration(
          None,
          Solid,
          Dash,
          Dot,
          DashDot,
          DashDotDot)   "Choices for line pattern" annotation (Documentation(info="<html>
<p>
Enumeration to define the line pattern, that is the line style how the
defined points are connected together by a polyline. Possible values:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.LinePattern.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">None</td>
    <td valign=\"top\">Points are not connected</td></tr>

<tr><td valign=\"top\">Solid</td>
    <td valign=\"top\">Points are connected with a solid line</td></tr>

<tr><td valign=\"top\">Dash</td>
    <td valign=\"top\">Points are connected with a dash line</td></tr>

<tr><td valign=\"top\">Dot</td>
    <td valign=\"top\">Points are connected with a dotted line</td></tr>

<tr><td valign=\"top\">DashDot</td>
    <td valign=\"top\">Points are connected with a dash-dotted line</td></tr>

<tr><td valign=\"top\">DashDotDot</td>
    <td valign=\"top\">Points are connected with a dash-dotted-dotted line</td></tr>
</table>

<p>
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Examples.showLinePatterns\">Example</a>:
</p>

<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/showLinePatterns.png\"></p>
</html>"));

        type PointSymbol = enumeration(
          None   "no symbol",
          Cross   "x",
          Circle   "o",
          Square,
          FilledSquare,
          TriangleDown,
          TriangleUp,
          Diamond,
          Dot)   "Choices for point symbol" annotation (Documentation(info="<html>
<p>
Enumeration to define the style of the symbol to mark a point in a diagram. Possible values:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.PointSymbol.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">None</td>
    <td valign=\"top\">No symbol (point is not explicitly marked)</td></tr>

<tr><td valign=\"top\">Cross</td>
    <td valign=\"top\">x</td></tr>

<tr><td valign=\"top\">Circle</td>
    <td valign=\"top\">o</td></tr>

<tr><td valign=\"top\">Square</td>
    <td valign=\"top\">Non-filled square</td></tr>

<tr><td valign=\"top\">FilledSquare</td>
    <td valign=\"top\">Filled square</td></tr>

<tr><td valign=\"top\">TriangleDown</td>
    <td valign=\"top\">Filled triangle pointing downwards</td></tr>

<tr><td valign=\"top\">TriangleUp</td>
    <td valign=\"top\">Filled triangle pointing upwards</td></tr>

<tr><td valign=\"top\">Diamond</td>
    <td valign=\"top\">Filled diamond</td></tr>

<tr><td valign=\"top\">Dot</td>
    <td valign=\"top\">.</td></tr>
</table>


<p>
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Examples.showPointSymbols\">Example</a>:
</p>

<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/showPointSymbols.png\"></p>
</html>"));

        type LegendLocation = enumeration(
          Above   "Above diagram",
          Right   "Right of diagram",
          Below   "Below of diagram",
          TopLeft   "Top left corner of diagram",
          TopRight   "Top right corner of diagram",
          BottomLeft   "Bottom left corner of diagram",
          BottomRight   "Bottom right corner of diagram") "Choices for legend location"
          annotation (Documentation(info="<html>
<p>
Enumeration to define the legend location. Possible values:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Types.LegendLocation.</b></th><th><b>Meaning</b></th></tr>
<tr><td valign=\"top\">Above</td>
    <td valign=\"top\">Above diagram</td></tr>

<tr><td valign=\"top\">Right</td>
    <td valign=\"top\">Right of diagram</td></tr>

<tr><td valign=\"top\">Below</td>
    <td valign=\"top\">Below of diagram</td></tr>

<tr><td valign=\"top\">TopLeft</td>
    <td valign=\"top\">Top left corner of diagram</td></tr>

<tr><td valign=\"top\">TopRight</td>
    <td valign=\"top\">Top right corner of diagram</td></tr>

<tr><td valign=\"top\">BottomLeft</td>
    <td valign=\"top\">Bottom left corner of diagram</td></tr>

<tr><td valign=\"top\">BottomRight</td>
    <td valign=\"top\">Bottom right corner of diagram</td></tr>
</table>

<p>
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Examples.showLegendStyles\">Example</a>:
</p>

<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/showLegendStyles.png\"></p>
</html>"));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This package contains type definitions. Generally,
the enumeration type is used to assign a unique choice of parameter
within a model.
</p>
</html>"));
      end Types;

      package Records "Package of library records"
        extends Modelica.Icons.Package;

        record Diagram
          "Properties of a diagram in a figure containing one or more curves"
          extends Modelica.Icons.Record;

          Modelica_LinearSystems2.Utilities.Plot.Records.Curve curve[:]
            "Properties of the curves in one diagram of the figure" annotation(Dialog);

          String heading="" "Heading displayed above diagram" annotation(Dialog);
          Real heightRatio = 0.45 "Height of diagram = heightRatio*diagramWidth" annotation(Dialog);
          Boolean grid=true "True, if grid is shown" annotation ( choices(checkBox=true));

          /* group "Axes" (Axes properties) */
          String xLabel=" " "String displayed at horizontal axis" annotation(Dialog(group="Axes"));
          String yLabel=" " "String displayed at vertical axis" annotation(Dialog(group="Axes"));
          Boolean logX = false "True, if logarithmic scale of x-axis" annotation(Dialog(group="Axes"),choices(checkBox=true));
          Boolean logY = false "True, if logarithmic scale of y-axis" annotation(Dialog(group="Axes"),choices(checkBox=true));
          Boolean uniformScaling = false
            "True, if same vertical and horizontal axis increment"
            annotation(Dialog(group="Axes"),choices(checkBox=true));

          /* group "Legend" (Legend properties) */
          Boolean legend = true "True, if legend is shown" annotation(Dialog(group="Legend"),choices(checkBox=true));
          Boolean legendFrame=false "True, if frame around legend"
            annotation(Dialog(group="Legend"),   choices(checkBox=true));
          Boolean legendHorizontal=true
            "True, if horizontal legend (provided it is meaningful)"
            annotation(Dialog(group="Legend"),choices(checkBox=true));
          Modelica_LinearSystems2.Utilities.Plot.Types.LegendLocation legendLocation=
            Modelica_LinearSystems2.Utilities.Plot.Types.LegendLocation.Above
            "Legend placement" annotation(Dialog(group="Legend"));

          annotation (Documentation(info="<html>
<p>
With this record the properties of a diagram are defined (like heading and legend),
as well as the properties of one or several curves in this diagram using record
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Curve\">Modelica_LinearSystems2.Utilities.Plot.Records.Curve</a>
</p>
</html>"));
        end Diagram;

        record Curve "Properties of a curve (displayed in a diagram)"
          extends Modelica.Icons.Record;

          Real x[:] "Values x of curve" annotation(Dialog);
          Real y[:] "Values y of curve" annotation(Dialog);
          String legend="" "Legend text of curve" annotation(Dialog);

          Boolean autoLine = true "True, if automatic line properties of curve"
            annotation ( choices(checkBox=true));

          Integer lineColor[3]={0,0,255} "Color of curve as rgb values"
            annotation(Dialog(enable=not autoLine,group="If autoLine = false (otherwise ignored)",colorSelector=true));

          Modelica_LinearSystems2.Utilities.Plot.Types.LinePattern linePattern=
            Modelica_LinearSystems2.Utilities.Plot.Types.LinePattern.Solid
            "Line pattern of curve" annotation(Dialog(enable=not autoLine,group="If autoLine = false (otherwise ignored)"));
          Modelica_LinearSystems2.Utilities.Plot.Types.PointSymbol lineSymbol=
            Modelica_LinearSystems2.Utilities.Plot.Types.PointSymbol.None
            "Symbol for points on curve" annotation(Dialog(enable=not autoLine,group="If autoLine = false (otherwise ignored)"));
          Real lineThickness=0.25 "Line thickness of curve"
            annotation(Dialog(group="If autoLine = false (otherwise ignored)"));

        /*
  Modelica_LinearSystems2.Utilities.Plot.Types.LineThickness_mm lineSymbolSize=3
    "Symbol size" annotation(Dialog(group="If autoLine = false (otherwise ignored)"));
*/

          annotation (Documentation(info="<html>
<p>
With this record the properties of one curve in a diagram are defined
(such as data points, color, line pattern).
</p>
</html>"));
        end Curve;

        record Device "Properties of a device"
          extends Modelica.Icons.Record;

          Modelica_LinearSystems2.Utilities.Plot.Types.DrawingUnit_mm xTopLeft=0
            "Horizontal position of top left figure corner if applicable (e.g. window)"
            annotation(Dialog);
          Modelica_LinearSystems2.Utilities.Plot.Types.DrawingUnit_mm yTopLeft=0
            "Vertical position of top left figure corner if applicable (e.g. window)"
            annotation(Dialog);
          Modelica_LinearSystems2.Utilities.Plot.Types.DrawingUnit_mm diagramWidth=140
            "Width of diagram" annotation(Dialog);
          Modelica_LinearSystems2.Utilities.Plot.Types.ImageResolution_dpi windowResolution=96
            "[dpi] Image resolution in window if applicable (e.g. unscaled window)" annotation(Dialog);

          Boolean autoLineColor = true
            "If automatic line properties: distinguish curves by color otherwise by line style"
               annotation(choices(checkBox=true));

          annotation (Documentation(info="<html>
<p>
With this record the placement of a diagram in the drawing window is defined,
as well as the diagram width (the height to width ratio of a diagram is defined
with record
<a href=\"modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Diagram\">Modelica_LinearSystems2.Utilities.Plot.Records.Diagram</a>.
Furthermore the window resolution is defined here in order to compute the number of pixels from length definitions in
mm.
</p>
</html>"));
        end Device;

        record DefaultDiagram
          "Diagram with no curves (might be used as default diagram)"
          extends Diagram(curve=fill(Curve(
                                     x=fill(0.0,0),y=fill(0.0,0)),0));

          annotation (Documentation(info="<html>
<p>
This record defines a default diagram without curves. In several cases a default is needed in order
that no translation error occurs and then this record can be used.
</p>
</html>"));
        end DefaultDiagram;
        annotation (
          Documentation(info="<html>
<p>
This package contains particular records used in various classes within the library.
Especially, the records used to define the function interfaces are provided here.
</p>
</html>"));
      end Records;

      package Internal
      "Internal functions, that should not be utilized by a user"
        extends Modelica.Icons.Package;

        function convertToDymolaMarker
          "Convert from marker type of Modelica_LinearSystems2 to Dymola marker"
          import Symbol = Modelica_LinearSystems2.Utilities.Plot.Types.PointSymbol;

          input Modelica_LinearSystems2.Utilities.Plot.Types.PointSymbol symbol
            "Enumeration value of point symbol used in Modelica_LinearSystems2";
          output MarkerStyle result
            "Enumeration value of point symbol used in Dymola";
        algorithm
          result := if symbol == Symbol.None then MarkerStyle.None else if symbol ==
            Symbol.Cross then MarkerStyle.Cross else if symbol == Symbol.Circle then
            MarkerStyle.Circle else if symbol == Symbol.Square then MarkerStyle.Square
             else if symbol == Symbol.FilledSquare then MarkerStyle.FilledSquare
             else if symbol == Symbol.TriangleDown then MarkerStyle.TriangleDown
             else if symbol == Symbol.TriangleUp then MarkerStyle.TriangleUp else if
            symbol == Symbol.Diamond then MarkerStyle.Diamond else if symbol ==
            Symbol.Dot then MarkerStyle.Dot else MarkerStyle.None;

          annotation (Inline=true, Documentation(info="<html>
<p>
This function converts the point symbol enumeration as used in the Modelica_LinearSystems2 library
to the enumeration used in Dymola.
</p>
</html>"));
        end convertToDymolaMarker;

        function convertToDymolaPattern
          "Convert from pattern type of Modelica_LinearSystems2 to Dymola pattern"
          import Pattern = Modelica_LinearSystems2.Utilities.Plot.Types.LinePattern;

          input Modelica_LinearSystems2.Utilities.Plot.Types.LinePattern pattern
            "Enumeration value of line pattern used in Modelica_LinearSystems2";
          output LinePattern result
            "Enumeration value of line pattern used in Dymola";
        algorithm
          result := if pattern == Pattern.None then LinePattern.None else if pattern ==
            Pattern.Solid then LinePattern.Solid else if pattern == Pattern.Dash
             then LinePattern.Dash else if pattern == Pattern.Dot then LinePattern.Dot
             else if pattern == Pattern.DashDot then LinePattern.DashDot else if
            pattern == Pattern.DashDotDot then LinePattern.DashDotDot else
            LinePattern.Solid;

          annotation (Inline=true, Documentation(info="<html>
<p>
This function converts the line pattern enumeration as used in the Modelica_LinearSystems2 library
to the enumeration used in Dymola.
</p>
</html>"));
        end convertToDymolaPattern;
        annotation (Documentation(info="<html>
<p>
This package contains utility functions to implement the plot functions.
These functions should not be used by a user.
</p>
</html>"));
      end Internal;
      annotation (Documentation(info="<html>
<p>
This package provides functions to plot curves in two dimensions. Here is a short overview:
</p>

<p>
A figure consists of a <b>set of diagrams</b>. Different functions are provided
to either plot one diagram (Plot.diagram) to plot several diagrams under each other
(Plot.vectorDiagrams) or to plot several diagrams in matrix layout
(Plot.matrixDiagrams).
</p>

<p>
Every diagram can have a set of <b>curves</b>. Every diagram has the same
width, defined by <b>diagramWidth</b>. The height of a diagram is defined
by variable <b>heightRatio</b>
(diagram height in row j = diagram[j].heightRatio*diagramWidth).
Several curves can be displayed in one diagram.
</p>

<p>
A typical example is shown in the next figure:
</p>

<p><img src=\"modelica://Modelica_LinearSystems2/Resources/Images/Utilities/showSinesInVectorDiagram.png\"></p>
</html>"));
    end Plot;

    package Types "Package of type definitions"
      extends Modelica.Icons.Package;

      type AnalogFilter = enumeration(
        CriticalDamping   "Filter with critical damping",
        Bessel   "Bessel filter",
        Butterworth   "Butterworth filter",
        Chebyshev   "Chebyshev filter")
        "Enumeration defining the method of filtering"
            annotation (Evaluate=true, Documentation(info="<html>
</html>"));

      type FilterType = enumeration(
        LowPass   "Low pass filter",
        HighPass   "High pass filter",
        BandPass   "Band pass filter",
        BandStop   "Band stop / notch filter")
        "Enumeration of analog filter types (high pass or low pass)"
          annotation (Evaluate=true, Documentation(info="<html>
</html>"));

      type Method = enumeration(
        ExplicitEuler   "Discretization with explicit Euler integration",
        ImplicitEuler   "Discretization with implicit Euler integration",
        Trapezoidal
            "Discretization with trapezoidal integration (Tustins method, recommended)",
        ImpulseExact   "Exact discretization for impulse inputs",
        StepExact
            "Exact discretization for step inputs (zero-order hold equivalent)",
        RampExact
            "Exact discretization for ramp inputs (first-order hold equivalent)")
        "Enumeration of discretization methods"
          annotation (Evaluate=true, Documentation(info="<html>
</html>"));

      type StaircaseMethod = enumeration(
        QR   "Apply staircase algorithm based on QR factorization",
        SVD   "Apply staircase algorithm based on SVD")
        "Enumeration of methods for staircase algorithm"
          annotation (Evaluate=true, Documentation(info="<html>
</html>"));

      type TimeResponse = enumeration(
        Impulse   "Impulse response",
        Step   "Step response",
        Ramp   "Ramp response",
        Initial   "Initial condition response") "Enumeration of time response type"
          annotation (Evaluate=true, Documentation(info="<html>
</html>"));
      annotation (
        preferredView="info",
        Documentation(info="<html>
<p>
This package contains type definitions. Generally,
the enumeration type is used to assign a unique choice of parameter
within a model.
</p>
</html>"));
    end Types;
    annotation (Documentation(info="<html>
<p>
This package contains auxiliary packages and elements to be used in context with the library.
</p>
</html>"));
  end Utilities;

  package Internal
  "Package of internal utilities of the library (for advanced users only)"
    extends Modelica.Icons.Package;

    package Streams
    "Package of functions to read from files and write to files"
      extends Modelica.Icons.Package;

      function readMatrixInternal "Read matrix matrixName[m,n] from file"
        input String fileName "File name";
        input String matrixName "Matrix name";
        input Integer m "Number of rows";
        input Integer n "Number of coloumns";
        output Real A[m,n] "Matrix to read";
      external "C" Modelica_LinearSystem2_readMatrixInternal(
          fileName,
          matrixName,
          A,
          m,
          n) annotation (Include="

#include <matrixop.h>
#include <ModelicaUtilities.h>

void Modelica_LinearSystem2_readMatrixInternal(const char *filename, const char *matrixname, double* matrix, int rows, int cols)
{
  int j;
  int i;
  RealArray m;
  m=readMatrix(filename,matrixname,rows,cols);
  for (j=0;j<rows;j++)
  {
    for (i=0;i<cols;i++)
    {
      matrix[i+j*cols]=m.data[i+j*cols];
    }
  }
  return;
}");
       annotation(Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>readMatrixInternal(fileName, matrixName, m, n)</pre></blockquote>

<h4>Description</h4>
<p>Read matrix <code>matrixName</code> from file <code>fileName</code>. The matrix saved in file must be of dimension [m,n].</p>
</html>"));
      end readMatrixInternal;
      annotation (
        Documentation(info="<html>
<p>
This package contains functions to input and output data from and to
the file, respectively.
</p>
</html>"));
    end Streams;

    record Eigenvalue
      "Record containing a eigen value or a pair of conjugated complex pair, respectively and additionally characteristics of the eigenvalue(s)"
      import Modelica_LinearSystems2.Math.Complex;
      extends Modelica.Icons.Record;

      Complex ev;
      Boolean imag = false;
      Boolean isStable = false;
      Boolean isControllable = false;
      Boolean isStabilizable = false;
      Boolean isObservable = false;
      Boolean isDetectable = false;
      Real frequency;
      Real damping;
      Real timeConstant;

      encapsulated function constructor "Default constructor for eigenvalue"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import Modelica_LinearSystems2.Internal;
        import Modelica_LinearSystems2.Internal.Eigenvalue;

        input Complex ev_in=Complex(0);
        input Boolean isControllable=false;
        input Boolean isObservable = false;
        input Integer maxIndex1=0;
        input Integer maxIndex2=0;
        input Real Teps = 1e6
          "Maximum time constant before regarded as infinity, i.e. a real eigenvalue is zero";

        output Eigenvalue ev;

    protected
        Boolean isStable = ev_in.re<0;
        Boolean isImag = abs(ev_in.im)>Modelica.Constants.eps;
        Real abs_ev = (ev_in.re^2+ev_in.im^2)^0.5;

      algorithm
        ev.ev := ev_in;
        ev.imag := isImag;
        ev.isStable := isStable;
        ev.isControllable := isControllable;
        ev.isStabilizable := isStable or isControllable;
        ev.isObservable := isObservable;
        ev.isDetectable := isStable or isObservable;
        ev.frequency := if ev.imag then abs_ev/(2*Modelica.Constants.pi) else 0.0;
        ev.damping := if ev.imag then if abs_ev>Modelica.Constants.eps then -ev.ev.re/abs_ev else 0.0 else 1.0;
        ev.timeConstant := if ev.imag then 0.0 else if abs(ev.ev.re) > 1/Teps then 1/abs(ev.ev.re) else Teps;
      end constructor;

    end Eigenvalue;

    record PolesAndZeros
      "Record containing poles and zeros of a system in two real vectors containing the real parts and the imaginary parts respctively"
      import Modelica_LinearSystems2.Math.Complex;
      extends Modelica.Icons.Record;

      Real p_real[:];
      Real p_im[:];
      Real z_real[:];
      Real z_im[:];

      Integer norz_p "number of real zeros of p";
      Integer norz_z "number of real zeros of z";
      encapsulated function constructor "Default constructor for poles and zeros"
        import Modelica;
        import Modelica_LinearSystems2.Math.Complex;
        import PolesAndZeros2 = Modelica_LinearSystems2.Internal.PolesAndZeros;
        import Modelica_LinearSystems2.Internal;

        input Complex p[:]={Complex(0, 0)} "Complex zeros";
        input Complex z[:]={Complex(0, 0)} "Complex zeros";
        output PolesAndZeros2 pz(
          redeclare Real p_real[size(p, 1)],
          redeclare Real p_im[size(p, 1)],
          redeclare Real z_real[size(z, 1)],
          redeclare Real z_im[size(z, 1)]);
      algorithm
        pz.p_real := p[:].re;
        pz.p_im := p[:].im;
        pz.z_real := z[:].re;
        pz.z_im := z[:].im;
        pz.norz_p := Internal.numberOfRealZeros(p);
        pz.norz_z := Internal.numberOfRealZeros(z);

      end constructor;

    end PolesAndZeros;

    operator record StateSpaceR
      "Continuous state space description of a linear, time invariant differential equation system (data + operations)"

      extends Modelica.Icons.Record;

      Real A[:,:]   annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
      Real B[size(A, 1),:]  annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
      Real C[:,size(A, 1)]  annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
      Real D[size(C, 1),size(B, 2)] annotation(Dialog(group="der(x) = A*x + B*u;  y = C*x + D*u"));
      Integer r=0;

      encapsulated function constructor
        "Default constructor for a StateSpace record"
        import Modelica;
        import Modelica_LinearSystems2.Internal.StateSpaceR;

        input Real A[:,size(A, 1)] "der(x) = A*x + B*u";
        input Real B[size(A, 1),:] "der(x) = A*x + B*u";
        input Real C[:,size(A, 1)] "y = C*x + D*u";
        input Real D[size(C, 1),size(B, 2)] "y = C*x + D*u";
        input Integer r;
        output StateSpaceR result(
          redeclare Real A[size(A, 1),size(A, 2)],
          redeclare Real B[size(B, 1),size(B, 2)],
          redeclare Real C[size(C, 1),size(C, 2)],
          redeclare Real D[size(D, 1),size(D, 2)]);
      algorithm
        result.A := A;
        result.B := B;
        result.C := C;
        result.D := D;
        result.r := r;
      end constructor;
      annotation (defaultComponentName="stateSpaceR", Documentation(info="<html>
<p>
This record defines a linear time invariant differential
equation system in state space form:
</p>
<pre>    <b>der</b>(x) = A * x + B * u
        y  = C * x + D * u
</pre>
<p>
with
</p>
<ul>
<li> u - the input vector</li>
<li> y - the output vector</li>
<li> x - the state vector</li>
<li> A,B,C,D - matrices of appropriate dimensions</li>
</ul>
Compared to record StateSpace StateSpaceR cantains an additional Integer value r
</html>"));
    end StateSpaceR;

    record AnalyseOptions
      "Defines the characteristics of the eigenvalues to be print or to be plot"
      extends Modelica.Icons.Record;
      Boolean plotEigenValues=true "Plot eigenvalues" annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotInvariantZeros=true "Plot invariant zeros" annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotStepResponse=true "Plot step respones"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotFrequencyResponse=true "Plot bode diagram"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printSystem=true "Write system into the report (if not too large)"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printEigenValues=true "Write eigenvalues into the report"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printEigenValueProperties=true "Write eigenvalues with properties"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printInvariantZeros=true "Write invariant zreos into the report"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printControllability=true
        "Indicates controllability of every single pole"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printObservability=true
        "Indicates observability of every single pole"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      String headingEigenValues="Eigenvalues";
      String headingInvariantzeros="Invariant zeros";
      String headingStepResponse="Step response";
      String headingFrequencyResponse="Frequency response";
      Boolean dB_w = false
        "= true, to plot Bode with dB over w [rad/s] otherwise magnitude over f [Hz]"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));

    end AnalyseOptions;

    record AnalyseOptions2
      "Defines the characteristics of the eigenvalues to be print or to be plot"
      extends Modelica.Icons.Record;
      Boolean plotEigenValues=true "Plot eigenvalues" annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotInvariantZeros=true "Plot invariant zeros" annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotStepResponse=true "Plot step respones. Only for SISO system"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean plotFrequencyResponse=true "Plot bode diagram. Only for SISO system"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printSystem=true "Write system into the report (if not too large)"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printEigenValues=true "Write eigenvalues into the report"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printInvariantZeros=true "Write invariant zreos into the report"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printControllability=false
        "Indicates controllability of every single pole"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean printObservability=false
        "Indicates observability of every single pole"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      String headingEigenValues="Eigenvalues";
      String headingInvariantzeros="Invariant zeros";
      String headingStepResponse="Step response";
      String headingFrequencyResponse="Frequency response";

      final Boolean printEigenValueProperties = false
        "Write eigenvalues with properties"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));
      Boolean dB_w = false
        "= true, to plot Bode with dB over w [rad/s] otherwise magnitude over f [Hz]"
        annotation(Dialog(group="Analyse options"),choices(checkBox=true));

    end AnalyseOptions2;

    record DefaultDiagramPolesAndZeros "Default diagram for polesAndZeros plot"
      import Modelica;

      extends Modelica.Icons.Record;
      extends Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram(
                          heading="Eigenvalues (x) and invariant zeros (o)",
                          heightRatio=0.6,
                          legend=false,
                          xLabel="Real part",
                          yLabel="Imaginary part");
      annotation (Documentation(info="<html>
<p>
This record contains the default diagram options for pole/zero plots.
</p>
</html>"));
    end DefaultDiagramPolesAndZeros;

    record DefaultDiagramBodePlot "Default diagram for Bode plot"
      import Modelica;

      extends Modelica.Icons.Record;
      extends Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram(
                          heading="Bode-Diagram",
                          heightRatio=0.4,
                          legend=false,
                          xLabel="Frequency [Hz]",
                          yLabel="",
                          logX=true,
                          logY=true);
      annotation (Documentation(info="<html>
<p>This record contains the default diagram options for magnitude in bode plots. </p>
</html>"));
    end DefaultDiagramBodePlot;

    record DefaultDiagramTimeResponse "Default diagram for a time response plot"
      import Modelica;

      extends Modelica.Icons.Record;
      extends Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram(
                          heading="time response",
                          heightRatio=0.4,
                          legend=false,
                          xLabel="time [s]",
                          yLabel="system output");
      annotation (Documentation(info="<html>
<p>
This record contains the default diagram options for pole/zero plots.
</p>
</html>"));
    end DefaultDiagramTimeResponse;

    partial function PartialPlotFunction "Interface of a plot function"

      import Modelica_LinearSystems2.Utilities.Plot;

      input Plot.Records.Diagram defaultDiagram "Default diagram layout" annotation(Dialog);
      input Plot.Records.Device device=Modelica_LinearSystems2.Utilities.Plot.Records.Device()
        "Properties of device where figure is shown" annotation(Dialog);
    end PartialPlotFunction;

    partial function PartialPlotFunctionMIMO
      "Interface of a plot function for MIMO systems"

      import Modelica_LinearSystems2.Utilities.Plot;

      input Plot.Records.Diagram defaultDiagram "Default diagram layout" annotation(Dialog);
      input Plot.Records.Device device=Modelica_LinearSystems2.Utilities.Plot.Records.Device()
        "Properties of device where figure is shown" annotation(Dialog);
    end PartialPlotFunctionMIMO;

    encapsulated function frequencyResponse
      "Compute frequency response based on zeros and poles"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Internal;
      import Modelica.Units.SI;

      input Real gain "Gain of transfer function";
      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      input Real Poles[:,2]
        "Poles as Real matrix (first column: real, second column imaginary values)";
      input Integer nPoints(min=2) = 200 "Number of points";
      input Boolean autoRange=true
        "= true, if abszissa range is automatically determined";
      input SI.Frequency f_min(min=0) = 0.1
        "Minimum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));
      input SI.Frequency f_max(min=0) = 10
        "Maximum frequency value, if autoRange = false" annotation(Dialog(enable=not autoRange));
      input Boolean Hz=true
        "= true, to compute abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
      input Boolean dB=false
        "= true, to compute magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));
      input Boolean logX=true
        "= true, to compute abszissa values for logarithmic scale" annotation(choices(checkBox=true));
      output Real f[nPoints] "Frequency vector (either in Hz or rad/s)";
      output Real A[nPoints] "Amplitude (either without unit or in dB)";
      output Modelica.Units.NonSI.Angle_deg phi[nPoints] "Angles in degree";
  protected
      SI.AngularVelocity w[nPoints];
      SI.Angle phi_old;
      Integer info;
    algorithm
      // Determine frequency vector f
      f := Internal.frequencyVector2(Zeros,Poles,nPoints,autoRange,
                                     f_min,f_max,logX);

      // Compute magnitude and phase at the frequency points
      phi_old := 0.0;
      for i in 1:nPoints loop
        w[i] := Modelica.Units.Conversions.from_Hz(f[i]);
        (A[i], phi_old, info) := Internal.frequencyEvaluate(gain, Zeros, Poles, 0, w[i]);
        phi[i] := Modelica.Units.Conversions.to_deg(phi_old);

        // Convert to other units, if required
        if not Hz then
           f[i] := w[i];
        end if;
        if dB then
          if A[i] <> 0 then
            A[i] := 20*log10(A[i]);
          else
            A[i] := -6000 "= 20*log10(1e-300)";
          end if;
        end if;
      end for;

      annotation (__Dymola_translate=true,Documentation(info="<html>
</html>"));
    end frequencyResponse;

    encapsulated function frequencyResponsePlot "Bode plot given f,A,phi values"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Internal;
      import Modelica_LinearSystems2.Utilities.Plot;
      import Modelica.Units.SI;

      input Real f[:] "Frequency vector (either in Hz or rad/s)";
      input Real a[size(f,1)]
        "Absolute value/magnitude vector (either without unit or in dB)";
      input Modelica.Units.NonSI.Angle_deg phi[size(f, 1)] "Angles in degree";

      input Boolean autoRange=true
        "= true, if abszissa range is automatically determined";
      input Modelica.Units.SI.Frequency f_min=0.1
        "Minimum frequency value, if autoRange = false";
      input Modelica.Units.SI.Frequency f_max=10
        "Maximum frequency value, if autoRange = false";

      input Boolean magnitude=true "= true, to plot magnitude" annotation(choices(checkBox=true));
      input Boolean phase=true "= true, to plot phase" annotation(choices(checkBox=true));

      input Boolean Hz=true
        "= true, to plot abszissa in [Hz], otherwise in [rad/s] (= 2*pi*Hz)" annotation(choices(checkBox=true));
      input Boolean dB=false
        "= true, to plot magnitude in [], otherwise in [dB] (=20*log10(value))" annotation(choices(checkBox=true),Dialog(enable=magnitude));

      input Plot.Records.Diagram diagram "Diagram layout" annotation(Dialog);
      input Plot.Records.Device device=Modelica_LinearSystems2.Utilities.Plot.Records.Device()
        "Properties of device where figure is shown" annotation(Dialog);
  protected
      Boolean OK;
      Integer window=0;
      SI.Angle phi_old;
      Plot.Records.Curve curves[2];
      Integer i;
      Plot.Records.Diagram diagram2[2];
    algorithm
      // Plot computed frequency response
      diagram2 := fill(diagram, 2);
      i := 0;
      if magnitude then
        i := i + 1;
        curves[i] := Plot.Records.Curve(
          x=f,
          y=a,
          autoLine=true);
        diagram2[i].curve := {curves[i]};
        diagram2[i].yLabel := if dB then "magnitude [dB]" else "magnitude";
        if phase then
           diagram2[i].xLabel:="";
        end if;
        if dB then
           diagram2[i].logY := false;
        end if;
      end if;

      if phase then
        i := i + 1;
        curves[i] := Plot.Records.Curve(
          x=f,
          y=phi,
          autoLine=true);
        diagram2[i].curve := {curves[i]};
        diagram2[i].yLabel := "phase [deg]";
        diagram2[i].logY := false;
        if magnitude then
          diagram2[i].heading:="";
        end if;
      end if;

      if not Hz then
         diagram2[i].xLabel:="Angular frequency [rad/s]";
      end if;

      if magnitude and phase then
        Plot.diagramVector(diagram2, device);
      else
        Plot.diagram(diagram2[1], device);
      end if;

      annotation (__Dymola_interactive=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ZerosAndPoles.Plot.<b>bode</b>(zp)
   or
ZerosAndPoles.Plot.<b>bode</b>(
  zp,
  nPoints,
  autoRange,
  f_min,
  f_max,
  magnitude=true,
  phase=true,
  diagram=<a href=\"modelica://Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot\">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</a>(),
  device=<a href=\"Modelica://Modelica_LinearSystems2.Utilities.Plot.Records.Device\">Modelica_LinearSystems2.Utilities.Plot.Records.Device</a>() )
</pre></blockquote>

<h4>Description</h4>
<p>
This function plots the bode-diagram of a transfer function.
</p>

<h4>Example</h4>
<blockquote><pre>
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp =(p^2 + 5*p + 7)/(p + 2)/(p + 3);

<b>algorithm</b>
  Modelica_LinearSystems2.ZerosAndPoles.Plot.bode(zp)
//  gives:
</pre></blockquote>

<blockquote>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodeMagnitude.png\">
<br>
<img src=\"modelica://Modelica_LinearSystems2/Resources/Images/bodePhase.png\">
</blockquote>
</html>"));
    end frequencyResponsePlot;

    function frequencyRangeBode "Determine min. and max. frequencies for Bode plot"
      import Modelica;
      import Modelica_LinearSystems2.Math.Complex;
      import Modelica_LinearSystems2.Internal;
      import Modelica_LinearSystems2.TransferFunction;
      import Modelica.Utilities.Streams;

      input Complex numZeros[:] "Zeros of numerator";
      input Complex denZeros[:] "Zeros of denominator";
      output Modelica.Units.SI.AngularVelocity w_min;
      output Modelica.Units.SI.AngularVelocity w_max;
  protected
      Real phi_min=Modelica.Units.Conversions.from_deg(5);
      Real real_min=1.0e-4;
      Real pi=Modelica.Constants.pi;
      Integer n_num;
      Integer n_den;
      Real w_min1;
      Real w_min2;
      Real w_max1;
      Real w_max2;
      Boolean useFullRange1;
      Boolean useFullRange2;
      /*
  Real f_min;
  Real f_max;
  */
    algorithm
      // Compute frequencies for numerator
      n_num := size(numZeros, 1);
      if n_num > 0 then
        (w_min1,w_max1,useFullRange1) := Internal.frequencyRangeZeros(
          numZeros,
          phi_min,
          real_min);
      end if;

      // Compute frequencies for denominator
      n_den := size(denZeros, 1);
      if n_den > 0 then
        (w_min2,w_max2,useFullRange2) := Internal.frequencyRangeZeros(
          denZeros,
          phi_min,
          real_min);
      end if;

      // Use largest range
      if n_num == 0 and n_den == 0 then
        w_min := Modelica.Units.Conversions.from_Hz(0.1);
        w_max := Modelica.Units.Conversions.from_Hz(1);
      elseif n_num == 0 then
        w_min := w_min2;
        w_max := w_max2;
      elseif n_den == 0 then
        w_min := w_min1;
        w_max := w_max1;
      else
        if useFullRange1 and useFullRange2 then
          w_min := min(w_min1, w_min2);
          w_max := max(w_max1, w_max2);
        elseif useFullRange1 then
          w_min :=w_min1;
          w_max :=w_max1;
        else
          w_min :=w_min2;
          w_max :=w_max2;
        end if;
      end if;

      /*
  f_min := Modelica.Units.Conversions.to_Hz(w_min);
  f_max := Modelica.Units.Conversions.to_Hz(w_max);
  */
    end frequencyRangeBode;

    function frequencyRangeBode2
      "Determine min. and max. frequencies for Bode plot (Zeros and Poles as Real matrix)"
      import Modelica;
      import Modelica_LinearSystems2.Internal;

      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      input Real Poles[:,2]
        "Poles as Real matrix (first column: real, second column imaginary values)";
      output Modelica.Units.SI.AngularVelocity w_min "Minimum angular frequency";
      output Modelica.Units.SI.AngularVelocity w_max "Maximum angular frequency";
  protected
      Real phi_min=Modelica.Units.Conversions.from_deg(5);
      Real real_min=1.0e-4;
      Real pi=Modelica.Constants.pi;
      Integer n_num;
      Integer n_den;
      Real w_min1;
      Real w_min2;
      Real w_max1;
      Real w_max2;
      Boolean useFullRange1;
      Boolean useFullRange2;
    algorithm
      // Compute frequencies for numerator
      n_num := size(Zeros, 1);
      if n_num > 0 then
        (w_min1,w_max1,useFullRange1) := Internal.frequencyRangeZeros2(
                                            Zeros, phi_min, real_min);
      end if;

      // Compute frequencies for denominator
      n_den := size(Poles, 1);
      if n_den > 0 then
        (w_min2,w_max2,useFullRange2) := Internal.frequencyRangeZeros2(
                                           Poles, phi_min, real_min);
      end if;

      // Use largest range
      if n_num == 0 and n_den == 0 then
        w_min :=Modelica.Units.Conversions.from_Hz(0.1);
        w_max :=Modelica.Units.Conversions.from_Hz(1);
      elseif n_num == 0 then
        w_min := w_min2;
        w_max := w_max2;
      elseif n_den == 0 then
        w_min := w_min1;
        w_max := w_max1;
      else
        if useFullRange1 and useFullRange2 then
          w_min := min(w_min1, w_min2);
          w_max := max(w_max1, w_max2);
        elseif useFullRange1 then
          w_min :=w_min1;
          w_max :=w_max1;
        else
          w_min :=w_min2;
          w_max :=w_max2;
        end if;
      end if;
    end frequencyRangeBode2;

    function frequencyRangeZeros
      "Determine min. and max. frequencies for a vector of zeros (numerator or denominator zeros)"
      import Modelica;
      import Modelica.Math;
      import      Modelica.Units.SI;
      import Modelica_LinearSystems2.Math.Complex;

      input Complex z[:] "Vector of zeros";
      input SI.Angle phi_min(min=10*Modelica.Constants.eps)=
        Modelica.Units.Conversions.from_deg(5) "Minimum phase angle";
      input Real real_min(min=0) = 1.e-4 "|r| < real_min are treated as |real_min|";
      output Modelica.Units.SI.AngularVelocity w_min "Minimum frequency";
      output Modelica.Units.SI.AngularVelocity w_max "Maximum frequency";
      output Boolean useFullRange = true;
  protected
      Integer nz=size(z, 1);
      Real tan_min1;
      Real tan_min2;
      Real tan_max1;
      Real tan_max2;
      Real z_re;
      Real w_min1;
      Real w_max1;
      Real z_abs2;
      Real k1;
      Real k2;
      Boolean first = true;
    algorithm
      /* - Real zero:
       tan(phi_desired) = w/|re| -> w = |re|*tan(phi_desired)

     - Conjugate complex zero:
       tan(phi1) = (w + im)/|re|
       tan(phi2) = (w - im)/|re|
       phi1 + phi2 = phi_desired ->
          tan(phi1 + phi2) = (tan(phi1) + tan(phi2))/(1-tan(phi1)*tan(phi2))
                           = ((w + im)/re + (w - im)/re) / ( 1 - (w+im)/re*(w-im)/re )
                           = 2*w/re / (re^2 - (w^2 - im^2))/re^2
                           = 2*w*re / (re^2 - w^2 + im^2)
          tan(phi_desired)*(re^2 + im^2 - w^2) = 2*w*re
          tan(phi_desired)*w^2 + 2*w*re - tan(phi_desired)*(re^2 + im^2) = 0
          w^2 + (2*re/tan(phi_desired))*w - (re^2 + im^2) = 0
          w = -re/tan(phi_desired) + sqrt(re^2/tan(phi_desired)^2 + re^2 + im^2)
  */
      assert(nz > 0, "Vector z of zeros has dimension 0, This is not allowed");
      tan_min1 := Math.tan(phi_min);
      tan_min2 := Math.tan(2*phi_min);
      tan_max1 := Math.tan(Modelica.Constants.pi/2 - phi_min);
      tan_max2 := Math.tan(Modelica.Constants.pi - 2*phi_min);
      for i in 1:size(z, 1) loop
        if z[i].im >= 0.0 and abs(z[i].re) >= real_min then
          //z_re := if abs(z[i].re) <= real_min then -real_min else z[i].re;
          z_re :=max(abs(z[i].re), real_min);
          if z[i].im > 0.0 then
            z_abs2 := z_re^2 + z[i].im^2;
            k1 := z_re/tan_min2;
            w_min1 := sqrt(k1^2 + z_abs2) - k1;
            k2 := z_re/tan_max2;
            w_max1 := sqrt(k2^2 + z_abs2) - k2;
            /*
        phi1 :=Modelica.Units.Conversions.to_deg(Modelica.Math.atan((w_max1 + z[i].im)/z_re));
        phi2 :=Modelica.Units.Conversions.to_deg(Modelica.Math.atan((w_max1 - z[i].im)/z_re));
        Modelica.Utilities.Streams.print("phi1, phi2, 180-sum = " + String(phi1) + ", " + String(phi2)+", " +String(180-phi1-phi2));
        */
          else
            w_min1 := z_re*tan_min1;
            w_max1 := z_re*tan_max1;
          end if;

          if first then
            first :=false;
            w_min := w_min1;
            w_max := w_max1;
          else
            w_min := min(w_min, w_min1);
            w_max := max(w_max, w_max1);
          end if;
        end if;
      end for;

      if first then
        useFullRange := false;
        w_min :=Modelica.Units.Conversions.from_Hz(0.1);
        w_max :=Modelica.Units.Conversions.from_Hz(1);
      end if;

      annotation (Documentation(info="<html>
<p>
This function estimates a useful frequency range for the
Bode plot of a vector of zeros (numerator or denominator zeros).
This frequency range is estimated such that the phase angle
of <b>one</b> zero is in the range:
</p>
<blockquote><pre>
phi_min/n_zeros &le; |phase angle| &le; pi/2 - phi_min/n_zeros
</pre></blockquote>

<p>
where n_zeros is the number of zeros.
Note, the phase angle of one zero for a frequency of 0 up to infinity
is in the range:
</p>
<blockquote><pre>
0 &le; |phase angle| &le; pi/2
</pre></blockquote>

<p>
Therefore, the frequency range is estimated
such that the essential part of the phase angle (defined by phi_min)
is present.
</p>
<p>
If the real part of a complex zero vanishes
(i.e., the zero is located on the imaginary axis),
the maximum value of the bode plot magnitude of the zero
is infinity. In order to avoid difficulties, zeros close to
the imaginary axis are shifted by the input argument
real_min along the real axis.
</p>
</html>"));
    end frequencyRangeZeros;

    function frequencyRangeZeros2
      "Determine min. and max. frequencies for a vector of zeros (numerator or denominator zeros; provided as Real matrix)"
      import Modelica;
      import Modelica.Math;
      import Modelica.Units.SI;

      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      input SI.Angle phi_min(min=10*Modelica.Constants.eps)=
        Modelica.Units.Conversions.from_deg(5) "Minimum phase angle";
      input Real real_min(min=0) = 1.e-4 "|r| < real_min are treated as |real_min|";
      output Modelica.Units.SI.AngularVelocity w_min "Minimum frequency";
      output Modelica.Units.SI.AngularVelocity w_max "Maximum frequency";
      output Boolean useFullRange = true;
  protected
      Integer nz=size(Zeros, 1);
      Real tan_min1;
      Real tan_min2;
      Real tan_max1;
      Real tan_max2;
      Real z_re;
      Real w_min1;
      Real w_max1;
      Real z_abs2;
      Real k1;
      Real k2;
      Boolean first = true;
    algorithm
      /* - Real zero:
       tan(phi_desired) = w/|re| -> w = |re|*tan(phi_desired)

     - Conjugate complex zero:
       tan(phi1) = (w + im)/|re|
       tan(phi2) = (w - im)/|re|
       phi1 + phi2 = phi_desired ->
          tan(phi1 + phi2) = (tan(phi1) + tan(phi2))/(1-tan(phi1)*tan(phi2))
                           = ((w + im)/re + (w - im)/re) / ( 1 - (w+im)/re*(w-im)/re )
                           = 2*w/re / (re^2 - (w^2 - im^2))/re^2
                           = 2*w*re / (re^2 - w^2 + im^2)
          tan(phi_desired)*(re^2 + im^2 - w^2) = 2*w*re
          tan(phi_desired)*w^2 + 2*w*re - tan(phi_desired)*(re^2 + im^2) = 0
          w^2 + (2*re/tan(phi_desired))*w - (re^2 + im^2) = 0
          w = -re/tan(phi_desired) + sqrt(re^2/tan(phi_desired)^2 + re^2 + im^2)
  */
      assert(nz > 0, "Matrix Zeros has dimension 0, This is not allowed");
      tan_min1 := Math.tan(phi_min);
      tan_min2 := Math.tan(2*phi_min);
      tan_max1 := Math.tan(Modelica.Constants.pi/2 - phi_min);
      tan_max2 := Math.tan(Modelica.Constants.pi - 2*phi_min);
      for i in 1:nz loop
        if Zeros[i,2] >= 0.0 and abs(Zeros[i,1]) >= real_min then
          //z_re := if abs(z[i].re) <= real_min then -real_min else z[i].re;
          z_re :=max(abs(Zeros[i,1]), real_min);
          if Zeros[i,2] > 0.0 then
            z_abs2 := z_re^2 + Zeros[i,2]^2;
            k1 := z_re/tan_min2;
            w_min1 := sqrt(k1^2 + z_abs2) - k1;
            k2 := z_re/tan_max2;
            w_max1 := sqrt(k2^2 + z_abs2) - k2;
            /*
        phi1 :=Modelica.Units.Conversions.to_deg(Modelica.Math.atan((w_max1 + z[i].im)/z_re));
        phi2 :=Modelica.Units.Conversions.to_deg(Modelica.Math.atan((w_max1 - z[i].im)/z_re));
        Modelica.Utilities.Streams.print("phi1, phi2, 180-sum = " + String(phi1) + ", " + String(phi2)+", " +String(180-phi1-phi2));
        */
          else
            w_min1 := z_re*tan_min1;
            w_max1 := z_re*tan_max1;
          end if;

          if first then
            first :=false;
            w_min := w_min1;
            w_max := w_max1;
          else
            w_min := min(w_min, w_min1);
            w_max := max(w_max, w_max1);
          end if;
        end if;
      end for;

      if first then
        useFullRange := false;
        w_min :=Modelica.Units.Conversions.from_Hz(0.1);
        w_max :=Modelica.Units.Conversions.from_Hz(1);
      end if;

      annotation (Documentation(info="<html>
<p>
This function estimates a useful frequency range for the
Bode plot of a vector of zeros (numerator or denominator zeros).
This frequency range is estimated such that the phase angle
of <b>one</b> zero is in the range:
</p>
<blockquote><pre>
phi_min/n_zeros &le; |phase angle| &le; pi/2 - phi_min/n_zeros
</pre></blockquote>

<p>
where n_zeros is the number of zeros.
Note, the phase angle of one zero for a frequency of 0 up to infinity
is in the range:
</p>
<blockquote><pre>
0 &le; |phase angle| &le; pi/2
</pre></blockquote>

<p>
Therefore, the frequency range is estimated
such that the essential part of the phase angle (defined by phi_min)
is present.
</p>
<p>
If the real part of a complex zero vanishes
(i.e., the zero is located on the imaginary axis),
the maximum value of the bode plot magnitude of the zero
is infinity. In order to avoid difficulties, zeros close to
the imaginary axis are shifted by the input argument
real_min along the real axis.
</p>
</html>"));
    end frequencyRangeZeros2;

    function frequencyVector "Determine frequency vector for Bode plot"
      import Modelica;
      import Modelica_LinearSystems2.Math.Complex;
      import LinearSystems = Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Internal;
      import Modelica.Units.SI;

      input Integer nPoints(min=2) = 200 "Number of points";
      input Boolean autoRange=true
        "True, if abszissa range is automatically determined";
      input Modelica.Units.SI.Frequency f_min(min=0) = 0.1
        "Minimum frequency value, if autoRange = false"
        annotation (Dialog(enable=not autoRange));
      input Modelica.Units.SI.Frequency f_max(min=0) = 10
        "Maximum frequency value, if autoRange = false"
        annotation (Dialog(enable=not autoRange));
      input Complex numZeros[:]=fill(Complex(0), 0) "Zeros of numerator"
        annotation(Dialog(enable=autoRange));
      input Complex denZeros[:]=fill(Complex(0), 0) "Zeros of denominator"
        annotation(Dialog(enable=autoRange));
      input Boolean logX=true
        "=true: logarithmic scale; = false: linear scale of frequency vector";
      output SI.Frequency f[nPoints] "Frequency vector (automatic or manual)";
  protected
      Real w_min;
      Real w_max;
      Real f_min2;
      Real f_min2b;
      Real f_max2;
      Real f_log[nPoints];
    algorithm
      // Determine f_min2, f_max2 (auto or manual)
      if autoRange then
        (w_min,w_max) := Internal.frequencyRangeBode(numZeros, denZeros);
        f_min2 := Modelica.Units.Conversions.to_Hz(w_min);
        f_max2 := Modelica.Units.Conversions.to_Hz(w_max);
      else
        f_min2 := f_min;
        f_max2 := f_max;
      end if;

      // Compute vector of frequency points
      if logX then
        if f_min2 <= 0 then
          // Change minimum frequency point
          f_min2b :=f_min2;
          f_min2  :=f_max2/10^5;
          assert(false,"Minimum frequency changed from " + String(f_min2b) +
                 " to " + String(f_min2) + " because log(0) is not defined",
                 AssertionLevel.warning);
        end if;
        f_log := linspace(
          Modelica.Math.log10(f_min2),
          Modelica.Math.log10(f_max2),
          nPoints);
        for i in 1:nPoints loop
          f[i] := 10^f_log[i];
        end for;
      else
        f :=linspace(f_min,f_max,nPoints);
      end if;
    end frequencyVector;

    function frequencyVector2
      "Determine frequency vector for Bode plot (using Real matrices for zeros and poles)"
      import Modelica;
      import Modelica_LinearSystems2.Internal;
      import      Modelica.Units.SI;

      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      input Real Poles[:,2]
        "Poles as Real matrix (first column: real, second column imaginary values)";
      input Integer nPoints(min=2) = 200 "Number of points";
      input Boolean autoRange=true
        "True, if abszissa range is automatically determined";
      input Modelica.Units.SI.Frequency f_min(min=0) = 0.1
        "Minimum frequency value, if autoRange = false"
        annotation (Dialog(enable=not autoRange));
      input Modelica.Units.SI.Frequency f_max(min=0) = 10
        "Maximum frequency value, if autoRange = false"
        annotation (Dialog(enable=not autoRange));
      input Boolean logX=true
        "=true: logarithmic scale; = false: linear scale of frequency vector";
      output SI.Frequency f[nPoints] "Frequency vector (automatic or manual)";
  protected
      Real w_min;
      Real w_max;
      Real f_min2;
      Real f_min2b;
      Real f_max2;
      Real f_log[nPoints];
    algorithm
      // Determine f_min2, f_max2 (auto or manual)
      if autoRange then
        (w_min,w_max) := Internal.frequencyRangeBode2(Zeros, Poles);
        f_min2 := Modelica.Units.Conversions.to_Hz(w_min);
        f_max2 := Modelica.Units.Conversions.to_Hz(w_max);
      else
        f_min2 := f_min;
        f_max2 := f_max;
      end if;

      // Compute vector of frequency points
      if logX then
        if f_min2 <= 0 then
          // Change minimum frequency point
          f_min2b :=f_min2;
          f_min2  :=f_max2/10^5;
          assert(false,"Minimum frequency changed from " + String(f_min2b) +
                 " to " + String(f_min2) + " because log(0) is not defined",
                 AssertionLevel.warning);
        end if;
        f_log := linspace(
          Modelica.Math.log10(f_min2),
          Modelica.Math.log10(f_max2),
          nPoints);
        for i in 1:nPoints loop
          f[i] := 10^f_log[i];
        end for;
      else
        f :=linspace(f_min,f_max,nPoints);
      end if;
    end frequencyVector2;

    encapsulated function frequencyEvaluate
      "Evaluate a SISO transfer function defined by Zeros and Poles matrices at a given complex value re + j*im"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Internal;
      import Modelica.Utilities.Streams.print;

      input Real gain "Gain of transfer function";
      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      input Real Poles[:,2]
        "Poles as Real matrix (first column: real, second column imaginary values)";
      input Real re "Real value of complex number";
      input Real im "Imaginary value of complex number";
      output Real A "Amplitude of complex value";
      output Modelica.Units.SI.Angle phi "Angle of complex value";
      output Integer info
        "= 0/1/2 success/infinity(A is a large value)/indefinite (A=0/0; A=0 returned)";
  protected
      Integer nn = size(Zeros,1);
      Integer nd = size(Poles,1);
      Real Zeros2[size(Zeros,1)];
      Real n_A[ size(Zeros,1)];
      Real n_A2[size(Zeros,1)];
      Real d_A[ size(Poles,1)];
      Real d_A2[size(Poles,1)];
      Modelica.Units.SI.Angle n_phi[size(Zeros, 1)];
      Modelica.Units.SI.Angle d_phi[size(Poles, 1)];
      Boolean n_zero=false;
      Boolean d_zero=false;
    algorithm
      assert( nd >= 1, "Vector Poles must have at least one element");
      assert( nn <= nd, "Size of vector Zeros <= size of vector Poles required");

      // Compute values of zeros and poles at s=re+j*im
      // z(s) = s - (a+j*b); z(re+j*im) = re-a + j(im-b)
      if nn > 0 then
        (n_A, n_phi, n_zero) :=Internal.toPolarForm([fill(re,nn)-Zeros[:, 1],fill(im,nn)-Zeros[:, 2]]);
      end if;
      (d_A, d_phi, d_zero) :=Internal.toPolarForm([fill(re,nd)-Poles[:, 1],fill(im,nd)-Poles[:, 2]]);

      // Handle zeros in numerator
      if n_zero then
        A := 0;
        phi := 0;
        info :=if d_zero then 2 else 0;
        return;
      end if;

      // Compute angle of fraction
      phi :=0;
      for i in 1:nn loop
        phi := phi + n_phi[i] - d_phi[i];
      end for;

      for i in nn+1:nd loop
        phi := phi - d_phi[i];
      end for;

      // Compute absolute value (avoid overflow)
      if d_zero then
        info :=1;
        A :=Modelica.Constants.inf;
      else
        info :=0;
        n_A2 :=Modelica.Math.Vectors.sort(n_A, ascending=false);
        d_A2 :=Modelica.Math.Vectors.sort(d_A, ascending=false);
        A := 1;
        for i in 1:nn loop
          A :=A*(n_A2[i]/d_A2[i]);
        end for;
        for i in nn+1:nd loop
          A :=A/d_A2[i];
        end for;
      end if;

      // Take gain into account
      if info == 0 then
        A :=gain*A;
      elseif info == 1 then
        A :=if gain >= 0 then A else -A;
      end if;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = ZerosAndPoles.Analysis.<b>evaluate</b>(zp, p, den_min=0)
</pre></blockquote>

<h4>Description</h4>
<p>
Function Analysis.<b>evaluate</b> evaluates the ZerosAndPoles transfer function at a given (complex) value of p and returns the value G(p)=N(p)/D(p). The optional argument den_min with default 0 is used to guard against a division by zero.
</p>
<pre>
  <b>if</b> |(D(p))| >= den_min <b>then</b>
     G(p) = N(p) / D(p);
  <b>elseif</b> D(p).re >= 0.0 <b>then</b>
     G(p) = N(p) / den_min
  <b>else</b>
     G(p) = -N(p) / den_min
  <b>end if</b>;
</p>
</pre>

<h4>Example</h4>
<blockquote><pre>
  Complex j = Modelica_LinearSystems2.Math.Complex.j();
  ZerosAndPoles p = Modelica_LinearSystems2.ZerosAndPoles.p();
  Modelica_LinearSystems2.ZerosAndPoles zp=(p+1)/(p^2+p+1);

  Complex result;

<b>algorithm</b>
  result := Modelica_LinearSystems2.ZerosAndPoles.Analysis.evaluate(zp, j+1);
//  result = 0.538462 - 0.307692j
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica_LinearSystems2.Math.Polynomial.evaluateComplex\">Math.Polynomial.evaluateComplex</a>
</p>
</html>",     revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
    end frequencyEvaluate;

    encapsulated function frequencyResponseGain
      "Compute the gain of a frequency response (system must be a SISO system)"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.StateSpace;
      import Modelica_LinearSystems2.Internal;
      import Modelica.Utilities.Streams.print;

      input Real A[:,size(A,1)] "A-matrix of linear state space system";
      input Real B[size(A,1),:] "B-matrix of linear state space system";
      input Real C[:,size(A,1)] "C-matrix of linear state space system";
      input Real D[size(C,1),size(B,2)] "D-matrix of linear state space system";
      input Real Zeros[:,2]
        "Zeros of state space system as Real matrix (first column: real, second column imaginary values)";
      input Real Poles[:,2]
        "Poles of state space system as Real matrix (first column: real, second column imaginary values)";
      output Real gain
        "y(s) = gain*(s-z1)*(s-z2)*...*(s-zm)/((s-p1)*(s-p2)*...(s-pn))";

  protected
      Real r;
      Real phi;
      Real kr1;
      Real kr2;
      Real A2[size(A,1), size(A,2)];

      function getReOutsidePolesZeros
        "Get p on the real axis so that there is a minimum distance to all poles and zeros"
        input Real Zeros[:,2]
          "Zeros of ss as Real matrix (first column: real, second column imaginary values)";
        input Real Poles[:,2]
          "Poles of ss as Real matrix (first column: real, second column imaginary values)";
        input Real minimumDistance=0.1;
        output Real p
          "Value on real axis > 0.0, so that poles and zeros on the axis have a minimumDistance to it";
        /* Most systems have no or only a few unstable poles or zeros.
    Searching for a suitable p is therefore fastest when searching
    only in the unstable region, that is p > 0.0
    */
    protected
        Integer nVec=size(Poles, 1) + size(Zeros, 1);
        Real vec[:];
        Real vecSorted[:];
        Integer i;
        Integer iMax;
        Real small = minimumDistance*1e-6;
      algorithm
        i := 0;
        vec := zeros(nVec);
        for j in 1:size(Poles, 1) loop
          if Poles[j,1] > small and abs(Poles[j,2]) <= minimumDistance then
            i := i + 1;
            vec[i] := Poles[j,1];
          end if;
        end for;
        for j in 1:size(Zeros, 1) loop
          if Zeros[j,1] > small and abs(Zeros[j,2]) <= minimumDistance then
            i := i + 1;
            vec[i] := Zeros[j,1];
          end if;
        end for;
        iMax := i;
        if iMax == 0 then
          p := minimumDistance;
          return;
        end if;

        vec := vec[1:iMax];
        vecSorted := Modelica.Math.Vectors.sort(vec);

        // Find p, so that vecSorted[i+1] - vecSorted[i] > 2*minimumDistance
        if vecSorted[1] >= 2*minimumDistance then
           p := minimumDistance;
           return;
        end if;

        i :=1;
        while i <= iMax loop
          if i == iMax then
            p := vecSorted[i] + minimumDistance;
            break;
          elseif vecSorted[i + 1] - vecSorted[i] > 2*minimumDistance then
            p := vecSorted[i] + minimumDistance;
            break;
          else
            i := i + 1;
          end if;
        end while;
      end getReOutsidePolesZeros;

    algorithm
      assert(size(B,2)==1 and size(C,1)==1, "System is not a SISO system");
      if size(A,1) == 0 then
        // no states
        gain :=D[1, 1];
        return;
      end if;

      // Determine real value r that is far enough away from all zeros and poles
      r := getReOutsidePolesZeros(Zeros,Poles);

      // With G1(s) = (s-z1)*(s-z2)*...*(s-zm)/((s-p1)*(s-p2)*...(s-pn))"
      // compute kr1 = G1(r)
      (kr1,phi) :=Internal.frequencyEvaluate(1,Zeros,Poles,r,0);
      if abs(phi) > 1 then
        kr1 :=-kr1;
      end if;

      // With G2(s) = C*inv(sI-A)*B + D
      // compute kr2 = G2(r)
      A2 :=-A;
      for i in 1:size(A, 1) loop
        A2[i, i] := A2[i, i] + r;
      end for;
      kr2 :=vector(C)*Modelica.Math.Matrices.solve(A2, vector(B)) + scalar(D);

      // Compute gain
      gain :=kr2/kr1;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
zp = StateSpace.Conversion.<b>toZerosAndPoles</b>(ss)
</pre> </blockquote>

<h4>Description</h4>
<p>
Computes a ZerosAndPoles record
</p>
<blockquote><pre>
          product(s + n1[i]) * product(s^2 + n2[i,1]*s + n2[i,2])
zp = k * ---------------------------------------------------------
          product(s + d1[i]) * product(s^2 + d2[i,1]*s + d2[i,2])
</pre></blockquote>
<p>
of a system from state space representation using the transformation algorithm described in [1].
The uncontrollable and unobservable parts are isolated and the eigenvalues and invariant zeros of the controllable and observable sub system are calculated.
</p>

<h4>Example</h4>
<blockquote><pre>
  Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
    A = [-1.0, 0.0, 0.0;
          0.0,-2.0, 0.0;
          0.0, 0.0,-3.0],
    B = [1.0;
         1.0;
         0.0],
    C = [1.0,1.0,1.0],
    D = [0.0]);

<b>algorithm</b>
  zp:=Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles(ss);
//                s + 1.5
//   zp = 2 -----------------
             (s + 1)*(s + 2)
</pre></blockquote>

<h4><a name=\"References\">References</a></h4>
<dl>
<dt>&nbsp;[1] Varga, A and Sima, V. (1981):</dt>
<dd> <b>Numerically stable algorithm for transfer function matrix evaluation</b>.
     Int. J. Control, Vol. 33, No. 6, pp. 1123-1133.<br>&nbsp;</dd>
</dl>
</html>", revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr>
    <th>Date</th>
    <th>Author</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td valign=\"top\">2011-07-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Improved frequency calculation</td>
  </tr>
  <tr>
    <td valign=\"top\">2010-05-31</td>
    <td valign=\"top\">Marcus Baur, DLR-RM</td>
    <td valign=\"top\">Realization</td>
  </tr>
</table>
</html>"));
    end frequencyResponseGain;

    encapsulated function toPolarForm
      "Transform a vector of complex values defined as a real Zeros matrix to polar form"
      import Modelica;
      import Modelica_LinearSystems2;
      import Modelica_LinearSystems2.Internal;

      input Real Zeros[:,2]
        "Zeros as Real matrix (first column: real, second column imaginary values)";
      output Real A[size(Zeros,1)] "Amplitudes of Zeros";
      output Modelica.Units.SI.Angle phi[size(Zeros, 1)] "Angles of zeros";
      output Boolean oneZeroAmplitude
        "=true: at least one element of Zeros has zero amplitude";
  protected
      Real r_abs;
      Real i_abs;
    algorithm
      oneZeroAmplitude :=false;
      for i in 1:size(Zeros,1) loop
        r_abs :=abs(Zeros[i,1]);
        i_abs :=abs(Zeros[i,2]);
        if r_abs == 0 and i_abs == 0 then
          A[i] :=0;
          phi[i] :=0;
          oneZeroAmplitude :=true;
        else
          A[i]   :=if r_abs > i_abs then r_abs*sqrt(1 + (i_abs/r_abs)^2) else i_abs*sqrt(1 + (r_abs/i_abs)^2);
          phi[i] :=atan2(Zeros[i,2], Zeros[i,1]);
        end if;
      end for;
    end toPolarForm;

    function numberOfRealZeros
      "Determine the number of elements of a Complex vector where the imaginary part is zero"
      import Modelica_LinearSystems2.Math.Complex;

      input Complex complexVector[:] "Complex vector";
      output Integer result "Number of elements of v with v.im = 0";

    algorithm
      result := 0;
      for i in 1:size(complexVector, 1) loop
        if complexVector[i].im == 0 then
          result := result + 1;
        end if;
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
     Matrices.<b>numberOfRealZeros</b>(complexVector);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>numberOfRealZeros</b>(..) determines the number of
elements of vector &quot;complexVector&quot; with vanishing imaginary part,
i.e., complexVector[i].im = 0.
</p>
<h4>Example</h4>
<blockquote><pre>
  // c = {0; 1+2*j; 1-2*j; 2; -3; -1-j; -1+j};
  result = Matrices.numberOfRealZeros(c);
           -> result = 3;
</pre></blockquote>
</html>"));
    end numberOfRealZeros;

    function reorderZeros
      "Extract real and conjugate complex elements from a complex vector"
      import Modelica_LinearSystems2.Math.Complex;

      input Complex complexVector[:]
        "Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix";
      input String name="complexVector"
        "Name of complexVector to be used in error message";
      output Complex reorderedZeros[size(complexVector, 1)] "Reordered zeros";
      output Integer nRealZeros=numberOfRealZeros(complexVector)
        "Number of real zeros (reorderedZeros[1:nRealZeros] are the real zeros)";

  protected
      Integer n=size(complexVector, 1);
      Integer i;
      Integer jr;
      Integer jc;
    algorithm
      i := 1;
      jr := 1;
      jc := nRealZeros + 1;
      while i <= n loop
        if abs(complexVector[i].im) < Modelica.Constants.eps then
          reorderedZeros[jr].re := complexVector[i].re;
          reorderedZeros[jr].im := 0.0;
          i := i + 1;
          jr := jr + 1;
        else
    // check that the next two zeros are a conjugate complex pair
          assert(i < n, "Argument " + name +
            " does not define a real valued polynomial\n" + name + "[" + String(n)
             + "] is complex without complex conjugate.");
          assert(abs(complexVector[i].re - complexVector[i + 1].re) < max(Modelica.Constants.eps,
            abs(complexVector[i + 1].re)*100*Modelica.Constants.eps),
            "No conjugate complex pair (checked the real parts)\n" + "  " + name +
            "[" + String(i) + "] = " + String(complexVector[i]) + "\n" + "  " +
            name + "[" + String(i + 1) + "] = " + String(complexVector[i]) + "\n"
             +
            "and the real parts of these two complex numbers should be identical\n"
             + "since conjugate complex pairs required.");
          assert(abs(complexVector[i].im + complexVector[i + 1].im) < max(Modelica.Constants.eps,
            abs(complexVector[i + 1].im)*100*Modelica.Constants.eps),
            "No conjugate complex pair (checked the imaginary parts)\n" + "  " +
            name + "[" + String(i) + "] = " + String(complexVector[i]) + "\n" +
            "  " + name + "[" + String(i + 1) + "] = " + String(complexVector[i + 1])
             + "\n" +
            "and the imaginary parts of these two complex numbers should be identical\n"
             + "with opposite sign, since a conjugate complex pair is required.");

            // Store the zero with the positive imaginary part
          if complexVector[i].im >= 0 then
            reorderedZeros[jc] := complexVector[i];
            reorderedZeros[jc + 1] := complexVector[i + 1];
          else
            reorderedZeros[jc] := complexVector[i + 1];
            reorderedZeros[jc + 1] := complexVector[i];
          end if;
          i := i + 2;
          jc := jc + 2;
        end if;
      end while;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
               reorderedZero = Internal.<b>reorderZeros</b>(complexVector);
(reorderedZeros, nRealZeros) = Internal.<b>reorderZeros</b>(complexVector,
                                                     name=&quot;complexVector&quot;);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>reorderZeros</b>(..) reorders the zeros from the
Complex vector &quot;complexVector&quot; such that the returned Complex vector
reorderedZeros contains first all real Zeros and afterwards the conjugate
complex zero pairs. It is required that all elements
of complexVector define either a real zero (complexVector[i].im=0)
or a conjugate complex zero pair
(complexVector[i].re == complexVector[i+1].re and
complexVector[i].im == -complexVector[i+1].im).
The optional input argument
&quot;name&quot; is used as name of &quot;complexVector&quot; in error messages.
</p>
<p>
The function returns the vector element reordered, as well as
the number of real zeros (nRealZeros).
<h4>Example</h4>
<blockquote><pre>

  // c = {0; 1+2j; 1-2j; 2; -3; -1-j; -1+j};
    Real complexZeros[:] = fill(Complex(0), integer((size(c,1)-n)/2));
  algorithm
  (reorderedZeros, nRealZeros) := reorderZeros(c);
      -> reorderedZeros = {0, 2, (-3), 1+2j, 1-2j, -1+j, -1-j}
         nRealZeros     = 3

</pre></blockquote>
</html>"));
    end reorderZeros;

    function sortEigenvalue
      "Sort elements of Eigenvalue-record depending on the eigenvalues"
      extends Modelica.Icons.Function;

      import Modelica_LinearSystems2.Internal.Eigenvalue;
      import Modelica_LinearSystems2.Math.Complex;

      input Eigenvalue ev[:] "Vector to be sorted";
      input Boolean ascending = true
        "= true if ascending order, otherwise descending order";
      input Boolean sortFrequency=true
        "True, if sorting is first for imaginary then for real value, otherwise sorting is for absolute value";
      output Eigenvalue sorted_ev[size(ev,1)] = ev "Sorted vector";
      output Integer indices[size(ev,1)] = 1:size(ev,1) "sorted_ev = ev[indices]";

      /* shellsort algorithm; should be improved later */
  protected
      Integer gap;
      Integer i;
      Integer j;
      Eigenvalue wev;
      Integer wi;
      Integer nev = size(ev,1);
      Boolean swap;
      Integer k1;
      Integer k2;
    algorithm
      gap := div(nev,2);

      while gap > 0 loop
        i := gap;
        while i < nev loop
          j := i-gap;
          if j>=0 then
            k1 := j+1;
            k2 := j + gap + 1;
            if sortFrequency then
              if ascending then
                swap := abs(sorted_ev[k1].ev.im) >  abs(sorted_ev[k2].ev.im) or
                        abs(sorted_ev[k1].ev.im) == abs(sorted_ev[k2].ev.im) and
                        (sorted_ev[k1].ev.re  > sorted_ev[k2].ev.re or
                         sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re and sorted_ev[k1].ev.im < sorted_ev[k2].ev.im);
              else
                swap := abs(sorted_ev[k1].ev.im) <  abs(sorted_ev[k2].ev.im) or
                        abs(sorted_ev[k1].ev.im) == abs(sorted_ev[k2].ev.im) and
                        (sorted_ev[k1].ev.re  < sorted_ev[k2].ev.re or
                         sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re and sorted_ev[k1].ev.im < sorted_ev[k2].ev.im);
              end if;
            else
              if ascending then
                swap := Complex.'abs'(sorted_ev[k1].ev) > Complex.'abs'(sorted_ev[k2].ev);
              else
                swap := Complex.'abs'(sorted_ev[k1].ev) < Complex.'abs'(sorted_ev[k2].ev);
              end if;
            end if;
          else
            swap := false;
          end if;

          while swap loop
            wev := sorted_ev[j+1];
            wi := indices[j+1];
            sorted_ev[j+1] := sorted_ev[j+gap+1];
            sorted_ev[j+gap+1] := wev;
            indices[j+1] := indices[j+gap+1];
            indices[j+gap+1] := wi;
            j := j - gap;
            if j >= 0 then
              k1 := j+1;
              k2 := j + gap + 1;
              if sortFrequency then
                if ascending then
                  swap := abs(sorted_ev[k1].ev.im) >  abs(sorted_ev[k2].ev.im) or
                          abs(sorted_ev[k1].ev.im) == abs(sorted_ev[k2].ev.im) and
                          (sorted_ev[k1].ev.re  > sorted_ev[k2].ev.re or
                           sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re and sorted_ev[k1].ev.im < sorted_ev[k2].ev.im);
                else
                  swap := abs(sorted_ev[k1].ev.im) <  abs(sorted_ev[k2].ev.im) or
                          abs(sorted_ev[k1].ev.im) == abs(sorted_ev[k2].ev.im) and
                          (sorted_ev[k1].ev.re  < sorted_ev[k2].ev.re or
                           sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re and sorted_ev[k1].ev.im < sorted_ev[k2].ev.im);
                end if;
              else
                if ascending then
                  swap := Complex.'abs'(sorted_ev[k1].ev) > Complex.'abs'(sorted_ev[k2].ev);
                else
                  swap := Complex.'abs'(sorted_ev[k1].ev) < Complex.'abs'(sorted_ev[k2].ev);
                end if;
              end if;
            else
              swap := false;
            end if;
          end while;
          i := i + 1;
        end while;
        gap := div(gap,2);
      end while;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_v = Vectors.<b>sort</b>(v);
(sorted_v, indices) = Vectors.<b>sort</b>(v, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>sort</b>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument &quot;ascending&quot; is <b>false</b>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>
<h4>Example</h4>
<blockquote><pre>
  (v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
       -> v2 = {-1, 2, 3, 6, 8}
          i2 = {1, 5, 3, 4, 2}
</pre></blockquote>
</html>"));
    end sortEigenvalue;

    partial function timeResponseMask2
      "Declares the common structure for the set of response functions"
      input StateSpace sc;
      input Real dt=0 "Sample time [s]";
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,size(sc.C, 1),size(sc.B, 2)]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_continuous[:,size(sc.A, 1),size(sc.B, 2)]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask2;

    partial function timeResponseMask2_tf
      "Declares the common structure for the set of response functions"
      input Modelica_LinearSystems2.TransferFunction tf;
      input Real dt=0 "Sample time [s]";
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,1,1]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_continuous[:,Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf), 1]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask2_tf;

    partial function timeResponseMask2_zp
      "Declares the common structure for the set of response functions"
      import Modelica_LinearSystems2;

      input Modelica_LinearSystems2.ZerosAndPoles zp;
      input Real dt=0 "Sample time [s]";
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,1,1]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_continuous[:,Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp), 1]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask2_zp;

    function timeResponseSamples
      "Estimate reasonable discretisation sample time and simulation time span for time response plot"
      import Modelica_LinearSystems2;

      input Modelica_LinearSystems2.StateSpace sc;
      output Real dt "Sample time";
      output Real tSpan "Time span";
  protected
      Modelica_LinearSystems2.Math.Complex eig[size(sc.A, 1)];
      Real realp[size(sc.A, 1)];
      Real sorted[size(sc.A, 1)];
      Real indices[size(sc.A, 1)];
      Integer i;
    algorithm
      if size(sc.A,1) > 0 then
        eig := Modelica_LinearSystems2.StateSpace.Analysis.eigenValues(sc);
        for i in 1:size(eig, 1) loop
          realp[i] := eig[i].re;
        end for;
        (sorted,indices) := Modelica.Math.Vectors.sort(realp);

        // Estimate simulation time span
        if sorted[end] < 0 then
          tSpan := -5/sorted[end];
        elseif sorted[end] > 0 then
          tSpan := 15/sorted[end];
        elseif sorted[end] == 0 then
          tSpan := 15000;
        end if;
        // Curb simulation time span to maximal 15000s
        if tSpan > 15000 then
          tSpan := 15000;
        end if;

        // set sample time:
        dt := tSpan/1000;
      else
        tSpan := 1.0;
        dt := 0.01;
      end if;
    end timeResponseSamples;

    function methodString
      "Return a sting with the name of the discretization method"
      extends Modelica.Icons.Function;

      import Modelica_LinearSystems2.Utilities.Types.Method;

      input Method method;
      output String s;
    algorithm
      s := if method==Method.ExplicitEuler then "ExplicitEuler" else
           if method==Method.ImplicitEuler then "ImplicitEuler" else
           if method==Method.Trapezoidal then "Trapezoidal" else
           if method==Method.ImpulseExact then "ImpulseExact" else
           if method==Method.StepExact then "StepExact" else
           "RampExact";
    end methodString;

    partial function timeResponseMask_discrete
      "Declares the common structure for the set of response functions"
      input DiscreteStateSpace dss;
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,size(dss.C, 1),size(dss.B, 2)]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_discrete[:,size(dss.A, 1),size(dss.B, 2)]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask_discrete;

    partial function timeResponseMask_zp_discrete
      "Declares the common structure for the set of discrete response functions"
      import Modelica_LinearSystems2;

      input Modelica_LinearSystems2.DiscreteZerosAndPoles dzp;
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,1,1]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_discrete[:,Modelica_LinearSystems2.DiscreteZerosAndPoles.Analysis.denominatorDegree(dzp), 1]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask_zp_discrete;

    partial function timeResponseMask_tf_discrete
      "Declares the common structure for the set of discrete response functions"
      input Modelica_LinearSystems2.DiscreteTransferFunction dtf;
      input Real tSpan=0 "Simulation time span [s]";

      replaceable output Real y[:,1,1]
        "Output response: (number of samples) x (number of outputs) x (number of inputs)";
      output Real t[:] "Time vector: (number of samples)";
      replaceable output Real x_discrete[:,Modelica_LinearSystems2.DiscreteTransferFunction.Analysis.denominatorDegree(dtf), 1]
        "State trajectories: (number of samples) x (number of states) x (number of inputs)";

    end timeResponseMask_tf_discrete;

    function complexFraction
      "Return z = n[1]*n[2]*...n[end]/(d[1]*d[2]*....*d[end])"
      import Modelica.Utilities.Streams.print;
      import Modelica.Math.Vectors.toString;
      input Complex n[:];
      input Complex d[:];
      output Complex z "= n[1]*n[2]*...n[end]/(d[1]*d[2]*....*d[end])";
      output Integer info
        "= 0/1/2 success/infinity(z is a large value)/indefinite (0/0; z=0)";
  protected
      Integer nn = size(n,1);
      Integer nd = size(d,1);
      Real n_abs[nn];
      Real n_abs2[nn];
      Real n_phi[nn];
      Real d_abs[nd];
      Real d_abs2[nd];
      Real d_phi[nd];
      Real wr;
      Real wi;
      Real wr_abs;
      Real wi_abs;
      Boolean n_zero = false;
      Boolean d_zero = false;
      Real z_abs;
      Real z_phi;
      constant Real pi = Modelica.Constants.pi;
      constant Real pi2 = 2*pi;
    algorithm
      // Transform elements of n to polar form
      for i in 1:nn loop
        wr :=n[i].re;
        wi :=n[i].im;
        wr_abs :=abs(wr);
        wi_abs :=abs(wi);
        if wr_abs == 0 and wi_abs == 0 then
          n_abs[i] :=0;
          n_phi[i] :=0;
          n_zero :=true;
        else
          n_abs[i] :=if wr_abs > wi_abs then wr_abs*sqrt(1 + (wi/wr)^2) else wi_abs*sqrt(1 + (wr/wi)^2);
          n_phi[i] :=atan2(wi, wr);
        end if;
      end for;

      // Transform elements of d to polar form
      for i in 1:nd loop
        wr :=d[i].re;
        wi :=d[i].im;
        wr_abs :=abs(wr);
        wi_abs :=abs(wi);
        if wr_abs == 0 and wi_abs == 0 then
          d_abs[i] :=0;
          d_phi[i] :=0;
          d_zero :=true;
        else
          d_abs[i] :=if wr_abs > wi_abs then wr_abs*sqrt(1 + (wi/wr)^2) else wi_abs*sqrt(1 + (wr/wi)^2);
          d_phi[i] :=atan2(wi, wr);
        end if;
      end for;

      // Handle zeros in n
      if n_zero then
        z :=Complex(0, 0);
        info :=if d_zero then 2 else 0;
        return;
      end if;

      // Compute angle of fraction
      z_phi :=0;
      if nn <= nd then
        for i in 1:nn loop
          z_phi := z_phi + n_phi[i] - d_phi[i];
        end for;

        for i in nn+1:nd loop
          z_phi := z_phi - d_phi[i];
        end for;
      else
        for i in 1:nd loop
          z_phi := z_phi + n_phi[i] - d_phi[i];
        end for;

        for i in nd+1:nn loop
          z_phi := z_phi + n_phi[i];
        end for;
      end if;

      // Compute absolute value (avoid overflow)
      if d_zero then
        info :=1;
        z_abs :=Modelica.Constants.inf;
      else
        info :=0;
        if nn > 0 then
          n_abs2 :=Modelica.Math.Vectors.sort(n_abs, ascending=false);
        end if;
        if nd > 0 then
          d_abs2 :=Modelica.Math.Vectors.sort(d_abs, ascending=false);
        end if;
        z_abs := 1;

        if nn <= nd then
          for i in 1:nn loop
            z_abs :=z_abs*(n_abs2[i]/d_abs2[i]);
          end for;
          for i in nn+1:nd loop
            z_abs :=z_abs/d_abs2[i];
          end for;
        else
          for i in 1:nd loop
            z_abs :=z_abs*(n_abs2[i]/d_abs2[i]);
          end for;
          for i in nd+1:nn loop
            z_abs :=z_abs*n_abs2[i];
          end for;
        end if;
      end if;

      // Transform polar in Cartesian description
      z.re :=z_abs*cos(z_phi);
      z.im :=z_abs*sin(z_phi);
    end complexFraction;

    function balanceABC "Return a balanced form of a system [A,B;C,0] to improve its condition by a state transformation (this function is provided in the trunk version
  of MSL and will be removed once Modelica_LinearSystems2 is based on the next MSL version)"
      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "System matrix A";
      input Real B[size(A,1),:] = fill(0.0, size(A,1),0)
        "System matrix B (need not be present)";
      input Real C[:,size(A,1)] = fill(0.0, 0, size(A,1))
        "System matrix C (need not be present)";
      output Real scale[size(A, 1)]
        "diagonal(scale)=T is such that [inv(T)*A*T, inv(T)*B; C*T, 0] has smaller condition as [A,B;C,0]";
      output Real As[size(A, 1), size(A, 1)] "Balanced matrix A (= inv(T)*A*T )";
      output Real Bs[size(A, 1), size(B, 2)] "Balanced matrix B (= inv(T)*B )";
      output Real Cs[size(C, 1), size(A, 1)] "Balanced matrix C (= C*T )";

  protected
      Integer na=size(A, 1);
      Integer radix=2 "Radix of exponent representation must be 'radix'
          or a multiple of 'radix'";
      Integer radix2=radix*radix;
      Boolean noconv=true;
      Integer i=1;
      Integer j=1;
      Real CO;
      Real RO;
      Real G;
      Real F;
      Real S;
    algorithm
      scale := ones(na);
      As := A;
      Bs := B;
      Cs := C;
      while noconv loop
        noconv := false;
        for i in 1:na loop
          CO := sum(abs(As[:, i])) - abs(As[i, i]) + sum(abs(Cs[:,i]));
          RO := sum(abs(As[i, :])) - abs(As[i, i]) + sum(abs(Bs[i,:]));
          G := RO/radix;
          F := 1;
          S := CO + RO;
          while not (CO >= G or CO == 0) loop
            F := F*radix;
            CO := CO*radix2;
          end while;
          G := RO*radix;
          while not (CO < G or RO == 0) loop
            F := F/radix;
            CO := CO/radix2;
          end while;
          if not ((CO + RO)/F >= 0.95*S) then
            G := 1/F;
            scale[i] := scale[i]*F;
            As[i, :] := As[i, :]*G;
            As[:, i] := As[:, i]*F;
            Bs[i, :] := Bs[i, :]*G;
            Cs[:, i] := Cs[:, i]*F;
            noconv := true;
          end if;
        end for;
      end while;
      annotation (Documentation(info="<HTML><

<h4>Syntax</h4>
<blockquote><pre>
(scale,As,Bs,Cs) = Matrices.<b>balanceABC</b>(A,B,C);
(scale,As,Bs)    = Matrices.<b>balanceABC</b>(A,B);
(scale,As,,Cs)   = Matrices.<b>balanceABC</b>(A,C=C);
</pre></blockquote>

<h4>Description</h4>

<p>
This function returns a vector scale, such that with T=diagonal(scale) system matrix S_scale
</p>

<pre>             |inv(T)*A*T, inv(T)*B|
   S_scale = |                    |
             |       C*T,     0   |
</pre>

<p>
has a better condition as system matrix S
</p>

<pre>       |A, B|
   S = |    |
       |C, 0|
</pre>
that is, conditionNumber(S_scale) &le; conditionNumber(S). The elements of vector scale
are multiples of 2 which means that this function does not introduce round-off errors.
</p>

<p>
Balancing a linear dynamic system in state space form
</p>

<pre>  der(x) = A*x + B*u
      y  = C*x + D*u
</pre>

<p>
means to find a state transformation x_new = T*x = diagonal(scale)*x
so that the transformed system is better suited for numerical algorithms.
</p>

<h4>Example</h4>

<blockquote>
<pre>import Modelica.Math.Matrices;

A = [1, -10,  1000; 0.01,  0,  10; 0.005,  -0.01,  10];
B = [100, 10; 1,0; -0.003, 1];
C = [-0.5, 1, 100];

(scale, As, Bs, Cs) := Matrices.balanceABC(A,B,C);
T    = diagonal(scale);
Diff = [Matrices.inv(T)*A*T, Matrices.inv(T)*B;
        C*T, zeros(1,2)] - [As, Bs; Cs, zeros(1,2)];
err  = Matrices.norm(Diff);

-> Results in:
scale = {16, 1, 0.0625}
norm(A)  = 1000.15, norm(B)  = 100.504, norm(C)  = 100.006
norm(As) = 10.8738, norm(Bs) = 16.0136, norm(Cs) = 10.2011
err = 0
</pre>
</blockquote>

<p>
The algorithm is taken from
</p>
<dl>
<dt>H. D. Joos, G. Grbel:
<dd><b>RAsP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
<p>
which is based on the <code>balance</code> function from EISPACK.
</p>
</html>",   revisions="<html>
<ul>
<li><i>Sept. 14, 2014</i>
       by Martin Otter: Implemented.
</li>
</ul>
</html>"));
    end balanceABC;
    annotation (Documentation(info="<html>
<p>
Generally, the functions in this package should not be used by the user.
</p>
<p>
This package contains models, functions and parameters designed
to build up other models of higher level within the library.
Some of them cannot be used in an arbitrary way and require
particular knowledge how to set the options in the parameter menu.
Therefore, only advanced users should deal with contained classes.
</p>
</html>"));
  end Internal;

  constant String DataDir=classDirectory() +  "Resources/Data/"
  "Absolute path to directory containing utilitiy files for this package";
annotation (
  preferredView="info",
  uses(Modelica(version="4.0.0")),
  version="2.4.0",
  versionDate="2020-06-26",
  dateModified = "2020-06-26 14:00:00Z",
  revisionId="$Id::                                       $",
  conversion(
    from(version={"2.0", "2.1", "2.2", "2.3", "2.3.1", "2.3.2", "2.3.2", "2.3.3", "2.3.4"},
      script="modelica://Modelica_LinearSystems2/Resources/Scripts/Conversion/ConvertLinearSystems2_from_2.3.4.mos", to="2.3.5"),
    from(version="2.3.5",
      script="modelica://Modelica_LinearSystems2/Resources/Scripts/Conversion/ConvertLinearSystems2_from_2.3.5.mos")),
  Documentation(info="<html>
<p>
Library <b>Modelica_LinearSystems2</b> is a Modelica package
providing different representations of linear, time invariant differential and
difference equation systems. For example, record
<a href=\"modelica://Modelica_LinearSystems2.StateSpace\">StateSpace</a>
defines a linear time invariant differential
equation system in state space form:
</p>
<blockquote><pre>
der(<b>x</b>) = <b>A</b> * <b>x</b> + <b>B</b> * <b>u</b>
    <b>y</b>  = <b>C</b> * <b>x</b> + <b>D</b> * <b>u</b>
</pre></blockquote>
<p>
Operators are overloaded to work conveniently with these system descriptions in an
interactive environment, e.g. to multiply transfer functions or to operate on complex numbers.
About 180 functions are provided to operate
on these data structures, e.g. to compute eigenvalues, zeros, step responses,
to design pole-placement and LQG controllers, to plot step responses, frequency responses,
eigenvalues, to convert between different description forms, or to
generate a linear system description by linearization of a Modelica model.
</p>

<p>
Furthermore, in subpackage
<a href=\"modelica://Modelica_LinearSystems2.Controller\">Controller</a>
about 20 input/output blocks of linear systems are provided that are
based on the different representation forms, e.g. PID, StateSpace, Filter blocks.
A unique feature of these blocks is that it is very convenient to quickly switch
between a continuous and a discrete block representation. Also, templates are provided
to quickly built-up standard controller structures.
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica_LinearSystems2.UsersGuide.GettingStarted\">Getting started</a>
     provides an overview of the Library in
     the <a href=\"modelica://Modelica_LinearSystems2.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica_LinearSystems2.UsersGuide.ReleaseNotes\">Release Notes</a>
     summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica_LinearSystems2.UsersGuide.Contact\">Contact</a>
     gives the contact information for this library.</li>
<li> In an interactive environment, it is useful to run first the script
     &quot;_abbreviations.mos&quot; in directory
     &quot;Modelica_LinearSystems2/Resources/Scripts&quot;
     in order to set useful abbreviations: ss, tf, zp, poly, Complex, Plot, s, p, j.</li>
</ul>

<p>
It is planned to include this library in a future version of the
Modelica Standard Library.
</p>


<p>
<strong>Licensed by DLR under the 3-Clause BSD License</strong><br>
</p>

<table border=\"0\" cellpadding=\"2\" cellspacing=\"2\">
<tr>
  <td colspan=\"1\" rowspan=\"2\" style=\"vertical-align: middle;\">
    <img src=\"modelica://Modelica_LinearSystems2/Resources/Images/dlr_logo.png\">
  </td>
  <td style=\"vertical-align: top;\"><b>Copyright &copy; 2005-2012, DLR Institute of Robotics and Mechatronics</b></td>
</tr>
<tr>
  <td style=\"vertical-align: top;\"><b>Copyright &copy; 2012-2020, DLR Institute of System Dynamics and Control</b></td>
</tr>
</table>

<p>
<em>
This Modelica package is <u>free</u> software and
the use is completely at <u>your own risk</u>;
it can be redistributed and/or modified under the terms of the
3-Clause BSD license, see the license conditions (including the
disclaimer of warranty) in the
<a href=\"modelica://Modelica_LinearSystems2.UsersGuide.The3clauseBSDLicense\">User's Guide</a>.
</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica_LinearSystems2;

package DataFiles "Functions for reading and writing data files"

  function readMATmatrix "Read a matrix from a mat-file"
    input String fileName "File containing the matrix, e.g. A.mat, dsin.txt";
    input String matrixName "Name of the matrix on the file";
    output Real matrix[readMatrixSize(fileName, matrixName)*{1,0}, readMatrixSize(fileName, matrixName)*{0,1}]=readMatrix(fileName, matrixName, readMatrixSize(fileName, matrixName)*{1,0}, readMatrixSize(fileName, matrixName)*{0,1});
  algorithm

    annotation (Documentation(info="<html>
<p>
Reads a matrix from a mat-file and returns the data as a matrix of Modelica type Real.
</p>
<p>
<b>Example</b>
</p>
<p>
In the online documentation for <a href=\"writeMATmatrix\">writeMATmatrix</a> it is described how to store
two matrices, A and B, in a mat-file, \"Mydata.mat\". To read, for example, the matrix A from this file we execute
<pre>
DataFiles.readMATmatrix(\"Mydata.mat\", \"A\")
</pre>
 = 
[1.0, 2.0;<br>
&#160;&#160;&#160;&#160;3.0, 4.0]
</p>
<p>
or if we want to read the B matrix
<pre>
DataFiles.readMATmatrix(\"Mydata.mat\", \"B\")
</pre>
 = 
[5.0, 6.0;<br>
&#160;&#160;&#160;&#160;7.0, 8.0]
</p>
<p>
Note:<br>
Only numeric values can be read from file.
</p>
</html>"));
  end readMATmatrix;

  function writeMATmatrix "Write a matrix to a mat-file"
    input String fileName "File that will contain the matrix, e.g. A.mat";
    input String matrixName "Name of the matrix in the file";
    input Real matrix[:, :]
    "Data to be written, use [A] to convert vector or scalar to matrix";
    input Boolean append=false "Append data to file";
    output Boolean status "true if successful";

    // Write one real-valued matrix expression to a file.
    // Vectors and scalar expression must be converted by enclosing them in [].
    // Arrays of matrices cannot currently be written.
    // The file format is Matlab v4

  algorithm
    status := writeMatrix(fileName, matrixName, matrix, append);

    annotation (Documentation(info="<html>
<p>
Write a matrix to a mat-file in file format Matlab v4.
 
The function writes one real-valued matrix expression to a file.
<br>Vectors and scalar expression must be converted by enclosing them in brackets, \"[ ]\".
</p>
<p>
Note:
<br>Arrays of matrices cannot currently be written.
</p>
<p>
<b>Example</b>
</p>
<p>
As an example, consider writing the matrix
<pre>
A = [1, 2;
     3, 4] 
</pre>
to a mat-file, \"Mydata.mat\". This can be done by executing
</p>
<pre>
DataFiles.writeMATmatrix(\"Mydata.mat\", \"A\", [1, 2; 3, 4]);
</pre>
<p>
The argument <b>append</b> is used to append data to an existing file.
 
As an example, consider adding the matrix
<pre>
B = [5, 6;
     7, 8] 
</pre>
to the file \"Mydata.mat\". This is done by executing
<pre>
DataFiles.writeMATmatrix(\"Mydata.mat\", \"B\", [5, 6; 7, 8], true);
</pre>
Note that <b>append</b> now is set to <tt>true</tt> (the last argument). This means that \"Mydata.mat\" now
contains both matrix A and matrix B. If <b>append</b> was set to <tt>false</tt> then \"Mydata.mat\" would be 
overwritten and only contain the matrix B. 
</p>
</html>"));
  end writeMATmatrix;

  function readCSVHeaders
  "Read headers from a text file with comma separated values (CSV)"
    input String fileName "File to examine";
    output String headers[readCSVsizes(fileName)*{0,1,0,0}]
    "Use numbers 1,2,3, if empty";
  algorithm
    headers := readCSVHeadersInternal(fileName);
    for i in 1:size(headers, 1) loop
      if headers[i] == "" then
        headers[i] := String(i);
      end if;
    end for;

    annotation (Include="#include <csvutil.c>", Documentation(info="<html>
<p>
Function to read headers from a CSV file. If no headers are available, 1, 2, 3 ... is returned.
</p>
<p>
<b>Example</b>
</p>
<p>
To demonstrate this function, we manually create a small CSV file to use as an example. 
Using a text editor we create a file with the data
<pre>
Time, Value
0, 10 
1, 20 
2, 30 
3  40 
4, 50 
5, 60 
</pre>
and store it as \"MyData.csv\". We can now read the headers by executing
<pre>
DataFiles.readCSVHeaders(\"MyData.csv\");
</pre>
 = {\"Time\", \"Value\"}
</p>
<p>
The function retruns the headers from the first row; \"Time\" and \"Value\".
</p>
</html>"));
  end readCSVHeaders;

  function readCSVmatrix
  "Read matrix from a text file with comma separated values (CSV)"
    input String fileName "File containing the data";
    output Real matrix[readCSVsizes(fileName)*{1,0,0,0}, readCSVsizes(fileName)*{0,1,0,0}];
  algorithm
    matrix := readCSVmatrixInternal(fileName, readCSVsizes(fileName)*{1,0,0,0}, readCSVsizes(fileName)*{0,1,0,0});
    annotation (Include="#include <csvutil.c>", Documentation(info="<html>
<p>
Reads a matrix from a text file with comma separated values and returns the data as a matrix of Modelica type Real.
</p>
<p>
<b>Example</b>
</p>
<p>
As an example consider reading the matrix stored in the csv-file \"MyData.csv\" (described in the online documentation
for <a href=\"readCSVHeaders\">readCSVHeaders</a>).<br>
Executing
<pre>
DataFiles.readCSVmatrix(\"MyData.csv\")
</pre>
 =
[0, 10.0;<br>
&#160;&#160;&#160;  1, 20.0;<br>
&#160;&#160;&#160;  2, 30.0;<br>
&#160;&#160;&#160;  3.0, 40.0;<br>
&#160;&#160;&#160;  4.0, 50.0;<br>
&#160;&#160;&#160;  5.0, 60.0]
</p>
<p>
returns the matrix stored in \"MyData.csv\".
</p>
</html>"));
  end readCSVmatrix;

  function writeCSVmatrix
  "Write matrix to a text file with comma separated values (CSV)"
    input String fileName "File containing the data";
    input String headers[:] "Headers to write";
    input Real data[:, size(headers, 1)] "Data to write";
    input String separator=";" "Separator used";
    input Boolean quoteAllHeaders=false "Quote all outputed headers";
protected
    Boolean ok;
  algorithm
    ok := writeCSVFileInternal(fileName, headers, data, separator,quoteAllHeaders);
    assert(ok, "Writing of csv-file: " + fileName);
    annotation (Include="#include <csvutil.c>", Documentation(info="<html>
<p>
Function to write a text file with comma separated values.
</p>
<p>
<b>Example</b>
</p>
<p>
Consider the data described in <a href=\"readCSVHeaders\">readCSVHeaders</a>, i.e.
<pre>
Time, Value
0, 10 
1, 20 
2, 30 
3, 40 
4, 50 
5, 60 
</pre>
To store this data in a CSV-file named \"MyData.csv\" (using \",\" as separator), we execute
<pre>
DataFiles.writeCSVmatrix(\"MyData.csv\", {\"Time\", \"Value\"}, [0, 10; 1, 20; 2, 30; 3, 40; 4, 50; 5, 60], \",\");
</pre>
</p>
</html>"));
  end writeCSVmatrix;

  function readCSVsizes "Read sizes from a CSV text file"
    input String fileName "File containing the data";
    output Integer sizes[4]
    "Number of rows, columns, row legends, column legends";
    // sizes[3] = if text_in_first_column then sizes[1] else 0
    // sizes[4] = if text_in_first_row then sizes[2] else 0
  external"built-in";
    annotation (Include="#include <csvutil.c>");
  end readCSVsizes;

  function readCSVmatrixInternal
  "Read data from a text file with comma separated values"
    input String fileName "File containing the data";
    input Integer nRows;
    input Integer nColumns;
    output Real matrix[nRows, nColumns];
  external"built-in";
    annotation (Include="#include <csvutil.c>");
  end readCSVmatrixInternal;

  function writeCSVFileInternal
  "Writes data to a text file with comma separated values"
    input String fileName "File containing the data";
    input String headers[:];
    input Real data[:, size(headers, 1)];
    input String separator=";";
    input Boolean quoteAllHeaders=false;
    output Boolean ok;
  external"built-in";
    annotation (Include="#include <csvutil.c>");
  end writeCSVFileInternal;

  function readCSVHeadersInternal
    input String fileName "File to examine";
    output String headers[:] "Numbered if no name ";
  external"built-in" readCSVHeadersInternal(headers, fileName);
  end readCSVHeadersInternal;
  annotation (
    Documentation(revisions="<html>
<ul>
<li>2004-06-28 First version. </li>
<li>2005-05-23 readMATmatrices and readCSVHeaders added. </li>
<li>2005-06-08 writeCSVmatrix added. </li>
</ul>
<p>Version 1.0.2</p>
<ul>
<li>2014-08-26 Introduced new funciton convertMATtoCSV</li>
</ul>
<p>Version 1.0.3</p>
<ul>
<li>2014-09-16 New input quoteAllHeaders for function converMATtoCSV and writeCSVMatrix</li>
</ul>
<p>Version 1.0.4</p>
<ul>
<li>2016-02-10 Updated to MSL 3.2.2</li>
</ul>
<p>Version 1.0.5</p>
<ul>
<li>2019-02-27 Updated to MSL 3.2.3</li>
</ul>
<p>Version 1.1.0</p>
<ul>
<li>2020-06-23 Updated to MSL 4.0.0</li>
</ul>
<p>&copy; Copyright 2001-2019 by Dassault Systemes. All rights reserved. </p>
</html>", info="<html><p>The <code>DataFiles</code> package contains functions for reading and writing data files in mat-format or comma separated values (CSV) in text files. </p><p><b>Notes:</b> </p><p>CSV (comma separated values) data files: </p><p><ul>
<li>The first row may contain column text legends. </li><li>The first column may contain row text legends. </li><li>The numeric data is separated by either &QUOT;;&QUOT;, &QUOT;,&QUOT; or tab. </li>
</ul></p></html>"),
    version="1.1.0",
    versionDate="2020-06-23",
    dateModified="2020-06-23 08:20:00Z",
    uses(Modelica(version="4.0.0")),
    conversion(noneFromVersion="1.0.4"));
end DataFiles;

package Utilities

  function ModelicaMessage
    input String msg="";
    output Boolean result;
  external "C";
  end ModelicaMessage;
end Utilities;

operator record Complex "Complex number with overloaded operators"

  replaceable Real re "Real part of complex number" annotation(Dialog);
  replaceable Real im "Imaginary part of complex number" annotation(Dialog);

  encapsulated operator 'constructor' "Constructor"
    function fromReal "Construct Complex from Real"
      import Complex;
      input Real re "Real part of complex number";
      input Real im=0 "Imaginary part of complex number";
      output Complex result(re=re, im=im) "Complex number";
    algorithm

      annotation(Inline=true, Documentation(info="<html>
<p>This function returns a Complex number defined by real part <em>re</em> and optional imaginary part <em>im</em> (default=0).</p>
</html>"));
    end fromReal;
    annotation (Documentation(info="<html>
<p>Here the constructor operator(s) is/are defined.</p>
</html>"), Icon(graphics={Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0), Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0)}));
  end 'constructor';

  encapsulated operator function '0' "Zero-element of addition (= Complex(0))"
    import Complex;
    output Complex result "Complex(0)";
  algorithm
    result := Complex(0);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the zero-element of Complex, that is, Complex(0) = 0 + j*0.</p>
</html>"));
  end '0';

  encapsulated operator '-' "Unary and binary minus"
    function negate "Unary minus (multiply complex number by -1)"
      import Complex;
      input Complex c1 "Complex number";
      output Complex c2 "= -c1";
    algorithm
      c2 := Complex(-c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the binary minus of the given Complex number.</p>
</html>"));
    end negate;

    function subtract "Subtract two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1 - c2";
    algorithm
      c3 := Complex(c1.re - c2.re, c1.im - c2.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the difference of two given Complex numbers.</p>
</html>"));
    end subtract;
    annotation (Documentation(info="<html>
<p>Here the unary and binary minus operator(s) is/are defined.</p>
</html>"), Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
              {100,100}}), graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-50,0},{50,0}})}));
  end '-';

  encapsulated operator '*' "Multiplication"
    function multiply "Multiply two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 := Complex(c1.re*c2.re - c1.im*c2.im, c1.re*c2.im + c1.im*c2.re);

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the product of two given Complex numbers.</p>
</html>"));
    end multiply;

    function scalarProduct "Scalar product c1*c2 of two complex vectors"
      import Complex;
      input Complex c1[:] "Vector of Complex numbers 1";
      input Complex c2[size(c1,1)] "Vector of Complex numbers 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 :=Complex(0);
      for i in 1:size(c1,1) loop
         c3 :=c3 + c1[i]*c2[i];
         /*
       c3 :=Complex(c3.re + c1[i].re*c2[i].re - c1[i].im*c2[i].im,
                    c3.im + c1[i].re*c2[i].im + c1[i].im*c2[i].re);
       */
      end for;

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the scalar product of two given arrays of Complex numbers.</p>
</html>"));
    end scalarProduct;
    annotation (
      Documentation(info="<html>
<p>Here the multiplication operator(s) is/are defined.</p>
</html>"),
      Icon(coordinateSystem(
          preserveAspectRatio=false,
          extent={{-100,-100},{100,100}}),
          graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-42,36},{39,-34}}),
          Line(
            points={{-42,-35},{39,37}}),
          Line(
            points={{-55,1},{52,1}}),
          Line(
            points={{-1.5,55},{-2,-53}})}));
  end '*';

  encapsulated operator function '+' "Add two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1 + c2";
  algorithm
    c3 := Complex(c1.re + c2.re, c1.im + c2.im);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the sum of two given Complex numbers.</p>
</html>"));
  end '+';

  encapsulated operator function '/' "Divide two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1/c2";
  algorithm
    c3 := Complex((+c1.re*c2.re + c1.im*c2.im)/(c2.re*c2.re + c2.im*c2.im),
                  (-c1.re*c2.im + c1.im*c2.re)/(c2.re*c2.re + c2.im*c2.im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the quotient of two given Complex numbers.</p>
</html>"));
  end '/';

  encapsulated operator function '^' "Complex power of complex number"
    import Complex;
    input Complex c1 "Complex number";
    input Complex c2 "Complex exponent";
    output Complex c3 "= c1^c2";
  protected
    Real lnz=0.5*log(c1.re*c1.re + c1.im*c1.im);
    Real phi=atan2(c1.im, c1.re);
    Real re=lnz*c2.re - phi*c2.im;
    Real im=lnz*c2.im + phi*c2.re;
  algorithm
    c3 := Complex(exp(re)*cos(im), exp(re)*sin(im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the given Complex numbers c1 to the power of the Complex number c2.</p>
</html>"));
  end '^';

  encapsulated operator function '=='
    "Test whether two complex numbers are identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 == c2";
  algorithm
    result := c1.re == c2.re and c1.im == c2.im;
    annotation(Inline=true, Documentation(info="<html>
<p>This function tests whether two given Complex numbers are equal.</p>
</html>"));
  end '==';

  encapsulated operator function '<>'
    "Test whether two complex numbers are not identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 <> c2";
  algorithm
    result := c1.re <> c2.re or c1.im <> c2.im;
    annotation(Inline=true, Documentation(info="<html>
    <p>This function tests whether two given Complex numbers are not equal.</p>
</html>"));
  end '<>';

  encapsulated operator function 'String'
    "Transform Complex number into a String representation"
    import Complex;
    input Complex c
      "Complex number to be transformed in a String representation";
    input String name="j"
      "Name of variable representing sqrt(-1) in the string";
    input Integer significantDigits=6
      "Number of significant digits that are shown";
    output String s="";
  algorithm
    s := String(c.re, significantDigits=significantDigits);
    if c.im <> 0 then
      if c.im > 0 then
        s := s + " + ";
      else
        s := s + " - ";
      end if;
      s := s + String(abs(c.im), significantDigits=significantDigits) + "*" + name;
    end if;
    annotation(Inline=true, Documentation(info="<html>
<p>This function converts a given Complex number to String representation.</p>
</html>"));
  end 'String';

annotation (
version="4.0.0",
versionDate="2020-06-04",
dateModified = "2020-06-04 11:00:00Z",
revisionId="6626538a2 2020-06-04 19:56:34 +0200",
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="1.0",
 noneFromVersion="1.1"),
Documentation(info="<html>
<p>Complex number defined as a record containing real and imaginary part, utilizing operator overloading.</p>
<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 2010-2020, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p></html>"),
    Icon(graphics={Rectangle(
          lineColor={160,160,164},
          fillColor={160,160,164},
          fillPattern=FillPattern.Solid,
          extent={{-100,-100},{100,100}},
          radius=25.0), Text(
          textColor={255,255,255},
          extent={{-90,-50},{90,50}},
          textString="C")}));

end Complex;

package SMIBPS_IdControl "A Tutorial on Power System Stability and Control"

  package Analysis
    extends Modelica.Icons.ExamplesPackage;

    package Simulation
      extends Modelica.Icons.ExamplesPackage;

      model SMIB_AVR_PSS
          extends Modelica.Icons.Example;
        extends BaseModelsPartial.BaseNetwork.SMIB_Partial(powerFlow_Data(
            redeclare record Bus = PF_Data.Bus_Data.PF_Bus_8,
            redeclare record Loads = PF_Data.Loads_Data.PF_Loads_8,
            redeclare record Trafos = PF_Data.Trafos_Data.PF_Trafos_8,
            redeclare record Machines = PF_Data.Machines_Data.PF_Machines_8),
            load_ExtInput(
            d_P=0,
            t1=0,
            d_t=0),
          fault(t2=0.5 + 5/60));
        import Modelica.Constants.pi;
        BaseModelsPartial.BasePlants.Generator_AVR_PSS G1(
          V_0=powerFlow_Data.bus.V1,
          P_0=powerFlow_Data.machines.PG1,
          Q_0=powerFlow_Data.machines.QG1,
          angle_0=powerFlow_Data.bus.A1)
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
        Modelica.Blocks.Sources.Constant const(k=0)
          annotation (Placement(transformation(extent={{0,-70},{8,-62}})));
    protected
        parameter Real S_b=SysData.S_b;
      equation
        connect(const.y, load_ExtInput.u) annotation (Line(points={{8.4,-66},{10,
                -66},{10,-66.7},{17.14,-66.7}}, color={0,0,127}));
        connect(G1.pwPin, B1.p)
          annotation (Line(points={{-99,0},{-80,0}}, color={0,0,255}));
        annotation (
          Diagram(coordinateSystem(extent={{-140,-100},{120,100}},
                preserveAspectRatio=false), graphics={Text(
                extent={{-112,64},{108,44}},
                lineColor={0,0,0},
                lineThickness=1,
                fillPattern=FillPattern.Solid,
                fontSize=15,
                textStyle={TextStyle.Bold},
                textString="(AVR + PSS)")}),
          Icon(coordinateSystem(extent={{-140,-100},{120,100}})),
          experiment(
            StopTime=10,
            Interval=0.0001,
            Tolerance=1e-006,
            __Dymola_fixedstepsize=0.0001,
            __Dymola_Algorithm="Rkfix2"),
          __Dymola_experimentSetupOutput,
          Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td><p>SMIB PSAT, d_kundur2.mdl, PSAT</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>February 2016</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Maxime Baudette, Ahsan Murad, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
      end SMIB_AVR_PSS;
    end Simulation;
  end Analysis;

  package BaseModelsPartial "Partial Models - Cannot be simulated!"
    extends Modelica.Icons.BasesPackage;

    package BasePlants
      extends Modelica.Icons.BasesPackage;

      model Generator_AVR_PSS
        extends OpenIPSL.Electrical.Essentials.pfComponent;
        OpenIPSL.Electrical.Machines.PSAT.Order6 machine(
          Vn=400,
          V_b=V_b,
          ra=0.003,
          xd=1.81,
          xq=1.76,
          x1d=0.3,
          x1q=0.65,
          x2d=0.23,
          x2q=0.25,
          T1d0=8,
          T1q0=1,
          T2d0=0.03,
          T2q0=0.07,
          M=7,
          D=0,
          P_0=P_0,
          Q_0=Q_0,
          V_0=V_0,
          angle_0=angle_0,
          Sn=2220,
          Taa=0) annotation (Placement(transformation(extent={{14,-30},{74,30}})));
        OpenIPSL.Interfaces.PwPin pwPin annotation (Placement(transformation(extent={
                  {100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,10}})));
        OpenIPSL.Electrical.Controls.PSAT.AVR.AVRtypeIII avr(
          vfmax=7,
          vfmin=-6.40,
          K0=200,
          T2=1,
          T1=1,
          Te=0.0001,
          Tr=0.015) annotation (Placement(transformation(extent={{-52,-4},{-12,36}})));
        OpenIPSL.Electrical.Controls.PSAT.PSS.PSSTypeII pss(
          vsmax=0.2,
          vsmin=-0.2,
          Kw=9.5,
          Tw=1.41,
          T1=0.154,
          T2=0.033,
          T3=1,
          T4=1) annotation (Placement(transformation(extent={{-84,-2},{-64,18}})));
      equation
        connect(machine.pm0, machine.pm) annotation (Line(points={{20,-33},{20,-33},{
                20,-40},{0,-40},{0,-15},{8,-15}},  color={0,0,127}));
        connect(machine.p, pwPin) annotation (Line(points={{74,0},{78.5,0},{78.5,0},{
                110,0}},           color={0,0,255}));
        connect(avr.vf, machine.vf) annotation (Line(points={{-10.3333,16},{2,16},
                {2,15},{8,15}},
                         color={0,0,127}));
        connect(machine.v, avr.v) annotation (Line(points={{77,9},{88,9},{88,52},
                {-50.3333,52},{-50.3333,26}},
                               color={0,0,127}));
        connect(pss.vs, avr.vs)
          annotation (Line(points={{-63,8},{-63,6},{-50.3333,6}},
                                                             color={0,0,127}));
        connect(machine.vf0, avr.vf0) annotation (Line(points={{20,33},{-6,33},{
                -6,44},{-32,44},{-32,34.3333}},
                                         color={0,0,127}));
        connect(machine.w, pss.vSI) annotation (Line(points={{77,27},{77,-54},{-98,
                -54},{-98,8},{-85,8}}, color={0,0,127}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),Line(
                points={{-48,2},{-20,56},{2,4},{24,-28},{48,22}},
                color={0,0,0},
                smooth=Smooth.Bezier),Text(
                extent={{-52,-18},{56,-66}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="%name")}),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}})),
          Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td><p>SMIB PSAT, d_kundur2.mdl, PSAT</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>February 2016</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Maxime Baudette, Ahsan Murad, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
      end Generator_AVR_PSS;
    annotation (Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td><p>SMIB PSAT, d_kundur2.mdl, PSAT</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>February 2016</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Maxime Baudette, Ahsan Murad, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
    end BasePlants;

    package BaseNetwork
      extends Modelica.Icons.BasesPackage;

      partial model SMIB_Base "Partial model containing the network elements"
        import Modelica.Constants.pi;
        OpenIPSL.Electrical.Branches.PSAT.TwoWindingTransformer transformer(
          Sn=2220,
          x=0.15,
          r=0,
          V_b=400,
          Vn=400) annotation (Placement(transformation(extent={{-66,-10},{-46,10}})));
        OpenIPSL.Electrical.Branches.PwLine line_1(
          R=0,
          G=0,
          B=0,
          X=0.5) annotation (Placement(transformation(extent={{22,14},{40,26}})));
        OpenIPSL.Electrical.Buses.InfiniteBus infinite_bus(angle_0=0, V_0=
              0.900810000000000) annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=0,
              origin={110,0})));
        OpenIPSL.Electrical.Branches.PwLine line_2(
          R=0,
          G=0,
          B=0,
          X=0.93/2)
          annotation (Placement(transformation(extent={{-2,-46},{16,-34}})));
        inner OpenIPSL.Electrical.SystemBase SysData(S_b=2220, fn=60)
          annotation (Placement(transformation(extent={{-140,80},{-86,100}})));
        OpenIPSL.Electrical.Branches.PwLine line_3(
          R=0,
          G=0,
          B=0,
          X=0.93/2,
          opening=1)
          annotation (Placement(transformation(extent={{44,-46},{62,-34}})));
        OpenIPSL.Electrical.Buses.Bus    B1(V_b=400)
          annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        OpenIPSL.Electrical.Buses.Bus    B2(
          V_b=400)
          annotation (Placement(transformation(extent={{10,10},{-10,-10}},
              rotation=180,
              origin={-30,0})));
        OpenIPSL.Electrical.Buses.Bus    B3(V_b=400)
          annotation (Placement(transformation(extent={{10,10},{-10,-10}},
              rotation=180,
              origin={82,0})));
        OpenIPSL.Electrical.Buses.Bus    B4(
          V_b=400)
                annotation (Placement(transformation(extent={{18,-50},{38,-30}})));

    protected
        parameter Real S_b=SysData.S_b;
      equation
        connect(line_2.p, line_1.p) annotation (Line(points={{-1.1,-40},{-10,-40},
                {-10,20},{22.9,20}},
                               color={0,0,255}));
        connect(transformer.n, B2.p) annotation (Line(points={{-45,0},{-38,0},{
                -38,4.44089e-16},{-30,4.44089e-16}}, color={0,0,255}));
        connect(B2.p, line_1.p) annotation (Line(points={{-30,0},{-10,0},{-10,20},
                {22.9,20}}, color={0,0,255}));
        connect(B3.p, infinite_bus.p) annotation (Line(points={{82,4.44089e-16},{
                81,4.44089e-16},{81,0},{100,0}}, color={0,0,255}));
        connect(line_1.n, B3.p) annotation (Line(points={{39.1,20},{70,20},{70,0},
                {82,0},{82,4.44089e-16}}, color={0,0,255}));
        connect(line_3.n, B3.p) annotation (Line(points={{61.1,-40},{70,-40},{70,
                4.44089e-16},{82,4.44089e-16}}, color={0,0,255}));
        connect(B4.p, line_3.p)
          annotation (Line(points={{28,-40},{44.9,-40}}, color={0,0,255}));
        connect(B4.p, line_2.n)
          annotation (Line(points={{28,-40},{15.1,-40}}, color={0,0,255}));
        connect(B1.p, transformer.p)
          annotation (Line(points={{-80,0},{-67,0}}, color={0,0,255}));
        annotation (
          Diagram(coordinateSystem(extent={{-140,-100},{120,100}},
                preserveAspectRatio=false), graphics={Text(
                extent={{-110,80},{110,60}},
                lineColor={0,0,0},
                lineThickness=1,
                fontSize=15,
                textStyle={TextStyle.Bold},
                textString="Single-machine infinite bus model*")}),
          Icon(coordinateSystem(extent={{-140,-100},{120,100}})),
          experiment(
            StopTime=10,
            Interval=0.0001,
            Tolerance=1e-006,
            __Dymola_fixedstepsize=0.0001,
            __Dymola_Algorithm="Rkfix2"),
          __Dymola_experimentSetupOutput,
          Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td><p>SMIB PSAT, d_kundur2.mdl, PSAT</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>February 2016</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Maxime Baudette, Ahsan Murad, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
      end SMIB_Base;

      partial model SMIB_Partial "Partial SMIB Model with a fault block"
        extends SMIB_Base(
          B2(
            V_0=powerFlow_Data.bus.V2,
            angle_0=powerFlow_Data.bus.A2),
          line_2(t1=0.57),
          infinite_bus(
            V_0=powerFlow_Data.bus.V3,
            angle_0=powerFlow_Data.bus.A3,
            P_0=powerFlow_Data.machines.PG2,
            Q_0=powerFlow_Data.machines.QG2),
          B1(V_0=powerFlow_Data.bus.V1, angle_0=powerFlow_Data.bus.A1),
          B3(V_0=powerFlow_Data.bus.V3, angle_0=powerFlow_Data.bus.A3),
          B4(V_0=powerFlow_Data.bus.V4, angle_0=powerFlow_Data.bus.A4));
        OpenIPSL.Electrical.Events.PwFault fault(
          R=0,
          t1=0.5,
          t2=0.57,
          X=1e-5) annotation (Placement(transformation(extent={{-6,-6},{6,6}},
              rotation=0,
              origin={32,-14})));
        OpenIPSL.Electrical.Loads.PSSE.Load_ExtInput load_ExtInput(
          V_0=powerFlow_Data.bus.V4,
          angle_0=powerFlow_Data.bus.A4,
          P_0=powerFlow_Data.loads.PL1,
          Q_0=powerFlow_Data.loads.QL1,
          d_P=0,
          t1=Modelica.Constants.inf,
          d_t=Modelica.Constants.inf)
          annotation (Placement(transformation(extent={{16,-76},{28,-64}})));
        PF_Data.PowerFlow_Data powerFlow_Data
          annotation (Placement(transformation(extent={{-120,44},{-100,64}})));
      equation
        connect(load_ExtInput.p, line_2.n)
          annotation (Line(points={{22,-64},{22,-40},{15.1,-40}}, color={0,0,255}));
        connect(fault.p, line_2.n) annotation (Line(points={{25,-14},{24,-14},{24,
                -40},{15.1,-40}}, color={0,0,255}));
      end SMIB_Partial;
    end BaseNetwork;
  end BaseModelsPartial;

  package PF_Data
    extends Modelica.Icons.RecordsPackage;

    record PowerFlow_Data
    extends Modelica.Icons.Record;

    replaceable record Bus = SMIBPS_IdControl.PF_Data.Bus_Template constrainedby
      PF_Data.Bus_Template
    annotation(choicesAllMatching);
    Bus bus;

    replaceable record Loads = SMIBPS_IdControl.PF_Data.Loads_Template constrainedby
      PF_Data.Loads_Template
    annotation(choicesAllMatching);
    Loads loads;

    replaceable record Trafos = SMIBPS_IdControl.PF_Data.Trafos_Template constrainedby
      PF_Data.Trafos_Template
    annotation(choicesAllMatching);
    Trafos trafos;

    replaceable record Machines = SMIBPS_IdControl.PF_Data.Machines_Template constrainedby
      PF_Data.Machines_Template
    annotation(choicesAllMatching);
    Machines machines;

    end PowerFlow_Data;

    record Bus_Template

    parameter Real V1;
    parameter Real A1;

    parameter Real V2;
    parameter Real A2;

    parameter Real V3;
    parameter Real A3;

    parameter Real V4;
    parameter Real A4;

    end Bus_Template;

    record Loads_Template

    parameter Real PL1;
    parameter Real QL1;

    end Loads_Template;

    record Trafos_Template

    parameter Real t1_trafo_1;
    parameter Real t2_trafo_1;

    end Trafos_Template;

    record Machines_Template

    parameter Real PG1;
    parameter Real QG1;

    parameter Real PG2;
    parameter Real QG2;

    end Machines_Template;

    package Bus_Data

      record PF_Bus_8
      extends SMIBPS_IdControl.PF_Data.Bus_Template(
      V1 = 1.0000000,
      A1 = 21.5193529,
      V2 = 0.9846224,
      A2 = 14.6810465,
      V3 = 1.0000000,
      A3 = 0.0000000,
      V4 = 0.9841510,
      A4 = 6.8899644);

      // Bus: 'B1' (PV bus)

      // Bus: 'B2' (PQ bus)

      // Bus: 'B3' (slack bus)

      // Bus: 'B4' (PQ bus)

      end PF_Bus_8;
    end Bus_Data;

    package Loads_Data

      record PF_Loads_8
      extends SMIBPS_IdControl.PF_Data.Loads_Template(
      PL1 = 63.49519748334588,
      QL1 = 0.0452430189276728);

      // Load: 'load_ext_input'

      end PF_Loads_8;
    end Loads_Data;

    package Trafos_Data

      record PF_Trafos_8
      extends SMIBPS_IdControl.PF_Data.Trafos_Template(
      t1_trafo_1 = 1.0000000,
      t2_trafo_1 = 1.0000000);

      // TRAFO: '['transformer']'
      // From: 'B1' - To: 'B2'

      end PF_Trafos_8;
    end Trafos_Data;

    package Machines_Data

      record PF_Machines_8
      extends SMIBPS_IdControl.PF_Data.Machines_Template(
      PG1 = 1735.1052632,
      QG1 = 331.2554139,
      PG2 = -1671.6098412,
      QG2 = 320.6034170);

      // MACHINE: 'gen_1'
      // Bus: B1'

      // MACHINE: 'Slack'
      // Bus: B3'

      end PF_Machines_8;
    end Machines_Data;
  annotation (Icon(graphics={             Text(
          extent={{-76,148},{86,-14}},
          lineColor={28,108,200},
          textString="PFlow")}));
  end PF_Data;
annotation(preferredView = "info",
  uses(
      DataFiles(version="1.0.5"),
    OpenIPSL(version="1.5.0"),
    DymolaCommands(version="1.9"),
    LinearAnalysis(version="1.0.1"),
    Modelica(version="4.0.0"),
    Modelica_LinearSystems2(version="2.4.0")),
  version="1",
  Documentation(info="<html>
<p><br>This package contains examples on using Modelica, OpenIPSL and the Modelica Linear Systems 2 library to carry out typical power system stability and control studies.</p>
<p>The goal is to illustrate how models need to be defined for linearization when different model variants need to be compared.</p>
<p>Another goal is to illustrate the use of the MLS2 library for typical power system control design tasks, specifically the excitation system controller (i.e. automatic voltage regulator) and the so-called Power System Stabilizer.</p>
<p><br>The analysis examples are developed using the single-machine infinite bus model used in the Example 13.2 of the Kundur&apos;s book, implemented in the OpenIPSL library.</p>
<p><br>(c) 2020-2050, Luigi Vanfretti, Rensselaer Polytechnic Institute, Troy, NY, USA.</p>
</html>"),
    Icon(graphics={
        Rectangle(
          lineColor={85,170,255},
          fillColor={28,108,200},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-100,-98},{100,102}},
          radius=25),
        Rectangle(
          lineColor={128,128,128},
          extent={{-100,-98},{100,102}},
          radius=25.0),
      Rectangle(
        origin={0,35.149},
        fillColor={255,255,255},
        extent={{-30.0,-20.1488},{30.0,20.1488}},
          lineColor={255,255,255},
          lineThickness=1),
      Rectangle(
        origin={0,-34.851},
        fillColor={255,255,255},
        extent={{-30.0,-20.1488},{30.0,20.1488}},
          lineColor={255,255,255},
          lineThickness=1),
      Line(
        origin={-51.25,0},
        points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}},
          color={255,255,255},
          thickness=1),
      Polygon(
        origin={-40,35},
        pattern=LinePattern.None,
        points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
      Line(
        origin={51.25,0},
        points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}},
          color={255,255,255},
          thickness=1),
      Polygon(
        origin={40,-35},
        pattern=LinePattern.None,
        points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid)}));
end SMIBPS_IdControl;

package DymolaEmbedded
  "Support library for Dymola's eFMU generation facilities."
  extends Icons.DymolaEmbedded;

  package EmbeddedConfiguration "Base-package for eFMU generation configurations."
    /*
  extends .Modelica.Clocked.ClockSignals.Clocks(
    PeriodicRealClock(
      final period = integrator_configuration.sample_period,
      final useSolver = integrator_configuration.use_solver(),
      final solverMethod = BuildUtilities.AlgorithmCode.solver_name(
        integrator_configuration.solver_method,
        false)));
  */

    extends Icons.EmbeddedConfiguration;

    package Clocked "Clocks and samples of 'Modelica.Clocked' specialized with the period and
   solver method of the eFMU generation configuration."
      extends .Modelica.Icons.Package;

      /*
  model BooleanSample
    "Boolean sample, specialized to use the clock of the eFMU generation
   configuration."
    extends .Modelica.Clocked.BooleanSignals.Interfaces.SamplerIcon;
    extends Icons.ConfiguredClock;

    .Modelica.Blocks.Interfaces.BooleanInput u
      "Connector of continuous-time, Boolean input signal"
      annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
    .Modelica.Blocks.Interfaces.BooleanOutput y
      "Connector of clocked, Boolean output signal"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));

  equation 
    y = sample(u, clock);

    annotation (
      Icon(
        graphics={
          Text(
            extent={{-200,50},{200,115}},
            lineColor={0,0,255},
            textString="%name")}));
  end BooleanSample;

  model IntegerSample
    "Integer sample, specialized to use the clock of the eFMU generation
   configuration."
    extends .Modelica.Clocked.IntegerSignals.Interfaces.SamplerIcon;
    extends Icons.ConfiguredClock;

    .Modelica.Blocks.Interfaces.IntegerInput u
      "Connector of continuous-time, Integer input signal"
      annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

    .Modelica.Blocks.Interfaces.IntegerOutput y
      "Connector of clocked, Integer output signal"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));

  equation 
    y = sample(u, clock);

    annotation (
      Icon(
        graphics={
          Text(
            extent={{-200,50},{200,115}},
            lineColor={0,0,255},
            textString="%name")}));
  end IntegerSample;

  model RealSample
    "Real sample, specialized to use the clock of the eFMU generation
   configuration."
    extends .Modelica.Clocked.RealSignals.Interfaces.PartialSISOSampler;
    extends Icons.ConfiguredClock;

  equation 
    y = sample(u, clock);

    annotation (
      Icon(
        graphics={
          Text(
            extent={{-200,50},{200,115}},
            lineColor={0,0,255},
            textString="%name")}));
  end RealSample;
protected 
  constant Clock clock_periodic_base=
    Clock(integrator_configuration.sample_period);

  constant Clock clock_with_solver = Clock(
    clock_periodic_base,
    BuildUtilities.AlgorithmCode.solver_name(
      integrator_configuration.solver_method,
      false));

  constant Clock clock = if integrator_configuration.use_solver()
    then clock_with_solver
    else clock_periodic_base;
  */

      model PeriodicRealClock
        "Periodic real clock using the period and solver method of the eFMU generation
   configuration."
        extends .Modelica.Clocked.ClockSignals.Clocks.PeriodicRealClock(
          final period = integrator_configuration.sample_period,
          final useSolver = integrator_configuration.use_solver(),
          final solverMethod = BuildUtilities.AlgorithmCode.solver_name(
            integrator_configuration.solver_method,
            false));
        extends Icons.ConfiguredClock;
      end PeriodicRealClock;
      annotation (
        Icon(
          coordinateSystem(
            extent = {{-100, -100}, {100, 100}},
            preserveAspectRatio = true),
          graphics={
            Ellipse(extent = {{-80, -80}, {80, 80}}),
            Line(points = {{80, 0}, {60, 0}}),
            Line(points = {{69.282, 40}, {51.962, 30}}),
            Line(points = {{40, 69.282}, {30, 51.962}}),
            Line(points = {{0, 80}, {0, 60}}),
            Line(points = {{-40, 69.282}, {-30, 51.962}}),
            Line(points = {{-69.282, 40}, {-51.962, 30}}),
            Line(points = {{-80, 0}, {-60, 0}}),
            Line(points = {{-69.282, -40}, {-51.962, -30}}),
            Line(points = {{-40, -69.282}, {-30, -51.962}}),
            Line(points = {{0, -80}, {0, -60}}),
            Line(points = {{40, -69.282}, {30, -51.962}}),
            Line(points = {{69.282, -40}, {51.962, -30}}),
            Line(points = {{80, 0}, {60, 0}}),
            Line(points = {{0, 0}, {-50, 50}}),
            Line(points = {{0, 0}, {40, 0}})}));
    end Clocked;

    function check_configuration
      "Analyse the configuration for errors or if it is marked to be unsupported.
   Configuration errors will raise exceptions in terms of failed assertions;
   unsupported features are echoed if desired."
      extends Icons.Configuration;
      extends Icons.Analysis;

      input Boolean display_warnings = true
        "Configures if unsupported features are echoed as warnings in the
     'Commands'-window.";
      input Boolean check_also_disabled = false
        "Configures if also disabled features should be checked (for example
     a disabled production code generator etc).";

      output Boolean supported
        "Whether the configuration is expected to work (i.e., is supported) or if
     it is marked to be unsupported ('true', if the configuration is supported;
     otherwise 'false').";

    algorithm
      supported :=
        AlgorithmCode.check_configuration(
          display_warnings = display_warnings)
        and BinaryCode.check_configuration(
          display_warnings = display_warnings,
          check_also_disabled = check_also_disabled);

      annotation (
        preferredView = "info",
        __Dymola_interactive = true);
    end check_configuration;

    function build
      "Build complete eFMU.
   The concrete configuration used can be interactively changed; by default the
   package's configuration is used. Interactive changes apply only for this very
   build, i.e., temporarily."
      extends Icons.BuildEmbedded;

      input Boolean update = true
        "Configures, if the eFMU is updated or created anew.";

      input BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration
        "Integrator configuration used for the build.";
      input BuildUtilities.AlgorithmCode.Code code = code_configuration
        "GALEC code configuration used for the build.";
      input BuildUtilities.ESP_Configurations ESP = ESP_configurations
        "CATIA ESP production code configurations used for the build.";

      input Boolean check_code = false
        "Configures, if CATIA ESP generated Production Code containers are
     analysized for embedded code quality as well (MISRA etc).";
      input Boolean load_binary_stub = false
        "Configures, if a eFMU co-simulation stub for CATIA ESP generated Binary
     Code containers is build and loaded as well.";
      input Boolean import_FMU = false
        "Configures, if a FMU, implemented based on the eFMU's Binary Code
     containers, is build and imported as well.";

      output BuildUtilities.BuildResult build_result
        "Build success report compiling all relevant build information.";

  protected
      BuildUtilities.eFMU efmu = efmu_configuration;
      BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;

      BuildUtilities.BuildResult step_result
        "BEWARE: Build result configuration <> single step result configuation
     because of potential for interactive changes.";

    algorithm
      () := clearlog();

      // Defensive programming - by default assume the build fails:
      build_result := BuildUtilities.BuildResult(
        succeeded = false,
        error_message = "Unknown error.",
        efmu = efmu,
        modelica_model = modelica_model,
        integrator = integrator,
        code = code,
        ESP = ESP);

      step_result := AlgorithmCode.build(
        update = update,
        integrator = integrator,
        code = code);
      if not
            (step_result.succeeded) then
        build_result.succeeded := false;
        build_result.error_message := step_result.error_message;
        return;
      end if;

      step_result := ProductionCode.build(
        update = update,
        ESP = ESP);
      if not
            (step_result.succeeded) then
        build_result.succeeded := false;
        build_result.error_message := step_result.error_message;
        return;
      end if;

      if check_code then
        step_result := ProductionCode.check_code(
          ESP = ESP);
        if not
              (step_result.succeeded) then
          build_result.succeeded := false;
          build_result.error_message := step_result.error_message;
          return;
        end if;
      end if;

      step_result := BinaryCode.build(
        update = update,
        ESP = ESP);
      if not
            (step_result.succeeded) then
        build_result.succeeded := false;
        build_result.error_message := step_result.error_message;
        return;
      end if;

      if load_binary_stub then
        step_result := BinaryCode.build_binary_stub(
          ESP = ESP,
          build_binary_stub = true,
          load_binary_stub = true);
        if not
              (step_result.succeeded) then
          build_result.succeeded := false;
          build_result.error_message := step_result.error_message;
          return;
        end if;
      end if;

      if import_FMU then
        step_result := BinaryCode.build_FMU();
        if not
              (step_result.succeeded) then
          build_result.succeeded := false;
          build_result.error_message := step_result.error_message;
          return;
        end if;
      end if;

      // Defensive programming - we are still here, so everything is alright:
      build_result.succeeded := true;
      build_result.error_message := "";
      return;

      annotation (
        preferredView = "info",
        __Dymola_interactive = true);
    end build;

    function browse_code
      "Return and open the eFMU generation directory (the build directory)."

      input Boolean open_file_manager = true
        "Open the build directory in the operating system's default file manager.";
      input Boolean open_terminal = false
        "Open the build directory in the operating system's default shell.";

      output String build_directory
        "The build directory.";
      output Boolean build_directory_exists
        "Whether the build directory exists or not.";
      output String configuration_package
        "The concrete configuration used
     (the configuration defining the build directory).";

  protected
      String instance_name;

    algorithm
      instance_name := getInstanceName();
      assert(
        .Modelica.Utilities.Strings.findLast(instance_name, ".") <> 0,
        "\n\nERROR (browse_code):"
        + "\n  Function must be called in the context of an eFMU generation configuration.\n\n");
      configuration_package := .Modelica.Utilities.Strings.substring(
        instance_name,
        1,
        .Modelica.Utilities.Strings.findLast(instance_name, ".") - 1);
      build_directory :=
        .Modelica.Utilities.System.getWorkDirectory()
        + "/"
        + (if efmu_configuration.name == ""
          then configuration_package
          else efmu_configuration.name);
      build_directory_exists :=
        .Modelica.Utilities.Files.exist(build_directory + "/");

      if build_directory_exists then
        if open_file_manager then
          () := .Modelica.Utilities.System.command(
            "start \"\" \"" + build_directory + "\"");
        end if;
        if open_terminal then
          () := .Modelica.Utilities.System.command(
            "start \"\" /D \"" + build_directory + "\" cmd");
        end if;
      else
        if open_file_manager or open_terminal then
          assert(
            false,
            "\n\nERROR (browse_code):"
            + "\n  eFMU not built yet; cannot browse its content.\n\n");
        end if;
      end if;

      annotation (
        preferredView = "info",
        __Dymola_interactive = true,
        Icon(graphics={
          Rectangle(
            extent = {{-90,-70},{90,70}},
            pattern = LinePattern.None,
            fillColor = {215,215,215},
            fillPattern = FillPattern.Sphere,
            lineColor = {135,135,135},
            radius = 5),
          Rectangle(
            extent = {{-80,-60},{80,60}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Polygon(
            points = {{-68,50},{-42,38},{-42,34},{-68,22},{-68,30},{-54,36},
              {-68,42},{-68,50}},
            lineColor = {0,0,0},
            pattern = LinePattern.None,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid),
          Rectangle(
            extent = {{-40,12},{-10,18}},
            lineColor = {0,0,0},
            pattern = LinePattern.None,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid)}));
    end browse_code;

    function check_eFMU
      "Analyse the generated eFMU for structural or integrity errors according to
  the eFMI Compliance Checker and the eFMI Container Manager."
      extends Icons.Bundle;
      extends Icons.Analysis;

      input Boolean eFMI_Compliance_Checker = true
        "Whether the eFMI Compliance Checker is executed or not.";
      input Boolean eFMI_Container_Manager = true
        "Whether the eFMI Container Manager is executed or not.";

      input Boolean open_log = true
        "Whether the log file summarizing the check-results will be opened after
     checking or not ('true' opens the log in the system's default editor for
     '.txt' files).";

      output Boolean is_valid
        "Whether the eFMU is valid or not ('true', if the eFMU has no errors
     according to the eFMI Container Manager; otherwise 'false').";
      output String error_message
        "Error message in case the eFMU is invalid.";

  protected
      BuildUtilities.eFMU efmu = efmu_configuration;

      String build_directory;
      final String eFMU_name = "eFMU";

      String log_file;

      String command;
      Boolean eFMI_Compliance_Checker_succeeded;
      Boolean eFMI_Container_Manager_succeeded;

    algorithm
      // Defensive programming - by default assume the check fails:
      is_valid := false;
      error_message := "Unknown error.";

      // Always perform common configuration checks:
      () := check_configuration();

      // Workaround Dymola bug: instead of...
      (build_directory,,) :=
        browse_code(open_file_manager = false);
      // ...use:
      build_directory :=
        .Modelica.Utilities.System.getWorkDirectory()
        + "/"
        + (if efmu.name == ""
          then .Modelica.Utilities.Strings.substring(
            getInstanceName(),
            1,
            .Modelica.Utilities.Strings.findLast(
              getInstanceName(),
              ".check_eFMU") - 1)
          else efmu.name);

      log_file := build_directory + "/check-eFMU-log.txt";
      .Modelica.Utilities.Files.remove(log_file);

      if not
            (.Modelica.Utilities.Files.exist(build_directory + "/" + eFMU_name + "/__content.xml")) then
        is_valid := false;
        error_message :=
          "Failed to check eFMU: " + build_directory
          + "\n  Content manifest '__content.xml' of eFMU missing.";
        return;
      else
        if eFMI_Compliance_Checker then
          /*
        Execute eFMI Compliance Checker:
      */
          command :=
            "cd \"" + build_directory + "\"" +
            " & echo=*************************************************************************** eFMI Compliance Checker:>> \"" + log_file + "\"" +
            " & set \"eFMU=" + build_directory + "\"" +
            " & \"" + R.eFMI_Compliance_Checker + "/check-eFMU.bat\"" +
            " >> " + "\"" + log_file + "\" 2>&1" +
            " & if ERRORLEVEL 1 ( exit /b 1 )";
          eFMI_Compliance_Checker_succeeded :=
            .Modelica.Utilities.System.command(command) == 0;
        end if;
        if eFMI_Container_Manager then
          /*
        Execute eFMI Container Manager:
      */
          command :=
            "cd \"" + build_directory + "\"" +
            " & echo=**************************************************************************** eFMI Container Manager:>> \"" + log_file + "\"" +
            " & set \"eFMU=" + build_directory + "\"" +
            " & \"" + R.eFMI_Container_Manager + "/check-eFMU.bat\"" +
            " >> " + "\"" + log_file + "\" 2>&1" +
            " & if ERRORLEVEL 1 ( exit /b 1 )";
          eFMI_Container_Manager_succeeded :=
            .Modelica.Utilities.System.command(command) == 0;
        end if;
        is_valid := eFMI_Compliance_Checker_succeeded
          and eFMI_Container_Manager_succeeded;
        /*
        Open log:
    */
        if open_log then
          () := .Modelica.Utilities.System.command("start \"\" \"" + log_file + "\"");
        end if;
        if not
              (is_valid) then
          error_message :=
            "Failed to check eFMU: " + build_directory
            + "\n  Cf. '" + log_file + "' for details.";
          return;
        end if;
      end if;

      // Defensive programming - we are still here, so everything is alright:
      is_valid := true;
      error_message := "";

      annotation (
        preferredView = "info",
        __Dymola_interactive = true,
        Documentation(info="<html>
<b>Important:</b> Please check, and confirm, the
<a href=\"modelica://DymolaEmbedded.UsersGuide.Requirements\">Requirements</a>
of the eFMU validation facilities before using this function.
</html>"));
    end check_eFMU;

    package AlgorithmCode "Functionalities to build and maintain the Algorithm Code container."
      extends Icons.SourceCodeContainer;

      function check_configuration
        "Analyse the configuration for errors or if it is marked to be unsupported.
   Configuration errors will raise exceptions in terms of failed assertions;
   unsupported features are echoed if desired."
        extends Icons.Configuration;
        extends Icons.Analysis;

        input BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration
          "Integrator configuration used for the build.";

        input Boolean display_warnings = true
          "Configures if unsupported features are echoed as warnings in the
     'Commands'-window.";

        output Boolean supported
          "Whether the configuration is expected to work (i.e., is supported) or if
     it is marked to be unsupported ('true', if the configuration is supported;
     otherwise 'false').";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;

        String build_directory;

        constant String instance_name = getInstanceName();
        String warnings;

      algorithm
        /*
    Check for configuration errors and raise respective exceptions:
  */
        supported := instance_name
          <> "DymolaEmbedded.EmbeddedConfiguration.AlgorithmCode.check_configuration";
        assert(
          supported,
          "\n\nERROR (check_configuration):"
          + "\n  No concrete configuration given.\n\n");
        supported := .ModelManagement.Structure.AST.Misc.ClassExists(
          modelica_model.model_name);
        assert(
          supported,
          "\n\nERROR (check_configuration):"
          + "\n  Unknown model subject to eFMU generation.\n\n");
        supported := integrator.sample_period > 0.0;
        assert(
          supported,
          "\n\nERROR (check_configuration):"
          + "\n  Invalid sample period.\n\n");

        /*
    Check path length to ensure eFMU generation will obey max. path length
    restrictions of Windows; raise exception if not:
  */
        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".AlgorithmCode.check_configuration") - 1)
            else efmu.name);
        supported := 256 > .Modelica.Utilities.Strings.length(
          build_directory
          + "/eFMU/BCode_ESP_1476857878_1965730977/default/mei_block_interface.obj"
          + "Security buffer for further extensions and tmp files.");
        assert(
          supported,
          "\n\nERROR (check_configuration):"
          + "\n  eFMU generation path exceeds max. path length limit.\n"
          + "\n  Please change working directory or set shortened eFMU name.\n\n");

        /*
    Check for unsupported marks:
  */
        warnings := "\n\nWARNING (" + instance_name + "):"
          + "\n  The Algorithm Code container configuration is marked to be unsupported."
          + "\n  It likely requires missing or prototypical eFMU generation facilities."
          + "\n  Generating an eFMU may fail or yield invalid solutions."
          + "\n  The unsupported features are:";
        if modelica_model.not_yet_supported <> "" then
          supported := false;
          warnings := warnings + "\n    - Model configuration: "
            + modelica_model.not_yet_supported;
        end if;
        if integrator.not_yet_supported <> "" then
          supported := false;
          warnings := warnings + "\n    - Integrator configuration: "
            + integrator.not_yet_supported;
        end if;
        warnings := warnings + "\n\n";
        if not
              (supported) and display_warnings then
          .Modelica.Utilities.Streams.print(warnings);
        end if;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end check_configuration;

      function build
        "Build Algorithm Code container.
   The concrete configuration used can be interactively changed; by default the
   package's configuration is used. Interactive changes apply only for this very
   build, i.e., temporarily."
        extends Icons.GenerateSourceCode;

        input Boolean update = true
          "Configures, if the Algorithm Code container is updated or created anew.";

        input BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration
          "Integrator configuration used for the build.";
        input BuildUtilities.AlgorithmCode.Code code = code_configuration
          "GALEC code configuration used for the build.";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.ESP_Configurations ESP = ESP_configurations;

        String build_directory;
        final String eFMU_name = "eFMU";

        final String acode_container_name = "ACode_Dymola";

        Integer integrator_inline_method;
        String integrator_inline_order;

      algorithm
        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        // Always perform common configuration checks:
        () := check_configuration(
          integrator = integrator);

        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".AlgorithmCode.build") - 1)
            else efmu.name);

        /*
    Create directories for generated artefacts:
  */
        if not
              (update) then
          // Empty container:
          .Modelica.Utilities.Files.remove(
            build_directory + "/" + eFMU_name + "/" + acode_container_name);
        end if;
        // Always delete non-eFMU artefacts:
        .Modelica.Utilities.Files.remove(
            build_directory + "/deobfuscation");
        // Create container and directories for non-eFMU artefacts:
        .Modelica.Utilities.Files.createDirectory(
          build_directory + "/" + eFMU_name + "/" + acode_container_name);
        .Modelica.Utilities.Files.createDirectory(
          build_directory + "/deobfuscation");
        // Copy XML Schema files if not already present:
        if not
              (.Modelica.Utilities.Files.exist(build_directory + "/" + eFMU_name + "/schemas")) then
          .Modelica.Utilities.Files.createDirectory(
            build_directory + "/" + eFMU_name + "/schemas");
          .Modelica.Utilities.Files.copy(
            R.efmi_xml_schemas,
            build_directory + "/" + eFMU_name + "/schemas/",
            replace = true);
        end if;

        /*
    Map selected solver method to inline integration method:
  */
        integrator_inline_order := "";
        if integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.None then
          integrator_inline_method := 0;
        elseif integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.Implicit_Euler then
          integrator_inline_method := 2;
        elseif integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.Explicit_Euler then
          integrator_inline_method := 1;
        else // Rosenbrock methods:
          integrator_inline_method := 7;
          integrator_inline_order := "Advanced.InlineOrder=" +
            String(Integer(integrator.solver_method) - 3) + ",";
        end if;

        /*
    Generate eFMU container manifest, Algorithm Code container manifest,
    GALEC program, static default initialization model and deobfuscation
    arefacts:
  */
        () := clearlog();
        build_result.succeeded := translateModelExport(modelica_model.model_name +
          " annotation(__Dymola_experimentFlags(" +
            "Advanced.TranslationInCommandLog=true," +
            "Hidden.eFMICodeGenerationSupport=true," +
            "eFMI.AlgorithmCodeContainer.ObfuscationLevel=" + String(Integer(code.obfuscate) - 1) + "," +
            "Hidden.SolveSmallSymbolically=true," +
            "Advanced.CompileAfterTranslation=false," +
            "Hidden.LapackCodeExport=true," +
            "Advanced.AllowNumericDifferentiation=true," +
            "Advanced.AutomaticDifferentiation=true," +
            "Advanced.PrintFailureToDifferentiate=true," +
            "Hidden.InitializeClockedDiscretizedStates=true," +
            "Advanced.InlineFixedStep=" + String(integrator.sample_period) + "," +
            "Advanced.InlineMethod=" + String(integrator_inline_method) + "," +
            integrator_inline_order +
            "Hidden.TranslateOnlyClockedPart=" + String(modelica_model.only_clocked) + "," +
            "Hidden.HandleNonRealInputAlsoFMI2=false," +
            "Advanced.InlineXMLTypeDefinitions=false," +
            "Advanced.OutputPlainNestedDeclaredCausality=true," +
            "Hidden.OutputEFMIAlgCode=true," +
            "Advanced.AllowParameterAlias=true," +
            "Advanced.EvaluateAlsoTop=" + String(code.fold_parameters) +"," +
            "Evaluate=" + String(code.fold_parameters) +
          "))");
        () := savelog(
          build_directory
          + (if code.obfuscate <> BuildUtilities.AlgorithmCode.Code.ObfuscationLevel.None
            then "/deobfuscation/build-log.txt"
            else "/" + eFMU_name + "/" + acode_container_name + "/build-log.txt"));
        () := clearlog();
        if not build_result.succeeded then
          build_result.error_message :=
            "Failed to generate Algorithm Code container.";
          return;
        end if;

        /*
    Copy generated eFMU container manifest, Algorithm Code container manifest,
    GALEC program, static default initialization model and deobfuscation
    artefacts:
  */
        .Modelica.Utilities.Files.move(
          .Modelica.Utilities.System.getWorkDirectory() + "/__content.xml",
          build_directory + "/" + eFMU_name + "/__content.xml",
          replace = true);
        .Modelica.Utilities.Files.move(
          .Modelica.Utilities.System.getWorkDirectory()
            + (if code.obfuscate <> BuildUtilities.AlgorithmCode.Code.ObfuscationLevel.None
              then "/alg-manifest-obfuscated.xml"
              else "/alg-manifest-cleartext.xml"),
          build_directory + "/" + eFMU_name + "/" + acode_container_name + "/manifest.xml",
          replace = true);
        .Modelica.Utilities.Files.move(
          .Modelica.Utilities.System.getWorkDirectory()
            + (if code.obfuscate <> BuildUtilities.AlgorithmCode.Code.ObfuscationLevel.None
              then "/block-obfuscated.alg"
              else "/block-cleartext.alg"),
          build_directory + "/" + eFMU_name + "/" + acode_container_name + "/block.alg",
          replace = true);
        .Modelica.Utilities.Files.move(
          .Modelica.Utilities.System.getWorkDirectory() + "/StaticInitialization.mo",
          build_directory + "/deobfuscation/StaticInitialization.mo",
          replace = true);
        if code.obfuscate <> BuildUtilities.AlgorithmCode.Code.ObfuscationLevel.None then
          .Modelica.Utilities.Files.move(
            .Modelica.Utilities.System.getWorkDirectory() + "/alg-manifest-cleartext.xml",
            build_directory + "/deobfuscation/alg-manifest.xml",
            replace = true);
          .Modelica.Utilities.Files.move(
            .Modelica.Utilities.System.getWorkDirectory() + "/block-cleartext.alg",
            build_directory + "/deobfuscation/block.alg",
            replace = true);
          .Modelica.Utilities.Files.move(
            .Modelica.Utilities.System.getWorkDirectory() + "/deobfuscation-mapping.txt",
            build_directory + "/deobfuscation/deobfuscation-mapping.txt",
            replace = true);
        end if;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build;
      annotation (preferredView = "info");
    end AlgorithmCode;

    package BehavioralModel "Functionalities to build and maintain Dymola-administered Behavioral Model
   containers."
      extends Icons.BehavioralModelContainer;

      function add_experiment
        "Derive from an existing model an experiment defining test scenarios for
   a Dymola-administered Behavioral Model container. Each eBlock of the new
   experiment defines one test scenario for the Behavioral Model container."
        extends Icons.BuildModelica;

        input String source_model
          "The model from which to derive reference secenarios for each of its
     eBlocks."
          annotation(Dialog(__Dymola_translatedModel(translate = false)));
        input String scenario_prefix = ""
          "Optional explicit name prefix for the defined scenarios; if no explicit
     name prefix is given, a unique prefix is automatically selected.
     The complete name of a scenario is the prefix followed by '_' and
     the name of the respective eBlock.";
        input Boolean sample_eBlocks = false
          "Configures if eBlocks are sampled -- if not already within a clocked
     partition -- with the sampling period and solver method of the
     eFMU generation configuration.";

      algorithm

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end add_experiment;

      function build
        "Build Behavioral Model container for an experiment with test scenarios."
        extends Icons.Runtime;
        extends Icons.Build;

      algorithm

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build;
      annotation (preferredView = "info");
    end BehavioralModel;

    package ProductionCode "Functionalities to build and maintain CATIA ESP based Production Code
   containers."
      extends Icons.SourceCodeContainer;

      function check_configuration
        "Analyse the configuration for errors or if it is marked to be unsupported.
   Configuration errors will raise exceptions in terms of failed assertions;
   unsupported features are echoed if desired."
        extends Icons.Configuration;
        extends Icons.Analysis;

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP configurations used for the build.";

        input Boolean display_warnings = true
          "Configures if unsupported features are echoed as warnings in the
     'Commands'-window.";
        input Boolean check_also_disabled = false
          "Configures if also disabled features should be checked (for example
     a disabled code generator etc).";

        output Boolean supported
          "Whether the configuration is expected to work (i.e., is supported) or if
     it is marked to be unsupported ('true', if the configuration is supported;
     otherwise 'false').";

    protected
        constant String instance_name = getInstanceName();
        String warnings;

        String pcode_container_name;

      algorithm
        supported := true;

        /*
    Check for configuration errors and raise respective exceptions:
  */
        for c in ESP.production_codes loop
          supported := not
                          (c.active) or R.ESP_available();
          assert(
            supported,
            "\n\nERROR (check-configuration):"
            + "\n  CATIA ESP not available."
            + "\n"
            + "\n  CATIA ESP license required to use CATIA ESP for eFMU Production and"
            + "\n  Binary Code container generation from within Dymola."
            + "\n"
            + "\n  CATIA ESP will be released as a 3DEXPERIENCE platform service with"
            + "\n  3DEXPERIENCE 2022x FD03 (end of June 2022)."
            + "\n"
            + "\n  For Dymola 2023 it is distributed to selected partners only as a"
            + "\n  separate \"Dymola eFMI kit supplementary\" distribution."
            + "\n  If you think you are eligible and should have access to the,"
            + "\n  \"Dymola eFMI kit supplementary\" please contact Christoff Bürger"
            + "\n  or Dan Henriksson of the Dymola team"
            + "\n  (Christoff.Buerger@3ds.com, Dan.Henriksson@3ds.com)."
            + "\n"
            + "\n  If you are interested in acquiring a CATIA ESP license, please"
            + "\n  contact Arthur Gauthier and Eric Mevel of the CATIA ESP team"
            + "\n  (Arthur.GAUTHIER@3ds.com; Eric.MEVEL@3ds.com).\n\n");
        end for;

        /*
    Check for unsupported marks:
  */
        warnings := "\n\nWARNING (" + instance_name + "):"
          + "\n  Some Production Code container configurations are marked to be unsupported."
          + "\n  They likely require missing or prototypical eFMU generation facilities."
          + "\n  Generating an eFMU may fail or yield invalid solutions."
          + "\n  The unsupported features are:";
        for c in ESP.production_codes loop
          pcode_container_name :=
            "PCode_ESP_"
            + String(BuildUtilities.ProductionCode.configuration_hash(c));

          if (c.active or check_also_disabled)
            and c.not_yet_supported <> "" then
            supported := false;
            warnings :=
              warnings
              + "\n    - CATIA ESP Production Code configuration: " + pcode_container_name
              + "\n      " + c.not_yet_supported;
          end if;
        end for;
        warnings := warnings + "\n\n";
        if not
              (supported) and display_warnings then
          .Modelica.Utilities.Streams.print(warnings);
        end if;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end check_configuration;

      function build
        "Build all CATIA ESP Production Code containers.
   The concrete configurations used can be interactively changed; by default the
   package's configurations are used. Interactive changes apply only for this
   very build, i.e., temporarily."
        extends Icons.GenerateSourceCode;

        input Boolean update = true
          "Configures, if production code containers are updated or created anew.";

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP production code configurations used for the build.";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;

        String configuration_package;
        String build_directory;
        final String eFMU_name = "eFMU";

        final String acode_container_name = "ACode_Dymola";

        String efmu_configuration_hash;

        String pcode_configuration_hash;
        String pcode_container_name;
        String pcode_log_file;
        String pcode_float_precision;
        String pcode_interface_name;

        String command;

      algorithm
        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        // Always perform common configuration checks:
        () := check_configuration(
          ESP = ESP);

        // Workaround Dymola bug: instead of...
        (build_directory,, configuration_package) :=
          browse_code(open_file_manager = false);
        // ...use:
        configuration_package := .Modelica.Utilities.Strings.substring(
          getInstanceName(),
          1,
          .Modelica.Utilities.Strings.findLast(
            getInstanceName(),
            ".ProductionCode.build") - 1);
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name);

        efmu_configuration_hash := "H"
          + String(abs(.Modelica.Utilities.Strings.hashString(
            if efmu.name == ""
            then configuration_package
            else efmu.name)));

        for c in ESP.production_codes loop
          pcode_configuration_hash :=
            String(BuildUtilities.ProductionCode.configuration_hash(c));
          pcode_container_name :=
            "PCode_ESP_" + pcode_configuration_hash;
          pcode_log_file :=
            build_directory
            + "/"
            + eFMU_name
            + "/"
            + pcode_container_name
            + "/logs/build-log.txt";

          if not
                (c.active) then
            .Modelica.Utilities.Streams.print(
              "\nSkipped to generate Production Code container: " + pcode_container_name
              + "\n  CATIA ESP configuration deactivated."
              + "\n");
          elseif not
                    (.Modelica.Utilities.Files.exist(build_directory + "/" + eFMU_name + "/" + acode_container_name + "/manifest.xml")) then
            build_result.succeeded := false;
            build_result.error_message :=
              "Failed to generate Production Code container: " + pcode_container_name
              + "\n  Algorithm Code container manifest missing.";
            return;
          else
            /*
        Create directories for generated artefacts:
      */
            if not
                  (update) then
              // Empty container:
              .Modelica.Utilities.Files.remove(
                build_directory + "/" + eFMU_name + "/" + pcode_container_name);
            end if;
            // Create container:
            .Modelica.Utilities.Files.createDirectory(
              build_directory + "/" + eFMU_name + "/" + pcode_container_name + "/logs");

            /*
        Generate production code:
      */
            pcode_float_precision :=
              (if BuildUtilities.ProductionCode.resolve_float_precision(c.float_precision)
                == DymolaEmbedded.BuildUtilities.ProductionCode.FloatPrecision.x32
              then "32" else "64");
            pcode_interface_name :=
              efmu_configuration_hash + "_" + pcode_configuration_hash;
            command :=
              "cd \"" + build_directory + "\"" +
              " & set \"containerType=ProductionCode\"" +
              " & set \"srcDir=" + build_directory + "/" + eFMU_name + "\"" +
              " & set \"prdCodeName=" + pcode_container_name + "\"" +
              " & set \"floatPrec=" + pcode_float_precision + "\"" +
              " & set \"interName=" + pcode_interface_name + "\"" +
              " & cmd /C \"" + R.esp + "/execute-esp.bat\"" +
              " > \"" + pcode_log_file + "\" 2>&1" +
              " & if ERRORLEVEL 1 ( exit /b 1 )";
            build_result.succeeded := .Modelica.Utilities.System.command(command) == 0;
            if not build_result.succeeded then
              build_result.error_message :=
                "Failed to generate Production Code container: " + pcode_container_name
                + "\n  Cf. '" + pcode_log_file + "' for details.";
              return;
            end if;
          end if;
        end for;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build;

      function check_code
        "Analyse all eFMU Production Code containers generated by CATIA ESP for
   embedded code qualities."
        extends Icons.SourceCodeAnalysis;

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP configurations used for the build.";

        input Boolean open_log = true
          "Whether the log file summarizing the check-results will be opened after
     checking or not ('true' opens the log in the system's default editor for
     '.txt'/'.html' files).";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;

        String build_directory;
        final String eFMU_name = "eFMU";

        String pcode_container_name;
        String pcode_cppcheck_directory;
        String pcode_cppcheck_log_file;

        String command;

      algorithm
        () := clearlog();

        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        // Always perform common configuration checks:
        () := check_configuration(
          ESP = ESP);

        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".ProductionCode.check_code") - 1)
            else efmu.name);

        for c in ESP.production_codes loop
          pcode_container_name :=
            "PCode_ESP_"
            + String(BuildUtilities.ProductionCode.configuration_hash(c));
          pcode_cppcheck_directory :=
            build_directory + "/" + eFMU_name + "/" + pcode_container_name + "/cppcheck/";
          pcode_cppcheck_log_file :=
            build_directory + "/" + eFMU_name + "/" + pcode_container_name + "/logs/check-code";

          if not
                (c.active) then
            .Modelica.Utilities.Streams.print(
              "\nSkipped to check Production Code container: " + pcode_container_name
              + "\n  CATIA ESP configuration deactivated."
              + "\n");
          elseif not
                    (.Modelica.Utilities.Files.exist(build_directory + "/" + eFMU_name + "/" + pcode_container_name)) then
            build_result.succeeded := false;
            build_result.error_message :=
              "Failed to check Production Code container: " + pcode_container_name
              + "\n  Production Code container missing.";
            return;
          else
            /*
        Copy Cppcheck artefacts:
      */
            if not
                  (.Modelica.Utilities.Files.exist(pcode_cppcheck_directory)) then
              .Modelica.Utilities.Files.createDirectory(pcode_cppcheck_directory);
              .Modelica.Utilities.Files.copy(
                R.cppcheck,
                pcode_cppcheck_directory,
                replace = true);
            end if;

            /*
        Execute Cppcheck and open log:
      */
            command :=
              "cd \"" + pcode_cppcheck_directory + "\"" +
              " & check-code.bat" +
              " & if ERRORLEVEL 1 ( exit /b 1 )";
            build_result.succeeded := .Modelica.Utilities.System.command(command) == 0;
            if open_log then
              pcode_cppcheck_log_file :=
                pcode_cppcheck_log_file
                + "/"
                + (
                  if not
                        (build_result.succeeded)
                    then "build-log.txt"
                  elseif .Modelica.Utilities.Files.exist(pcode_cppcheck_log_file + "/html")
                    then "html/index.html"
                  else "results.txt");
              () := .Modelica.Utilities.System.command("start \"\" \"" + pcode_cppcheck_log_file + "\"");
            end if;
            if not
                  (build_result.succeeded) then
              build_result.error_message :=
                "Failed to check Production Code container: " + pcode_container_name
                + "\n  Cf. '" + pcode_cppcheck_log_file + "' for details.";
              return;
            end if;
          end if;
        end for;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true,
          Documentation(info="<html>
<b>Important:</b> Please check, and confirm, the
<a href=\"modelica://DymolaEmbedded.UsersGuide.Requirements\">Requirements</a>
of the production code analyses facilities before using this function.
</html>"));
      end check_code;
      annotation (preferredView = "info");
    end ProductionCode;

    package BinaryCode "Functionalities to build and maintain CATIA ESP based Binary Code
   containers."
      extends Icons.BinaryCodeContainer;

      function check_configuration
        "Analyse the configuration for errors or if it is marked to be unsupported.
   Configuration errors will raise exceptions in terms of failed assertions;
   unsupported features are echoed if desired."
        extends Icons.Configuration;
        extends Icons.Analysis;

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP configurations used for the build.";

        input Boolean display_warnings = true
          "Configures if unsupported features are echoed as warnings in the
     'Commands'-window.";
        input Boolean check_also_disabled = false
          "Configures if also disabled features should be checked (for example
     a disabled code generator etc).";

        output Boolean supported
          "Whether the configuration is expected to work (i.e., is supported) or if
     it is marked to be unsupported ('true', if the configuration is supported;
     otherwise 'false').";

    protected
        constant String instance_name = getInstanceName();
        String warnings;

        Boolean pcode_supported;

        String bcode_container_name;

      algorithm
        supported := true;

        /*
    Check the originating production code configurations:
  */
        pcode_supported := ProductionCode.check_configuration(
          ESP = ESP);

        /*
    Check for unsupported marks:
  */
        warnings := "\n\nWARNING (" + instance_name + "):"
          + "\n  Some Binary Code container configurations are marked to be unsupported."
          + "\n  They likely require missing or prototypical eFMU generation facilities."
          + "\n  Generating an eFMU may fail or yield invalid solutions."
          + "\n  The unsupported features are:";
        for pc in ESP.production_codes loop
          for bc in ESP.binary_codes loop
            bcode_container_name :=
              "BCode_ESP_"
              + String(BuildUtilities.ProductionCode.configuration_hash(pc))
              + "_"
              + String(BuildUtilities.BinaryCode.configuration_hash(bc));

            if (bc.active or check_also_disabled)
              and bc.not_yet_supported <> "" then
              supported := false;
              warnings :=
                warnings
                + "\n    - CATIA ESP Binary Code configuration: " + bcode_container_name
                + "\n      " + bc.not_yet_supported;
            end if;
          end for;
        end for;
        warnings := warnings + "\n\n";
        if not
              (supported) and display_warnings then
          .Modelica.Utilities.Streams.print(warnings);
        end if;

        supported := pcode_supported and supported;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end check_configuration;

      function build
        "Build all CATIA ESP Binary Code containers.
   The concrete configuration used can be interactively changed; by default the
   package's configuration is used. Interactive changes apply only for this very
   build, i.e., temporarily."
        extends Icons.BuildEmbedded;

        input Boolean update = true
          "Configures, if the Binary Code container is updated or created anew.";

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP production code configurations used for the build.";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;

        String build_directory;
        final String eFMU_name = "eFMU";

        String pcode_configuration_hash;
        String pcode_container_name;

        String bcode_configuration_hash;
        String bcode_container_name;
        String bcode_log_file;

        String command;

      algorithm
        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        // Always perform common configuration checks:
        () := check_configuration(
          ESP = ESP);

        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".BinaryCode.build") - 1)
            else efmu.name);

        for pc in ESP.production_codes loop
          pcode_configuration_hash :=
            String(BuildUtilities.ProductionCode.configuration_hash(pc));
          pcode_container_name := "PCode_ESP_" + pcode_configuration_hash;

          if pc.active then for bc in ESP.binary_codes loop
            bcode_configuration_hash :=
              String(BuildUtilities.BinaryCode.configuration_hash(bc));
            bcode_container_name :=
              "BCode_ESP_"
              + pcode_configuration_hash
              + "_"
              + bcode_configuration_hash;
            bcode_log_file :=
              build_directory
              + "/"
              + eFMU_name
              + "/"
              + bcode_container_name
              + "/logs/build-log.txt";

            if not
                  (bc.active) then
              .Modelica.Utilities.Streams.print(
                "\nSkipped to generate Binary Code container: " + bcode_container_name
                + "\n  CATIA ESP configuration deactivated."
                + "\n");
            elseif not
                      (.Modelica.Utilities.Files.exist(build_directory + "/" + eFMU_name + "/" + pcode_container_name + "/manifest.xml")) then
              build_result.succeeded := false;
              build_result.error_message :=
                "Failed to generate Binary Code container: " + bcode_container_name
                + "\n  Production Code container [" + pcode_container_name + "] missing.";
              return;
            else
              /*
          Create directories for generated artefacts:
        */
              if not
                    (update) then
                // Empty container:
                .Modelica.Utilities.Files.remove(
                  build_directory + "/" + eFMU_name + "/" + bcode_container_name);
              end if;
              // Create container:
              .Modelica.Utilities.Files.createDirectory(
                build_directory + "/" + eFMU_name + "/" + bcode_container_name + "/logs");

              /*
          Build binary code:
        */
              command :=
                "cd \"" + build_directory + "\"" +
                " & set \"containerType=BinaryCode\"" +
                " & set \"srcDir=" + build_directory + "/" + eFMU_name + "\"" +
                " & set \"prdCodeName=" + pcode_container_name + "\"" +
                " & set \"binCodeName=" + bcode_container_name + "\"" +
                " & set \"cmpName=VS\"" +
                " & set \"cmpVendor=Microsoft\"" +
                " & set \"cmpExecName=cl\"" +
                " & set \"cmpOptSets=default SWT nologo\"" +
                " & set \"dftCmpOptSetName=default\"" +
                " & set \"lkrName=VS\"" +
                " & set \"lkrVendor=Microsoft\"" +
                " & set \"lkrExeName=lib\"" +
                " & set \"lkrOptSet=SWT nologo\"" +
                " & set \"tgtName=Windows\"" +
                " & set \"tgtVendor=CATIA ESP\"" +
                " & set \"tgtChipVersion=1.0\"" +
                " & set \"tgtInstrSetArch=" +
                  (if bc.isa == BuildUtilities.BinaryCode.ISA.x86_32bit then "x86"
                   else "x64") + "\"" +
                " & set \"tgtEndianess=big\"" +
                " & set \"tgtRegWidth=" +
                  (if bc.isa == BuildUtilities.BinaryCode.ISA.x86_32bit then "32"
                   else "64") + "\"" +
                " & set \"tgtAddrWidth="+
                  (if bc.isa == BuildUtilities.BinaryCode.ISA.x86_32bit then "32"
                   else "64") + "\"" +
                " & set \"objExt=obj\"" +
                " & set \"binExt=lib\"" +
                " & cmd /C \"" + R.esp + "/execute-esp.bat\"" +
                " > " + "\"" + bcode_log_file + "\" 2>&1" +
                " & if ERRORLEVEL 1 ( exit /b 1 )";
              build_result.succeeded := .Modelica.Utilities.System.command(command) == 0;
              if not build_result.succeeded then
                build_result.error_message :=
                  "Failed to generate Binary Code container: " + bcode_container_name
                  + "\n  Cf. '" + bcode_log_file + "' for details.";
                return;
              end if;
            end if;
          end for; end if;
        end for;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build;

      function build_binary_stub
        "Generate and/or load a eFMU co-simulation stub wrapping the eFMU
   production codes generated by CATIA ESP for SiL simulation as
   ordinary Modelica component."
        extends Icons.BuildModelica;

        input BuildUtilities.ESP_Configurations ESP = ESP_configurations
          "CATIA ESP production code configurations used for the build.";

        input Boolean build_binary_stub = true
          "Configures, if the eFMU co-simulation stub is generated.";
        input Boolean load_binary_stub = true
          "Configures, if the eFMU co-simulation stub is loaded. If the stub has not
     been build as well, the eFMU is checkd for any existing stub which is
     loaded; if such is missing, then 'build_result.succeeded = false'.";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;

        String configuration_package;
        String build_directory;
        final String eFMU_name = "eFMU";
        final String acode_container_name = "ACode_Dymola";

        String efmu_configuration_hash;
        String galec_program;

        String efmu_stub_package_name;
        String efmu_stub_directory;
        String efmu_stub_file;

        Boolean is_any_esp_configuration_active;

        String pcode_configuration_hash;
        String[:] pcode_container_names;
        String pcode_interface_name;
        String[:] pcode_interface_names;

        String bcode_configuration_hash;

        String[:] library_directories;
        String[:] library_names;

        BuildUtilities.BinaryCode.BCodeToBinaryStub implementation;
        BuildUtilities.BinaryCode.BCodeToBinaryStub[:] implementations;

      algorithm
        () := clearlog();

        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        if build_binary_stub then
          // Always perform common configuration checks:
          () := check_configuration(
            ESP = ESP);
        end if;

        // Workaround Dymola bug: instead of...
        (build_directory,, configuration_package) :=
          browse_code(open_file_manager = false);
        // ...use:
        configuration_package := .Modelica.Utilities.Strings.substring(
          getInstanceName(),
          1,
          .Modelica.Utilities.Strings.findLast(
            getInstanceName(),
            ".BinaryCode.build_binary_stub") - 1);
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name);

        efmu_configuration_hash := "H"
          + String(abs(.Modelica.Utilities.Strings.hashString(
            if efmu.name == ""
            then configuration_package
            else efmu.name)));

        galec_program := build_directory + "/deobfuscation/block.alg";
        if not
              (.Modelica.Utilities.Files.exist(galec_program)) then
          galec_program :=
            build_directory
            + "/"
            + eFMU_name
            + "/"
            + acode_container_name
            + "/block.alg";
        end if;

        /*
    Configure the stub packages's name and location:
  */
        efmu_stub_package_name :=
          "'"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name)
          + ".eFMU_SiL_Support'";
        efmu_stub_directory :=
          build_directory + "/SiL-integration/eFMU";
        efmu_stub_file := efmu_stub_directory + "/_package_.mo";

        if build_binary_stub then
          /*
      Configure the production codes, their interfaces and respective
      target-platform implementations (i.e., static linked libraries) used
      for co-simulation:
    */
          is_any_esp_configuration_active := false;
          for pc in ESP.production_codes loop
            if pc.active then
              pcode_configuration_hash :=
                String(BuildUtilities.ProductionCode.configuration_hash(pc));

              // Derive the container name of each production code (used by the eFMU
              // co-simulation stub to configure the co-simulated production codes):
              pcode_container_names := cat(
                1,
                pcode_container_names,
                {"PCode_ESP_" + pcode_configuration_hash});

              // Derive the interface name of each production code (used by the eFMU
              // co-simulation stub to bind the interface-functions of respective
              // production code implementations):
              pcode_interface_name :=
                efmu_configuration_hash + "_" + pcode_configuration_hash;
              pcode_interface_names := cat(
                1,
                pcode_interface_names,
                {pcode_interface_name});

              // Derive the library name of each production code (used by the eFMU
              // co-simulation stub to bind implementations of the respective production
              // code):
              library_directories := cat(
                1,
                library_directories,
                {"modelica://" + efmu_stub_package_name + "/"});

              // Derive the library directory of each production code (used by the eFMU
              // co-simulation stub to bind implementations of the respective production
              // code):
              library_names := cat(
                1,
                library_names,
                {pcode_interface_name});

              for bc in ESP.binary_codes loop
                if bc.active then
                  is_any_esp_configuration_active := true;

                  bcode_configuration_hash :=
                    String(BuildUtilities.BinaryCode.configuration_hash(bc));

                  // Derive the mapping of eFMU binaries to implementation libraries
                  // used by the eFMU co-simulation stub:
                  implementation := BuildUtilities.BinaryCode.BCodeToBinaryStub(
                    bcode_container_name=
                      "BCode_ESP_"
                      + pcode_configuration_hash
                      + "_"
                      + bcode_configuration_hash,
                    target_platform=
                      (if bc.isa == BuildUtilities.BinaryCode.ISA.x86_32bit then "win32"
                       else "win64"),
                    library_name = pcode_interface_name);
                  implementations := cat(
                    1,
                    implementations,
                    {implementation});

                  // Check that the Binary Code container is available:
                  if not
                        (.Modelica.Utilities.Files.exist(
                    build_directory
                    + "/"
                    + eFMU_name
                    + "/"
                    + implementation.bcode_container_name
                    + "/block.lib")) then
                    build_result.succeeded := false;
                    build_result.error_message :=
                      "Failed to generate eFMU co-simulation stub for: " + configuration_package
                      + "\n  Binary Code container [" + implementation.bcode_container_name + "]"
                      + "\n  or its binary [block.lib] missing.";
                    return;
                  end if;
                end if;
              end for;
            end if;
          end for;

          if not
                (.Modelica.Utilities.Files.exist(galec_program)) then
            build_result.succeeded := false;
            build_result.error_message :=
              "Failed to generate eFMU co-simulation stub for: " + configuration_package
              + "\n  Algorithm Code container [" + acode_container_name + "]"
              + "\n  or its GALEC code [block.alg] missing.";
            return;
          elseif not
                    (is_any_esp_configuration_active) then
            .Modelica.Utilities.Streams.print(
              "\nSkipped to generate eFMU co-simulation stub for: " + configuration_package
              + "\n  No active CATIA ESP production or binary code configuration."
              + "\n");
          else
            /*
        Unload and delete existing co-simulation stub:
      */
            if .ModelManagement.Structure.AST.Misc.ClassExists(efmu_stub_package_name) then
              () := .ModelManagement.Structure.AST.Misc.EraseClasses({efmu_stub_package_name});
            end if;
            .Modelica.Utilities.Files.remove(efmu_stub_directory);
            .Modelica.Utilities.Files.createDirectory(efmu_stub_directory);

            /*
        Copy libraries used for co-simulation to the stub's directory:
      */
            for i in implementations loop
              if not
                    (.Modelica.Utilities.Files.exist(
                efmu_stub_directory + "/" + i.target_platform)) then
                .Modelica.Utilities.Files.createDirectory(
                  efmu_stub_directory + "/" + i.target_platform);
              end if;
              .Modelica.Utilities.Files.copy(
                build_directory
                  + "/"
                  + eFMU_name
                  + "/"
                  + i.bcode_container_name
                  + "/block.lib",
                efmu_stub_directory
                  + "/"
                  + i.target_platform
                  + "/"
                  + i.library_name
                  + ".lib",
                replace = true);
            end for;

            /*
        Generate co-simulation stub:
      */
            .Modelica.Utilities.Streams.print(
              string = BuildUtilities.BinaryCode.BinaryStubGeneration.declare_stub_package(
                configuration_package = configuration_package,
                source_model = modelica_model.model_name,
                galec_program = galec_program,
                sample_period = integrator.sample_period,
                stub_package_name = efmu_stub_package_name,
                pcode_container_names = pcode_container_names,
                library_directories = library_directories,
                library_names = library_names,
                pcode_interface_names = pcode_interface_names),
              fileName = efmu_stub_file);
          end if;
        end if;

        /*
    Load eFMU co-simulation stub:
  */
        if load_binary_stub then
          if not
                (.Modelica.Utilities.Files.exist(efmu_stub_file)) then
            build_result.succeeded := false;
            build_result.error_message :=
                "\nFailed to load eFMU co-simulation stub for: " + configuration_package
              + "\n  Stub does not exist; please generate it first."
              + "\n";
            return;
          end if;
          build_result.succeeded := .ModelManagement.Structure.AST.Misc.ReadModelicaFile(
            fileName = efmu_stub_file);
          if not
                (build_result.succeeded) then
            build_result.error_message :=
                "\nFailed to load eFMU co-simulation stub for: " + configuration_package
              + "\n  Stub import error."
              + "\n";
            return;
          end if;
        end if;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build_binary_stub;

      function load_binary_stub
        "Load the eFMU co-simulation stub of the eFMU if any is available (the stub
   is not build, only loaded)."
        extends Icons.BuildModelica;

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

      algorithm
        build_result := build_binary_stub(
          build_binary_stub = false,
          load_binary_stub = true);

        annotation (
          Protection(
            hideFromBrowser = true),
          preferredView = "info",
          __Dymola_interactive = true);
      end load_binary_stub;

      function build_FMU
        "Generate and optionally import a FMU implemented by the binaries of the
   CATIA ESP Binary Code containers linked by the eFMU co-simulation stub."
        extends Icons.Bundle;
        extends Icons.Build;

        input Boolean import_FMU = true
          "Configures, if the generated FMU is imported as well.";

        output BuildUtilities.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;
        BuildUtilities.ESP_Configurations ESP = ESP_configurations;

        String configuration_package;
        String build_directory;

        String efmu_configuration_hash;

        String efmu_stub_package_name;
        String efmu_stub_file;
        Boolean efmu_stub_was_loaded;

        String fmu_modelIdentifier;
        String fmu_stub_model_name;
        String fmu_directory;

      algorithm
        () := clearlog();

        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          ESP = ESP);

        // Workaround Dymola bug: instead of...
        (build_directory,, configuration_package) :=
          browse_code(open_file_manager = false);
        // ...use:
        configuration_package := .Modelica.Utilities.Strings.substring(
          getInstanceName(),
          1,
          .Modelica.Utilities.Strings.findLast(
            getInstanceName(),
            ".BinaryCode.build_FMU") - 1);
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name);

        efmu_configuration_hash := "H"
          + String(abs(.Modelica.Utilities.Strings.hashString(
            if efmu.name == ""
            then configuration_package
            else efmu.name)));

        /*
    Configure the stub package's name and location:
  */
        efmu_stub_package_name :=
          "'"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name)
          + ".eFMU_SiL_Support'";
        efmu_stub_file :=
          build_directory + "/SiL-integration/eFMU/_package_.mo";
        efmu_stub_was_loaded :=
          .ModelManagement.Structure.AST.Misc.ClassExists(efmu_stub_package_name);

        /*
    Configure the FMU's name and location:
  */
        fmu_modelIdentifier := efmu_configuration_hash;
        fmu_stub_model_name := fmu_modelIdentifier + "_fmu_black_box";
        fmu_directory :=
          build_directory + "/SiL-integration/FMU";

        if not
              (.Modelica.Utilities.Files.exist(efmu_stub_file)) then
          build_result.succeeded := false;
          build_result.error_message :=
            "\nFailed to generate FMU for: " + configuration_package
            + "\n  eFMU co-simulation stub missing."
            + "\n";
          return;
        else
          /*
      Unload and delete existing FMU:
    */
          if .ModelManagement.Structure.AST.Misc.ClassExists(fmu_stub_model_name) then
            () := .ModelManagement.Structure.AST.Misc.EraseClasses(
              {fmu_stub_model_name});
          end if;
          .Modelica.Utilities.Files.remove(fmu_directory);
          .Modelica.Utilities.Files.createDirectory(fmu_directory);

          /*
      Generate FMU:
    */
          // ALWAYS load eFMU co-simulation stub if not loaded yet:
          if not
                (efmu_stub_was_loaded) then
            () := .ModelManagement.Structure.AST.Misc.ReadModelicaFile(
              fileName = efmu_stub_file);
          end if;
          // Then generate FMU:
          build_result.error_message := .DymolaCommands.SimulatorAPI.translateModelFMU(
            modelToOpen = efmu_stub_package_name + ".BinaryStub",
            storeResult = false,
            modelName = fmu_modelIdentifier,
            fmiVersion = "2",
            fmiType = "cs",
            includeSource = false,
            includeImage = 0,
            includeVariables = fill("", 0));
          // ALWAYS unload eFMU co-simulation stub if not originally loaded:
          if not
                (efmu_stub_was_loaded) then
            () := .ModelManagement.Structure.AST.Misc.EraseClasses(
              {efmu_stub_package_name});
          end if;
          if build_result.error_message == ""
            or build_result.error_message <> fmu_modelIdentifier then
            build_result.succeeded := false;
            build_result.error_message :=
                "\nFailed to generate FMU for: " + configuration_package
              + "\n  FMU generation error."
              + "\n";
            return;
          end if;

          /*
      Move generated FMU:
    */
          .Modelica.Utilities.Files.move(
            .Modelica.Utilities.System.getWorkDirectory()
            + "/"
            + fmu_modelIdentifier
            + ".fmu",
            fmu_directory + "/" + fmu_modelIdentifier + ".fmu",
            replace = true);

          /*
      Import FMU:
    */
          if import_FMU then
            build_result.succeeded := DymolaCommands.SimulatorAPI.importFMU(
              fileName = fmu_directory + "/" + fmu_modelIdentifier + ".fmu",
              includeAllVariables = false,
              integrate = false,
              promptReplacement = false,
              packageName = "",
              includeVariables = fill("", 0));
            if not
                  (build_result.succeeded) then
              build_result.error_message :=
                  "\nFailed to generate FMU for: " + configuration_package
                + "\n  FMU import error."
                + "\n";
              return;
            end if;
          end if;
        end if;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build_FMU;
      annotation (preferredView = "info");
    end BinaryCode;

    package Dymola_C "DEPRECATED: Build functionalities for
   Dymola's legacy embedded C code generator."
      extends Icons.DymolaEmbedded;

      extends .Modelica.Icons.ObsoleteModel;

      function build
        "DEPRECATED: Build production and binary code using Dymola's legacy embedded
   C code generator."
        extends Icons.BuildEmbedded;
        extends .Modelica.Icons.ObsoleteModel;

        input BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration
          "Integrator configuration used for the build.";
        input BuildUtilities.AlgorithmCode.Code code = code_configuration
          "GALEC code configuration used for the build.";
        input BuildUtilities.Dymola_C.Dymola Dymola = dymola_production_code_configuration
          "Dymola Production Code configuration used for the build.";

        output BuildUtilities.Dymola_C.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;

        String build_directory;

        Integer integrator_inline_method;
        String integrator_inline_order;

        // Dymola Production Code configuration related support variables:
        constant String static_source_code_files[:] = {
          "dse_macros.h",
          "dse_types.h"};
        constant String generated_source_code_files[:] = {
          "dsembedded.c",
          "dsembedded.h",
          "dsembedded_codes.c",
          "dsembedded_prototypes.h",
          "dsembedded_structs.h"};
        BuildUtilities.Dymola_C.CompilerVersion compiler_selected;

        String command;
        String tmp_string;

      algorithm
        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.Dymola_C.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          Dymola = Dymola);

        // Always perform common configuration checks:
        () := AlgorithmCode.check_configuration(
          integrator = integrator);

        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".Dymola_C.build") - 1)
            else efmu.name);
        build_directory := build_directory + "/dymola-c";

        if not
              (Dymola.active) then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to generate production and binary code; Dymola's legacy embedded C code generator is deactivated.";
          return;
        end if;
        if code.obfuscate <> BuildUtilities.AlgorithmCode.Code.ObfuscationLevel.None then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to generate production and binary code; Dymola's legacy embedded C code generator does not support code obfuscation.";
          return;
        end if;

        /*
    Cleanup and create directories for generated artefacts:
  */
        .Modelica.Utilities.Files.remove(build_directory);
        .Modelica.Utilities.Files.remove(build_directory + "/logs");
        .Modelica.Utilities.Files.remove(build_directory + "/sources");
        .Modelica.Utilities.Files.remove(build_directory + "/cppcheck");
        .Modelica.Utilities.Files.remove(build_directory + "/build");
        .Modelica.Utilities.Files.remove(build_directory + "/binaries");
        .Modelica.Utilities.Files.createDirectory(build_directory + "/logs");
        .Modelica.Utilities.Files.createDirectory(build_directory + "/sources");
        .Modelica.Utilities.Files.createDirectory(build_directory + "/build");
        .Modelica.Utilities.Files.createDirectory(build_directory + "/binaries");

        /*
    Map selected solver method to inline integration method:
  */
        integrator_inline_order := "";
        if integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.None then
          integrator_inline_method := 0;
        elseif integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.Implicit_Euler then
          integrator_inline_method := 2;
        elseif integrator.solver_method
          == BuildUtilities.AlgorithmCode.Integrator.SolverMethod.Explicit_Euler then
          integrator_inline_method := 1;
        else // Rosenbrock methods:
          integrator_inline_method := 7;
          integrator_inline_order := "Advanced.InlineOrder=" +
            String(Integer(integrator.solver_method) - 3) + ",";
        end if;

        /*
    Generate C code:
  */
        () := clearlog();
        build_result.succeeded := translateModelExport(modelica_model.model_name +
          " annotation(__Dymola_experimentFlags(" +
            "Advanced.TranslationInCommandLog=true," +
            "Hidden.eFMICodeGenerationSupport=true," +
            "Hidden.SolveSmallSymbolically=true," +
            "Hidden.GenerateDsEmbedded=true," +
            "Hidden.VariablePrefixEmbedded=\"\"," +
            "Advanced.CompileAfterTranslation=false," +
            "Hidden.LapackCodeExport=true," +
            "Advanced.AutomaticDifferentiation=true," +
            "Advanced.AllowNumericDifferentiation=true," +
            "Advanced.PrintFailureToDifferentiate=true," +
            "Hidden.InitializeClockedDiscretizedStates=true," +
            "Advanced.InlineFixedStep=" + String(integrator.sample_period) + "," +
            "Advanced.InlineMethod=" + String(integrator_inline_method) + "," +
            integrator_inline_order +
            "Hidden.TranslateOnlyClockedPart=" + String(modelica_model.only_clocked) + "," +
            "Advanced.Embedded.OptimizeForOutputs=true," +
            "Hidden.HandleNonRealInputAlsoFMI2=false," +
            "Advanced.InlineXMLTypeDefinitions=false," +
            "Advanced.OutputPlainNestedDeclaredCausality=true," +
            "Advanced.AllowParameterAlias=true," +
            "Advanced.EvaluateAlsoTop=" + String(code.fold_parameters) +"," +
            "Evaluate=" + String(code.fold_parameters) +
          "))");
        () := savelog(
          build_directory + "/logs/build-log.txt");
        () := clearlog();
        if not build_result.succeeded then
          build_result.error_message :=
            "Failed to generate production code using Dymola's legacy embedded C code generator.";
          return;
        end if;

        /*
    Copy generated C code:
  */
        for file in static_source_code_files loop
          .Modelica.Utilities.Files.copy(
            .Modelica.Utilities.System.getEnvironmentVariable("DYMOLA", true) + "/source/" + file,
            build_directory + "/sources/" + file,
            replace = true);
        end for;
        for file in generated_source_code_files loop
          .Modelica.Utilities.Files.move(
            .Modelica.Utilities.System.getWorkDirectory() + "/" + file,
            build_directory + "/sources/" + file,
            replace = true);
        end for;

        /*
    Copy include directory contents:
  */
        for directory in Dymola.includes loop
          tmp_string := .Modelica.Utilities.Files.loadResource(directory);
          for file in SupportFunctions.get_files(tmp_string) loop
            .Modelica.Utilities.Files.copy(
              tmp_string + "/" + file,
              build_directory + "/sources/" + file,
              replace = false);
          end for;
        end for;

        /*
    Select compiler:
  */
        (build_result.succeeded, compiler_selected) :=
          BuildUtilities.Dymola_C.find_compiler(Dymola.compiler_version);
        if not build_result.succeeded then
          build_result.error_message :=
            "Failed to find compiler for Dymola's legacy embedded C code generator.";
          return;
        end if;

        /*
    Copy build scripts:
  */
        .Modelica.Utilities.Files.copy(
          R.dymola_c_vs_configurations + "/" + String(compiler_selected),
          build_directory + "/build/",
          replace = true);

        /*
    Build binary code:
  */
        command :=
          "cd \"" + build_directory + "/build/\"" +
          " & build.bat" +
          " " + (if BuildUtilities.BinaryCode.resolve_isa() == BuildUtilities.BinaryCode.ISA.x86_32bit then "x86" else "x64") +
          " " + String(Dymola.build_version) +
          " & if ERRORLEVEL 1 ( exit /b 1 )";
        build_result.succeeded := .Modelica.Utilities.System.command(command) == 0;
        if not build_result.succeeded then
          build_result.error_message :=
            "Faild to compile production code generated by Dymola's legacy embedded C code generator.";
          return;
        end if;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build;

      function check_code
        "DEPRECATED: Analyse the production code generated by Dymola's legacy embedded C
   code generator for embedded code qualities."
        extends Icons.SourceCodeAnalysis;
        extends .Modelica.Icons.ObsoleteModel;

        input Boolean open_log = true
          "Whether the log file summarizing the check-results will be opened after
     checking or not ('true' opens the log in the system's default editor for
     '.txt' files).";

        output BuildUtilities.Dymola_C.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;
        BuildUtilities.Dymola_C.Dymola Dymola = dymola_production_code_configuration;

        String build_directory;

        String cppcheck_directory;
        String log_file;

        String command;

      algorithm
        () := clearlog();

        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.Dymola_C.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          Dymola = Dymola);

        // Workaround Dymola bug: instead of...
        (build_directory,,) :=
          browse_code(open_file_manager = false);
        // ...use:
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then .Modelica.Utilities.Strings.substring(
              getInstanceName(),
              1,
              .Modelica.Utilities.Strings.findLast(
                getInstanceName(),
                ".Dymola_C.check_code") - 1)
            else efmu.name);
        build_directory := build_directory + "/dymola-c";

        cppcheck_directory :=
          build_directory + "/cppcheck/";
        log_file :=
          build_directory + "/logs/check-code-log.txt";

        if not
              (Dymola.active) then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to check production code; Dymola's legacy embedded C code generator is deactivated.";
          return;
        end if;
        if not
              (.Modelica.Utilities.Files.exist(build_directory + "/sources")
          and .Modelica.Utilities.Files.exist(build_directory + "/build/block.vcxproj")) then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to check production code; production code or Microsoft Visual Studio project file missing.";
          return;
        end if;

        /*
    Copy Cppcheck artefacts:
  */
        if not
              (.Modelica.Utilities.Files.exist(cppcheck_directory)) then
          .Modelica.Utilities.Files.createDirectory(cppcheck_directory);
          .Modelica.Utilities.Files.copy(
            R.dymola_c_cppcheck,
            cppcheck_directory,
            replace = true);
        end if;

        /*
    Execute Cppcheck and open log:
  */
        command :=
          "cd \"" + cppcheck_directory + "\"" +
          " & check-code.bat " +
          " & if ERRORLEVEL 1 ( exit /b 1 )";
        build_result.succeeded := .Modelica.Utilities.System.command(command) == 0;
        if open_log and .Modelica.Utilities.Files.exist(log_file) then
          () := .Modelica.Utilities.System.command("start \"\" \"" + log_file + "\"");
        end if;
        if not
              (build_result.succeeded) then
          build_result.error_message :=
            "Failed to check production code (cf. '" + log_file + "' for details).";
          return;
        end if;

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true,
          Documentation(info="<html>
<b>Important:</b> Please check, and confirm, the
<a href=\"modelica://DymolaEmbedded.UsersGuide.Requirements\">Requirements</a>
of the production code analyses facilities before using this function.
</html>"));
      end check_code;

      function build_binary_stub
        "DEPRECATED: Generate and load a Modelica stub-model wapping the binary code
   generated by Dymola's legacy embedded C code generator for cosimulation as
   ordinary Modelica component."
        extends Icons.BuildModelica;
        extends .Modelica.Icons.ObsoleteModel;

        output BuildUtilities.Dymola_C.BuildResult build_result
          "Build success report compiling all relevant build information.";

    protected
        BuildUtilities.eFMU efmu = efmu_configuration;
        BuildUtilities.AlgorithmCode.Model modelica_model = model_configuration;
        BuildUtilities.AlgorithmCode.Integrator integrator = integrator_configuration;
        BuildUtilities.AlgorithmCode.Code code = code_configuration;
        BuildUtilities.Dymola_C.Dymola Dymola = dymola_production_code_configuration;

        String configuration_package;
        String build_directory;

        String stub_model_name;
        String stub_directory;
        String stub_file;

      algorithm
        () := clearlog();

        // Defensive programming - by default assume the build fails:
        build_result := BuildUtilities.Dymola_C.BuildResult(
          succeeded = false,
          error_message = "Unknown error.",
          efmu = efmu,
          modelica_model = modelica_model,
          integrator = integrator,
          code = code,
          Dymola = Dymola);

        // Workaround Dymola bug: instead of...
        (build_directory,, configuration_package) :=
          browse_code(open_file_manager = false);
        // ...use:
        configuration_package := .Modelica.Utilities.Strings.substring(
          getInstanceName(),
          1,
          .Modelica.Utilities.Strings.findLast(
            getInstanceName(),
            ".Dymola_C.build_binary_stub") - 1);
        build_directory :=
          .Modelica.Utilities.System.getWorkDirectory()
          + "/"
          + (if efmu.name == ""
            then configuration_package
            else efmu.name);
        build_directory := build_directory + "/dymola-c";

        if not
              (Dymola.active) then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to generate binary stub; Dymola's legacy embedded C code generator is deactivated.";
          return;
        end if;
        if not
              (.Modelica.Utilities.Files.exist(build_directory + "/binaries")) then
          build_result.succeeded := false;
          build_result.error_message :=
            "Failed to generate binary stub; binaries missing.";
          return;
        end if;

        /*
    Configure the stub model's name and location:
  */
        stub_model_name :=
          "'"
          + (if efmu.name == "" then configuration_package else efmu.name)
          + ".eFMU_Stub'";
        stub_directory :=
          build_directory + "/modelica-integration";
        stub_file := stub_directory + "/eFMU_Stub.mo";

        /*
    Unload and delete old generated co-simulation stub:
  */
        if .ModelManagement.Structure.AST.Misc.ClassExists(stub_model_name) then
          () := .ModelManagement.Structure.AST.Misc.EraseClasses({stub_model_name});
        end if;
        .Modelica.Utilities.Files.remove(stub_directory);
        .Modelica.Utilities.Files.createDirectory(stub_directory);

        /*
    Generate and load co-simulation stub:
  */
        .Modelica.Utilities.Streams.print(
          string = BuildUtilities.Dymola_C.StubGeneration.declare_stub_model(
            source_model = modelica_model.model_name,
            stub_model_name = stub_model_name,
            configuration_package = configuration_package,
            library_directory = "modelica://" + stub_model_name + "/../binaries",
            library_name = "block"),
          fileName = stub_file);
        () := .ModelManagement.Structure.AST.Misc.ReadModelicaFile(
          fileName = stub_file);

        // Defensive programming - we are still here, so everything is alright:
        build_result.succeeded := true;
        build_result.error_message := "";
        return;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end build_binary_stub;
      annotation (preferredView = "info");
    end Dymola_C;
    constant BuildUtilities.eFMU efmu_configuration
      "Configures general characteristics of generated eFMUs.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (
        HideResult = true,
        Placement(transformation(extent={{56,-86},{94,-48}})));
    constant BuildUtilities.AlgorithmCode.Model model_configuration
      "Configures the model used for eFMI Algorithm Code container generation.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (
        HideResult = true,
        Placement(transformation(extent = {{-80,40},{-60,60}})));
    constant BuildUtilities.AlgorithmCode.Integrator integrator_configuration
      "Configures the integration scheme applied by generated eFMI GALEC code.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (
        HideResult = true,
        Placement(transformation(extent = {{-10,40},{10,60}})));
    constant BuildUtilities.AlgorithmCode.Code code_configuration
      "Configures code-characteristics of the generated eFMI GALEC code.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (
        HideResult = true,
        Placement(transformation(extent = {{60,40},{80,60}})));
    constant BuildUtilities.ESP_Configurations ESP_configurations(
        production_codes={BuildUtilities.ProductionCode.ESP_Configuration(
          float_precision=BuildUtilities.ProductionCode.FloatPrecision.x32),
          BuildUtilities.ProductionCode.ESP_Configuration(float_precision=
          BuildUtilities.ProductionCode.FloatPrecision.x64)}, binary_codes={
          BuildUtilities.BinaryCode.ESP_Configuration(isa=BuildUtilities.BinaryCode.ISA.x86_32bit),
          BuildUtilities.BinaryCode.ESP_Configuration(isa=BuildUtilities.BinaryCode.ISA.x86_64bit)})
      "Optional configurations for the CATIA ESP production and binary code generator.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (HideResult=true, Placement(transformation(extent={{-10,-60},{10,
              -40}})));
    constant BuildUtilities.ExternalResources R
      "Directories of external resources shipping with, and used by,
     'DymolaEmbedded'."
      annotation (
        HideResult = true);
    constant BuildUtilities.Dymola_C.Dymola dymola_production_code_configuration(
      includes = fill("", 0))
      "Optional configuration for Dymola's legacy embedded C code generator.
     Must be configured by concrete embedded-configurations (sub-packages)."
      annotation (
        HideResult = true,
        Placement(transformation(extent={{-80,-60},{-60,-40}})));

    annotation (
      preferredView = "info",
      Documentation(info=
      "<html>This package is the base-package for eFMU generation configurations.
    Its purpose is to be subclassed to set-up the build and runtime parameters
    for a concrete embedded code generation scenario within the scope of the
    subclassing package and its sub-components. We call subclassing packages a
    concrete configuration; the functionalities inherited from this
    package are automatically considering the settings of concrete
    configurations when applied within the scope of such.</html>"),
      Diagram(graphics={
        Rectangle(
          extent = {{-100,100},{100,-100}},
          lineThickness = 1,
          pattern = LinePattern.None,
          lineColor = {0,0,0},
          fillColor = {255,255,255},
          fillPattern = FillPattern.Solid),
        Rectangle(
          extent = {{-98,-2},{20,-20}},
          lineColor = {102,44,145},
          lineThickness = 1,
          fillColor = {102,44,145},
          fillPattern = FillPattern.Solid),
        Rectangle(
          extent = {{-98,98},{20,80}},
          lineColor = {28,108,200},
          lineThickness = 1,
          fillColor = {28,108,200},
          fillPattern = FillPattern.Solid),
        Rectangle(
          extent = {{-98,98},{98,2}},
          lineColor = {28,108,200},
          lineThickness = 1),
        Rectangle(
          extent = {{-98,-2},{98,-98}},
          lineColor = {102,44,145},
          lineThickness = 1),
        Text(
          extent = {{-88,96},{10,82}},
          lineColor = {255,255,255},
          textString = "Algorithm Code",
          textStyle = {TextStyle.Bold}),
        Text(
          extent = {{-88,-4},{10,-18}},
          lineColor={255,255,255},
          textStyle={TextStyle.Bold},
            textString="Production Codes"),
        Rectangle(
          extent = {{36,22},{48,-8}},
          pattern = LinePattern.None,
          lineThickness = 1,
          fillColor = {217,67,180},
          fillPattern = FillPattern.Solid),
        Polygon(
          points = {{26,-8},{58,-8},{42,-28},{26,-8}},
          pattern = LinePattern.None,
          lineThickness = 1,
          fillColor = {217,67,180},
          fillPattern = FillPattern.Solid),
        Text(
          extent = {{50,22},{80,2}},
          lineColor = {217,67,180},
          textString = "prerequisite\nfor")}));
  end EmbeddedConfiguration;

  package BuildUtilities
  "Configuration and build utilities for eFMU generation."
    extends Modelica.Icons.UtilitiesPackage;
    extends Icons.Build;

    record BuildResult
      "Report compiling information about the used configuration and build success
   of an eFMU generation."
      extends .Modelica.Icons.Record
        annotation(IconMap(extent={{-100,-75},{100,125}}));
      extends .Modelica.Icons.Information
        annotation(IconMap(extent={{-70,-70},{70,70}}));

      parameter Boolean succeeded
        "Whether the build succeeded or failed.";
      parameter String error_message
        "Error message in case the build failed.";
      parameter eFMU efmu
        "The eFMU configuration used for the build";
      parameter AlgorithmCode.Model modelica_model
        "Model configuration used for the build.";
      parameter AlgorithmCode.Integrator integrator
        "Integrator configuration used for the build.";
      parameter AlgorithmCode.Code code
        "Code configuration used for the build.";
      parameter ESP_Configurations ESP
        "CATIA ESP production and binary code generation-configurations used for the
     build.";

      annotation (preferredView = "info");
    end BuildResult;

    final record ExternalResources
      "Directories of external resources shipping with, and used by,
   'DymolaEmbedded'."

      extends .Modelica.Icons.Record
        annotation(IconMap(extent={{-100,-75},{100,125}}));
      extends Icons.DymolaEmbedded
        annotation(IconMap(extent={{-60,-60},{60,60}}));

      constant String root =  .Modelica.Utilities.Files.loadResource(
          "modelica://DymolaEmbedded/")
        + "Resources"
        "Absolute path of 'Resources' directory.";
      constant String efmi_xml_schemas=
        root + "/external-tooling/efmi-xml-schemas"
        "Absolute path of the directory with the eFMI XML Schemas.";
      constant String esp=
        root + "/external-tooling/esp"
        "Absolute path of the directory with CATIA ESP and its related support
     tooling.";
      constant String cppcheck=
        root + "/external-tooling/cppcheck"
        "Absolute path of the directory with Cppcheck related support tooling.";
      constant String eFMI_Compliance_Checker=
        root + "/external-tooling/efmi-compliance-checker"
        "Absolute path of the directory with the eFMI Compliance Checker and its
     related support tooling.";
      constant String eFMI_Container_Manager=
        root + "/external-tooling/efmi-container-manager"
        "Absolute path of the directory with the eFMI Container Manager and its
     related support tooling.";
      constant String dymola_c_cppcheck=
        root + "/external-tooling/deprecated-dymola-c-backend/cppcheck"
        "DEPRECATED: Absolute path of the directory with Cppcheck related support
     tooling for Dymola's legacy embedded C code generator.";
      constant String dymola_c_vs_configurations=
        root + "/external-tooling/deprecated-dymola-c-backend/vs-configurations"
        "DEPRECATED: Absolute path of the directory with Microsoft Visual Studio
     related support tooling for Dymola's legacy embedded C code generator.";

      function ESP_available
        "Check if CATIA ESP is available."
        extends Icons.Configuration;
        extends Icons.Analysis;

        output Boolean is_available
          "'true' if CATIA ESP has been found, 'false' otherwise.";
      algorithm
        is_available := .Modelica.Utilities.Files.exist(esp + "/bin/alg2prod.jar")
          and .Modelica.Utilities.Files.exist(esp + "/bin/prod2bin.jar");
      end ESP_available;

      annotation (preferredView = "info");
    end ExternalResources;

    record eFMU
      "eFMU configuration: Configures general eFMU characteristics."
      extends Icons.Bundle;
      extends Icons.Configuration;

      parameter String name = ""
        "Name of the eFMU and directory containing it. If left empty, the
     name will be derived from the full qualified Modelica name of the concrete
     configuration.";

      annotation (
        preferredView = "info",
        Icon(graphics={
          Text(
            extent={{-100,-100},{100,-150}},
            lineColor = {28,108,200},
            textStyle = {TextStyle.Bold},
            textString = "eFMU bundle\nconfiguration")}));
    end eFMU;

    record ESP_Configurations
      "CATIA ESP production and binary code generation-configurations for the eFMU."
      extends Icons.Embedded;
      extends Icons.Configuration;

      parameter ProductionCode.ESP_Configuration[:] production_codes
        "Array of all CATIA ESP production code configurations for the eFMU.";
      parameter BinaryCode.ESP_Configuration[:] binary_codes
        "Array of all CATIA ESP binary code configurations for the eFMU.";

      annotation (
        preferredView = "Info",
        Icon(
          graphics={
            Text(
              extent = {{-100,-140},{100,-210}},
              lineColor = {28,108,200},
              textStyle = {TextStyle.Bold},
              textString = "CATIA ESP\nconfigurations")}));
    end ESP_Configurations;

    package AlgorithmCode
    "Utilities for generating eFMI Algorithm Code containers."
      extends Icons.SourceCodeContainer;

      record Model
        "Model configuration: Configures the Modelica model subject to eFMU generation."
        extends Icons.SourceCode;
        extends Icons.Configuration;

        extends ConfigurationBaseTypes.Unsupported;

        parameter String model_name = ""
          "Modelica model for which to generate an eFMU."
          annotation(Dialog(__Dymola_translatedModel(translate = false)));
        parameter Boolean only_clocked = false
          "Configures, whether the given model is either, (1) a system model with
     clocked sub-partitions for which only code will be generated or (2) if code
     is generated for the whole model (i.e., not only its clocked
     sub-partitions). If 'true', clock independent model parts are ignored and
     will not be computed by the generated eFMU. Using this flag, whole
     system models can be conveniently used as input for eFMU code generation
     with code being only generated for their clocked parts (typically
     their controllers).";

        annotation (
          preferredView = "info",
          Icon(graphics={
            Text(
              extent={{-100,-130},{100,-180}},
              lineColor = {28,108,200},
              textStyle = {TextStyle.Bold},
              textString = "model\nconfiguration")}));
      end Model;

      record Integrator
        "Integrator configuration: Configures the simulation method applied by the
   generated eFMI GALEC code."
        extends Icons.Configuration;
        extends Icons.Runtime;

        extends ConfigurationBaseTypes.Unsupported;

        encapsulated type SolverMethod = enumeration(
          None
              "No solver",
          Implicit_Euler
              "Implicit Euler",
          Explicit_Euler
              "Explicit Euler",
          Rosenbrock_1
              "Rosenbrock (order 1)",
          Rosenbrock_2
              "Rosenbrock (order 2)",
          Rosenbrock_3
              "Rosenbrock (order 3)",
          Rosenbrock_4
              "Rosenbrock (order 4)")
          "Enumeration of solvers (i.e., integration methods for discretized
   continuous-time partitions) available for eFMU generation."
          annotation (
           Icon(
             graphics={
              Polygon(
                origin = {1.3835,-4.1418},
                rotation = 45.0,
                fillColor = {64,64,64},
                pattern = LinePattern.None,
                fillPattern = FillPattern.Solid,
                points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
                  {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
                  {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
                  {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
                  {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
                  {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
                  {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
                  {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
              Polygon(
                origin = {10.1018,5.218},
                rotation = -45.0,
                fillColor = {255,255,255},
                fillPattern = FillPattern.Solid,
                points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
                  {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
                  {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
                  {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
                  {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
                  {-20.0,82.273}})}));

        parameter .Modelica.Units.SI.Time sample_period = 0.0
          "Time span in which the eFMU will be called by the embedded runtime
     environment. If less or equal 0, a variable sampling period is assumed,
     otherwise the given constant interval. Variable sampling requires
     that the embedded runtime environment provides at each integration step,
     i.e., 'DoStep()' call, the time passed since the last call.";
        parameter SolverMethod solver_method = SolverMethod.None
          "Integration method used to solve any discretized continuous-time partitions
     resulting from differential equations of the model subject to eFMU
     generation. The solver's implementation (its complete source code) will be
     embedded into generated eFMU code, such that the eFMU is self-contained and
     does not require any external solvers.";

        function use_solver
          "Return whether the integrator configuration uses a solver method or not."
          extends .Modelica.Units.Icons.Conversion;

          output Boolean use_solver = not (solver_method == SolverMethod.None)
            "'true', if the integrator configuration specifies a certain integration
     method to solve any discretized continuous-time partitions; 'false'
     otherwise.";

        algorithm
          annotation (preferredView = "info");
        end use_solver;

        annotation (
          preferredView = "info",
          Icon(graphics={
            Text(
              extent = {{-100,-130},{100,-180}},
              lineColor = {28,108,200},
              textStyle = {TextStyle.Bold},
              textString = "integrator\nconfiguration")}));
      end Integrator;

      record Code
        "GALEC code configuration: Configures characteristics of the generated eFMI
   GALEC code (e.g., code obfuscation)."
        extends Icons.SourceCode;
        extends Icons.Configuration;

        encapsulated type ObfuscationLevel = enumeration(
          None
            "No obfuscation",
          Internal
            "Level 1: only non block-interface",
          Tunable
            "Level 2: also tunable parameters",
          Interface
            "Level 3: also block-inputs and -outputs")
          "Enumeration of obfuscation levels available for GALEC code generation."
          annotation (Icon(graphics={
        Polygon(
          origin = {1.3835,-4.1418},
          rotation = 45.0,
          fillColor = {64,64,64},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
            {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
            {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
            {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
            {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
            {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
            {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
            {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
        Polygon(
          origin = {10.1018,5.218},
          rotation = -45.0,
          fillColor = {255,255,255},
          fillPattern = FillPattern.Solid,
          points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
            {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
            {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
            {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
            {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
            {-20.0,82.273}})}));

        parameter ObfuscationLevel obfuscate = ObfuscationLevel.None
          "Configures whether, and if so how much, generated code is obfuscated or
     not.";
        parameter Boolean fold_parameters = false
          "Configures whether constants and parameters are statically evaluated,
     the respective results inlined and offset with one another
     (constant folded). Thereby all parameters, including top-level, are
     considered constants; tunable parameters are eliminated with their constant
     value being their respective default initialization value.";

        annotation (
          preferredView = "info",
          Icon(graphics={
            Text(
              extent = {{-100,-130},{100,-180}},
              lineColor = {28,108,200},
              textStyle = {TextStyle.Bold},
                textString = "code\nconfiguration")}));

      end Code;

      function solver_name
        "Map a solver representation as used by 'DymolaEmbedded' to its
   'Modelica.Clocked' string name."
        extends .Modelica.Units.Icons.Conversion;

        input Integrator.SolverMethod solver_type
          "Solver enumeration value as used by
     'DymolaEmbedded.BuildUtilities.Integrator.solver_method'.";
        input Boolean multi_rate
          "Whether the multi-rate variant of the solver is inqueried or not.";
        output String solver_name
          "Solver name as used by
     'Modelica.Clocked.ClockSignal.Interfaces.PartialClock.solverMethod'.";

      algorithm
        if solver_type == Integrator.SolverMethod.None then
          solver_name := "";
        else
          solver_name := .Modelica.Utilities.Strings.replace(
            String(solver_type),
            "_",
            "");
          if multi_rate then
            solver_name := "MultiRate_" + solver_name;
          end if;
        end if;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end solver_name;
      annotation (preferredView = "info");
    end AlgorithmCode;

    package ProductionCode
    "Utilities for generating eFMI Production Code containers."
      extends Icons.SourceCodeContainer;

      record ESP_Configuration
        "Production code configuration: Configures CATIA ESP for eFMI Production Code
   generation."
        extends ConfigurationBaseTypes.CodeGenerator(
          active = ExternalResources.ESP_available());

        parameter FloatPrecision float_precision = FloatPrecision.Dymola
          "Configures the precision of floating point operations of the
     generated production code.";

        annotation (
          preferredView = "Info",
          Icon(graphics={
            Text(
              extent={{-100,-140},{100,-210}},
              lineColor={28,108,200},
              textStyle={TextStyle.Bold},
                textString="CATIA ESP\nproduction code\nconfiguration")}));
      end ESP_Configuration;

      encapsulated type FloatPrecision = enumeration(
        Dymola
            "Current Dymola simulation precision",
        x32 "32-bit",
        x64 "64-bit")
        "Enumeration of floating-point operation precisions available for
   production code generation."
        annotation (Icon(graphics={
        Polygon(
          origin = {1.3835,-4.1418},
          rotation = 45.0,
          fillColor = {64,64,64},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
            {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
            {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
            {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
            {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
            {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
            {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
            {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
        Polygon(
          origin = {10.1018,5.218},
          rotation = -45.0,
          fillColor = {255,255,255},
          fillPattern = FillPattern.Solid,
          points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
            {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
            {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
            {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
            {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
            {-20.0,82.273}})}));

      function resolve_float_precision
        "Map a requested precision for floating point operations to an
   actual production code precision. By default, if no argument is given and
   therefore no specific precision is requested, 64 Bit will be selected."
        extends .Modelica.Units.Icons.Conversion;

        input FloatPrecision requested_precision = FloatPrecision.Dymola
          "The requested precision.";

        output FloatPrecision selected_precision
          "The selected actual production code precision.";

      algorithm
        selected_precision := (if requested_precision == FloatPrecision.Dymola
          then FloatPrecision.x64
          else requested_precision);

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end resolve_float_precision;

      function configuration_hash
        "Compute hash for given CATIA ESP production code configuration."
        extends .Modelica.Units.Icons.Conversion;

        input ESP_Configuration ESP
          "CATIA ESP production code configuration.";

        output Integer hash
          "Hash of configuration.";

      algorithm
        hash := abs(
          .Modelica.Utilities.Strings.hashString(
            String(resolve_float_precision(ESP.float_precision))));

        annotation (
          preferredView = "info");
      end configuration_hash;
      annotation (preferredView = "info");
    end ProductionCode;

    package BinaryCode "Utilities for generating eFMI Binary Code containers."
      extends Icons.BinaryCodeContainer;

      record ESP_Configuration
        "Binary code configuration: Configures CATIA ESP for eFMI Binary Code
   generation."
        extends ConfigurationBaseTypes.CodeGenerator(
          active = ExternalResources.ESP_available());

        parameter ISA isa = ISA.Dymola
          "Configures the target instruction set architecture (ISA) of the generated
     binaries.";

        annotation (
          preferredView = "Info",
          Icon(graphics={
            Text(
              extent={{-100,-140},{100,-210}},
              lineColor={28,108,200},
              textStyle={TextStyle.Bold},
                textString="CATIA ESP\nbinary code\nconfiguration")}));
      end ESP_Configuration;

      encapsulated type ISA = enumeration(
        Dymola
            "Current Dymola simulation ISA",
        x86_32bit
            "x86, 32-bit",
        x86_64bit
            "x86, 64-bit")
        "Enumeration of instruction set architectures available for
   binary code generation (target platform)."
      annotation (Icon(graphics={
      Polygon(
        origin = {1.3835,-4.1418},
        rotation = 45.0,
        fillColor = {64,64,64},
        pattern = LinePattern.None,
        fillPattern = FillPattern.Solid,
        points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
          {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
          {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
          {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
          {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
          {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
          {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
          {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin = {10.1018,5.218},
        rotation = -45.0,
        fillColor = {255,255,255},
        fillPattern = FillPattern.Solid,
        points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
          {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
          {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
          {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
          {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
          {-20.0,82.273}})}));

      function resolve_isa
        "Map a requested ISA to an actual target platform. By default, if no argument
   is given and therefore no specific ISA is requested, the current
   simulation-code ISA of Dymola as configured by the 'Advanced.CompileWith64'
   flag will be selected."
        extends .Modelica.Units.Icons.Conversion;

        input ISA requested_isa = ISA.Dymola
          "The requested ISA.";

        output ISA selected_isa
          "The selected actual ISA.";

      algorithm
        if requested_isa == ISA.Dymola then
          selected_isa :=
            (if Advanced.CompileWith64 == 2
             then ISA.x86_64bit
             else ISA.x86_32bit);
        else
          selected_isa := requested_isa;
        end if;

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end resolve_isa;

      function configuration_hash
        "Compute hash for given CATIA ESP binary code configuration."
        extends .Modelica.Units.Icons.Conversion;

        input ESP_Configuration ESP
          "CATIA ESP binary code configuration.";

        output Integer hash
          "Hash of configuration.";

      algorithm
        hash := abs(
          .Modelica.Utilities.Strings.hashString(
            String(resolve_isa(ESP.isa))));

        annotation (
          preferredView = "info",
          __Dymola_interactive = true);
      end configuration_hash;

      partial block BinaryStub
        "Base-model of eFMU co-simulation stubs (Modelica ⟺ Binary Code container
   bindings enabling SiL simulation of an eFMU in Dymola)."
        extends Icons.ControllerEmbedded;

        /*
    Stub-interface:
  */

        input ReinitializeConnector __reinitialize
          if __enable_reinitialization
          "Signals whether a reinitialization is requested right before the next
     'DoStep()' or not."
          annotation (Placement(
            iconTransformation(extent={{-80,-80},{-30,-30}}),
            transformation(extent={{-80,-80},{-60,-60}})));

        output Boolean __recalibrated(
          final start = false,
          final fixed = true)
          "Signals whether the eFMU has been recalibrated before calling 'DoStep()'
     or not.";
        output .Modelica.Blocks.Interfaces.IntegerOutput __error_signals_Recalibrate(
          final start = 0,
          final fixed = true)
          "Error signals returned throughout the execution of the 'Recalibrate()'
     function of the defining production code.";
        output .Modelica.Blocks.Interfaces.IntegerOutput __error_signals_Reinitialize(
          final start = 0,
          final fixed = true)
          "Error signals returned throughout the execution of the 'Reinitialize()'
     function of the defining production code.";
        output .Modelica.Blocks.Interfaces.IntegerOutput __error_signals_DoStep(
          final start = 0,
          final fixed = true)
          "Error signals returned throughout the execution of the 'DoStep()'
     function of the defining production code.";

        parameter Boolean __assert_error_signals = true
          "Configures if error signals of the eFMU are asserted or not.";
        parameter Boolean __embedd_clock = true
          "Configures the synchronous integration of the stub; whether it defines
     such itself (i.e., has its own clock; '__embedd_clock = true') or uses the
     clock of its instanciation context (i.e., uses an external clock;
     '__embedd_clock = false').";
        parameter .Modelica.Units.SI.Time __sampling_period
          "Configures the sampling period of the stub. In case of an embedded clock
     ('__embedd_clock = true') its sampling period and in case of an external
     clock the expected sampling period of such as required by the eFMU.";
        parameter Boolean __enable_tuning = false
          "Configures if tuning via the tuning bus is supported or not.";
        parameter Boolean __enable_reinitialization = false
          "Configures if reinitialization is supported or not; if enabled, runtime
     values for the '__reinitialize' input must be provided.";

        /*
    Clocked modelling:
  */

    protected
        replaceable DefaultSampledInterface __sampled
          constrainedby DefaultSampledInterface
          "Internal support record providing a sampled communication interface as
     required by the eFMU (i.e., all sampled and hold signals exchanged between
     the eFMU co-simulation stub and the eFMU).";

        ClockConnector __clock
          "The clock used for sampling.";
        ClockConnector __embedded_clock = Clock(__sampling_period)
          if __embedd_clock
          "The internally defined clock, if any.";
        ClockConnector __external_clock = Clock()
          if not (__embedd_clock)
          "The externally given clock, if any.";

        /*
    Initialization modelling:
  */

        Boolean __is_initialized(
          start = false,
          fixed = true)
          "Support variable used to ensure correct initialization of eFMU production
     codes right before the first 'DoStep()' call (e.g., tuneables parameters
     are correctly recalibrated according to modifications of the stub instance,
     states are initialized using the inputs at the first clock tick etc).";

        .Modelica.Blocks.Routing.BooleanPassThrough __reinitialize_connector
          "Support component required for conditional connection of the conditionally
     declared '__reinitialize' input (conditional equations only work for
     connections, which in turn require connector types)";

      initial algorithm
        /*
    Catch error signals of the defining binary:
  */

        assert(
          (if __assert_error_signals then __error_signals_Recalibrate == 0 else true),
          "ERROR: eFMU [" + getInstanceName() + "] signals 'Recalibrate()' initialization error.");
        assert(
          (if __assert_error_signals then __error_signals_Reinitialize == 0 else true),
          "ERROR: eFMU [" + getInstanceName() + "] signals 'Reinitialize()' initialization error.");
        assert(
          (if __assert_error_signals then __error_signals_DoStep == 0 else true),
          "ERROR: eFMU [" + getInstanceName() + "] signals 'DoStep()' initialization error.");

      equation
        assert(
          (if __assert_error_signals then __error_signals_Recalibrate == 0 else true),
          "ERROR: eFMU ["+ getInstanceName() +"] signals 'Recalibrate()' simulation error.");
        assert(
          (if __assert_error_signals then __error_signals_Reinitialize == 0 else true),
          "ERROR: eFMU ["+ getInstanceName() +"] signals 'Reinitialize()' simulation error.");
        assert(
          (if __assert_error_signals then __error_signals_DoStep == 0 else true),
          "ERROR: eFMU ["+ getInstanceName() +"] signals 'DoStep()' simulation error.");

        /*
    Incorporate the sampling:
  */

        if __enable_reinitialization then
          connect(__reinitialize, __reinitialize_connector.u);
        else
          __reinitialize_connector.u = false;
        end if;

        if __embedd_clock then
          // =============> Workaround Dymola bug start =============>
          //connect(__clock, __embedded_clock);
          // <============= Workaround  Dymola  bug end <=============
          __sampled.__reinitialize = sample(__reinitialize_connector.y);
          __recalibrated = hold(__sampled.__recalibrate);
          __error_signals_Recalibrate = hold(__sampled.__error_signals_Recalibrate);
          __error_signals_Reinitialize = hold(__sampled.__error_signals_Reinitialize);
          __error_signals_DoStep = hold(__sampled.__error_signals_DoStep);
        else
          // =============> Workaround Dymola bug start =============>
          /*
    assert(
      (if firstTick(__clock) then true else (interval(__clock) == __sampling_period)),
      "ERROR: The sampling period of the external clock does not match the sampling period of the eFMU's GALEC code."
      + "\n         The used external sampling period is [" + String(interval(__clock)) + "]."
      + "\n         The sampling period in the GALEC code is [" + String(__sampling_period) + "].");
    */
          // <============= Workaround  Dymola  bug end <=============
          connect(__clock, __external_clock);
          __sampled.__reinitialize = __reinitialize_connector.y;
          __recalibrated = __sampled.__recalibrate;
          __error_signals_Recalibrate = __sampled.__error_signals_Recalibrate;
          __error_signals_Reinitialize = __sampled.__error_signals_Reinitialize;
          __error_signals_DoStep = __sampled.__error_signals_DoStep;
        end if;

        annotation (
          preferredView = "info",
          Diagram(graphics={
            Text(
              extent={{-80,80},{80,60}},
              textColor={28,108,200},
              textString="Has embedded clock: %__embedd_clock%\nSampling period: %__sampling_period%",
              textStyle={TextStyle.Bold}),
            Rectangle(
              extent={{-90,90},{90,50}},
              lineColor={28,108,200},
              lineThickness=1)}),
          Icon(graphics={
            Text(
              extent={{-40,28},{40,-28}},
              textColor={238,46,47},
              textString="%__sampling_period%",
              textStyle={TextStyle.Bold})}));
      end BinaryStub;

      package BinaryStubGeneration "Functions generating eFMU co-simulation stubs for the CATIA ESP generated
   production codes of an eFMU, enabling SiL simulation of such in Dymola."
        extends .Modelica.Icons.Package;
        extends Icons.Modelica;
        extends Icons.Build;

        encapsulated record InterfaceComponent
          extends .Modelica.Icons.Record;

          encapsulated type IOType = enumeration(
            Input,
            Output,
            Parameter);

          encapsulated type PrimitiveType = enumeration(
            Unsupported,
            Boolean,
            Integer,
            Real);

          IOType io_type;
          PrimitiveType primitive_type;
          String type_name;
          Integer dimensionality[:];
          String component_name;
          String value;
          String description;
          String placement;

          encapsulated function print_dimensionality
            input .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStubGeneration.InterfaceComponent component;

            output String dimensionality;

        protected
            String separator;

          algorithm
            dimensionality := "";
            if size(component.dimensionality, 1) > 0 then
              dimensionality := "[";
              separator := "";
              for i in component.dimensionality loop
                dimensionality := dimensionality
                  + separator
                  + (if i > 0 then String(i) else ":");
                separator := ", ";
              end for;
              dimensionality := dimensionality + "]";
            end if;
          end print_dimensionality;
        end InterfaceComponent;

        function extract_interface
          "Extract the input, output and tuneable parameter interface of a given model."
          extends Icons.SourceCodeAnalysis;

          input String model_name
            "Full qualified name of the model to analyse for its interface."
            annotation(Dialog(__Dymola_translatedModel(translate = false)));
          input String galec_program
            "Path to the GALEC program for the model.";

          output InterfaceComponent[:] interface
            "Array of the top-level input, output and tuneable parameter components of
     the model.";

      protected
          type IOType = InterfaceComponent.IOType;

          function extract_tuneables
            input String galec_program;

            output String[:] tuneables;

        protected
            String tuneable;

          algorithm
            for line in .Modelica.Utilities.Streams.readFile(galec_program) loop
              if line == "protected" then
                break;
              end if;
              if .Modelica.Utilities.Strings.length(line) >= 11 then
              if .Modelica.Utilities.Strings.substring(line, 1, 11) == "\tparameter " then
                (tuneable,) := .Modelica.Utilities.Strings.scanIdentifier(
                  line,
                  .Modelica.Utilities.Strings.find(line, " ", 12) + 1);
                tuneables := cat(1, tuneables, {tuneable});
              end if;
              end if;
            end for;
          end extract_tuneables;

          function find_tuneable
            input String tuneable;
            input String[:] tuneables;

            output Boolean found;

          algorithm
            for t in tuneables loop
              if t == tuneable then
                found := true;
                return;
              end if;
            end for;
            found := false;
          end find_tuneable;

          function extract_interface_recursive
            input String model_name;
            input String[:] tuneables;

            output InterfaceComponent[:] interface;

        protected
            InterfaceComponent input_component_interface;
            InterfaceComponent output_component_interface;
            InterfaceComponent parameter_component_interface;

          algorithm
            if not
                  (.ModelManagement.Structure.AST.Misc.ClassExists(model_name)) then
              return;
            end if;

            // Reflexive (check local components):
            for component in .ModelManagement.Structure.AST.Classes.ComponentsInClassAttributes(model_name) loop
              if not
                    (component.isProtected) then
                input_component_interface := InterfaceComponent(
                  io_type = IOType.Input,
                  primitive_type = is_primitive_type(component.fullTypeName),
                  type_name = component.fullTypeName,
                  dimensionality = component.sizes,
                  component_name = component.name,
                  value = "",
                  description = component.description,
                  placement = .ModelManagement.Structure.AST.Classes.GetAnnotation(
                    className = model_name,
                    componentName = component.name,
                    annotationName = "Placement"));
                output_component_interface := input_component_interface;
                output_component_interface.io_type := IOType.Output;
                parameter_component_interface := input_component_interface;
                parameter_component_interface.io_type := IOType.Parameter;
                if component.isInput then
                  interface := cat(1, interface, {input_component_interface});
                elseif component.isOutput then
                  interface := cat(1, interface, {output_component_interface});
                elseif component.variability == "parameter"
                  and find_tuneable(component.name, tuneables) then
                  interface := cat(1, interface, {parameter_component_interface});
                else
                  if is_short_class_io_connector_type(component.fullTypeName, IOType.Input) <> "" then
                    interface := cat(1, interface, {input_component_interface});
                  elseif is_short_class_io_connector_type(component.fullTypeName, IOType.Output) <> "" then
                    interface := cat(1, interface, {output_component_interface});
                  end if;
                end if;
              end if;
            end for;

            // Irreflexive (check inherited components):
            for e in .ModelManagement.Structure.AST.Classes.ExtendsInClassAttributes(model_name) loop
              interface := cat(
                1,
                interface,
                extract_interface_recursive(e.fullTypeName, tuneables));
            end for;
          end extract_interface_recursive;

          function extract_values
            input String model_name;
            input InterfaceComponent[:] interface;

            output InterfaceComponent[:] refined_interface;

        protected
            String value;
            Integer length;
            String m;

          algorithm
            refined_interface := interface;
            for i in 1:size(interface, 1) loop
              if interface[i].io_type == IOType.Parameter then
                value := "";
                for m in .ModelManagement.Structure.AST.Components.ComponentModifiers(
                  model_name,
                  interface[i].component_name) loop
                  length := .Modelica.Utilities.Strings.length(m);
                  if length >= 2 then
                  if .Modelica.Utilities.Strings.substring(m, 1, 1) == "=" then
                    value := .Modelica.Utilities.Strings.substring(m, 2, length);
                    break;
                  end if;
                  end if;
                end for;
                if value == "" then
                  m := .ModelManagement.Structure.AST.Components.DefaultComponentModifier(
                    model_name,
                    interface[i].component_name);
                  length := .Modelica.Utilities.Strings.length(m);
                  if length >= 2 then
                  if .Modelica.Utilities.Strings.substring(m, 1, 1) == "=" then
                    value := .Modelica.Utilities.Strings.substring(m, 2, length);
                  end if;
                  end if;
                end if;
                refined_interface[i].value := value;
              end if;
            end for;
          end extract_values;

          function extract_dimensionalities
            input String galec_program;
            input InterfaceComponent[:] interface;

            output InterfaceComponent[:] refined_interface;

        protected
            .Modelica.Utilities.Types.TokenValue token;
            Integer next_token;
            Integer[:] dimensionality;

            InterfaceComponent updated;

          algorithm
            //refined_interface := interface;
            for line in .Modelica.Utilities.Streams.readFile(galec_program) loop
              if line == "protected" then
                break;
              end if;
              (token, next_token) :=
                .Modelica.Utilities.Strings.scanToken(line);
              if token.tokenType == .Modelica.Utilities.Types.TokenType.IdentifierToken
                and (
                  token.string == "input"
                  or token.string == "output"
                  or token.string == "parameter") then
                (token, next_token) :=
                  .Modelica.Utilities.Strings.scanToken(line, next_token);
                if token.tokenType == .Modelica.Utilities.Types.TokenType.IdentifierToken
                  and (
                    token.string == "Boolean"
                    or token.string == "Integer"
                    or token.string == "Real") then
                  (token, next_token) :=
                    .Modelica.Utilities.Strings.scanToken(line, next_token);
                  if token.tokenType == .Modelica.Utilities.Types.TokenType.IdentifierToken then
                    dimensionality := parse_dimensionality(line, next_token);
                    //if size(dimensionality, 1) > 0 then
                    for i in 1:size(interface, 1) loop
                      if interface[i].component_name == token.string then
                        /*
                  Stupid work around for just
                    refined_interface[i].dimensionality := dimensionality;
                  because Dymola claims that
                    refined_interface[i].dimensionality
                  is a constant:
                */
                        //refined_interface[i].dimensionality := dimensionality;
                        updated := interface[i];
                        updated.dimensionality := dimensionality;
                        refined_interface := cat(
                          1,
                          refined_interface,
                          { updated});
                        // Update all, i.e., do not 'break;'.
                      end if;
                    end for;
                    //end if;
                  end if;
                end if;
              end if;
            end for;
          end extract_dimensionalities;

          function parse_dimensionality
            input String line;
            input Integer start_index;

            output Integer[:] dimensionality;

        protected
            .Modelica.Utilities.Types.TokenValue token;
            Integer next_token;
            Integer dimension_size;

          algorithm
            dimensionality := fill(0, 0);
            (token, next_token) :=
              .Modelica.Utilities.Strings.scanToken(line, start_index);
            if token.tokenType == .Modelica.Utilities.Types.TokenType.NoToken
              or token.string == ";" or token.string == "]" then
              return;
            elseif token.string == "," or token.string == "[" then
              dimensionality := parse_dimensionality(line, next_token);
            else
              (dimension_size, next_token) :=
                .Modelica.Utilities.Strings.scanInteger(line, start_index);
              dimensionality := cat(
                1,
                { dimension_size},
                parse_dimensionality(line, next_token));
            end if;
          end parse_dimensionality;

        algorithm
          interface := extract_interface_recursive(
            model_name,
            extract_tuneables(galec_program));
          interface := extract_dimensionalities(galec_program, interface);
          interface := extract_values(model_name, interface);

          annotation (preferredView = "info");
        end extract_interface;

        function is_short_class_io_connector_type
          "Check if a given class is a short-class input or output connector type and
   return the wrapped type if so."
          extends Icons.SourceCodeAnalysis;

          input String class_name
            "Class to check."
            annotation(Dialog(__Dymola_translatedModel(translate = false)));
          input IOType io_type
            "The io-type to check for (either input or output).";
          output String wrapped_type = ""
            "The wrapped original type if the class is a short-class connector type of
     the given io-type, otherwise the empty string.";

      protected
          type IOType = InterfaceComponent.IOType;

          .ModelManagement.Structure.AST.Classes.ClassAttributes class_attributes;

        algorithm
          if not
                (.ModelManagement.Structure.AST.Misc.ClassExists(class_name)) then
            return;
          end if;

          class_attributes := .ModelManagement.Structure.AST.Classes.GetClassAttributes(
            class_name);
          if not
                (class_attributes.restricted == "connector") or not
                                                                   (class_attributes.isShortClass) then
            return;
          end if;
          for e in .ModelManagement.Structure.AST.Classes.ExtendsInClassAttributes(class_attributes.fullName) loop
            if (io_type == IOType.Input and e.isInput) or (io_type == IOType.Output and e.isOutput) then
              wrapped_type := e.fullTypeName;
              return;
            end if;
          end for;

          annotation (preferredView = "info");
        end is_short_class_io_connector_type;

        function is_primitive_type
          "Check if a given class is a short-class type for one of the Modelica-internal
   primitive types (Boolean, Integer and Real) and return the wrapped type if
   so."
          extends Icons.SourceCodeAnalysis;

          input String class_name
            "Class to check."
            annotation(Dialog(__Dymola_translatedModel(translate = false)));

          output InterfaceComponent.PrimitiveType wrapped_primitive_type
            "The wrapped original primitive type if the class is a short-class for it,
     otherwise 'InterfaceComponent.PrimitiveType.Unsupported'.";

      protected
          type PrimitiveType = InterfaceComponent.PrimitiveType;

          .ModelManagement.Structure.AST.Classes.ClassAttributes class_attributes;

          function to_primitive_type
            input String class_name;
            output InterfaceComponent.PrimitiveType primitive_type;
          algorithm
            if class_name == "Boolean" then
              primitive_type := InterfaceComponent.PrimitiveType.Boolean;
              return;
            elseif class_name == "Integer" then
              primitive_type := InterfaceComponent.PrimitiveType.Integer;
              return;
            elseif class_name == "Real" then
              primitive_type := InterfaceComponent.PrimitiveType.Real;
              return;
            end if;
            primitive_type := InterfaceComponent.PrimitiveType.Unsupported;
          end to_primitive_type;

        algorithm
          wrapped_primitive_type := to_primitive_type(class_name);
          if wrapped_primitive_type <> PrimitiveType.Unsupported then
            return;
          end if;

          if not
                (.ModelManagement.Structure.AST.Misc.ClassExists(class_name)) then
            return;
          end if;

          class_attributes := .ModelManagement.Structure.AST.Classes.GetClassAttributes(
            class_name);
          if not
                (class_attributes.isShortClass) then
            return;
          end if;
          for e in .ModelManagement.Structure.AST.Classes.ExtendsInClassAttributes(class_attributes.fullName) loop
            wrapped_primitive_type := to_primitive_type(e.fullTypeName);
            if wrapped_primitive_type <> PrimitiveType.Unsupported then
              return;
            end if;
            wrapped_primitive_type := is_primitive_type(e.fullTypeName);
            if wrapped_primitive_type <> PrimitiveType.Unsupported then
              return;
            end if;
          end for;

          annotation (preferredView = "info");
        end is_primitive_type;

        function declare_stub_package
          extends Icons.GenerateSourceCode;

          input String configuration_package;
          input String source_model;
          input String galec_program;
          input .Modelica.Units.SI.Time sample_period;
          input String stub_package_name;
          input String[:] pcode_container_names;
          input String[size(pcode_container_names, 1)] library_directories;
          input String[size(pcode_container_names, 1)] library_names;
          input String[size(pcode_container_names, 1)] pcode_interface_names;

          output String code = "";

      protected
          InterfaceComponent[:] interface;
          Integer year;
          Integer month;
          Integer day;
          Integer hour;
          Integer minute;
          Integer second;
          String date;

          Boolean first;

          function 'interface component <'
              input InterfaceComponent t1;
              input InterfaceComponent t2;
              output Boolean is_less;
          algorithm
            is_less := true;
            if t1.io_type <> t2.io_type then
              is_less := t1.io_type < t2.io_type;
              return;
            end if;
            if t1.primitive_type <> t2.primitive_type then
              is_less := t1.primitive_type < t2.primitive_type;
              return;
            end if;
            if t1.component_name <> t2.component_name then
              is_less := t1.component_name < t2.component_name;
              return;
            end if;
          end 'interface component <';

          function sort_interface
            input InterfaceComponent[:] interface;
            output InterfaceComponent[size(interface, 1)] sorted;
        protected
            InterfaceComponent tmp;
            Integer i;
          algorithm
            sorted := interface;
            // Gnome sort:
            i := 1;
            while i <= size(interface, 1) loop
              if i == 1 then
                i := i + 1;
              elseif 'interface component <'(sorted[i - 1], sorted[i]) then
                i := i + 1;
              else
                tmp := sorted[i];
                sorted[i] := sorted[i - 1];
                sorted[i - 1] := tmp;
                i := i - 1;
              end if;
            end while;
          end sort_interface;

          function unify_interface
            input InterfaceComponent[:] interface;
            output InterfaceComponent[:] unified;
        protected
            String last_component;
          algorithm
            last_component := "";
            for i in interface loop
              if i.component_name <> last_component then
                last_component := i.component_name;
                unified := cat(1, unified, {i});
              end if;
            end for;
          end unify_interface;

        algorithm
          interface := extract_interface(source_model, galec_program);
          interface := sort_interface(interface);
          interface := unify_interface(interface);
          (, second, minute, hour, day, month, year) :=
            .Modelica.Utilities.System.getTime();
          date :=
            String(year) + "-" +
            (if month < 10 then "0" else "") +
            String(month) + "-" +
            (if day < 10 then "0" else "") +
            String(day) + " at " +
            (if hour < 10 then "0" else "") +
            String(hour) + ":" +
            (if minute < 10 then "0" else "") +
            String(minute) + ":" +
            (if second < 10 then "0" else "") +
            String(second);

          code := "package " + stub_package_name + "
  \"Package supporting software in the loop (SiL) simulation of the production
   codes of the eFMU generated for the eFMU generation configuration
     "         + configuration_package + "\"
  
  extends .DymolaEmbedded.Icons.BinaryCodeContainer;
  
  block BinaryStub
    \"Stub for eFMU-based co-simulation of
       "         + source_model + "
     using the static linked libraries suited for Dymola's current simulation
     platform generated for the Production Code containers";
            for pcode_container_name in pcode_container_names loop
              code := code + "\n         " + pcode_container_name;
            end for;
            code := code + "
     as configured by
       "         + configuration_package + "
     Generated by Dymola on "         + date + ".\"
     
    import __TuningConfiguration = "         + stub_package_name + ".TuningConfiguration;
    import __TuningBus = "         + stub_package_name + ".TuningBus;
    import __TuningBusSampler = "         + stub_package_name + ".TuningBusSampler;
    import __ProductionCodes = "         + stub_package_name + ".ProductionCodes;
    
    extends .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStub(
      final __sampling_period = "         + String(sample_period) + ",
      redeclare final __SampledInterface __sampled);
    
    /*
      Stub-interface:
    */
    
    // Inputs:"         +
            declare_io_types(
              interface,
              "    ",
              true,
              false,
              true,
              false,
              false,
              true,
              false) + "
    
    // Outputs:"         +
            declare_io_types(
              interface,
              "    ",
              true,
              false,
              false,
              true,
              false,
              true,
              false) + "
    
    // Tuneable parameters:"         +
            declare_io_types(
              interface,
              "    ",
              true,
              false,
              false,
              false,
              true,
              true,
              true) + "
    
    parameter __TuningConfiguration __tuning_configuration
      \"Tuning configuration selecting the tuneable parameters to tune/recalibrate
       at runtime (i.e., throughout simulation). Only the selected tuneables are
       taken from the tuning bus; all others are set to the stub's respective
       Modelica parameters.\";
    __TuningBus __tuning
      if __enable_tuning
      \"Tuning bus providing the runtime values used for recalibration. Values have
       to be provided only for the parameters selected in the tuning
       configuration.\"
      annotation (Placement(
        iconTransformation(extent={{10,-100},{90,-20}}),
        transformation(extent={{60,-80},{80,-60}})));
    
    // Supported production codes:
    parameter __ProductionCodes __defining_code =
      __ProductionCodes."         + pcode_container_names[1] + "
      \"The production code defining the stub's results,
       i.e., whose results are propagated by the stub.\";
    
    parameter __ProductionCodes[:] __active_codes = {";
            first := true;
            for pcode_container_name in pcode_container_names loop
              code := code
                + (if first then "" else ",")
                + "\n      __ProductionCodes."
                + pcode_container_name;
              first := false;
            end for;
            code := code + "}
      \"Set of production codes co-simulated. By default, all production codes
       are co-simulated. The '__defining_code' is always active, even if not
       explicitly listed in the set.\";
    
    // Co-simulation results of each production code:
    __CosimulationResults[__ProductionCodes] __cosimulation_results
    \"Vector capturing the results of all co-simulated production codes.\";
    
  protected
    /*
      Internal support facilities: 
    */
    
    __TuningBusSampler __tuning_sampler
      if __embedd_clock
      \"Sampler used to sample all tuning bus signals in case of
       '__embedd_clock = true'.\";
    __TuningBusDecoder __tuning_decoder
      \"Decoder providing the sampled tuning signals of the tuning bus as
       individual output connections.\";
    __TuningBusSource __tuning_mockup(
      final tuning(";
              first := true;
              for i in interface loop
                if i.io_type == InterfaceComponent.IOType.Parameter then
                  code := code
                    + (if first then "" else ",")
                    + "
        final "         + i.component_name + " = " + i.component_name;
                  first := false;
                end if;
              end for;
              code := code + "))
      if not(__enable_tuning)
      \"Mockup tuning bus used as tuning signals source if tuning is disabled.
       It just provides the given parameterization as bus signals.\";
    __Tuning __active_tuning
      \"Support record holding the active calibration, i.e., the calibration
       the eFMU uses so far. Used to compare it with the currently -- by
       modifications or the tuning bus -- desired values for updating
       '__recalibrate'.\";
    
    parameter Boolean[__ProductionCodes] __active_codes_map = {";
            first := true;
            for pcode_container_name in pcode_container_names loop
              code := code
                + (if first then "" else ",")
                + "
      __defining_code == __ProductionCodes."         + pcode_container_name + "
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes."         + pcode_container_name + "),
          Integer(__active_codes))";
              first := false;
            end for;
            code := code + "}
      \"Internal precomputed cache mapping production codes to their
       activation-status.\"
      annotation(Evaluate = true);
    ";      for i in 1:size(pcode_container_names, 1) loop
              code := code + declare_pcode_binding(
                pcode_container_names[i],
                library_directories[i],
                library_names[i],
                pcode_interface_names[i],
                interface);
            end for;
            code := code + "
  equation
    /*
      Incorporate the sampling:
    */
    
    if __embedd_clock then
      // =============> Workaround Dymola bug start =============>
      connect(__clock, __embedded_clock);
      // <============= Workaround  Dymola  bug end <=============
      // In- and outputs:"         +
              connect_sampled(interface, true) + "
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_sampler.ingoing);
      else
        connect(__tuning_mockup.bus, __tuning_sampler.ingoing);
      end if;
      connect(__tuning_sampler.outgoing, __tuning_decoder.__bus);
    else
      // In- and outputs:"         +
              connect_sampled(interface, false) + "
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_decoder.__bus);
      else
        connect(__tuning_mockup.bus, __tuning_decoder.__bus);
      end if;
    end if;
    
    /*
      Select the tuneables either from the bus or parametrization,
      depending on their tuning configuration:
    */
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    __sampled.__tuning."         + i.component_name + " =
      (if __tuning_configuration."         + i.component_name + "
       then __tuning_decoder."         + i.component_name + "
       else "         + i.component_name + ");";
              end if;
            end for;
            code := code + "
    
  algorithm
    when Clock() then
      /*
        Update tuning:
      */
      
      if not(__is_initialized) then
        // Initialization the active calibration with the eFMU's default calibration:";
                for i in interface loop
                  if i.io_type == InterfaceComponent.IOType.Parameter then
                    code := code + "
        __active_tuning."         + i.component_name + " := " + i.value + ";";
                  end if;
                end for;
              code := code + "
      end if;
      
      __sampled.__recalibrate := false";
              for i in interface loop
                if i.io_type == InterfaceComponent.IOType.Parameter then
                  code := code + "
        or max(abs(__sampled.__tuning."         + i.component_name + "
          - __active_tuning."         + i.component_name + ")) > 0.0";
                end if;
              end for;
              code := code + ";
      
      if __sampled.__recalibrate then
        __active_tuning := __sampled.__tuning;
      end if;
      
      /*
        Cosimulate the active binaries:
      */
      ";    for pcode_container_name in pcode_container_names loop
              code :=
                code
                + execute_pcode(pcode_container_name, interface)
                + "\n    ";
            end for;
            code := code + "
      /*
        Stub-modification and input dependent initialization of all
        eFMU production codes certainly finished:
      */
      __is_initialized := true;
      
      /*
        Propagate the results of the defining production code:
      */
      
      __sampled.__error_signals_Recalibrate :=
        __cosimulation_results[__defining_code].__error_signals_Recalibrate;
      __sampled.__error_signals_Reinitialize :=
        __cosimulation_results[__defining_code].__error_signals_Reinitialize;
      __sampled.__error_signals_DoStep :=
        __cosimulation_results[__defining_code].__error_signals_DoStep;";
            for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Output then
                code := code + "
      __sampled."         + i.component_name + " :=
        __cosimulation_results[__defining_code]."         + i.component_name + ";";
              end if;
            end for;
            code := code + "
    end when;
    
    /*
      Preconfigure FMU export:
    */
    
    annotation (
      preferredView = \"info\",
      experiment(
        __Dymola_fixedstepsize = "         + String(sample_period) + ",
        __Dymola_Algorithm = \"Euler\"),
      __Dymola_experimentFlags(
        Advanced(
          InlineMethod = 1,
          InlineOrder = 2,
          InlineFixedStep = "         + String(sample_period) + ")));
  end BinaryStub;
  
  encapsulated record TuningConfiguration
    \"Record type for selecting tuneable parameters to tune/recalibrate at runtime.\"

    extends .DymolaEmbedded.Icons.TuningBus;
    extends .DymolaEmbedded.Icons.Configuration;
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    parameter Boolean "         + i.component_name + " = false;";
              end if;
            end for;
            code := code + "
    
    annotation(preferredView = \"info\");
  end TuningConfiguration;
  
  expandable connector TuningBus
    \"Expandable connector type for provisioning runtime values used for
     recalibration.\"

    extends .DymolaEmbedded.Icons.TuningBus;
    extends __Tuning;

    annotation(preferredView = \"info\");
  end TuningBus;
  
  model TuningBusSampler
    \"Sampler for sampling a tuning bus with the clock of the clocked-partition
     the outgoing bus is part of.\"

    extends .DymolaEmbedded.Icons.TuningBusSampler;

    TuningBus ingoing
      annotation (
        Placement(
          transformation(extent={{-140,-50},{-40,50}}),
          iconTransformation(extent={{-140,-50},{-40,50}})));
    TuningBus outgoing
      annotation (
        Placement(
          transformation(extent={{40,-50},{140,50}}),
          iconTransformation(extent={{40,-50},{140,50}})));

  protected 
    __TuningBusDecoder decoder;
    __TuningBusEncoder encoder;

  equation 
    connect(ingoing, decoder.__bus);
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    encoder."         + i.component_name + " = sample(decoder." + i.component_name + ");";
              end if;
            end for;
            code := code + "

    connect(encoder.__bus, outgoing);

    annotation (preferredView = \"info\");
  end TuningBusSampler;
  
  // Supported production codes:
  encapsulated type ProductionCodes = enumeration(";
          first := true;
          for pcode_container_name in pcode_container_names loop
            code := code
              + (if first then "" else ",")
              + "\n    "
              + pcode_container_name;
            first := false;
          end for;
          code := code + ")
    \"Production codes the stub provides for co-simulation.\"
    annotation (
      preferredView = \"info\",
      Icon(
        graphics={
          Rectangle(
            extent={{-82,-80},{80,80}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={100,187,75},
            fillPattern=FillPattern.Solid,
            radius=10),
          Rectangle(
            extent={{-72,86},{-68,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,86},{-58,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,86},{-48,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,86},{-38,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,86},{-28,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,86},{-18,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,86},{-8,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,86},{2,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,86},{12,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,86},{22,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,86},{32,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,86},{42,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,86},{52,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,86},{62,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,86},{72,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-72,-76},{-68,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,-76},{-58,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,-76},{-48,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,-76},{-38,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,-76},{-28,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,-76},{-18,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,-76},{-8,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,-76},{2,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,-76},{12,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,-76},{22,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,-76},{32,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,-76},{42,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,-76},{52,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,-76},{62,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,-76},{72,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,70},
            rotation=90),
          Rectangle(
            extent={{-20,-18},{20,20}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={130,238,94},
            fillPattern=FillPattern.Solid,
            radius=10),
          Polygon(
            origin = {1.3835,-4.1418},
            rotation = 45.0,
            fillColor = {64,64,64},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
              {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
              {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
              {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
              {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
              {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
              {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
              {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin = {10.1018,5.218},
            rotation = -45.0,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
              {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
              {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
              {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
              {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
              {-20.0,82.273}})}));
  
protected
  record __Tuning
    \"Support record type compiling all tuneable parameters, each typed with
     a fitting builtin Modelica type.\"
    "         +
            declare_io_types(
              interface,
              "    ",
              false,
              false,
              false,
              false,
              true,
              false,
              false) + "
  end __Tuning;
  
  class __TuningConnectors
    \"Connector types for each tuneable parameter (required by tuning bus en- and
     decoders to provide respective in- and output connectors).\"
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    connector "         + i.component_name + " =
      ."         + i.type_name + InterfaceComponent.print_dimensionality(i) + ";";
              end if;
            end for;
            code := code + "
  end __TuningConnectors;
  
  block __TuningBusSource
    \"Tuning source providing a given, fixed parameterization as bus signals.\"
    
    parameter __Tuning tuning;
    TuningBus bus;
    
  protected 
    __TuningBusEncoder encoder;
    Source source(__tuning = tuning);

    block Source
      parameter __Tuning __tuning;";
              for i in interface loop
                if i.io_type == InterfaceComponent.IOType.Parameter then
                  code := code + "
      output __TuningConnectors."         + i.component_name + " " + i.component_name + ";";
                end if;
              end for;
              code := code + "
    equation";for i in interface loop
                if i.io_type == InterfaceComponent.IOType.Parameter then
                  code := code + "
      "         + i.component_name + " = __tuning." + i.component_name + ";";
                end if;
              end for;
              code := code + "
    end Source;
    
  equation";for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    connect(source."         + i.component_name + ", encoder." + i.component_name + ");";
              end if;
            end for;
            code := code + "
    connect(encoder.__bus, bus);
  end __TuningBusSource;
    
  model __TuningBusDecoder
    \"Decoder providing each tuning signal of a tuning bus as individually
     connectable output.\"
     
    import __TuningBus = "         + stub_package_name + ".TuningBus;
    
    __TuningBus __bus;
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    output __TuningConnectors."         + i.component_name + " " + i.component_name + ";";
              end if;
            end for;
            code := code + "
    
  equation";for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    connect(__bus."         + i.component_name + ", " + i.component_name + ");";
              end if;
            end for;
            code := code + "
  end __TuningBusDecoder;
  
  model __TuningBusEncoder
    \"Encoder setting each tuning signal of a tuning bus via an individually
     connectable input.\"
     
    import __TuningBus = "         + stub_package_name + ".TuningBus;
    ";      for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    input __TuningConnectors."         + i.component_name + " " + i.component_name + ";";
              end if;
            end for;
            code := code + "
    
    __TuningBus __bus;
    
  equation";for i in interface loop
              if i.io_type == InterfaceComponent.IOType.Parameter then
                code := code + "
    connect("         + i.component_name + ", __bus." + i.component_name + ");";
              end if;
            end for;
            code := code + "
  end __TuningBusEncoder;
  
  record __SampledInterface
    \"Refined, actual eFMU communication interface as defined and required by the
     eFMU used for co-simulation.\"
    
    extends .DymolaEmbedded.BuildUtilities.BinaryCode.DefaultSampledInterface;
    
    // Inputs:"         +
            declare_io_types(
              interface,
              "    ",
              false,
              true,
              true,
              false,
              false,
              false,
              false) + "
      
    // Outputs:"         +
            declare_io_types(
              interface,
              "    ",
              false,
              true,
              false,
              true,
              false,
              false,
              false) + "
    
    // Tuneable parameters:
    __Tuning __tuning;
  end __SampledInterface;
  
  record __CosimulationResults
    \"Record compiling the results of a single co-simulated production code.\"
     
    import __ProductionCodes = "         + stub_package_name + ".ProductionCodes;
    
    // Cosimulation status:
    __ProductionCodes __production_code
      \"The production code this are the results of.\";
    Boolean __is_active
      \"Whether the production code has been co-simulated or not.\";
    Integer __error_signals_Recalibrate
      \"Errors signaled by the last execution of the 'Recalibrate()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).\";
    Integer __error_signals_Reinitialize
      \"Errors signaled by the last execution of the 'Reinitialize()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).\";   
    Integer __error_signals_DoStep
      \"Errors signaled by the last execution of the 'DoStep()' block-interface
       method of the production code; 0 in case of no errors (cf. the eFMI
       specification for pre-defined error signals and the encoding of such).\";
    
    // Cosimulation outputs:"         +
            declare_io_types(
              interface,
              "    ",
              false,
              true,
              false,
              true,
              false,
              false,
              false) + "
  end __CosimulationResults;
  
  annotation(preferredView = \"info\");
end "         + stub_package_name + ";";
        end declare_stub_package;

        function connect_sampled
          extends Icons.GenerateSourceCode;

          input InterfaceComponent[:] interface;
          input Boolean include_sampling;

          output String code = "";

      protected
          constant String sampled_access=
            "__sampled.";
          constant String clock=
            "__clock";

        algorithm
          for i in interface loop
            if i.io_type == InterfaceComponent.IOType.Input then
              code := code + "\n      " + sampled_access + i.component_name + " = ";
              if include_sampling then
                code := code + "sample(" + i.component_name + ", " + clock + ");";
              else
                code := code + i.component_name + ";";
              end if;
            elseif i.io_type == InterfaceComponent.IOType.Output then
              code := code + "\n      " + i.component_name + " = ";
              if include_sampling then
                code := code + "hold(" + sampled_access + i.component_name + ");";
              else
                code := code + sampled_access + i.component_name + ";";
              end if;
            end if;
          end for;
        end connect_sampled;

        function declare_pcode_binding
          extends Icons.GenerateSourceCode;

          input String pcode_container_name;
          input String library_directory;
          input String library_name;
          input String pcode_interface_name;
          input InterfaceComponent[:] interface;

          output String code = "";

      protected
          constant String block_state_type=
            "__BlockState_" + pcode_container_name;
          constant String block_state_instance=
            "__block_state_" + pcode_container_name;
          constant String Recalibrate_name_modelica=
            "__Recalibrate_" + pcode_container_name;
          constant String Reinitialize_name_modelica=
            "__Reinitialize_" + pcode_container_name;
          constant String DoStep_name_modelica=
            "__DoStep_" + pcode_container_name;
          constant String Startup_name_library=
            "mei_Startup_" + pcode_interface_name;
          constant String Recalibrate_name_library=
            "mei_Recalibrate_" + pcode_interface_name;
          constant String Reinitialize_name_library=
            "mei_Reinitialize_" + pcode_interface_name;
          constant String DoStep_name_library=
            "mei_DoStep_" + pcode_interface_name;
          constant String Terminate_name_library=
            "mei_Terminate_" + pcode_interface_name;

        algorithm
          code := "
    /*
    Internal bindings for production code
        "         + pcode_container_name + ":
    */
    
    class "         + block_state_type + "
      extends ExternalObject;
  
      function constructor
        output "         + block_state_type + " block_state;
        external \"C\" block_state = "         + Startup_name_library + "()
          annotation(
            LibraryDirectory = \""         + library_directory + "\",
            Library = \""         + library_name + "\");
      end constructor;
  
      function destructor
        input "         + block_state_type + " block_state;
        external \"C\" "         + Terminate_name_library + "(block_state)
          annotation(
            LibraryDirectory = \""         + library_directory + "\",
            Library = \""         + library_name + "\");
      end destructor;
    end "         + block_state_type + ";
    "         + bind_c_function(
                Recalibrate_name_modelica,
                Recalibrate_name_library,
                block_state_type,
                interface,
                false,
                false,
                true,
                library_directory,
                library_name,
                "    ")
              + "
    "         + bind_c_function(
                Reinitialize_name_modelica,
                Reinitialize_name_library,
                block_state_type,
                interface,
                true,
                true,
                false,
                library_directory,
                library_name,
                "    ")
              + "
    "         + bind_c_function(
                DoStep_name_modelica,
                DoStep_name_library,
                block_state_type,
                interface,
                true,
                true,
                false,
                library_directory,
                library_name,
                "    ")
              + "
    
    "         + block_state_type + " " + block_state_instance + " =
      "         + block_state_type + "();
    ";
        end declare_pcode_binding;

        function execute_pcode
          extends Icons.GenerateSourceCode;

          input String pcode_container_name;
          input InterfaceComponent[:] interface;

          output String code;

      protected
          constant String pcode_container_access=
            "__ProductionCodes." + pcode_container_name;
          constant String block_state_instance=
            "__block_state_" + pcode_container_name;
          constant String tuning_access=
            "__sampled.__tuning.";
          constant String input_access=
            "__sampled.";
          constant String results_access=
            "__cosimulation_results[" + pcode_container_access + "].";
          constant String Recalibrate_name_modelica=
             "__Recalibrate_" + pcode_container_name;
          constant String Reinitialize_name_modelica=
             "__Reinitialize_" + pcode_container_name;
          constant String DoStep_name_modelica=
            "__DoStep_" + pcode_container_name;

          String Recalibrate_arguments;
          String Reinitialize_arguments;
          String Reinitialize_results;
          String DoStep_arguments;
          String DoStep_results;

        algorithm
          Recalibrate_arguments := pass_arguments(
            interface,
            "              ",
            false,
            false,
            true,
            tuning_access);

          Reinitialize_arguments := pass_arguments(
            interface,
            "            ",
            true,
            false,
            false,
            input_access);

          Reinitialize_results := pass_arguments(
            interface,
            "            ",
            false,
            true,
            false,
            results_access);

          DoStep_arguments := pass_arguments(
            interface,
            "          ",
            true,
            false,
            false,
            input_access);

          DoStep_results := pass_arguments(
            interface,
            "          ",
            false,
            true,
            false,
            results_access);

          code := "
      "         + results_access + "__production_code :=
        "         + pcode_container_access + ";
      "         + results_access + "__is_active :=
        __active_codes_map["         + pcode_container_access + "];
      if "         + results_access + "__is_active then
        "         + results_access + "__error_signals_Recalibrate := 0;
        if __sampled.__recalibrate then
          "         + results_access + "__error_signals_Recalibrate :=
            "         + Recalibrate_name_modelica + "(
              "         + block_state_instance
                        + (if Recalibrate_arguments <> "" then "," else "")
                        + Recalibrate_arguments
                        + ");
        end if;
        if __sampled.__reinitialize or not(__is_initialized) then
          (
            "         + results_access + "__error_signals_Reinitialize"
                      + (if Reinitialize_results <> "" then "," else "")
                      + Reinitialize_results
                      + " 
          ) := "         + Reinitialize_name_modelica + "(
            "         + block_state_instance
                      + (if Reinitialize_arguments <> "" then "," else "")
                      + Reinitialize_arguments
                      + "
          );
        end if;
        (
          "         + results_access + "__error_signals_DoStep"
                    + (if DoStep_results <> "" then "," else "")
                    + DoStep_results
                    + " 
        ) := "         + DoStep_name_modelica + "(
          "         + block_state_instance
                    + (if DoStep_arguments <> "" then "," else "")
                    + DoStep_arguments
                    + "
        );
      end if;";
        end execute_pcode;

        function bind_c_function
          extends Icons.GenerateSourceCode;

          input String function_name_modelica;
          input String function_name_library;
          input String block_state_type;
          input InterfaceComponent[:] interface;
          input Boolean include_inputs = true;
          input Boolean include_outputs = true;
          input Boolean include_parameters = true;
          input String library_directory;
          input String library_name;
          input String indentation = "";

          output String code;

      protected
          type IOType = EmbeddedInterfaceType.IOType;

          String arguments;

        algorithm
          arguments := pass_arguments(
            interface,
            indentation + "      ",
            include_inputs,
            include_outputs,
            include_parameters);
          code := "\n" + indentation + "function " + function_name_modelica + "\n"
            + indentation + "  input " + block_state_type + " block_state;"
            + declare_io_types(
              interface,
              indentation + "  ",
              false,
              true,
              include_inputs,
              false,
              false,
              true,
              false)
            + declare_io_types(
              interface,
              indentation + "  ",
              false,
              true,
              false,
              false,
              include_parameters,
              true,
              false,
              "input ")
            + "\n"
            + indentation + "  output Integer error_signals;"
            + declare_io_types(
              interface,
              indentation + "  ",
              false,
              true,
              false,
              include_outputs,
              false,
              true,
              false)
            + "\n"
            + indentation + "  external \"C\" error_signals =\n"
            + indentation + "    " + function_name_library + "(\n"
            + indentation + "      block_state" + (if arguments <> "" then "," else "")
            + arguments
            + ");\n"
            + indentation + "    annotation(\n"
            + indentation + "      LibraryDirectory = \"" + library_directory + "\",\n"
            + indentation + "      Library = \"" + library_name + "\");\n"
            + indentation + "end " + function_name_modelica + ";";
        end bind_c_function;

        function declare_io_types
          extends Icons.GenerateSourceCode;

          input InterfaceComponent[:] interface;
          input String indentation = "";
          input Boolean include_placement = true;
          input Boolean force_primitive_types = false;
          input Boolean include_inputs = true;
          input Boolean include_outputs = true;
          input Boolean include_parameters = false;
          input Boolean include_io_qualifier = true;
          input Boolean include_value = true;
          input String replace_io_qualifier = "";

          output String code = "";

      protected
          type IOType = InterfaceComponent.IOType;

        algorithm
          if include_inputs then
            for i in interface loop
              if i.io_type == IOType.Input then
                code := code + declare_io_type(
                  i,
                  indentation,
                  include_placement,
                  force_primitive_types,
                  include_io_qualifier,
                  include_value,
                  replace_io_qualifier);
              end if;
            end for;
          end if;
          if include_outputs then
            for i in interface loop
              if i.io_type == IOType.Output then
                code := code + declare_io_type(
                  i,
                  indentation,
                  include_placement,
                  force_primitive_types,
                  include_io_qualifier,
                  include_value,
                  replace_io_qualifier);
              end if;
            end for;
          end if;
          if include_parameters then
            for i in interface loop
              if i.io_type == IOType.Parameter then
                code := code + declare_io_type(
                  i,
                  indentation,
                  include_placement,
                  force_primitive_types,
                  include_io_qualifier,
                  include_value,
                  replace_io_qualifier);
              end if;
            end for;
          end if;
        end declare_io_types;

        function declare_io_type
          extends Icons.GenerateSourceCode;

          input InterfaceComponent component;
          input String indentation = "";
          input Boolean include_placement = true;
          input Boolean force_primitive_types = false;
          input Boolean include_io_qualifier = true;
          input Boolean include_value = true;
          input String replace_io_qualifier = "";

          output String code;

      protected
          type IOType = InterfaceComponent.IOType;

          String final_type;

        algorithm
          final_type := "";
          if force_primitive_types then
            final_type := is_short_class_io_connector_type(
              component.type_name,
              component.io_type);
          end if;
          if final_type == "" then
            final_type :=
              (if .Modelica.Utilities.Strings.find(component.type_name, ".") == 1
                or component.type_name == "Boolean"
                or component.type_name == "Integer"
                or component.type_name == "Real"
                then ""
                else ".") +
              component.type_name;
          end if;

          code :=
            "\n" + indentation +
            (if not (include_io_qualifier) then ""
             elseif replace_io_qualifier <> "" then replace_io_qualifier
             elseif component.io_type == IOType.Input then "input "
             elseif component.io_type == IOType.Output then "output "
             else "parameter ") +
            final_type +
            " " +
            component.component_name +
            InterfaceComponent.print_dimensionality(component) +
            (if include_value and component.value <> ""
             then " = " + component.value
             else "") +
            (if component.description <> ""
              then "\n" + indentation + "  \"" + component.description + "\""
              else "") +
            (if include_placement and component.placement <> ""
              then "\n" + indentation + "  annotation (" + component.placement + ")"
              else "") +
            ";";
        end declare_io_type;

        function pass_arguments
          extends Icons.GenerateSourceCode;

          input InterfaceComponent[:] interface;
          input String identation = "";
          input Boolean include_inputs = true;
          input Boolean include_outputs = true;
          input Boolean include_parameters = true;
          input String access_pattern = "";

          output String code = "";

      protected
          type IOType = InterfaceComponent.IOType;

          String separator;

        algorithm
          separator := "";
          if include_inputs then
            for i in interface loop
              if i.io_type == IOType.Input then
                code := code
                  + separator + "\n" + identation + access_pattern + i.component_name;
                separator := ",";
              end if;
            end for;
          end if;
          if include_outputs then
            for i in interface loop
              if i.io_type == IOType.Output then
                code := code
                  + separator + "\n" + identation + access_pattern + i.component_name;
                separator := ",";
              end if;
            end for;
          end if;
          if include_parameters then
            for i in interface loop
              if i.io_type == IOType.Parameter then
                code := code
                  + separator + "\n" + identation + access_pattern + i.component_name;
                separator := ",";
              end if;
            end for;
          end if;
        end pass_arguments;
        annotation (preferredView = "info");
      end BinaryStubGeneration;

      record DefaultSampledInterface
        "Support type for 'BinaryStub': Basic eFMU communication interface common to
   all eFMU production codes."

        extends .Modelica.Icons.Record
          annotation(IconMap(extent={{-100,-75},{100,125}}));
        extends Icons.Embedded
          annotation(IconMap(extent={{-70,-70},{70,70}}));

        Boolean __recalibrate
          "Support variable used to decide if a recalibration of eFMU production
     codes is required before executing their 'DoStep()' implementation.";
        Integer __error_signals_Recalibrate;
        Boolean __reinitialize
          "Support variable used to decide if a reinitialization of eFMU production
     codes is requested before executing their 'DoStep()' implementation.";
        Integer __error_signals_Reinitialize;
        Integer __error_signals_DoStep;
      end DefaultSampledInterface;

      encapsulated connector ClockConnector = Clock
        "Support type for 'BinaryStub': Used to connect the actually used clock
   ('__clock') with either, the internally defined one ('__embedded_clock') or
   the externally given one ('__external_clock') depending on '__embedd_clock'
   respectively."
         annotation (
           Icon(
             graphics={
               Rectangle(
                 extent={{-100,100},{100,-100}},
                 lineColor={95,95,95},
                 fillColor={95,95,95},
                 fillPattern=FillPattern.Solid)}));

      encapsulated connector ReinitializeConnector =
        .Modelica.Blocks.Interfaces.BooleanInput
        "Support type for 'BinaryStub': Boolean input type used for signaling
   recalibration requests; fully compatible with Boolean input values.
   The main purpose of this class is JUST to provide a nice
   icon for the connector."
         annotation (
           IconMap(extent={{-10,-10},{10,10}}),
           Icon(
             graphics={
               Ellipse(
                 extent={{-100,100},{100,-100}},
                 lineColor={28,108,200},
                 pattern=LinePattern.None,
                 fillColor={255,0,255},
                 fillPattern=FillPattern.Solid),
               Ellipse(
                 extent={{-80,10},{80,-40}},
                 lineColor={102,44,145},
                 pattern=LinePattern.None,
                 fillColor={0,0,0},
                 fillPattern=FillPattern.Sphere),
               Ellipse(
                 extent={{-30,-2},{30,-18}},
                 lineColor={238,46,47},
                 pattern=LinePattern.None,
                 fillColor={206,103,29},
                 fillPattern=FillPattern.VerticalCylinder),
               Rectangle(
                 extent={{-30,12},{30,-10}},
                 lineColor={238,46,47},
                 pattern=LinePattern.None,
                 fillColor={193,96,27},
                 fillPattern=FillPattern.VerticalCylinder),
               Ellipse(
                 extent={{-60,30},{60,2}},
                 lineColor={28,108,200},
                 pattern=LinePattern.None,
                 fillColor={162,31,33},
                 fillPattern=FillPattern.Solid),
               Rectangle(
                 extent={{-60,30},{60,16}},
                 lineColor={255,49,52},
                 pattern=LinePattern.None,
                 fillPattern=FillPattern.Solid,
                 fillColor={165,31,34}),
               Ellipse(
                 extent={{-60,46},{60,16}},
                 lineColor={238,46,47},
                 pattern=LinePattern.None,
                 fillColor={238,46,47},
                 fillPattern=FillPattern.Sphere)}));

      record BCodeToBinaryStub
        "Support type for 'EmbeddedConfiguration.BinaryCode.build_binary_stub()':
   Mapping of eFMU Binary Code containers to implementation libraries of a
   respective eFMU co-simulation stub that can be used for SiL testing the
   eFMU."

        extends .Modelica.Icons.Record
          annotation(IconMap(extent={{-100,-75},{100,125}}));
        extends Icons.Embedded
          annotation(IconMap(extent={{-70,-70},{70,70}}));

        String bcode_container_name
          "Binary Code container providing the implementation.";
        String target_platform
          "Platform the binary code is targeting according to 12.9.4 of the
     Modelica Standard, annotation LibraryDirectory => platform directory.";
        String library_name
          "Name of the static linked library as used by the
     eFMU co-simulation stub.";
      end BCodeToBinaryStub;
      annotation (preferredView = "info");
    end BinaryCode;

    package ConfigurationBaseTypes "Partial configuration record types for common eFMU generation options.
   Configuration types supporting any such option can do so by subclassing."
      extends .Modelica.Icons.TypesPackage;

      record Unsupported
        "Document malfunctioning or missing eFMU tool-chain features in concrete
   configurations."
        /*
  extends .Modelica.Icons.Record
    annotation(IconMap(extent={{-100,-75},{100,125}}));
  */

        parameter String not_yet_supported = ""
          "Flag to explicitly mark that a concrete configuration is not yet
     supported. Configures whether it is expected to work (empty string) or
     further development of the used toolings are required (non-empty string).
     Non-empty strings are supposed to give a short rationale why the
     configuration is unsupported or what is broken. Unsupported configurations
     are skipped when generating code for whole package hierarchies
     (cf. 'build_all'). Explicit building via 'build' is still
     possible, but will emit respective warnings.";

        /*
    Icon(
      graphics={
        Text(
          extent={{-80,80},{0,0}},
          lineColor={0,140,72},
          textString="✓",
          textStyle={TextStyle.Bold}),
        Line(
          points={{-80,-80},{80,80}},
          color={28,108,200},
          thickness=1),
        Text(
          extent={{0,0},{80,-80}},
          lineColor={238,46,47},
          textString="✕")})
  */
        annotation (
          preferredView = "Info");
      end Unsupported;

      record CodeGenerator
        "Common configuration options for eFMU code-generation toolings."
        extends Icons.Embedded;
        extends Icons.Configuration;

        extends Unsupported;

        parameter Boolean active = false
          "Configures whether, the code generation configuration is used or not;
     'false' deactivates the generator, 'true' activates it.";

        annotation (preferredView = "Info");
      end CodeGenerator;
      annotation (preferredView = "Info");
    end ConfigurationBaseTypes;

    package Dymola_C
    "DEPRECATED: Utilities for Dymola's legacy embedded C code generator."
      extends Icons.DymolaEmbedded;
      extends .Modelica.Icons.ObsoleteModel;

      record BuildResult
        "DEPRECATED: Report compiling information about the used configuration and
   build success of embedded C code generation with Dymola's legacy embedded C
   code generator."
        extends .Modelica.Icons.Record
          annotation(IconMap(extent={{-100,-75},{100,125}}));
        extends .Modelica.Icons.Information
          annotation(IconMap(extent={{-70,-70},{70,70}}));
        extends .Modelica.Icons.ObsoleteModel;

        parameter Boolean succeeded
          "Whether the build succeeded or failed.";
        parameter String error_message
          "Error message in case the build failed.";
        parameter eFMU efmu
          "The eFMU configuration used for the build";
        parameter AlgorithmCode.Model modelica_model
          "Model configuration used for the build.";
        parameter AlgorithmCode.Integrator integrator
          "Integrator configuration used for the build.";
        parameter AlgorithmCode.Code code
          "Code configuration used for the build.";
        parameter Dymola_C.Dymola Dymola
          "Configuration of Dymola's legacy embedded C code generator used for the
     build.";

        annotation (preferredView = "info");
      end BuildResult;

      record Dymola
        "DEPRECATED: Configures Dymola's legacy embedded C code generator."
        extends Icons.Embedded;
        extends Icons.Configuration;
        extends .Modelica.Icons.ObsoleteModel;

        parameter String not_yet_supported = ""
          "Flag to explicitly mark that a concrete configuration is not yet
     supported. Configures whether it is expected to work (empty string) or
     further development of the used toolings are required (non-empty string).
     Non-empty strings are supposed to give a short rationale why the
     configuration is unsupported or what is broken. Unsupported configurations
     are skipped when generating code for whole package hierarchies
     (cf. 'build_all'). Explicit building via 'build' is still
     possible, but will emit respective warnings.";
        parameter Boolean active = false
          "Configures whether, the code generation configuration is used or not;
     'false' deactivates the generator, 'true' activates it.";

        parameter BuildVersion build_version = BuildVersion.Debug
          "Production Code version to build.";
        parameter CompilerVersion compiler_version = CompilerVersion.any
          "Compiler to use for building binaries.";
        parameter String[:] includes
          "External include directories added for compiling and linking the Production
     Code. Typically used to provide external embedded runtime environment code
     required for system integration.";
        /*
  Default = fill("", 0)
    "External include directories added for compiling and linking the Production
     Code. Typically used to provide external embedded runtime environment code
     required for system integration.";
  */

        annotation (
          preferredView = "Info",
          Icon(graphics={
            Text(
              extent = {{-100,-130},{100,-180}},
              lineColor = {28,108,200},
              textStyle = {TextStyle.Bold},
                textString = "Dymola production\ncode configuration")}));
      end Dymola;

      type BuildVersion = enumeration(
        Debug,
        Release)
        "DEPRECATED: Enumeration of compilation configurations available for
   Dymola's legacy embedded C code generator."
      annotation (Icon(graphics={
        Polygon(
          origin = {1.3835,-4.1418},
          rotation = 45.0,
          fillColor = {64,64,64},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
            {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
            {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
            {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
            {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
            {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
            {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
            {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
        Polygon(
          origin = {10.1018,5.218},
          rotation = -45.0,
          fillColor = {255,255,255},
          fillPattern = FillPattern.Solid,
          points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
            {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
            {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
            {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
            {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
            {-20.0,82.273}}),                  Rectangle(
                extent={{-102,102},{102,-102}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5)}));

      type CompilerVersion = enumeration(
        Visual_Studio_v10
            "Microsoft Visual Studio 2010",
        Visual_Studio_v11
            "Microsoft Visual Studio 2012",
        Visual_Studio_v12
            "Microsoft Visual Studio 2013",
        Visual_Studio_v14
            "Microsoft Visual Studio 2015",
        Visual_Studio_v15
            "Microsoft Visual Studio 2017",
        Visual_Studio_most_recent_available
            "Microsoft Visual Studio: most recent available",
        any "Any available compiler")
        "DEPRECATED: Enumeration of compilers supported by
   Dymola's legacy embedded C code generator."
      annotation (Icon(graphics={
        Polygon(
          origin = {1.3835,-4.1418},
          rotation = 45.0,
          fillColor = {64,64,64},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
            {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
            {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
            {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
            {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
            {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
            {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
            {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
        Polygon(
          origin = {10.1018,5.218},
          rotation = -45.0,
          fillColor = {255,255,255},
          fillPattern = FillPattern.Solid,
          points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
            {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
            {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
            {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
            {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
            {-20.0,82.273}}),                  Rectangle(
                extent={{-102,102},{102,-102}},
                lineColor={255,0,0},
                pattern=LinePattern.Dash,
                lineThickness=0.5)}));

      function find_compiler
        "DEPRECATED: Select a compiler version for Dymola's legacy embedded C code
   generator based on a given desired compiler and return if a match has been
   found, the actual compiler version selected and its installation-directory."
        extends Icons.Configuration;
        extends Icons.Analysis;
        extends .Modelica.Icons.ObsoleteModel;

        input CompilerVersion compilerDesired = CompilerVersion.any
          "The compiler to look for.";
        output Boolean succeeded
          "Whether a matching compiler installation has been found; 'true' if so,
    'false' otherwise.";
        output CompilerVersion compilerSelected
          "The actual compiler version selected.
     Meaningless if 'succeeded' is 'false'.";
        output String installationDirectory
          "The installation-directory of the selected compiler.
     Meaningless if 'succeeded' is 'false'.";

    protected
        constant String[CompilerVersion.any] compilers = {
          "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC",
          "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC","C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC",
          "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC","C:\\Program Files (x86)\\Microsoft Visual Studio\\2017",
          "",
          ""};

      algorithm
        compilerSelected := CompilerVersion.any;
        installationDirectory := "";

        if compilerDesired == CompilerVersion.any then
          for version in CompilerVersion loop
            if .Modelica.Utilities.Files.exist(compilers[version]) then
              compilerSelected := version;
            end if;
          end for;
        elseif compilerDesired == CompilerVersion.Visual_Studio_most_recent_available then
          for version in CompilerVersion.Visual_Studio_v10:CompilerVersion.Visual_Studio_v15 loop
            if .Modelica.Utilities.Files.exist(compilers[version]) then
              compilerSelected := version;
            end if;
          end for;
        elseif .Modelica.Utilities.Files.exist(compilers[compilerDesired]) then
          compilerSelected := compilerDesired;
        end if;

        succeeded :=compilerSelected <> CompilerVersion.any;
        if succeeded then
          installationDirectory := compilers[compilerSelected];
        end if;

        annotation (preferredView = "info");
      end find_compiler;

      package StubGeneration "DEPRECATED: Functions generating Modelica-stubs for Dymola's legacy embedded
   C code generator, enabling co-simulation of generated code."
        extends .Modelica.Icons.Package;
        extends Icons.Modelica;
        extends Icons.Build;
        extends .Modelica.Icons.ObsoleteModel;

        record EmbeddedInterfaceType
          extends .Modelica.Icons.Record;

          encapsulated type IOType = enumeration(
            Input,
            Output);

          IOType io_type;
          String type_name;
          Integer dimensionality[:];
          String component_name;
          String description;
          String placement;
        end EmbeddedInterfaceType;

        function extract_interface
          "Extract the input and output interface of a given model."
          extends Icons.SourceCodeAnalysis;

          input String model_name
            "Full qualified name of the model to analyse for its interface."
            annotation(Dialog(__Dymola_translatedModel(translate = false)));
          output EmbeddedInterfaceType[:] interface
            "Array of the top-level input and output components of the model.";

      protected
          type IOType = EmbeddedInterfaceType.IOType;

          EmbeddedInterfaceType input_component_interface;
          EmbeddedInterfaceType output_component_interface;

        algorithm
          if not
                (.ModelManagement.Structure.AST.Misc.ClassExists(model_name)) then
            return;
          end if;

          // Reflexive (check local components):
          for component in .ModelManagement.Structure.AST.Classes.ComponentsInClassAttributes(model_name) loop
            if not
                  (component.isProtected) then
              input_component_interface := EmbeddedInterfaceType(
                io_type = IOType.Input,
                type_name = component.fullTypeName,
                dimensionality = component.sizes,
                component_name = component.name,
                description = component.description,
                placement = .ModelManagement.Structure.AST.Classes.GetAnnotation(
                  className = model_name,
                  componentName = component.name,
                  annotationName = "Placement"));
              output_component_interface := input_component_interface;
              output_component_interface.io_type := IOType.Output;
              if component.isInput then
                interface := cat(1, interface, {input_component_interface});
              elseif component.isOutput then
                interface := cat(1, interface, {output_component_interface});
              else
                if is_short_class_io_connector_type(component.fullTypeName, IOType.Input) <> "" then
                  interface := cat(1, interface, {input_component_interface});
                elseif is_short_class_io_connector_type(component.fullTypeName, IOType.Output) <> "" then
                  interface := cat(1, interface, {output_component_interface});
                end if;
              end if;
            end if;
          end for;

          // Irreflexive (check inherited components):
          for e in .ModelManagement.Structure.AST.Classes.ExtendsInClassAttributes(model_name) loop
            interface := cat(
              1,
              interface,
              extract_interface(e.fullTypeName));
          end for;

          annotation (preferredView = "info");
        end extract_interface;

        function is_short_class_io_connector_type
          "Check if a given class is a short-class input or output connector type and
   return the wrapped type if so."
          extends Icons.SourceCodeAnalysis;

          input String class_name
            "Class to check."
            annotation(Dialog(__Dymola_translatedModel(translate = false)));
          input IOType io_type
            "The io-type to check for (either input or output).";
          output String wrapped_type = ""
            "The wrapped original type if the class is a short-class connector type of
     the given io-type, otherwise the empty string.";

      protected
          type IOType = EmbeddedInterfaceType.IOType;

          .ModelManagement.Structure.AST.Classes.ClassAttributes class_attributes;

        algorithm
          if not
                (.ModelManagement.Structure.AST.Misc.ClassExists(class_name)) then
            return;
          end if;

          class_attributes :=.ModelManagement.Structure.AST.Classes.GetClassAttributes(
            class_name);
          if not
                (class_attributes.restricted == "connector") or not
                                                                   (class_attributes.isShortClass) then
            return;
          end if;
          for e in .ModelManagement.Structure.AST.Classes.ExtendsInClassAttributes(class_attributes.fullName) loop
            if (io_type == IOType.Input and e.isInput) or (io_type == IOType.Output and e.isOutput) then
              wrapped_type := e.fullTypeName;
              break;
            end if;
          end for;

          annotation (preferredView = "info");
        end is_short_class_io_connector_type;

        function declare_stub_model
          extends Icons.GenerateSourceCode;

          input String source_model;
          input String stub_model_name;
          input String configuration_package;
          input String library_directory;
          input String library_name;

          output String code = "";

      protected
          EmbeddedInterfaceType[:] interface;
          Integer year;
          Integer month;
          Integer day;
          Integer hour;
          Integer minute;
          Integer second;
          String date;

        algorithm
          interface := extract_interface(source_model);
          (, second, minute, hour, day, month, year) :=
            .Modelica.Utilities.System.getTime();
          date :=
            String(year) + "-" +
            (if month < 10 then "0" else "") +
            String(month) + "-" +
            (if day < 10 then "0" else "") +
            String(day) + " at " +
            (if hour < 10 then "0" else "") +
            String(hour) + ":" +
            (if minute < 10 then "0" else "") +
            String(minute) + ":" +
            (if second < 10 then "0" else "") +
            String(second);

          code := "block " + stub_model_name + "
  \"Stub for co-simulation of binaries generated using
   Dymola's legacy embedded C code generator for
     '"         + source_model + "'
   as configured in
     '"         + configuration_package + "'.
   Generated by 'DymolaEmbedded' on "         + date + ".\"
  extends .DymolaEmbedded.Icons.ControllerEmbedded;
  "         +
          declare_io_types(interface, "  ") + "
  
  output Integer __error_signals_DoStep
    \"Error signals returned throughout the execution of the sampling method.\";
  
protected"         +
        bind_c_function("initialize", interface, library_directory, library_name, "  ") + "
  "         +
        bind_c_function("do_step", interface, library_directory, library_name, "  ") + "
  
initial algorithm";

          /*
    Workaround Dymola synchonous initialization bug...
  */
          code := code + "\n  // TO FIX: Dymola synchonous initialization.\n  (";
          for t in interface loop
            if t.io_type == EmbeddedInterfaceType.IOType.Output then
              code := code + ",";
            end if;
          end for;
          code := code + ") :=\n";
          /*
    ...the solution when synchronous initialization is fixed is
      (" + pass_arguments(interface, false, true) + ", __error_signals_DoStep) :=
    but for now use:
  */
          code := code + "
    initialize("         + pass_arguments(interface, true, false) + ");

equation
  ("         + pass_arguments(interface, false, true) + ", __error_signals_DoStep) =
    do_step("         + pass_arguments(interface, true, false) + ");
  
  annotation (preferredView = \"info\");
end "         + stub_model_name + ";";
        end declare_stub_model;

        function bind_c_function
          extends Icons.GenerateSourceCode;

          input String function_name;
          input EmbeddedInterfaceType[:] interface;
          input String library_directory;
          input String library_name;
          input String indentation = "";

          output String code;

      protected
          type IOType = EmbeddedInterfaceType.IOType;

        algorithm
          code := "\n" + indentation + "function " + function_name +
            declare_io_types(interface, indentation + "  ", false, true) + "\n" +
            indentation + "  output Integer exit_code;\n" +
            indentation + "  external \"C\" exit_code =\n" +
            indentation + "    " + function_name + "(" + pass_arguments(interface) + ");\n" +
            indentation + "    annotation(\n" +
            indentation + "      LibraryDirectory = \"" + library_directory + "\",\n" +
            indentation + "      Library = \"" + library_name + "\");\n" +
            indentation + "end " + function_name + ";";
        end bind_c_function;

        function declare_io_types
          extends Icons.GenerateSourceCode;

          input EmbeddedInterfaceType[:] interface;
          input String indentation = "";
          input Boolean include_placement = true;
          input Boolean force_primitive_types = false;
          output String code = "";

      protected
          type IOType = EmbeddedInterfaceType.IOType;

        algorithm
          for i in interface loop
            if i.io_type == IOType.Input then
              code :=code + declare_io_type(
                i,
                indentation,
                include_placement,
                force_primitive_types);
            end if;
          end for;
          for i in interface loop
            if i.io_type == IOType.Output then
              code :=code + declare_io_type(
                i,
                indentation,
                include_placement,
                force_primitive_types);
            end if;
          end for;
        end declare_io_types;

        function declare_io_type
          extends Icons.GenerateSourceCode;

          input EmbeddedInterfaceType interface_type;
          input String indentation = "";
          input Boolean include_placement = true;
          input Boolean force_primitive_types = false;
          output String code;

      protected
          type IOType = EmbeddedInterfaceType.IOType;

          String final_type;
          String final_dimensionality;
          String separator;

        algorithm
          final_type := "";
          if force_primitive_types then
            final_type := is_short_class_io_connector_type(
              interface_type.type_name,
              interface_type.io_type);
          end if;
          if final_type == "" then
            final_type :=
              (if .Modelica.Utilities.Strings.find(interface_type.type_name, ".") == 1
                then ""
                else ".") +
              interface_type.type_name;
          end if;

          final_dimensionality := "";
          if size(interface_type.dimensionality, 1) > 0 then
            final_dimensionality := "[";
            separator := "";
            for i in interface_type.dimensionality loop
              final_dimensionality := final_dimensionality + separator + String(i);
              separator := ", ";
            end for;
            final_dimensionality := final_dimensionality + "]";
          end if;

          code :=
            "\n" + indentation +
            (if interface_type.io_type == IOType.Input
              then "input"
              else "output") +
            " " +
            final_type +
            " " +
            interface_type.component_name +
            final_dimensionality +
            (if interface_type.description <> ""
              then "\n" + indentation + "  \"" + interface_type.description + "\""
              else "") +
            (if interface_type.placement <> "" and include_placement
              then "\n" + indentation + "  annotation (" + interface_type.placement + ")"
              else "") +
            ";";
        end declare_io_type;

        function pass_arguments
          extends Icons.GenerateSourceCode;

          input EmbeddedInterfaceType[:] interface;
          input Boolean include_inputs = true;
          input Boolean include_outputs = true;
          output String code = "";

      protected
          type IOType = EmbeddedInterfaceType.IOType;

          String separator;

        algorithm
          separator := "";
          if include_inputs then
            for i in interface loop
              if i.io_type == IOType.Input then
                code := code + separator + i.component_name;
                separator := ", ";
              end if;
            end for;
          end if;
          if include_outputs then
            for i in interface loop
              if i.io_type == IOType.Output then
                code := code + separator + i.component_name;
                separator := ", ";
              end if;
            end for;
          end if;
        end pass_arguments;
        annotation (preferredView = "info");
      end StubGeneration;
      annotation (preferredView = "info");
    end Dymola_C;
    annotation (preferredView = "Info");
  end BuildUtilities;

  package SupportFunctions "General support functions."
    extends .Modelica.Icons.FunctionsPackage;

    function get_files
      "Array of all files and directories contained in a given directory."

      input String directory
        "Directory for which to return its included files and directories."
        annotation(Dialog(__Dymola_directorySelector));
      output String[:] files
        "The files and directories of the given directory.";

    algorithm
      assert(
        .Modelica.Utilities.Files.exist(directory),
        "Directory '" + directory + "' does not exist.");
      files := .Modelica.Utilities.Internal.FileSystem.readDirectory(
        directory,
        .Modelica.Utilities.Internal.FileSystem.getNumberOfFiles(directory));

      annotation (preferredView = "info");
    end get_files;
    annotation (preferredView = "info");
  end SupportFunctions;

  package Icons "Icons for embedded devices and code generation."
    extends .Modelica.Icons.IconsPackage;

    class Modelica
      "Modelica icon."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Polygon(
            origin = {-6.9888,20.048},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            points = {{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
            smooth = Smooth.Bezier),
          Ellipse(
            origin = {40.8208,-37.7602},
            fillColor = {161,0,4},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            extent = {{-17.8562,-17.8563},{17.8563,17.8562}})}));
    end Modelica;

    partial class Dymola
      "Dymola icon."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Rectangle(
            extent = {{-100,100},{100,-100}},
            lineColor = {0,0,255},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid),
          Rectangle(
            extent = {{-34,72},{36,48}},
            lineColor = {28,108,200},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            origin = {0,60},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            extent = {{-50,-20},{50,20}},
            lineColor = {0,0,0},
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-44,58},{-78,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-78,-60},{-74,60}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-44,-62},{-78,-58}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            origin = {0,-60},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            extent = {{-50,-20},{50,20}},
            lineColor = {0,0,0},
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-40,-48},{40,-72}},
            lineColor = {28,108,200},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{80,58},{46,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{76,-60},{80,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{80,-62},{46,-58}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-40,72},{40,48}},
            lineColor = {28,108,200},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None)}));
    end Dymola;

    partial class DymolaEmbedded
      "DymolaEmbedded library icon."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Rectangle(
            extent = {{-100,-100},{100,100}},
            lineColor = {95,95,95},
            pattern = LinePattern.None,
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            radius = 10),
          Rectangle(
            extent = {{-72,106},{-68,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-52,106},{-48,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-32,106},{-28,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-12,106},{-8,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{8,106},{12,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{28,106},{32,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{48,106},{52,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{68,106},{72,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-72,-94},{-68,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-52,-94},{-48,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-32,-94},{-28,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-12,-94},{-8,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{8,-94},{12,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{28,-94},{32,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{48,-94},{52,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{68,-94},{72,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,70},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,50},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,30},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,10},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,-10},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,-30},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,-50},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,-70},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,-70},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,-50},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,-30},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,-10},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,10},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,30},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,50},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,70},
            rotation = 90),
          Rectangle(
            extent = {{-20,-18},{20,20}},
            lineColor = {95,95,95},
            pattern = LinePattern.None,
            fillColor = {14,143,255},
            fillPattern = FillPattern.Solid,
            radius = 10),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,90},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {-100,-90},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,90},
            rotation = 90),
          Rectangle(
            extent = {{-2,6},{2,-6}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0},
            origin = {100,-90},
            rotation = 90),
          Rectangle(
            extent = {{-92,106},{-88,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{88,106},{92,94}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{-92,-94},{-88,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            extent = {{88,-94},{92,-106}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            radius = 10,
            pattern = LinePattern.None,
            lineColor = {0,0,0}),
          Rectangle(
            origin = {0,-60},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            extent = {{-50,-20},{50,20}},
            lineColor = {0,0,0},
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-44,-62},{-78,-58}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-78,-60},{-74,60}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-44,58},{-78,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            origin = {0,60},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            extent = {{-50,-20},{50,20}},
            lineColor = {0,0,0},
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-40,72},{40,48}},
            lineColor = {28,108,200},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{-40,-48},{40,-72}},
            lineColor = {28,108,200},
            fillColor = {0,0,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{80,-62},{46,-58}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{76,-60},{80,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None),
          Rectangle(
            extent = {{80,58},{46,62}},
            lineColor = {28,108,200},
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None)}));
    end DymolaEmbedded;

    class Bundle "Icon for software bundles."

      annotation (
        preferredView = "icon",
        Icon(
          graphics={
            Polygon(points={{-60,20},{-60,20}}, lineColor={28,108,200}),
            Polygon(points={{-80,32},{-80,32}}, lineColor={28,108,200}),
            Polygon(
              points={{-80,30},{0,0},{0,-80},{-80,-50},{-80,30}},
              lineColor={173,83,0},
              fillColor={255,170,85},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,0},{0,-80},{80,-50},{80,30},{0,0}},
              lineColor={173,83,0},
              fillColor={191,127,63},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-80,30},{0,60},{80,30},{0,0},{-80,30}},
              lineColor={173,83,0},
              fillColor={207,138,69},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-48,42},{-28,50},{52,20},{32,12},{-48,42}},
              lineColor={173,83,0},
              fillColor={236,236,236},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{32,12},{52,20},{52,-60},{32,-68},{32,12}},
              lineColor={173,83,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-48,18},{28,50},{48,42},{-28,10},{-48,18}},
              lineColor={173,83,0},
              fillColor={236,236,236},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-48,18},{-28,10},{-28,-70},{-48,-62},{-48,18}},
              lineColor={173,83,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid)}));
    end Bundle;

    partial function Analysis
      "Icon for analysis-functionality."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Ellipse(
            extent = {{-50,-50},{50,50}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            lineColor = {0,0,0}),
          Ellipse(
            extent = {{40,40},{-40,-40}},
            fillColor = {85,170,255},
            fillPattern = FillPattern.Solid,
            pattern = LinePattern.None,
            lineColor = {85,170,255}),
          Polygon(
            points = {{30,-40},{68,-100},{48,-100},{18,-44},{30,-40}},
            fillColor = {0,0,0},
            fillPattern = FillPattern.Solid,
            lineColor = {0,0,0})}));
    end Analysis;

    partial class Build
      "Icon for build functionalities generating eFMU artefacts or parts thereof."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Rectangle(
            extent={{-26,100},{26,12}},
            lineColor = {0,0,0},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            fillColor = {0,0,127}),
          Polygon(
            points={{-72,12},{70,12},{0,-40},{-72,12}},
            lineColor = {85,170,255},
            pattern = LinePattern.None,
            fillPattern = FillPattern.HorizontalCylinder,
            fillColor = {0,0,127})}));
    end Build;

    partial class Runtime
      "Icon for simulation methods and data."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Line(
            points = {{-80,80}, {-46,66}, {-16,-2}, {0,-60}},
            color = {238,46,47},
            smooth = Smooth.Bezier,
            thickness = 2),
          Line(
            points = {{0,-60}, {20,8}, {50,40}},
            color = {238,46,47},
            smooth = Smooth.Bezier,
            thickness = 2),
          Line(
            points = {{-80,-60}, {80,-60}},
            color = {0, 0, 0},
            thickness = 1),
          Rectangle(
            extent = {{-80,-60}, {80,-80}},
            lineThickness = 0.5,
            fillColor = {255, 255, 255},
            fillPattern = FillPattern.Backward,
            pattern = LinePattern.None,
            lineColor = {0, 0, 0}),
          Ellipse(
            extent = {{34,56}, {66,24}},
            lineColor = {0, 0, 0},
            lineThickness = 1,
            fillColor = {238, 46, 47},
            fillPattern = FillPattern.Sphere)}));
    end Runtime;

    partial class Configuration
      "Icon for configuration functionalities and data."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Polygon(
            origin = {1.3835,-4.1418},
            rotation = 45.0,
            fillColor = {64,64,64},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
              {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
              {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
              {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
              {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
              {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
              {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
              {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin = {10.1018,5.218},
            rotation = -45.0,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
              {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
              {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
              {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
              {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
              {-20.0,82.273}})}));
    end Configuration;

    partial class Embedded
      "Icon for embedded devices, packages, functionalities, data and models."

      annotation (
        preferredView = "icon",
        Icon(
          graphics={
            Rectangle(
              extent={{-82,-80},{80,80}},
              lineColor={95,95,95},
              pattern=LinePattern.None,
              fillColor={100,187,75},
              fillPattern=FillPattern.Solid,
              radius=10),
            Rectangle(
              extent={{-72,86},{-68,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-62,86},{-58,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-52,86},{-48,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-42,86},{-38,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-32,86},{-28,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-22,86},{-18,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-12,86},{-8,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-2,86},{2,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{8,86},{12,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{18,86},{22,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{28,86},{32,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{38,86},{42,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{48,86},{52,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{58,86},{62,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{68,86},{72,74}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-72,-76},{-68,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-62,-76},{-58,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-52,-76},{-48,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-42,-76},{-38,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-32,-76},{-28,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-22,-76},{-18,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-12,-76},{-8,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-2,-76},{2,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{8,-76},{12,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{18,-76},{22,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{28,-76},{32,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{38,-76},{42,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{48,-76},{52,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{58,-76},{62,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{68,-76},{72,-88}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,70},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,60},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,50},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,40},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,30},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,20},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,10},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,0},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-10},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-20},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-30},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-40},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-50},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-60},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={82,-70},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-70},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-60},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-50},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-40},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-30},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-20},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,-10},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,0},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,10},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,20},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,30},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,40},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,50},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,60},
              rotation=90),
            Rectangle(
              extent={{-2,6},{2,-6}},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              radius=10,
              pattern=LinePattern.None,
              lineColor={0,0,0},
              origin={-84,70},
              rotation=90),
            Rectangle(
              extent={{-20,-18},{20,20}},
              lineColor={95,95,95},
              pattern=LinePattern.None,
              fillColor={130,238,94},
              fillPattern=FillPattern.Solid,
              radius=10)}));
    end Embedded;

    partial class EmbeddedConfiguration
      "Icon for eFMU generation configurations."
      extends .Modelica.Icons.Package;
      extends Embedded
        annotation(IconMap(extent={{-85,-85},{85,85}}));
      extends Configuration
        annotation(IconMap(extent={{-85,-85},{85,85}}));

      annotation (preferredView = "icon");
    end EmbeddedConfiguration;

    partial class SourceCodeContainer
      "Icon for packages providing functionalities related to eFMU source code
   containers (Algorithm or Production Code containers)."
      extends .Modelica.Icons.Package;
      extends SourceCode
        annotation(IconMap(extent={{-70,-70},{70,70}}));

      annotation (preferredView = "icon");
    end SourceCodeContainer;

    partial class BehavioralModelContainer
      "Icon for packages providing functionalities related to eFMU Behavioral
   Model containers."
      extends .Modelica.Icons.Package;
      extends Icons.Runtime;

      annotation (preferredView = "icon");
    end BehavioralModelContainer;

    partial class BinaryCodeContainer
      "Icon for packages providing functionalities related to eFMU Binary Code
   containers."
      extends .Modelica.Icons.Package;
      extends Icons.Embedded
        annotation(IconMap(extent={{-85,-85},{85,85}}));

      annotation (preferredView = "icon");
    end BinaryCodeContainer;

    partial block Controller
      "Icon for blocks that are controllers."

      annotation (
        preferredView = "icon",
        Icon(
          graphics={
            Rectangle(
              origin={0,44},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-40,-16},{40,16}}),
            Rectangle(
              origin={0,-44},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid,
              extent={{-40,-16},{40,16}}),
            Line(
              origin={-63.25,6},
              points={{23.25,-50},{-2.75,-50},{-2.75,38},{23.25,38}}),
            Line(
              origin={59.25,6},
              points={{-19.25,38},{6.75,38},{6.75,-50},{-19.25,-50}}),
            Polygon(
              points={{-60,54},{-60,34},{-40,44},{-60,54}},
              lineColor={28,108,200},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{60,-34},{60,-54},{40,-44},{60,-34}},
              lineColor={28,108,200},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None)}));
    end Controller;

    partial block ControllerEmbedded
      "Icon for models that are embedded controllers, predictors, virtual sensors
   etc (eBlocks)."
      extends .Modelica.Blocks.Icons.Block;
      extends Embedded;
      extends Controller;

      annotation (preferredView = "icon");
    end ControllerEmbedded;

    partial function BuildEmbedded
      "Icon for functions that are interactively used to build embedded artefacts."
      extends Icons.Embedded;
      extends .Modelica.Icons.Function
        annotation(IconMap(extent = {{-60,-60},{60,60}}));
      extends Build;

      annotation (
        preferredView = "icon",
        __Dymola_interactive = true);
    end BuildEmbedded;

    partial function BuildModelica
      "Icon for functions that are interactively used to build Modelica artefacts."
      extends Icons.Dymola;
      extends .Modelica.Icons.Function
        annotation(IconMap(extent={{-60,-60},{60,60}}));
      extends Build;

      annotation (
        preferredView = "icon",
        __Dymola_interactive = true);
    end BuildModelica;

    partial class SourceCode
      "Icon for source code."

      annotation (
        preferredView = "icon",
        Icon(graphics={
          Polygon(
            points = {{-80,-100},{-80,100},{0,100},{0,20},{80,20},{80,-100},{-80,-100}},
            lineColor = {0,0,0},
            fillColor = {245,245,245},
            fillPattern = FillPattern.Solid),
          Polygon(
            points = {{0,100},{80,20},{0,20},{0,100}},
            lineColor = {0,0,0},
            fillColor = {215,215,215},
            fillPattern = FillPattern.Solid),
          Line(points = {{-60,-90},{20,-90}}),
          Line(points = {{-60,0},{60,0}}),
          Line(points = {{-40,-60},{70,-60}}),
          Line(points = {{-60,-30},{40,-30}})}));
    end SourceCode;

    partial function SourceCodeAnalysis
      "Icon for source code analysis functionality."
      extends SourceCode;
      extends Analysis;

      annotation (
        preferredView = "icon",
        __Dymola_interactive = true);
    end SourceCodeAnalysis;

    partial function GenerateSourceCode
      "Icon for functions that are interactively used to generate source code."
      extends SourceCode;
      extends Build;

      annotation (
        preferredView = "icon",
        __Dymola_interactive = true);
    end GenerateSourceCode;

    class TuningBus
      "Icon for tuning buses enabling recalibration, for example the tuning buses
   provided by eFMU co-simulation stubs."

      annotation (
        preferredView = "icon",
        Icon(
          coordinateSystem(initialScale=0.2),
          graphics={
            Rectangle(
              lineColor={255,204,51},
              lineThickness=0.5,
              extent={{-20.0,-2.0},{20.0,2.0}}),
            Polygon(
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              points={{-80.0,50.0},{80.0,50.0},{100.0,30.0},{80.0,-40.0},{60.0,-50.0},{-60.0,-50.0},{-80.0,-40.0},{-100.0,30.0}},
              smooth=Smooth.Bezier),
            Ellipse(
              fillPattern=FillPattern.Solid,
              extent={{-65.0,15.0},{-55.0,25.0}}),
            Ellipse(
              fillPattern=FillPattern.Solid,
              extent={{-5.0,15.0},{5.0,25.0}}),
            Ellipse(
              fillPattern=FillPattern.Solid,
              extent={{55.0,15.0},{65.0,25.0}}),
            Ellipse(
              fillPattern=FillPattern.Solid,
              extent={{-35.0,-25.0},{-25.0,-15.0}}),
            Ellipse(
              fillPattern=FillPattern.Solid,
              extent={{25.0,-25.0},{35.0,-15.0}})}),
        Diagram(
          coordinateSystem(initialScale=0.2),
          graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,-20},{-50,15}},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid,
              smooth=Smooth.Bezier),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              textString="%name")}));
    end TuningBus;

    class TuningBusSampler
      "Icon for the tuning bus samplers provided by eFMU co-simulation stubs."
      extends .Modelica.Clocked.RealSignals.Interfaces.SamplerIcon;

      annotation (
        preferredView = "icon",
        Icon(
          graphics={
            Polygon(
              points={{-120,100},{-120,40},{-60,70},{-120,100}},
              lineColor={244,204,51},
              fillColor={244,204,51},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{60,100},{60,40},{120,70},{60,100}},
              lineColor={244,204,51},
              lineThickness=1),
            Line(
              points={{-62,70},{60,70}},
              color={244,204,51},
              thickness=1)}));
    end TuningBusSampler;

    partial class ConfiguredClock
      "Icon for implicitly, by the eFMU generation configuration, defined
   'Modelica.Clocked' constructs."

      annotation (
        preferredView = "icon",
        Icon(
          graphics={
            Ellipse(
              extent={{20,-120},{120,-20}},
              lineColor={0,0,0},
              fillColor={216,216,216},
              fillPattern=FillPattern.Solid),
            Line(points={{107.282,-40},{96,-48}}, color={0,0,0}),
            Line(points={{70,-20},{70,-36}}, color={0,0,0}),
            Line(points={{36,-34.718},{46,-46}}, color={0,0,0}),
            Line(points={{20,-70},{36,-70}}, color={0,0,0}),
            Line(points={{36,-106},{46,-96}}, color={0,0,0}),
            Line(points={{70,-120},{70,-106}}, color={0,0,0}),
            Line(points={{103.282,-106},{94,-96}}, color={0,0,0}),
            Line(points={{120,-70},{106,-70}}, color={0,0,0}),
            Line(points={{70,-70},{56,-32}}, color={0,0,0}),
            Line(points={{70,-70},{98,-70}}, color={0,0,0})}));
    end ConfiguredClock;
    annotation (preferredView = "info");
  end Icons;
  annotation (
    preferredView = "info",
    uses(
      Modelica(version = "4.0.0"),
      ModelManagement(version = "1.3"),
      Testing(version="1.4.1"),
      eFMI(version = "1.1.0")),
    version = "0.33.0",
    Protection(
      __Dymola_showFlat = true,
      access = Access.packageDuplicate),
    __Dymola_Commands(
      executeCall = DymolaEmbedded.BuildUtilities.build_all(
        package_name = "DymolaEmbedded.Examples")
        "Build embedded simulators of examples"),
    Documentation(info="<html>
The <code>DymolaEmbedded</code> library provides documentation, common utility functions and
application examples for the
<a href=\"https://www.efmi-standard.org\">eFMU</a>
generation facilities of the
<a href=\"https://www.3ds.com/products-services/catia/products/dymola/\">Dymola</a>
Modelica-IDE.
<p>
A detailed documentation is given in the
<a href=\"modelica://DymolaEmbedded.UsersGuide\">user's guide</a>.
<p>
<b>Important:</b> Please note the library
<a href=\"modelica://DymolaEmbedded.UsersGuide.Requirements\">requirements</a>.
<h4>Copyright</h4>
<table border=\"0\" cellspacing=\"10\">
<tr>
<td><a href=\"https://www.3ds.com/\">
<img src=\"modelica://DymolaEmbedded/Resources/Images/ds-logo.png\"></a></td>
<td style=\"vertical-align: middle;\">
<b>Copyright &copy; 2016-2022, Dassault Systèmes AB</b>
</td>
</tr>
</table>
</html>"));
end DymolaEmbedded;

package 'Luigi_eFMI_Test.eFMU_SiL_Support' "Package supporting software in the loop (SiL) simulation of the production
   codes of the eFMU generated for the eFMU generation configuration
     Luigi_eFMI_Test"
  extends .DymolaEmbedded.Icons.BinaryCodeContainer;

  block BinaryStub
    "Stub for eFMU-based co-simulation of
       Luigi_eFMI_Test.PSSTypeII_Parameterized
     using the static linked libraries suited for Dymola's current simulation
     platform generated for the Production Code containers
         PCode_ESP_1476857878
         PCode_ESP_859909373
     as configured by
       Luigi_eFMI_Test
     Generated by Dymola on 2022-02-25 at 13:57:40."

    import __TuningConfiguration = 'Luigi_eFMI_Test.eFMU_SiL_Support'.TuningConfiguration;
    import __TuningBus = 'Luigi_eFMI_Test.eFMU_SiL_Support'.TuningBus;
    import __TuningBusSampler = 'Luigi_eFMI_Test.eFMU_SiL_Support'.TuningBusSampler;
    import __ProductionCodes = 'Luigi_eFMI_Test.eFMU_SiL_Support'.ProductionCodes;

    extends .DymolaEmbedded.BuildUtilities.BinaryCode.BinaryStub(
      final __sampling_period = 0.001,
      redeclare final __SampledInterface __sampled);

    /*
      Stub-interface:
    */

    // Inputs:
    input .Modelica.Blocks.Interfaces.RealInput vSI
      "PSS input signal "
      annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));

    // Outputs:
    output .Modelica.Blocks.Interfaces.RealOutput vs
      "PSS output signal"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));

    // Tuneable parameters:
    parameter Real Kw = 9.5
      "Stabilizer gain (pu/pu)";
    parameter Real T1 = 0.154
      "First stabilizer time constant (s)";
    parameter Real T2 = 0.033
      "Second stabilizer time constant (s)";
    parameter Real T3 = 1
      "Third stabilizer time constant (s)";
    parameter Real T4 = 1
      "Fourth stabilizer time constant (s)";
    parameter Real Tw = 1.41
      "Wash-out time constant (s)";
    parameter Real vSI_start = 1.0
      "Default start value for vSI, the PSS input signal.";
    parameter Real vsmax = 0.2
      "Max stabilizer output signal (pu)";
    parameter Real vsmin = -0.2
      "Min stabilizer output signal (pu)";

    parameter __TuningConfiguration __tuning_configuration
      "Tuning configuration selecting the tuneable parameters to tune/recalibrate
       at runtime (i.e., throughout simulation). Only the selected tuneables are
       taken from the tuning bus; all others are set to the stub's respective
       Modelica parameters.";
    __TuningBus __tuning
      if __enable_tuning
      "Tuning bus providing the runtime values used for recalibration. Values have
       to be provided only for the parameters selected in the tuning
       configuration."
      annotation (Placement(
        iconTransformation(extent={{10,-100},{90,-20}}),
        transformation(extent={{60,-80},{80,-60}})));

    // Supported production codes:
    parameter __ProductionCodes __defining_code=
      __ProductionCodes.PCode_ESP_1476857878
      "The production code defining the stub's results,
       i.e., whose results are propagated by the stub.";

    parameter __ProductionCodes[:] __active_codes = {
      __ProductionCodes.PCode_ESP_1476857878,
      __ProductionCodes.PCode_ESP_859909373}
      "Set of production codes co-simulated. By default, all production codes
       are co-simulated. The '__defining_code' is always active, even if not
       explicitly listed in the set.";

    // Co-simulation results of each production code:
    __CosimulationResults[__ProductionCodes] __cosimulation_results
    "Vector capturing the results of all co-simulated production codes.";

    /*
      Internal support facilities: 
    */

protected
    __TuningBusSampler __tuning_sampler
      if __embedd_clock
      "Sampler used to sample all tuning bus signals in case of
       '__embedd_clock = true'.";
    __TuningBusDecoder __tuning_decoder
      "Decoder providing the sampled tuning signals of the tuning bus as
       individual output connections.";
    __TuningBusSource __tuning_mockup(
      final tuning(
        final Kw = Kw,
        final T1 = T1,
        final T2 = T2,
        final T3 = T3,
        final T4 = T4,
        final Tw = Tw,
        final vSI_start = vSI_start,
        final vsmax = vsmax,
        final vsmin = vsmin))
      if not
            (__enable_tuning)
      "Mockup tuning bus used as tuning signals source if tuning is disabled.
       It just provides the given parameterization as bus signals.";
    __Tuning __active_tuning
      "Support record holding the active calibration, i.e., the calibration
       the eFMU uses so far. Used to compare it with the currently -- by
       modifications or the tuning bus -- desired values for updating
       '__recalibrate'.";

    parameter Boolean[__ProductionCodes] __active_codes_map = {
      __defining_code == __ProductionCodes.PCode_ESP_1476857878
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes.PCode_ESP_1476857878),
          Integer(__active_codes)),
      __defining_code == __ProductionCodes.PCode_ESP_859909373
        or 0 < .Modelica.Math.Vectors.find(
          Integer(__ProductionCodes.PCode_ESP_859909373),
          Integer(__active_codes))}
      "Internal precomputed cache mapping production codes to their
       activation-status."
      annotation(Evaluate = true);

    /*
    Internal bindings for production code
        PCode_ESP_1476857878:
    */

    class __BlockState_PCode_ESP_1476857878
      extends ExternalObject;

      function constructor
        output __BlockState_PCode_ESP_1476857878 block_state;
        external "C" block_state = mei_Startup_H632826200_1476857878()
          annotation (
            LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
            Library = "H632826200_1476857878");
      end constructor;

      function destructor
        input __BlockState_PCode_ESP_1476857878 block_state;
        external "C" mei_Terminate_H632826200_1476857878(block_state)
          annotation (
            LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
            Library = "H632826200_1476857878");
      end destructor;
    end __BlockState_PCode_ESP_1476857878;

    function __Recalibrate_PCode_ESP_1476857878
      input __BlockState_PCode_ESP_1476857878 block_state;
      input Real Kw
        "Stabilizer gain (pu/pu)";
      input Real T1
        "First stabilizer time constant (s)";
      input Real T2
        "Second stabilizer time constant (s)";
      input Real T3
        "Third stabilizer time constant (s)";
      input Real T4
        "Fourth stabilizer time constant (s)";
      input Real Tw
        "Wash-out time constant (s)";
      input Real vSI_start
        "Default start value for vSI, the PSS input signal.";
      input Real vsmax
        "Max stabilizer output signal (pu)";
      input Real vsmin
        "Min stabilizer output signal (pu)";
      output Integer error_signals;
      external "C" error_signals =
        mei_Recalibrate_H632826200_1476857878(
          block_state,
          Kw,
          T1,
          T2,
          T3,
          T4,
          Tw,
          vSI_start,
          vsmax,
          vsmin);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_1476857878");
    end __Recalibrate_PCode_ESP_1476857878;

    function __Reinitialize_PCode_ESP_1476857878
      input __BlockState_PCode_ESP_1476857878 block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_Reinitialize_H632826200_1476857878(
          block_state,
          vSI,
          vs);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_1476857878");
    end __Reinitialize_PCode_ESP_1476857878;

    function __DoStep_PCode_ESP_1476857878
      input __BlockState_PCode_ESP_1476857878 block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_DoStep_H632826200_1476857878(
          block_state,
          vSI,
          vs);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_1476857878");
    end __DoStep_PCode_ESP_1476857878;

    __BlockState_PCode_ESP_1476857878 __block_state_PCode_ESP_1476857878=
      __BlockState_PCode_ESP_1476857878();

    /*
    Internal bindings for production code
        PCode_ESP_859909373:
    */

    class __BlockState_PCode_ESP_859909373
      extends ExternalObject;

      function constructor
        output __BlockState_PCode_ESP_859909373 block_state;
        external "C" block_state = mei_Startup_H632826200_859909373()
          annotation (
            LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
            Library = "H632826200_859909373");
      end constructor;

      function destructor
        input __BlockState_PCode_ESP_859909373 block_state;
        external "C" mei_Terminate_H632826200_859909373(block_state)
          annotation (
            LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
            Library = "H632826200_859909373");
      end destructor;
    end __BlockState_PCode_ESP_859909373;

    function __Recalibrate_PCode_ESP_859909373
      input __BlockState_PCode_ESP_859909373 block_state;
      input Real Kw
        "Stabilizer gain (pu/pu)";
      input Real T1
        "First stabilizer time constant (s)";
      input Real T2
        "Second stabilizer time constant (s)";
      input Real T3
        "Third stabilizer time constant (s)";
      input Real T4
        "Fourth stabilizer time constant (s)";
      input Real Tw
        "Wash-out time constant (s)";
      input Real vSI_start
        "Default start value for vSI, the PSS input signal.";
      input Real vsmax
        "Max stabilizer output signal (pu)";
      input Real vsmin
        "Min stabilizer output signal (pu)";
      output Integer error_signals;
      external "C" error_signals =
        mei_Recalibrate_H632826200_859909373(
          block_state,
          Kw,
          T1,
          T2,
          T3,
          T4,
          Tw,
          vSI_start,
          vsmax,
          vsmin);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_859909373");
    end __Recalibrate_PCode_ESP_859909373;

    function __Reinitialize_PCode_ESP_859909373
      input __BlockState_PCode_ESP_859909373 block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_Reinitialize_H632826200_859909373(
          block_state,
          vSI,
          vs);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_859909373");
    end __Reinitialize_PCode_ESP_859909373;

    function __DoStep_PCode_ESP_859909373
      input __BlockState_PCode_ESP_859909373 block_state;
      input Real vSI
        "PSS input signal ";
      output Integer error_signals;
      output Real vs
        "PSS output signal";
      external "C" error_signals =
        mei_DoStep_H632826200_859909373(
          block_state,
          vSI,
          vs);
        annotation (
          LibraryDirectory = "modelica://'Luigi_eFMI_Test.eFMU_SiL_Support'/",
          Library = "H632826200_859909373");
    end __DoStep_PCode_ESP_859909373;

    __BlockState_PCode_ESP_859909373 __block_state_PCode_ESP_859909373=
      __BlockState_PCode_ESP_859909373();

  equation
    /*
      Incorporate the sampling:
    */

    if __embedd_clock then
      // =============> Workaround Dymola bug start =============>
      connect(__clock, __embedded_clock);
      // <============= Workaround  Dymola  bug end <=============
      // In- and outputs:
      __sampled.vSI = sample(vSI, __clock);
      vs = hold(__sampled.vs);
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_sampler.ingoing);
      else
        connect(__tuning_mockup.bus, __tuning_sampler.ingoing);
      end if;
      connect(__tuning_sampler.outgoing, __tuning_decoder.__bus);
    else
      // In- and outputs:
      __sampled.vSI = vSI;
      vs = __sampled.vs;
      // Tuneables:
      if __enable_tuning then
        connect(__tuning, __tuning_decoder.__bus);
      else
        connect(__tuning_mockup.bus, __tuning_decoder.__bus);
      end if;
    end if;

    /*
      Select the tuneables either from the bus or parametrization,
      depending on their tuning configuration:
    */

    __sampled.__tuning.Kw =
      (if __tuning_configuration.Kw
       then __tuning_decoder.Kw
       else Kw);
    __sampled.__tuning.T1 =
      (if __tuning_configuration.T1
       then __tuning_decoder.T1
       else T1);
    __sampled.__tuning.T2 =
      (if __tuning_configuration.T2
       then __tuning_decoder.T2
       else T2);
    __sampled.__tuning.T3 =
      (if __tuning_configuration.T3
       then __tuning_decoder.T3
       else T3);
    __sampled.__tuning.T4 =
      (if __tuning_configuration.T4
       then __tuning_decoder.T4
       else T4);
    __sampled.__tuning.Tw =
      (if __tuning_configuration.Tw
       then __tuning_decoder.Tw
       else Tw);
    __sampled.__tuning.vSI_start =
      (if __tuning_configuration.vSI_start
       then __tuning_decoder.vSI_start
       else vSI_start);
    __sampled.__tuning.vsmax =
      (if __tuning_configuration.vsmax
       then __tuning_decoder.vsmax
       else vsmax);
    __sampled.__tuning.vsmin =
      (if __tuning_configuration.vsmin
       then __tuning_decoder.vsmin
       else vsmin);

  algorithm
    when Clock() then
      /*
        Update tuning:
      */

      if not
            (__is_initialized) then
        // Initialization the active calibration with the eFMU's default calibration:
        __active_tuning.Kw := 9.5;
        __active_tuning.T1 := 0.154;
        __active_tuning.T2 := 0.033;
        __active_tuning.T3 := 1;
        __active_tuning.T4 := 1;
        __active_tuning.Tw := 1.41;
        __active_tuning.vSI_start := 1.0;
        __active_tuning.vsmax := 0.2;
        __active_tuning.vsmin := -0.2;
      end if;

      __sampled.__recalibrate := false
        or max(abs(__sampled.__tuning.Kw
          - __active_tuning.Kw)) > 0.0
        or max(abs(__sampled.__tuning.T1
          - __active_tuning.T1)) > 0.0
        or max(abs(__sampled.__tuning.T2
          - __active_tuning.T2)) > 0.0
        or max(abs(__sampled.__tuning.T3
          - __active_tuning.T3)) > 0.0
        or max(abs(__sampled.__tuning.T4
          - __active_tuning.T4)) > 0.0
        or max(abs(__sampled.__tuning.Tw
          - __active_tuning.Tw)) > 0.0
        or max(abs(__sampled.__tuning.vSI_start
          - __active_tuning.vSI_start)) > 0.0
        or max(abs(__sampled.__tuning.vsmax
          - __active_tuning.vsmax)) > 0.0
        or max(abs(__sampled.__tuning.vsmin
          - __active_tuning.vsmin)) > 0.0;

      if __sampled.__recalibrate then
        __active_tuning := __sampled.__tuning;
      end if;

      /*
        Cosimulate the active binaries:
      */

      __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__production_code :=
        __ProductionCodes.PCode_ESP_1476857878;
      __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__is_active :=
        __active_codes_map[__ProductionCodes.PCode_ESP_1476857878];
      if __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__is_active then
        __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__error_signals_Recalibrate := 0;
        if __sampled.__recalibrate then
          __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__error_signals_Recalibrate :=
            __Recalibrate_PCode_ESP_1476857878(
              __block_state_PCode_ESP_1476857878,
              __sampled.__tuning.Kw,
              __sampled.__tuning.T1,
              __sampled.__tuning.T2,
              __sampled.__tuning.T3,
              __sampled.__tuning.T4,
              __sampled.__tuning.Tw,
              __sampled.__tuning.vSI_start,
              __sampled.__tuning.vsmax,
              __sampled.__tuning.vsmin);
        end if;
        if __sampled.__reinitialize or not
                                          (__is_initialized) then
          ( __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__error_signals_Reinitialize,
            __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].vs)
            := __Reinitialize_PCode_ESP_1476857878(
            __block_state_PCode_ESP_1476857878,
            __sampled.vSI);
        end if;
        ( __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].__error_signals_DoStep,
          __cosimulation_results[__ProductionCodes.PCode_ESP_1476857878].vs)
          := __DoStep_PCode_ESP_1476857878(
          __block_state_PCode_ESP_1476857878,
          __sampled.vSI);
      end if;

      __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__production_code :=
        __ProductionCodes.PCode_ESP_859909373;
      __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__is_active :=
        __active_codes_map[__ProductionCodes.PCode_ESP_859909373];
      if __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__is_active then
        __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__error_signals_Recalibrate := 0;
        if __sampled.__recalibrate then
          __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__error_signals_Recalibrate :=
            __Recalibrate_PCode_ESP_859909373(
              __block_state_PCode_ESP_859909373,
              __sampled.__tuning.Kw,
              __sampled.__tuning.T1,
              __sampled.__tuning.T2,
              __sampled.__tuning.T3,
              __sampled.__tuning.T4,
              __sampled.__tuning.Tw,
              __sampled.__tuning.vSI_start,
              __sampled.__tuning.vsmax,
              __sampled.__tuning.vsmin);
        end if;
        if __sampled.__reinitialize or not
                                          (__is_initialized) then
          ( __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__error_signals_Reinitialize,
            __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].vs)
            := __Reinitialize_PCode_ESP_859909373(
            __block_state_PCode_ESP_859909373,
            __sampled.vSI);
        end if;
        ( __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].__error_signals_DoStep,
          __cosimulation_results[__ProductionCodes.PCode_ESP_859909373].vs)
          := __DoStep_PCode_ESP_859909373(
          __block_state_PCode_ESP_859909373,
          __sampled.vSI);
      end if;

      /*
        Stub-modification and input dependent initialization of all
        eFMU production codes certainly finished:
      */
      __is_initialized := true;

      /*
        Propagate the results of the defining production code:
      */

      __sampled.__error_signals_Recalibrate :=
        __cosimulation_results[__defining_code].__error_signals_Recalibrate;
      __sampled.__error_signals_Reinitialize :=
        __cosimulation_results[__defining_code].__error_signals_Reinitialize;
      __sampled.__error_signals_DoStep :=
        __cosimulation_results[__defining_code].__error_signals_DoStep;
      __sampled.vs :=
        __cosimulation_results[__defining_code].vs;
    end when;

    /*
      Preconfigure FMU export:
    */

    annotation (
      preferredView = "info",
      experiment(
        __Dymola_fixedstepsize = 0.001,
        __Dymola_Algorithm = "Euler"),
      __Dymola_experimentFlags(
        Advanced(
          InlineMethod = 1,
          InlineOrder = 2,
          InlineFixedStep = 0.001)));
  end BinaryStub;

  encapsulated record TuningConfiguration
    "Record type for selecting tuneable parameters to tune/recalibrate at runtime."

    extends .DymolaEmbedded.Icons.TuningBus;
    extends .DymolaEmbedded.Icons.Configuration;

    parameter Boolean Kw = false;
    parameter Boolean T1 = false;
    parameter Boolean T2 = false;
    parameter Boolean T3 = false;
    parameter Boolean T4 = false;
    parameter Boolean Tw = false;
    parameter Boolean vSI_start = false;
    parameter Boolean vsmax = false;
    parameter Boolean vsmin = false;

    annotation(preferredView = "info");
  end TuningConfiguration;

  expandable connector TuningBus
    "Expandable connector type for provisioning runtime values used for
     recalibration."

    extends .DymolaEmbedded.Icons.TuningBus;
    extends __Tuning;

    annotation(preferredView = "info");
  end TuningBus;

  model TuningBusSampler
    "Sampler for sampling a tuning bus with the clock of the clocked-partition
     the outgoing bus is part of."

    extends .DymolaEmbedded.Icons.TuningBusSampler;

    TuningBus ingoing
      annotation (
        Placement(
          transformation(extent={{-140,-50},{-40,50}}),
          iconTransformation(extent={{-140,-50},{-40,50}})));
    TuningBus outgoing
      annotation (
        Placement(
          transformation(extent={{40,-50},{140,50}}),
          iconTransformation(extent={{40,-50},{140,50}})));

protected
    __TuningBusDecoder decoder;
    __TuningBusEncoder encoder;

  equation
    connect(ingoing, decoder.__bus);

    encoder.Kw = sample(decoder.Kw);
    encoder.T1 = sample(decoder.T1);
    encoder.T2 = sample(decoder.T2);
    encoder.T3 = sample(decoder.T3);
    encoder.T4 = sample(decoder.T4);
    encoder.Tw = sample(decoder.Tw);
    encoder.vSI_start = sample(decoder.vSI_start);
    encoder.vsmax = sample(decoder.vsmax);
    encoder.vsmin = sample(decoder.vsmin);

    connect(encoder.__bus, outgoing);

    annotation (preferredView = "info");
  end TuningBusSampler;

  encapsulated type ProductionCodes = enumeration(
    PCode_ESP_1476857878,
    PCode_ESP_859909373)
    "Production codes the stub provides for co-simulation."
    annotation (
      preferredView = "info",
      Icon(
        graphics={
          Rectangle(
            extent={{-82,-80},{80,80}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={100,187,75},
            fillPattern=FillPattern.Solid,
            radius=10),
          Rectangle(
            extent={{-72,86},{-68,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,86},{-58,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,86},{-48,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,86},{-38,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,86},{-28,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,86},{-18,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,86},{-8,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,86},{2,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,86},{12,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,86},{22,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,86},{32,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,86},{42,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,86},{52,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,86},{62,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,86},{72,74}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-72,-76},{-68,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-62,-76},{-58,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-52,-76},{-48,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-42,-76},{-38,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-32,-76},{-28,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-22,-76},{-18,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-12,-76},{-8,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,-76},{2,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{8,-76},{12,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{18,-76},{22,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{28,-76},{32,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{38,-76},{42,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{48,-76},{52,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{58,-76},{62,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{68,-76},{72,-88}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0}),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={82,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-70},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,-10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,0},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,10},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,20},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,30},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,40},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,50},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,60},
            rotation=90),
          Rectangle(
            extent={{-2,6},{2,-6}},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid,
            radius=10,
            pattern=LinePattern.None,
            lineColor={0,0,0},
            origin={-84,70},
            rotation=90),
          Rectangle(
            extent={{-20,-18},{20,20}},
            lineColor={95,95,95},
            pattern=LinePattern.None,
            fillColor={130,238,94},
            fillPattern=FillPattern.Solid,
            radius=10),
          Polygon(
            origin = {1.3835,-4.1418},
            rotation = 45.0,
            fillColor = {64,64,64},
            pattern = LinePattern.None,
            fillPattern = FillPattern.Solid,
            points = {{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},
              {15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},
              {10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},
              {0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
              {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},
              {-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},
              {-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
              {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin = {10.1018,5.218},
            rotation = -45.0,
            fillColor = {255,255,255},
            fillPattern = FillPattern.Solid,
            points = {{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},
              {10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},
              {5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},
              {-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
              {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},
              {-20.0,82.273}})}));

  record __Tuning
    "Support record type compiling all tuneable parameters, each typed with
     a fitting builtin Modelica type."

    Real Kw
      "Stabilizer gain (pu/pu)";
    Real T1
      "First stabilizer time constant (s)";
    Real T2
      "Second stabilizer time constant (s)";
    Real T3
      "Third stabilizer time constant (s)";
    Real T4
      "Fourth stabilizer time constant (s)";
    Real Tw
      "Wash-out time constant (s)";
    Real vSI_start
      "Default start value for vSI, the PSS input signal.";
    Real vsmax
      "Max stabilizer output signal (pu)";
    Real vsmin
      "Min stabilizer output signal (pu)";
  end __Tuning;

  class __TuningConnectors
    "Connector types for each tuneable parameter (required by tuning bus en- and
     decoders to provide respective in- and output connectors)."

    connector Kw =
      .Real;
    connector T1 =
      .Real;
    connector T2 =
      .Real;
    connector T3 =
      .Real;
    connector T4 =
      .Real;
    connector Tw =
      .Real;
    connector vSI_start =
      .Real;
    connector vsmax =
      .Real;
    connector vsmin =
      .Real;
  end __TuningConnectors;

  block __TuningBusSource
    "Tuning source providing a given, fixed parameterization as bus signals."

    parameter __Tuning tuning;
    TuningBus bus;

protected
    __TuningBusEncoder encoder;
    Source source(__tuning = tuning);

    block Source
      parameter __Tuning __tuning;
      output __TuningConnectors.Kw Kw;
      output __TuningConnectors.T1 T1;
      output __TuningConnectors.T2 T2;
      output __TuningConnectors.T3 T3;
      output __TuningConnectors.T4 T4;
      output __TuningConnectors.Tw Tw;
      output __TuningConnectors.vSI_start vSI_start;
      output __TuningConnectors.vsmax vsmax;
      output __TuningConnectors.vsmin vsmin;
    equation
      Kw = __tuning.Kw;
      T1 = __tuning.T1;
      T2 = __tuning.T2;
      T3 = __tuning.T3;
      T4 = __tuning.T4;
      Tw = __tuning.Tw;
      vSI_start = __tuning.vSI_start;
      vsmax = __tuning.vsmax;
      vsmin = __tuning.vsmin;
    end Source;

  equation
    connect(source.Kw, encoder.Kw);
    connect(source.T1, encoder.T1);
    connect(source.T2, encoder.T2);
    connect(source.T3, encoder.T3);
    connect(source.T4, encoder.T4);
    connect(source.Tw, encoder.Tw);
    connect(source.vSI_start, encoder.vSI_start);
    connect(source.vsmax, encoder.vsmax);
    connect(source.vsmin, encoder.vsmin);
    connect(encoder.__bus, bus);
  end __TuningBusSource;

  model __TuningBusDecoder
    "Decoder providing each tuning signal of a tuning bus as individually
     connectable output."

    import __TuningBus = 'Luigi_eFMI_Test.eFMU_SiL_Support'.TuningBus;

    __TuningBus __bus;

    output __TuningConnectors.Kw Kw;
    output __TuningConnectors.T1 T1;
    output __TuningConnectors.T2 T2;
    output __TuningConnectors.T3 T3;
    output __TuningConnectors.T4 T4;
    output __TuningConnectors.Tw Tw;
    output __TuningConnectors.vSI_start vSI_start;
    output __TuningConnectors.vsmax vsmax;
    output __TuningConnectors.vsmin vsmin;

  equation
    connect(__bus.Kw, Kw);
    connect(__bus.T1, T1);
    connect(__bus.T2, T2);
    connect(__bus.T3, T3);
    connect(__bus.T4, T4);
    connect(__bus.Tw, Tw);
    connect(__bus.vSI_start, vSI_start);
    connect(__bus.vsmax, vsmax);
    connect(__bus.vsmin, vsmin);
  end __TuningBusDecoder;

  model __TuningBusEncoder
    "Encoder setting each tuning signal of a tuning bus via an individually
     connectable input."

    import __TuningBus = 'Luigi_eFMI_Test.eFMU_SiL_Support'.TuningBus;

    input __TuningConnectors.Kw Kw;
    input __TuningConnectors.T1 T1;
    input __TuningConnectors.T2 T2;
    input __TuningConnectors.T3 T3;
    input __TuningConnectors.T4 T4;
    input __TuningConnectors.Tw Tw;
    input __TuningConnectors.vSI_start vSI_start;
    input __TuningConnectors.vsmax vsmax;
    input __TuningConnectors.vsmin vsmin;

    __TuningBus __bus;

  equation
    connect(Kw, __bus.Kw);
    connect(T1, __bus.T1);
    connect(T2, __bus.T2);
    connect(T3, __bus.T3);
    connect(T4, __bus.T4);
    connect(Tw, __bus.Tw);
    connect(vSI_start, __bus.vSI_start);
    connect(vsmax, __bus.vsmax);
    connect(vsmin, __bus.vsmin);
  end __TuningBusEncoder;

  record __SampledInterface
    "Refined, actual eFMU communication interface as defined and required by the
     eFMU used for co-simulation."

    extends .DymolaEmbedded.BuildUtilities.BinaryCode.DefaultSampledInterface;

    // Inputs:
    Real vSI
      "PSS input signal ";

    // Outputs:
    Real vs
      "PSS output signal";

    // Tuneable parameters:
    __Tuning __tuning;
  end __SampledInterface;

  record __CosimulationResults
    "Record compiling the results of a single co-simulated production code."

    import __ProductionCodes = 'Luigi_eFMI_Test.eFMU_SiL_Support'.ProductionCodes;

    // Cosimulation status:
    __ProductionCodes __production_code
      "The production code this are the results of.";
    Boolean __is_active
      "Whether the production code has been co-simulated or not.";
    Integer __error_signals_Recalibrate
      "Errors signaled by the last execution of the 'Recalibrate()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_Reinitialize
      "Errors signaled by the last execution of the 'Reinitialize()'
       block-interface method of the production code; 0 in case of no errors
       (cf. the eFMI specification for pre-defined error signals and the
       encoding of such).";
    Integer __error_signals_DoStep
      "Errors signaled by the last execution of the 'DoStep()' block-interface
       method of the production code; 0 in case of no errors (cf. the eFMI
       specification for pre-defined error signals and the encoding of such).";

    // Cosimulation outputs:
    Real vs
      "PSS output signal";
  end __CosimulationResults;
  annotation(preferredView = "info");
end 'Luigi_eFMI_Test.eFMU_SiL_Support';

package ModelicaServices
  "ModelicaServices (Dymola implementation) - Models and functions used in the Modelica Standard Library requiring a tool specific implementation"
extends Modelica.Icons.Package;

package ExternalReferences

  function loadResource
    "Return the absolute path name of a URI or local file name (in this default implementation URIs are not supported, but only local file names)"
    input String uri;
    output String fileReference;
  external "builtin" fileReference=Dymola_ResolveURI(uri);
  annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = <b>loadResource</b>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<b>loadResource</b>(uri)</code>\" returns the
<b>absolute path name</b> of the file that is either defined by an URI or by a local
(e.g. relative) path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific, and this implementation is for Dymola.
However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute and relative local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\data\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
  end loadResource;
end ExternalReferences;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;

package Types "Library of types with vendor specific choices"

  type SolverMethod = String
    "String defining the integration method to solve differential equations in a clocked discretized continuous-time partition"
    annotation (choices(
      choice="External" "Solver specified externally",
      choice="ExplicitEuler" "Explicit Euler method (order 1)",
      choice="ExplicitMidPoint2" "Explicit mid point rule (order 2)",
      choice="ExplicitRungeKutta4" "Explicit Runge-Kutta method (order 4)",
      choice="ImplicitEuler" "Implicit Euler method (order 1)",
      choice="ImplicitTrapezoid" "Implicit trapezoid rule (order 2)"),
      Documentation(info="<html>
<p>
Type <b>SolverMethod</b> is a String type with menu choices to select the
integration method to solve differential equations in a clocked discretized
continuous-time partition. The choices are tool dependent.
For details, see chapter 16.8.2 \"Solver Method\" in the Modelica Language
Specification (version &ge; 3.3).
</p>
</html>"));
end Types;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="4.0.0",
  Dymola2(checkSum="3933384872:3320196239"),
  versionBuild=0,
  versionDate="2020-01-15",
  dateModified = "2020-01-15 08:44:41Z",
  uses(Modelica(version="4.0.0")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2",
    noneFromVersion="3.2.1",
 noneFromVersion="3.2.3"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Animation.Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Animation.Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Vector\">Animation.Vector</a>
     provides a 3-dim. visualization of a vector objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Vector\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Vector</a>
     via inheritance.</li>
	 
<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">ExternalReferences.loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.System.exit\">System.exit</a> provides a function to terminate the execution of the Modelica environment. It is used in <a href=\"modelica://Modelica.Utilities.System.exit\">Modelica.Utilities.System.exit</a> via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This is the Dymola implementation.
</p>

<p>
Original version
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 2009-2020, Modelica Association and contributors.
</p>
<p>
<strong>Modifications licensed by Dassault Syst&egrave;mes, copyright &copy; 2009-2020.</strong>
</p>

</html>"));
end ModelicaServices;

package Modelica "Modelica Standard Library - Version 4.0.0"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package Continuous
    "Library of continuous control blocks with internal states"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      block Integrator "Output the integral of the input signal with optional reset"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Integrator gain";
        parameter Boolean use_reset = false "= true, if reset port enabled"
          annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
        parameter Boolean use_set = false "= true, if set port enabled and used as reinitialization value when reset"
          annotation(Dialog(enable=use_reset), Evaluate=true, HideResult=true, choices(checkBox=true));

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Init initType=Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        extends Interfaces.SISO(y(start=y_start));
        Modelica.Blocks.Interfaces.BooleanInput reset if use_reset "Optional connector of reset signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=90,
            origin={60,-120})));
        Modelica.Blocks.Interfaces.RealInput set if use_reset and use_set "Optional connector of set signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={60,120})));
    protected
        Modelica.Blocks.Interfaces.BooleanOutput local_reset annotation(HideResult=true);
        Modelica.Blocks.Interfaces.RealOutput local_set annotation(HideResult=true);

      initial equation
        if initType == Init.SteadyState then
           der(y) = 0;
        elseif initType == Init.InitialState or
               initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        if use_reset then
          connect(reset, local_reset);
          if use_set then
            connect(set, local_set);
          else
            local_set = y_start;
          end if;
          when local_reset then
            reinit(y, local_set);
          end when;
        else
          local_reset = false;
          local_set = 0;
        end if;
        der(y) = k*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>integral</em> of the input <strong>u</strong> multiplied with
the gain <em>k</em>:
</p>
<blockquote><pre>
    k
y = - u
    s
</pre></blockquote>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

<p>
If the <em>reset</em> port is enabled, then the output <strong>y</strong> is reset to <em>set</em>
or to <em>y_start</em> (if the <em>set</em> port is not enabled), whenever the <em>reset</em>
port has a rising edge.
</p>
</html>"),     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Line(
                  points={{-80.0,78.0},{-80.0,-90.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                Line(
                  points={{-90.0,-80.0},{82.0,-80.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                Text(
                  textColor={192,192,192},
                  extent={{0.0,-70.0},{60.0,-10.0}},
                  textString="I"),
                Text(
                  extent={{-150.0,-150.0},{150.0,-110.0}},
                  textString="k=%k"),
                Line(
                  points=DynamicSelect({{-80.0,-80.0},{80.0,80.0}}, if use_reset then {{-80.0,-80.0},{60.0,60.0},{60.0,-80.0},{80.0,-60.0}} else {{-80.0,-80.0},{80.0,80.0}}),
                  color={0,0,127}),
                Line(
                  visible=use_reset,
                  points={{60,-100},{60,-80}},
                  color={255,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  visible=use_reset,
                  extent={{-28,-62},{94,-86}},
                  textString="reset")}));
      end Integrator;

      block FirstOrder "First order transfer function block (= 1 pole)"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gain";
        parameter SI.Time T(start=1) "Time Constant";
        parameter Init initType=Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3/4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));

        extends Interfaces.SISO(y(start=y_start));

      initial equation
        if initType == Init.SteadyState then
          der(y) = 0;
        elseif initType == Init.InitialState or initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        der(y) = (k*u - y)/T;
        annotation (
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the input u
and the output y as <em>first order</em> system:
</p>
<blockquote><pre>
          k
y = ------------ * u
       T * s + 1
</pre></blockquote>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <strong>TransferFunction</strong> instead
and model a first order SISO system with parameters<br>
b = {k}, a = {T, 1}.
</p>
<blockquote><pre>
Example:
   parameter: k = 0.3, T = 0.4
   results in:
             0.3
      y = ----------- * u
          0.4 s + 1.0
</pre></blockquote>

</html>"),     Icon(
        coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
          graphics={
        Line(points={{-80.0,78.0},{-80.0,-90.0}},
          color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
        Line(points={{-90.0,-80.0},{82.0,-80.0}},
          color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
        Line(origin = {-26.667,6.667},
            points = {{106.667,43.333},{-13.333,29.333},{-53.333,-86.667}},
            color = {0,0,127},
            smooth = Smooth.Bezier),
        Text(textColor={192,192,192},
          extent={{0.0,-60.0},{60.0,0.0}},
          textString="PT1"),
        Text(extent={{-150.0,-150.0},{150.0,-110.0}},
          textString="T=%T")}));
      end FirstOrder;

      block SecondOrder "Second order transfer function block (= 2 poles)"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gain";
        parameter Real w(start=1) "Angular frequency";
        parameter Real D(start=1) "Damping";
        parameter Init initType=Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3/4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        parameter Real yd_start=0
          "Initial or guess value of derivative of output (= state)"
          annotation (Dialog(group="Initialization"));

        extends Interfaces.SISO(y(start=y_start));
        output Real yd(start=yd_start) "Derivative of y";

      initial equation
        if initType == Init.SteadyState then
          der(y) = 0;
          der(yd) = 0;
        elseif initType == Init.InitialState or initType == Init.InitialOutput then
          y = y_start;
          yd = yd_start;
        end if;
      equation
        der(y) = yd;
        der(yd) = w*(w*(k*u - y) - 2*D*yd);
        annotation (
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the input u and
the output y as <em>second order</em> system:
</p>
<blockquote><pre>
                    k
y = --------------------------------- * u
     ( s / w )^2 + 2*D*( s / w ) + 1
</pre></blockquote>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general model class <strong>TransferFunction</strong>
instead and model a second order SISO system with parameters<br>
b = {k}, a = {1/w^2, 2*D/w, 1}.
</p>
<blockquote><pre>
Example:

   parameter: k =  0.3,  w = 0.5,  D = 0.4
   results in:
                  0.3
      y = ------------------- * u
          4.0 s^2 + 1.6 s + 1
</pre></blockquote>

</html>"),     Icon(
            coordinateSystem(preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
            Line(points={{-80.0,78.0},{-80.0,-90.0}},
                color={192,192,192}),
          Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
          Line(points={{-90.0,-80.0},{82.0,-80.0}},
              color={192,192,192}),
          Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
          Line(origin = {-1.939,-1.816},
              points = {{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color = {0,0,127},
              smooth = Smooth.Bezier),
          Text(textColor={192,192,192},
              extent={{0.0,-70.0},{60.0,-10.0}},
              textString="PT2"),
          Text(extent={{-150.0,-150.0},{150.0,-110.0}},
              textString="w=%w")}));
      end SecondOrder;

      block TransferFunction "Linear transfer function"
        import Modelica.Blocks.Types.Init;
        extends Interfaces.SISO;

        parameter Real b[:]={1}
          "Numerator coefficients of transfer function (e.g., 2*s+3 is specified as {2,3})";
        parameter Real a[:]={1}
          "Denominator coefficients of transfer function (e.g., 5*s+6 is specified as {5,6})";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                           annotation(Evaluate=true, Dialog(group=
                "Initialization"));
        parameter Real x_start[size(a, 1) - 1]=zeros(nx)
          "Initial or guess values of states"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0
          "Initial value of output (derivatives of y are zero up to nx-1-th derivative)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));
        output Real x[size(a, 1) - 1](start=x_start)
          "State of transfer function from controller canonical form";
    protected
        parameter Integer na=size(a, 1) "Size of Denominator of transfer function.";
        parameter Integer nb=size(b, 1) "Size of Numerator of transfer function.";
        parameter Integer nx=size(a, 1) - 1;
        parameter Real bb[:] = vector([zeros(max(0,na-nb),1);b]);
        parameter Real d = bb[1]/a[1];
        parameter Real a_end = if a[end] > 100*Modelica.Constants.eps*sqrt(a*a) then a[end] else 1.0;
        Real x_scaled[size(x,1)] "Scaled vector x";

      initial equation
        if initType == Init.SteadyState then
          der(x_scaled) = zeros(nx);
        elseif initType == Init.InitialState then
          x_scaled = x_start*a_end;
        elseif initType == Init.InitialOutput then
          y = y_start;
          der(x_scaled[2:nx]) = zeros(nx-1);
        end if;
      equation
        assert(size(b,1) <= size(a,1), "Transfer function is not proper");
        if nx == 0 then
           y = d*u;
        else
           der(x_scaled[1])    = (-a[2:na]*x_scaled + a_end*u)/a[1];
           der(x_scaled[2:nx]) = x_scaled[1:nx-1];
           y = ((bb[2:na] - d*a[2:na])*x_scaled)/a_end + d*u;
           x = x_scaled/a_end;
        end if;
        annotation (
          Documentation(info="<html>
<p>
This block defines the transfer function between the input
u and the output y
as (nb = dimension of b, na = dimension of a):
</p>
<blockquote><pre>
        b[1]*s^[nb-1] + b[2]*s^[nb-2] + ... + b[nb]
y(s) = --------------------------------------------- * u(s)
        a[1]*s^[na-1] + a[2]*s^[na-2] + ... + a[na]
</pre></blockquote>
<p>
State variables <strong>x</strong> are defined according to <strong>controller canonical</strong>
form. Internally, vector <strong>x</strong> is scaled to improve the numerics (the states in versions before version 3.0 of the Modelica Standard Library have been not scaled). This scaling is
not visible from the outside of this block because the non-scaled vector <strong>x</strong>
is provided as output signal and the start value is with respect to the non-scaled
vector <strong>x</strong>.
Initial values of the states <strong>x</strong> can be set via parameter <strong>x_start</strong>.
</p>

<p>
Example:
</p>
<blockquote><pre>
TransferFunction g(b = {2,4}, a = {1,3});
</pre></blockquote>
<p>
results in the following transfer function:
</p>
<blockquote><pre>
     2*s + 4
y = --------- * u
      s + 3
</pre></blockquote>
</html>"),Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
              Line(points={{-80.0,0.0},{80.0,0.0}},
                color={0,0,127}),
            Text(textColor={0,0,127},
              extent={{-90.0,10.0},{90.0,90.0}},
              textString="b(s)"),
            Text(textColor={0,0,127},
              extent={{-90.0,-90.0},{90.0,-10.0}},
              textString="a(s)")}));
      end TransferFunction;

      block Der "Derivative of input (= analytic differentiations)"
          extends Interfaces.SISO;

      equation
        y = der(u);
          annotation (defaultComponentName="der1",
       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
              graphics={Text(
                extent={{-96,28},{94,-24}},
                textString="der()",
                textColor={0,0,127})}),
              Documentation(info="<html>
<p>
Defines that the output y is the <em>derivative</em>
of the input u. Note, that Modelica.Blocks.Continuous.Derivative
computes the derivative in an approximate sense, where as this block computes
the derivative exactly. This requires that the input u is differentiated
by the Modelica translator, if this derivative is not yet present in
the model.
</p>
</html>"));
      end Der;
      annotation (
        Documentation(info="<html>
<p>
This package contains basic <strong>continuous</strong> input/output blocks
described by differential equations.
</p>

<p>
All blocks of this package can be initialized in different
ways controlled by parameter <strong>initType</strong>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>Name</strong></td>
      <td><strong>Description</strong></td></tr>

  <tr><td><strong>Init.NoInit</strong></td>
      <td>no initialization (start values are used as guess values with fixed=false)</td></tr>

  <tr><td><strong>Init.SteadyState</strong></td>
      <td>steady state initialization (derivatives of states are zero)</td></tr>

  <tr><td><strong>Init.InitialState</strong></td>
      <td>Initialization with initial states</td></tr>

  <tr><td><strong>Init.InitialOutput</strong></td>
      <td>Initialization with initial outputs (and steady state of the states if possible)</td></tr>
</table>

<p>
For backward compatibility reasons the default of all blocks is
<strong>Init.NoInit</strong>, with the exception of Integrator and LimIntegrator
where the default is <strong>Init.InitialState</strong> (this was the initialization
defined in version 2.2 of the Modelica standard library).
</p>

<p>
In many cases, the most useful initial condition is
<strong>Init.SteadyState</strong> because initial transients are then no longer
present. The drawback is that in combination with a non-linear
plant, non-linear algebraic equations occur that might be
difficult to solve if appropriate guess values for the
iteration variables are not provided (i.e., start values with fixed=false).
However, it is often already useful to just initialize
the linear blocks from the Continuous blocks library in SteadyState.
This is uncritical, because only linear algebraic equations occur.
If Init.NoInit is set, then the start values for the states are
interpreted as <strong>guess</strong> values and are propagated to the
states with fixed=<strong>false</strong>.
</p>

<p>
Note, initialization with Init.SteadyState is usually difficult
for a block that contains an integrator
(Integrator, LimIntegrator, PI, PID, LimPID).
This is due to the basic equation of an integrator:
</p>

<blockquote><pre>
<strong>initial equation</strong>
   <strong>der</strong>(y) = 0;   // Init.SteadyState
<strong>equation</strong>
   <strong>der</strong>(y) = k*u;
</pre></blockquote>

<p>
The steady state equation leads to the condition that the input to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <strong>singular</strong>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is always defined by
Init.InitialState or Init.SteadyState initialization.
</p>

<p>
In such a case, <strong>Init.NoInit</strong> has to be selected for the integrator
and an additional initial equation has to be added to the system
to which the integrator is connected. E.g., useful initial conditions
for a 1-dim. rotational inertia controlled by a PI controller are that
<strong>angle</strong>, <strong>speed</strong>, and <strong>acceleration</strong> of the inertia are zero.
</p>

</html>"),     Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      extends Modelica.Icons.InterfacesPackage;

      connector RealInput = input Real "'input Real' as connector" annotation (
        defaultComponentName="u",
        Icon(graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})},
          coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
          Text(
            textColor={0,0,127},
            extent={{-10.0,60.0},{-10.0,85.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

      connector RealOutput = output Real "'output Real' as connector" annotation (
        defaultComponentName="y",
        Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})}),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
          Text(
            textColor={0,0,127},
            extent={{30.0,60.0},{30.0,110.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

      connector BooleanInput = input Boolean "'input Boolean' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              textColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

      connector BooleanOutput = output Boolean "'output Boolean' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              textColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

      connector IntegerOutput = output Integer "'output Integer' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              textColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>"));

      partial block SO "Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

      end SO;

      partial block SISO "Single Input Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
      end SISO;

      partial block SI2SO
        "2 Single Input / 1 Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u1 "Connector of Real input signal 1" annotation (Placement(
              transformation(extent={{-140,40},{-100,80}})));
        RealInput u2 "Connector of Real input signal 2" annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"));

      end SI2SO;

      partial block SignalSource "Base class for continuous signal source"
        extends SO;
        parameter Real offset=0 "Offset of output signal y";
        parameter SI.Time startTime=0 "Output y = offset for time < startTime";
        annotation (Documentation(info="<html>
<p>
Basic block for Real sources of package Blocks.Sources.
This component has one continuous Real output signal y
and two parameters (offset, startTime) to shift the
generated signal.
</p>
</html>"));
      end SignalSource;

      partial block BooleanSISO
        "Single Input Single Output control block with signals of type Boolean"

        extends Modelica.Blocks.Icons.BooleanBlock;

    public
        BooleanInput u "Connector of Boolean input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        BooleanOutput y "Connector of Boolean output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has one continuous Boolean input and one continuous Boolean output signal.
</p>
</html>"));
      end BooleanSISO;

      partial block partialBooleanSource
        "Partial source block (has 1 output Boolean signal and an appropriate default icon)"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;

        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,88},{-88,66},{-72,66},{-80,88}},
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,66},{-80,-82}}, color={255,0,255}),
              Line(points={{-90,-70},{72,-70}}, color={255,0,255}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y then {0,255,0} else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y then {0,255,0} else {235,235,235}),
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
Basic block for Boolean sources of package Blocks.Sources.
This component has one continuous Boolean output signal y
and a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSource;
      annotation (Documentation(info="<html>
<p>
This package contains interface definitions for
<strong>continuous</strong> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</html>",     revisions="<html>
<ul>
<li><em>June 28, 2019</em>
       by Thomas Beutlich:<br>
       Removed obsolete blocks.</li>
<li><em>Oct. 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Added several new interfaces.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Interfaces;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      block Gain "Output the product of a gain value with the input signal"

        parameter Real k(start=1, unit="1")
          "Gain value multiplied with input signal";
    public
        Interfaces.RealInput u "Input signal connector" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Output signal connector" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

      equation
        y = k*u;
        annotation (
          Documentation(info="<html>
<p>
This block computes output <em>y</em> as
<em>product</em> of gain <em>k</em> with the
input <em>u</em>:
</p>
<blockquote><pre>
y = k * u;
</pre></blockquote>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                textColor={0,0,255})}));
      end Gain;

      block Feedback "Output difference between commanded and feedback input"

        Interfaces.RealInput u1 "Commanded input" annotation (Placement(transformation(extent={{-100,
                  -20},{-60,20}})));
        Interfaces.RealInput u2 "Feedback input" annotation (Placement(transformation(
              origin={0,-80},
              extent={{-20,-20},{20,20}},
              rotation=90)));
        Interfaces.RealOutput y annotation (Placement(transformation(extent={{80,-10},
                  {100,10}})));

      equation
        y = u1 - u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>difference</em> of the
commanded input <strong>u1</strong> and the feedback
input <strong>u2</strong>:
</p>
<blockquote><pre>
<strong>y</strong> = <strong>u1</strong> - <strong>u2</strong>;
</pre></blockquote>
<p>
Example:
</p>
<blockquote><pre>
   parameter:   n = 2

results in the following equations:

   y = u1 - u2
</pre></blockquote>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                lineColor={0,0,127},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                extent={{-20,-20},{20,20}}),
              Line(points={{-60,0},{-20,0}}, color={0,0,127}),
              Line(points={{20,0},{80,0}}, color={0,0,127}),
              Line(points={{0,-20},{0,-60}}, color={0,0,127}),
              Text(extent={{-14,-94},{82,0}}, textString="-"),
              Text(
                textColor={0,0,255},
                extent={{-150,40},{150,80}},
                textString="%name")}));
      end Feedback;

      block Add3 "Output the sum of the three inputs"
        extends Modelica.Blocks.Icons.Block;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";
        parameter Real k3=+1 "Gain of input signal 3";
        Interfaces.RealInput u1 "Connector of Real input signal 1" annotation (
            Placement(transformation(extent={{-140,60},{-100,100}})));
        Interfaces.RealInput u2 "Connector of Real input signal 2" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealInput u3 "Connector of Real input signal 3" annotation (
            Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = k1*u1 + k2*u2 + k3*u3;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
three input signals <strong>u1</strong>, <strong>u2</strong> and <strong>u3</strong>:
</p>
<blockquote><pre>
<strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong> + k3*<strong>u3</strong>;
</pre></blockquote>
<p>
Example:
</p>
<blockquote><pre>
   parameter:   k1= +2, k2= -3, k3=1;

results in the following equations:

   y = 2 * u1 - 3 * u2 + u3;
</pre></blockquote>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-100,50},{5,90}},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                textString="%k3"),
              Text(
                extent={{10,40},{90,-40}},
                textString="+")}));
      end Add3;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>,
such as summation and multiplication, and basic <strong>mathematical
functions</strong>, such as <strong>sqrt</strong> and <strong>sin</strong>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added WrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><em>August 7, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"),     Icon(graphics={Line(
              points={{-80,-2},{-68.7,32.2},{-61.5,51.1},{-55.1,64.4},{-49.4,72.6},
                  {-43.8,77.1},{-38.2,77.8},{-32.6,74.6},{-26.9,67.7},{-21.3,57.4},
                  {-14.9,42.1},{-6.83,19.2},{10.1,-32.8},{17.3,-52.2},{23.7,-66.2},
                  {29.3,-75.1},{35,-80.4},{40.6,-82},{46.2,-79.6},{51.9,-73.5},{
                  57.5,-63.9},{63.9,-49.2},{72,-26.8},{80,-2}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Math;

    package Nonlinear
    "Library of discontinuous or non-differentiable algebraic control blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

          block Limiter "Limit the range of a signal"
            parameter Real uMax(start=1) "Upper limits of input signals";
            parameter Real uMin= -uMax "Lower limits of input signals";
            parameter Boolean strict=false "= true, if strict limits with noEvent(..)"
              annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));
            parameter Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization"
              annotation (Evaluate=true, Dialog(group="Initialization"));
            extends Interfaces.SISO;
    protected
            Real simplifiedExpr "Simplified expression for homotopy-based initialization";

          equation
            assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) +
                                 ") < uMin (=" + String(uMin) + ")");
            simplifiedExpr = (if homotopyType == Types.LimiterHomotopy.Linear then u
                              else if homotopyType == Types.LimiterHomotopy.UpperLimit then uMax
                              else if homotopyType == Types.LimiterHomotopy.LowerLimit then uMin
                              else 0);
            if strict then
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u));
              else
                y = homotopy(actual = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u)),
                             simplified=simplifiedExpr);
              end if;
            else
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u);
              else
                y = homotopy(actual = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u),
                             simplified=simplifiedExpr);
              end if;
            end if;
            annotation (
              Documentation(info="<html>
<p>
The Limiter block passes its input signal as output signal
as long as the input is within the specified upper and lower
limits. If this is not the case, the corresponding limits are passed
as output.
</p>
<p>
The parameter <code>homotopyType</code> in the Advanced tab specifies the
simplified behaviour if homotopy-based initialization is used:
</p>
<ul>
<li><code>NoHomotopy</code>: the actual expression with limits is used</li>
<li><code>Linear</code>: a linear behaviour y = u is assumed (default option)</li>
<li><code>UpperLimit</code>: it is assumed that the output is stuck at the upper limit u = uMax</li>
<li><code>LowerLimit</code>: it is assumed that the output is stuck at the lower limit u = uMin</li>
</ul>
<p>
If it is known a priori in which region the input signal will be located, this option can help
a lot by removing one strong nonlinearity from the initialization problem.
</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,-90},{0,68}}, color={192,192,192}),
              Polygon(
                points={{0,90},{-8,68},{8,68},{0,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,-8},{68,8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="uMax=%uMax"),
              Line(
                visible=strict,
                points={{50,70},{80,70}},
                color={255,0,0}),
              Line(
                visible=strict,
                points={{-80,-70},{-50,-70}},
                color={255,0,0})}));
          end Limiter;
          annotation (
            Documentation(info="<html>
<p>
This package contains <strong>discontinuous</strong> and
<strong>non-differentiable, algebraic</strong> input/output blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by Christian Schweiger:<br>
       New block VariableLimiter added.</li>
<li><em>August 22, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.
</li>
</ul>
</html>"),     Icon(graphics={Line(points={{-80,-66},{-26,-66},{28,52},{88,52}},
                color={95,95,95})}));
    end Nonlinear;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      model BooleanPassThrough "Pass a Boolean signal through without modification"
        extends Modelica.Blocks.Interfaces.BooleanSISO;
      equation
        y = u;
        annotation (Documentation(info="<html>
<p>Passes a Boolean signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.</p>
</html>"),Icon(
            coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={255,0,255})}));
      end BooleanPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),     Icon(graphics={
            Line(points={{-90,0},{4,0}}, color={95,95,95}),
            Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
            Line(points={{-8,0},{93,0}}, color={95,95,95}),
            Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real, Integer and Boolean signals"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                textColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block Constant "Generate constant signal of type Real"
        parameter Real k(start=1) "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png"));
        extends Interfaces.SO;

      equation
        y = k;
        annotation (
          defaultComponentName="const",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\"
     alt=\"Constant.png\">
</p>
</html>"));
      end Constant;

      block Step "Generate step signal of type Real"
        parameter Real height=1 "Height of step"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Step.png"));
        extends Interfaces.SignalSource;

      equation
        y = offset + (if time < startTime then 0 else height);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{0,-70},{0,50},{80,50}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="startTime=%startTime")}),
          Documentation(info="<html>
<p>
The Real output y is a step signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Step.png\"
     alt=\"Step.png\">
</p>

</html>"));
      end Step;

      block Ramp "Generate ramp signal"
        parameter Real height=1 "Height of ramps"
          annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Ramp.png"));
        parameter SI.Time duration(min=0.0, start=2)
          "Duration of ramp (= 0.0 gives a Step)";
        extends Interfaces.SignalSource;

      equation
        y = offset + (if time < startTime then 0 else if time < (startTime +
          duration) then (time - startTime)*height/duration else height);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-40,-70},{31,38}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="duration=%duration"),
              Line(points={{31,38},{86,38}})}),
          Documentation(info="<html>
<p>
The Real output y is a ramp signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Ramp.png\"
     alt=\"Ramp.png\">
</p>

<p>
If parameter duration is set to 0.0, the limiting case of a Step signal is achieved.
</p>
</html>"));
      end Ramp;

      block Sine "Generate sine signal"
        import Modelica.Constants.pi;
        parameter Real amplitude=1 "Amplitude of sine wave"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Sine.png"));
        parameter SI.Frequency f(start=1) "Frequency of sine wave";
        parameter SI.Angle phase=0 "Phase of sine wave";
        extends Interfaces.SignalSource;
      equation
        y = offset + (if time < startTime then 0 else amplitude*Modelica.Math.sin(2
          *pi*f*(time - startTime) + phase));
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,8},{68,-8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,
                    74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,
                    59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,
                    -64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},
                    {57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, smooth = Smooth.Bezier),
              Text(
                extent={{-147,-152},{153,-112}},
                textString="f=%f")}),
          Documentation(info="<html>
<p>
The Real output y is a sine signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Sine.png\"
     alt=\"Sine.png\">
</p>
</html>"));
      end Sine;

      block Cosine "Generate cosine signal"
        import Modelica.Constants.pi;
        parameter Real amplitude=1 "Amplitude of cosine wave"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Cosine.png"));
        parameter SI.Frequency f(start=1) "Frequency of cosine wave";
        parameter SI.Angle phase=0 "Phase of cosine wave";
        extends Interfaces.SignalSource;
      equation
        y = offset + (if time < startTime then 0 else amplitude*Modelica.Math.cos(2
          *pi*f*(time - startTime) + phase));
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,8},{68,-8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,80},{-76.2,79.8},{-70.6,76.6},{-64.9,69.7},{-59.3,
                    59.4},{-52.9,44.1},{-44.83,21.2},{-27.9,-30.8},{-20.7,-50.2},{-14.3,
                    -64.2},{-8.7,-73.1},{-3,-78.4},{2.6,-80},{8.2,-77.6},{13.9,-71.5},
                    {19.5,-61.9},{25.9,-47.2},{34,-24.8},{42,0}}, smooth=Smooth.Bezier),
              Text(
                extent={{-147,-152},{153,-112}},
                textString="f=%f"),
              Line(points={{42,1},{53.3,35.2},{60.5,54.1},{66.9,67.4},{72.6,75.6},{
                    78.2,80.1},{83.8,80.8}})}),
          Documentation(info="<html>
<p>
The Real output y is a cosine signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Cosine.png\"
     alt=\"Cosine.png\">
</p>
</html>"));
      end Cosine;

      block ExpSine "Generate exponentially damped sine signal"
        import Modelica.Constants.pi;
        parameter Real amplitude=1 "Amplitude of sine wave"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/ExpSine.png"));
        parameter SI.Frequency f(start=2) "Frequency of sine wave";
        parameter SI.Angle phase=0 "Phase of sine wave";
        parameter SI.Damping damping(start=1)
          "Damping coefficient of sine wave";
        extends Interfaces.SignalSource;
      equation
        y = offset + (if time < startTime then 0 else amplitude*Modelica.Math.exp(-
          (time - startTime)*damping)*Modelica.Math.sin(2*pi*f*(time -
          startTime) + phase));
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,8},{68,-8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{-75.2,32.3},{-72,50.3},{-68.7,64.5},{-65.5,74.2},
                    {-62.3,79.3},{-59.1,79.6},{-55.9,75.3},{-52.7,67.1},{-48.6,52.2},
                    {-43,25.8},{-35,-13.9},{-30.2,-33.7},{-26.1,-45.9},{-22.1,-53.2},
                    {-18.1,-55.3},{-14.1,-52.5},{-10.1,-45.3},{-5.23,-32.1},{8.44,
                    13.7},{13.3,26.4},{18.1,34.8},{22.1,38},{26.9,37.2},{31.8,31.8},
                    {38.2,19.4},{51.1,-10.5},{57.5,-21.2},{63.1,-25.9},{68.7,-25.9},
                    {75.2,-20.5},{80,-13.8}}, smooth = Smooth.Bezier),
              Text(
                extent={{-147,-152},{153,-112}},
                textString="f=%f")}),
          Documentation(info="<html>
<p>
The Real output y is a sine signal with exponentially changing amplitude:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/ExpSine.png\"
     alt=\"ExpSine.png\">
</p>
</html>"));
      end ExpSine;

      block BooleanConstant "Generate constant signal of type Boolean"
        parameter Boolean k=true "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/BooleanConstant.png"));
        extends Interfaces.partialBooleanSource;

      equation
        y = k;
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Line(points={{-80,0},{80,0}}),
                Text(
                extent={{-150,-140},{150,-110}},
                textString="%k")}),
            Documentation(info="<html>
<p>
The Boolean output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/BooleanConstant.png\"
     alt=\"BooleanConstant.png\">
</p>
</html>"));
      end BooleanConstant;

      block BooleanStep "Generate step signal of type Boolean"
        parameter SI.Time startTime=0 "Time instant of step start"
         annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/BooleanStep.png"));
        parameter Boolean startValue=false "Output before startTime";

        extends Interfaces.partialBooleanSource;
      equation
        y = if time >= startTime then not startValue else startValue;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Line(
                visible=not startValue,
                points={{-80,-70},{0,-70},{0,50},{80,50}}),
              Line(
                visible=startValue,
                points={{-80,50},{0,50},{0,-70},{68,-70}}),
              Text(
                extent={{-150,-140},{150,-110}},
                textString="%startTime")}),
          Documentation(info="<html>
<p>
The Boolean output y is a step signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/BooleanStep.png\"
     alt=\"BooleanStep.png\">
</p>
</html>"));
      end BooleanStep;

      block BooleanPulse "Generate pulse signal of type Boolean"

        parameter Real width(
          final min=Modelica.Constants.small,
          final max=100) = 50 "Width of pulse in % of period"
          annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/BooleanPulse.png"));
        parameter SI.Time period(final min=Modelica.Constants.small,
            start=1) "Time for one period";
        parameter SI.Time startTime=0 "Time instant of first pulse";
        extends Modelica.Blocks.Interfaces.partialBooleanSource;

    protected
        parameter SI.Time Twidth=period*width/100
          "Width of one pulse" annotation (HideResult=true);
        discrete SI.Time pulseStart "Start time of pulse"
          annotation (HideResult=true);
      initial equation
        pulseStart = startTime;
      equation
        when sample(startTime, period) then
          pulseStart = time;
        end when;
        y = time >= pulseStart and time < pulseStart + Twidth;
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Text(
                extent={{-150,-140},{150,-110}},
                textString="%period"), Line(points={{-80,-70},{-40,-70},{-40,44},{0,
                    44},{0,-70},{40,-70},{40,44},{79,44}})}),
            Documentation(info="<html>
<p>
The Boolean output y is a pulse signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Pulse.png\"
     alt=\"Pulse.png\">
</p>
</html>"));
      end BooleanPulse;
      annotation (Documentation(info="<html>
<p>
This package contains <strong>source</strong> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>offset</strong></td>
      <td>Value which is added to the signal</td>
  </tr>
  <tr><td><strong>startTime</strong></td>
      <td>Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <strong>offset</strong> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><em>Nov. 8, 1999</em>
       by <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><em>Oct. 31, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><em>June 29, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Types
    "Library of constants, external objects and types with choices, especially to build menus"
      extends Modelica.Icons.TypesPackage;

        type Init = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)")
        "Enumeration defining initialization of a block" annotation (Evaluate=true,
        Documentation(info="<html>
  <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
  </dl>
</html>"));

      type LimiterHomotopy = enumeration(
        NoHomotopy   "Homotopy is not used",
        Linear   "Simplified model without limits",
        UpperLimit   "Simplified model fixed at upper limit",
        LowerLimit   "Simplified model fixed at lower limit")
        "Enumeration defining use of homotopy in limiter components" annotation (Evaluate=true);
      annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong>, <strong>constants</strong> and <strong>external objects</strong> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
    end Types;

    package Icons "Icons for Blocks"
        extends Modelica.Icons.IconsPackage;

        partial block Block "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end Block;

        partial block BooleanBlock "Basic graphical layout of Boolean block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations).
</p>
</html>"));

        end BooleanBlock;

        partial block DiscreteBlock
        "Graphical layout of discrete block component icon"

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}),
                               Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
discrete block (no declarations, no equations), e.g.,
from Blocks.Discrete.
</p>
</html>"));
        end DiscreteBlock;

      partial block PartialBooleanBlock "Basic graphical layout of logical block"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                textColor={0,0,255})}), Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations) used especially
in the Blocks.Logical library.
</p>
</html>"));
      end PartialBooleanBlock;
    end Icons;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a><br></dd>
</dl>
<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 23, 2004</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapted all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New subpackage Examples, additional components.
       </li>
<li><em>June 20, 2000</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<blockquote><pre>
replaceable type SignalType = Real
</pre></blockquote>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<blockquote><pre>
Sine sin1(outPort(redeclare type SignalType=Modelica.Units.SI.Torque))
</pre></blockquote>
      </li>
<li><em>Sept. 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package Clocked "Clock triggered blocks for describing synchronous behavior suited for implementation of control
systems"
  extends Modelica.Icons.Package;

    package ClockSignals "Library of blocks for clocked signals"
      extends Modelica.Icons.Package;
      import Modelica.Units.SI;

      package Clocks "Library of blocks that generate clocks"
        extends Modelica.Icons.SourcesPackage;

        block PeriodicRealClock
          "Generate a periodic clock signal with a period defined by a Real number"
          parameter SI.Time period
            "Period of clock (defined as Real number)" annotation(Evaluate=true);
          extends Clocked.ClockSignals.Interfaces.PartialPeriodicClock;
        equation
          if useSolver then
             y = Clock(Clock(period), solverMethod=solverMethod);
          else
             y = Clock(period);
          end if;

          annotation (
             defaultComponentName="periodicClock1",
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}, initialScale=0.06),
                            graphics={
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=45,
                  origin={-50,-120},
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=90,
                  origin={52,60},
                  pattern=LinePattern.None,
                  fillColor={95,95,95}),
                Text(
                  extent={{-150,-110},{150,-150}},
                  textColor={0,0,0},
                  textString="%period"),
                Text(
                  visible=useSolver,
                  extent={{-150,-160},{150,-200}},
                  textColor={0,0,0},
                  textString="%solverMethod")}),
            Documentation(info="<html>
<p>
This component generates a periodic clock that starts ticking when
the simulation starts. The <strong>period</strong> is defined in seconds
by a <strong>Real</strong> number. If clocks are synchronized relatively to each other
then only one of the clocks can be defined with PeriodicRealClock.
</p>

<p>
For an introduction to clocks see
<a href=\"modelica://Modelica.Clocked.UsersGuide.Clocks\">UsersGuide.Clocks</a>.
If exact, integer based, time synchronization with absolute period definitions is
desired, use block
<a href=\"modelica://Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock\">PeriodicExactClock</a>
to generate a periodic clock signal.
</p>

<p>
If a clock is associated to a clocked continuous-time partition, then an <strong>integrator</strong>
has to be defined that is used to integrate the partition from the previous
to the current clock tick. This is performed by setting parameter <strong>useSolver</strong>
= <strong>true</strong> and defining the integration method as String with
parameter <strong>solver</strong>. Both parameters are in tab <strong>Advanced</strong>.
For an example, see
<a href=\"modelica://Modelica.Clocked.Examples.Systems.ControlledMixingUnit\">Examples.Systems.ControlledMixingUnit</a>.
</p>
</html>"));
        end PeriodicRealClock;
      annotation (Documentation(info="<html>
<p>
This package contains blocks that generate clock signals. For an introduction
to clocks see
<a href=\"modelica://Modelica.Clocked.UsersGuide.Clocks\">UsersGuide.Clocks</a>.
</p>
</html>"));
      end Clocks;

      package Interfaces
      "Library of connectors and partial blocks with clock signals"
        extends Modelica.Icons.InterfacesPackage;

        connector ClockInput = input Clock "'input Clock' as connector"
          annotation (defaultComponentName="u",
               Icon(graphics={Polygon(
                  points={{-34,6},{20,0},{-34,-8},{-34,6}},
                  lineColor={175,175,175},
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dot,
                  lineThickness=0.5),
                              Polygon(
                  points={{-100,100},{100,0},{-100,-100},{-100,100}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)},
                    coordinateSystem(extent={{-100,-100},{100,100}},
                preserveAspectRatio=true, initialScale=0.2)),    Diagram(coordinateSystem(
                preserveAspectRatio=true, initialScale=0.2,
                extent={{-100,-100},{100,100}}),
                graphics={Polygon(
                  points={{0,50},{100,0},{0,-50},{0,50}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-10,85},{-10,60}},
                  textColor={0,0,255},
                  textString="%name",
                fillPattern=FillPattern.Solid,
                fillColor={128,0,255})}),
            Documentation(info="<html>
<p>
Connector with one input signal of type Clock.
</p>
</html>"));

        connector ClockOutput = output Clock "'output Clock' as connector"
                                          annotation (defaultComponentName="y",
          Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={Polygon(
                  points={{-10,6},{10,0},{-10,-6},{-10,6}},
                  lineColor={175,175,175},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5,
                  pattern=LinePattern.Dot),
                                       Polygon(
                  points={{-100,99},{100,-1},{-100,-101},{-100,99}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={Polygon(
                  points={{-100,50},{0,0},{-100,-50},{-100,50}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{30,110},{30,60}},
                  textColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Connector with one output signal of type Clock.
</p>
</html>"));

        partial block PartialClock
          "Icon, connector, and solver method of a block that generates a clock"
          parameter Boolean useSolver = false
            "= true, if solverMethod shall be explicitly defined"
            annotation(Evaluate=true, Dialog(tab="Advanced"), choices(checkBox=true));
          parameter ModelicaServices.Types.SolverMethod solverMethod="ExplicitEuler"
            "Integration method used for discretized continuous-time partitions" annotation(Dialog(tab="Advanced",enable=useSolver));
          Clocked.ClockSignals.Interfaces.ClockOutput y
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                    100,100}}),
                            graphics={
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={95,95,95}),
                Ellipse(
                  extent={{9,-10},{-11,10}},
                  lineColor={95,95,95},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-1,0},{52,50}},  color={95,95,95}),
                Rectangle(
                  extent={{80,6},{100,-6}},
                  fillPattern=FillPattern.Solid,
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{-100,6},{-80,-6}},
                  fillPattern=FillPattern.Solid,
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=90,
                  origin={52,-120},
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=45,
                  origin={80,6},
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=135,
                  origin={-6,80},
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Rectangle(
                  extent={{20,58},{40,46}},
                  fillPattern=FillPattern.Solid,
                  rotation=135,
                  origin={122,-48},
                  lineColor={95,95,95},
                  fillColor={95,95,95}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  textColor={0,0,255})}),
            Documentation(info="<html>

</html>"));
        end PartialClock;

        partial block PartialPeriodicClock
          "Icon, connector, and solver method of a block that generates a periodic clock"
          extends Clocked.ClockSignals.Interfaces.PartialClock;

        end PartialPeriodicClock;
        annotation (Documentation(info="<html>
<p>
This package contains clock connectors, as well as partial blocks that are used to
construct clock blocks.
</p>
</html>"));
      end Interfaces;
      annotation (Documentation(info="<html>
<p>
This package contains blocks that transform a clock signal, by
sub-, super-, and shift-sampling a clock. For an introduction
to clocks see
<a href=\"modelica://Modelica.Clocked.UsersGuide.Clocks\">UsersGuide.Clocks</a>.
</p>
</html>"));
    end ClockSignals;

    package RealSignals "Library of clocked blocks for Real signals"
      extends Modelica.Icons.Package;
      import Modelica.Units.SI;

      package Sampler "Library of sampler and hold blocks for Real signals"
        extends Modelica.Icons.Package;

        block SampleClocked
          "Sample the continuous-time, Real input signal and provide it as clocked output signal. The clock is provided as input signal"
          extends Clocked.RealSignals.Interfaces.SamplerIcon;
          Modelica.Blocks.Interfaces.RealInput u
            "Connector of continuous-time, Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput y
            "Connector of clocked, Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Clocked.ClockSignals.Interfaces.ClockInput clock
            "Output signal y is associated with this clock input" annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));

        equation
          y = sample(u,clock);

          annotation (
           defaultComponentName="sample1",
           Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.06),
                             graphics={
                Line(
                  points={{0,-100},{0,18}},
                  color={175,175,175},
                  pattern=LinePattern.Dot,
                  thickness=0.5),
            Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                textColor={0,0,255})}),
            Documentation(info="<html>
<p>
This block is similar to the
<a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.Sample\">Sample</a>
block. The only difference is that a clock signal is provided via a second
input and the output is associated to this clock.
</p>

<p>
Note, it does not make much sense to vectorize this block, because then
also the clock input is vectorized. Instead, if the input signal is a vector, use block
<a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SampleVectorizedAndClocked\">SampleVectorizedAndClocked</a>
that has a <strong>vector</strong> Real input and output, as well as a <strong>scalar</strong> clock input.
</p>

<h4>Example</h4>

<p>
The following
<a href=\"modelica://Modelica.Clocked.Examples.Elementary.RealSignals.SampleClocked\">example</a>
samples a sine signal with a periodic clock of 20 ms period:<br>
</p>

<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td width=\"50\"></td>
    <td valign=\"bottom\"><img src=\"modelica://Modelica/Resources/Images/Clocked/RealSignals/SampleClocked_Model.png\" alt=\"SampleClocked_Model.png\"></td>
    <td valign=\"bottom\">&nbsp;&nbsp;&nbsp;
                        <img src=\"modelica://Modelica/Resources/Images/Clocked/RealSignals/SampleClocked_Result.png\" alt=\"SampleClocked_Result.png\"></td>
    </tr>
<tr><td></td>
    <td align=\"center\">model</td>
    <td align=\"center\">simulation result<br></td>
   </tr>
</table>
</html>"));
        end SampleClocked;

        block Hold
          "Hold the clocked, Real input signal and provide it as continuous-time output signal (zero order hold)"
        extends Clocked.RealSignals.Interfaces.PartialSISOHold;

        equation
            y = hold(u);

          annotation (
            defaultComponentName="hold1",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.06),
                             graphics={
                Ellipse(
                  extent={{-70,-30},{-50,-50}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-30,28},{-10,8}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,70},{30,50}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{50,10},{70,-10}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This block holds the clocked Real input signal u with a zero order hold
and provides it as continuous-time output signal y.
The clock of the input signal is inferred
(that is, it needs to be defined somewhere else in the clocked partition).
</p>

<p>
To be more precise: The input signal u(ti) must be a clocked signal.
The output signal y(t) is a piecewise constant continuous-time signal.
When the clock of u ticks at time ti, the block output y(ti) = u(ti). Otherwise y(t), t &ge;ti, is the value of
u(ti) from the last clock activation at time ti. Before the first clock activation of u,
the block outputs the value of parameter <strong>y_start</strong>. The value of
this parameter is displayed below the icon.
</p>

<h4>Example</h4>

<p>
The following
<a href=\"modelica://Modelica.Clocked.Examples.Elementary.RealSignals.Hold\">example</a>
samples a sine signal with a periodic clock of 20 ms period and delays it for 2 sample periods.
The resulting signal is hold with the Hold block. As a result, the clock of hold.u starts
ticking at 40 ms. The output hold.y of the block is a continuous-time signal that is present
from the start of the simulation. Before the first tick of the clock of hold.u, it is set
to -1.0 (= the value of parameter hold.y_start).<br>
</p>

<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td width=\"50\"></td>
    <td valign=\"bottom\"><img src=\"modelica://Modelica/Resources/Images/Clocked/RealSignals/Hold_Model.png\" alt=\"Hold_Model.png\"></td>
    <td valign=\"bottom\">&nbsp;&nbsp;&nbsp;
                        <img src=\"modelica://Modelica/Resources/Images/Clocked/RealSignals/Hold_Result.png\" alt=\"Hold_Result.png\"></td>
    </tr>
<tr><td></td>
    <td align=\"center\">model</td>
    <td align=\"center\">simulation result</td>
   </tr>
</table>
&nbsp;
</html>"));
        end Hold;
        annotation (Documentation(info="<html>
<p>
This package contains blocks that mark boundaries of a clocked partition
and transform a <strong>Real</strong> signal from one partition to the next. Especially,
the following blocks are provided:<br>&nbsp;
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">
<tr><th align=\"left\"><strong>Boundary Type</strong></th>
    <th align=\"left\"><strong>Block Name</strong></th>
    <th align=\"left\"><strong>Description</strong></th></tr>

<tr><td valign=\"top\" rowspan=\"4\">continuous-time &rarr; clocked</td>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.Sample\">Sample</a></td>
      <td>Sample a continuous-time signal.</td>
    </tr>
    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SampleClocked\">SampleClocked</a></td>
      <td>Sample and associate a clock to the sampled <strong>scalar</strong> signal.</td>
    </tr>
    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SampleVectorizedAndClocked\">SampleVectorizedAndClocked</a></td>
      <td>Sample an input vector and associate a clock to the sampled <strong>vector</strong> signal.</td>
    </tr>
    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SampleWithADeffects\">SampleWithADeffects</a></td>
      <td>Sample with (simulated) Analog-Digital converter effects including noise.</td>
    </tr>

<tr><td valign=\"top\" rowspan=\"2\">clocked &rarr; continuous-time</td>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.Hold\">Hold</a></td>
      <td>Hold a clocked signal with zero-order hold.</td>
    </tr>
    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.HoldWithDAeffects\">HoldWithDAeffects</a></td>
      <td>Hold with (simulated) Digital-Analog converter effects and computational delay.</td>
    </tr>

<tr><td valign=\"top\" rowspan=\"5\">clocked &rarr; clocked</td>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SubSample\">SubSample</a></td>
      <td>Sub-sample a signal (output clock is slower as input clock).</td>
    </tr>

    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SuperSample\">SuperSample</a></td>
      <td>Super-sample a signal (output clock is faster as input clock).</td>
    </tr>

    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.SuperSampleInterpolated\">SuperSampleInterpolated</a></td>
      <td>Super-sample a signal with linear interpolation (output clock is faster as input clock).</td>
    </tr>

    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.ShiftSample\">ShiftSample</a></td>
      <td>Shift a signal (output clock is delayed with respect to input clock).</td>
    </tr>

    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.BackSample\">BackSample</a></td>
      <td>Shift a signal and start the output clock before the input clock with a start value.</td>
    </tr>

<tr><td valign=\"top\" rowspan=\"2\">within clocked partition</td>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.AssignClock\">AssignClock</a></td>
      <td>Assign a clock to a clocked <strong>scalar</strong> signal.</td>
    </tr>
    <tr>
      <td><a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.AssignClockVectorized\">AssignClockVectorized</a></td>
      <td>Assign a clock to a clocked <strong>vector</strong> signal.</td>
    </tr>
</table>

<p>
Additionally, package
<a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.Utilities\">Utilities</a>
contains utility blocks that are used as building blocks for user-relevant blocks.
Especially, block
<a href=\"modelica://Modelica.Clocked.RealSignals.Sampler.Utilities.UpSample\">UpSample</a>
can be used in combination with a
<a href=\"modelica://Modelica.Clocked.RealSignals.Periodic.FIRbyCoefficients\">FIR filter</a>
block to model super-sampling with interpolation and filtering.
</p>
</html>"));
      end Sampler;

      package Interfaces
      "Library of partial blocks for components with clocked Real signals"
        extends Modelica.Icons.InterfacesPackage;

        partial block SamplerIcon
          "Basic graphical layout of block used for sampling of Real signals"

          annotation (
            Icon(
              coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.06),
              graphics={
                Line(points={{-100,0},{-45,0}}, color={0,0,127}),
                Line(points={{-35,0},{30,35}}, color={0,0,127}),
                Ellipse(
                  extent={{45,-10},{25,10}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{45,0},{100,0}}, color={0,0,127}),
                Ellipse(
                  extent={{-25,-10},{-45,10}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end SamplerIcon;

        partial block PartialSISOHold
          "Basic block used for zero order hold of Real signals"

          parameter Real y_start = 0.0
            "Value of output y before the first tick of the clock associated to input u";

          Modelica.Blocks.Interfaces.RealInput u(final start=y_start)
            "Connector of clocked, Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput y
            "Connector of continuous-time, Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (
            defaultComponentName="hold1",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                initialScale=0.06),
                             graphics={Line(points={{-60,-40},{-20,-40},{-20,20},{20,20},
                      {20,60},{60,60},{60,0},{100,0},{100,0},{100,0},{100,0},{120,0}},
                                         color={0,0,127}), Line(
                  points={{-60,-40},{-60,0},{-100,0}},
                  color={0,0,127}),
                Text(
                  extent={{-150,130},{150,90}},
                  textString="%name",
                  textColor={0,0,255}),
                Text(
                  extent={{-150,-100},{150,-140}},
                  textString="%y_start",
                  textColor={0,0,0})}),
            Documentation(info="<html>

</html>"));
        end PartialSISOHold;
        annotation (Documentation(info="<html>
<p>
This package contains partial blocks that are used to
construct blocks operating on clocked Real signals.
</p>
</html>"));
      end Interfaces;
      annotation (Documentation(info="<html>
<p>
This package contains blocks that operate on clocked Real signals.
Especially blocks are provided to transform from continuous-time Real signals to
clocked Real signals (with Sampler blocks) and vice versa
(with Hold blocks), as well as to transform a clocked Real signal from
one clock to a different clock in a time-synchronized way.
</p>
</html>"));
    end RealSignals;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Library <strong>Modelica.Clocked</strong> is a Modelica package
to precisely define and synchronize sampled data systems with different sampling rates.
The library has elements to define periodic clocks and event clocks that trigger elements to sample, sub-sample, super-sample, or shift-sample partitions synchronously. Optionally, quantization effects, computational delay or noise can be simulated. Continuous-time equations can be automatically discretized and utilized in a sampled data system. The sample rate of
a partition need to be defined only at one location.
</p>

<p>
In the following
<a href=\"modelica://Modelica.Clocked.Examples.SimpleControlledDrive.ClockedWithDiscreteController\">example</a>
a simple sampled data system is shown, where the borders of the
discrete-time partition are marked by the sample and hold operators, a clocked PI
controller is used in the partition and the sample
rate is defined at one location with a clock:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Clocked/SimpleSampledSystem.png\" alt=\"Simple sampled-data system\">
</p>
<p>
The initial version of this library was developed and released under the name <strong>Modelica_Synchronous</strong> library
before the library became a package of the Modelica Standard Library using the name <strong>Modelica.Clocked</strong>.
The basic principles and components are the same as in the initial library, therefore the introductory material
for <strong>Modelica_Synchronous</strong> is still valid, in particular:
</p>
<ul>
<li> <a href=\"modelica://Modelica/Resources/Documentation/Clocked/Modelica_Synchronous.pdf\">Modelica_Synchronous.pdf</a>
     is a slide set that provides an overview of the Library.</li>
<li><a href=\"https://www.doi.org/10.3384/ecp1207627\">A Library for Synchronous Control Systems in Modelica</a> is the corresponding paper.</li>
</ul>
<p>
Furthermore:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Clocked.UsersGuide\">User's Guide</a>
     discusses the most important aspects of this library.</li>
<li><a href=\"modelica://Modelica.Clocked.UsersGuide.ReleaseNotes\">Release Notes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Clocked.UsersGuide.Contact\">Contact</a>
     gives author and acknowledgement information for this library.</li>
</ul>
<p>
<em>Copyright &copy; 2012-2020, Modelica Association and contributors.</em>
</p>
</html>",
  revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> Aug. 28, 2012 </td>
    <td>
    <table border=\"0\">
    <tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\" alt=\"DLR logo\">
    </td><td valign=\"bottom\">
    Initial version implemented by M. Otter and B. Thiele released as <em>Modelica_Synchronous</em> (version 0.9) library.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
    </td></tr>
    </table>
</td></tr>

<tr><td></td><td>Several releases as <em>Modelica_Synchronous</em> library.</td></tr>

<tr><td> 2019 </td><td>The <em>Modelica_Synchronous</em> library is included as <em>Modelica.Clocked</em> in the Modelica Standard Library 4.0.0.</td></tr>

<tr><td></td><td>see <a href=\"modelica://Modelica.Clocked.UsersGuide.ReleaseNotes\">Release Notes</a>.</td></tr>

</table>
</html>"),
      Icon(
        coordinateSystem(
          extent = {{-100, -100}, {100, 100}},
          preserveAspectRatio = true),
        graphics={
          Ellipse(extent = {{-80, -80}, {80, 80}}),
          Line(points = {{80, 0}, {60, 0}}),
          Line(points = {{69.282, 40}, {51.962, 30}}),
          Line(points = {{40, 69.282}, {30, 51.962}}),
          Line(points = {{0, 80}, {0, 60}}),
          Line(points = {{-40, 69.282}, {-30, 51.962}}),
          Line(points = {{-69.282, 40}, {-51.962, 30}}),
          Line(points = {{-80, 0}, {-60, 0}}),
          Line(points = {{-69.282, -40}, {-51.962, -30}}),
          Line(points = {{-40, -69.282}, {-30, -51.962}}),
          Line(points = {{0, -80}, {0, -60}}),
          Line(points = {{40, -69.282}, {30, -51.962}}),
          Line(points = {{69.282, -40}, {51.962, -30}}),
          Line(points = {{80, 0}, {60, 0}}),
          Line(points = {{0, 0}, {-50, 50}}),
          Line(points = {{0, 0}, {40, 0}})}));
  end Clocked;

  package Electrical
  "Library of electrical models (analog, digital, machines, polyphase)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package Analog "Library for analog electrical models"
      extends Modelica.Icons.Package;

      package Interfaces
      "Connectors and partial models for Analog electrical components"
        extends Modelica.Icons.InterfacesPackage;

        connector PositivePin "Positive pin of an electrical component"
          SI.ElectricPotential v "Potential at the pin" annotation (
              unassignedMessage="An electrical potential cannot be uniquely calculated.
The reason could be that
- a ground object is missing (Modelica.Electrical.Analog.Basic.Ground)
  to define the zero potential of the electrical circuit, or
- a connector of an electrical component is not connected.");
          flow SI.Current i "Current flowing into the pin" annotation (
              unassignedMessage="An electrical current cannot be uniquely calculated.
The reason could be that
- a ground object is missing (Modelica.Electrical.Analog.Basic.Ground)
  to define the zero potential of the electrical circuit, or
- a connector of an electrical component is not connected.");
          annotation (defaultComponentName="pin_p",
            Documentation(info="<html>
<p>Connectors PositivePin and NegativePin are nearly identical. The only difference is that the icons are different in order to identify more easily the pins of a component. Usually, connector PositivePin is used for the positive and connector NegativePin for the negative pin of an electrical component.</p>
</html>",                     revisions="<html>
<ul>
<li><em> 1998   </em>
       by Christoph Clauss<br> initially implemented<br>
       </li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-40,40},{40,-40}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-160,110},{40,50}},
                  textColor={0,0,255},
                  textString="%name")}));
        end PositivePin;

        connector NegativePin "Negative pin of an electrical component"
          SI.ElectricPotential v "Potential at the pin" annotation (
              unassignedMessage="An electrical potential cannot be uniquely calculated.
The reason could be that
- a ground object is missing (Modelica.Electrical.Analog.Basic.Ground)
  to define the zero potential of the electrical circuit, or
- a connector of an electrical component is not connected.");
          flow SI.Current i "Current flowing into the pin" annotation (
              unassignedMessage="An electrical current cannot be uniquely calculated.
The reason could be that
- a ground object is missing (Modelica.Electrical.Analog.Basic.Ground)
  to define the zero potential of the electrical circuit, or
- a connector of an electrical component is not connected.");
          annotation (defaultComponentName="pin_n",
            Documentation(info="<html>
<p>Connectors PositivePin and NegativePin are nearly identical. The only difference is that the icons are different in order to identify more easily the pins of a component. Usually, connector PositivePin is used for the positive and connector NegativePin for the negative pin of an electrical component.</p>
</html>",       revisions="<html>
<dl>
<dt><em>1998</em></dt>
<dd>by Christoph Clauss initially implemented
</dd>
</dl>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-40,40},{40,-40}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-40,110},{160,50}},
                  textString="%name",
                  textColor={0,0,255})}));
        end NegativePin;

        partial model TwoPin "Component with two electrical pins"
          SI.Voltage v "Voltage drop of the two pins (= p.v - n.v)";

          PositivePin p "Positive electrical pin"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          NegativePin n "Negative electrical pin"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        equation
          v = p.v - n.v;
          annotation (
            Documentation(revisions = "<html>
<ul>
<li><em> 1998   </em>
       by Christoph Clauss<br> initially implemented<br>
       </li>
</ul>
</html>",       info = "<html>
<p>TwoPin is a partial model with two pins and one internal variable for the voltage over the two pins. Internal currents are not defined. It is intended to be used in cases where the model which inherits TwoPin is composed by combining other components graphically, not by equations.</p>
</html>"));
        end TwoPin;

        partial model OnePort
          "Component with two electrical pins p and n and current i from p to n"
          extends TwoPin;
          SI.Current i "Current flowing from pin p to pin n";
        equation
          0 = p.i + n.i;
          i = p.i;
          annotation (
            Documentation(info="<html>
<p>Superclass of elements which have <strong>two</strong> electrical pins: the positive pin connector <em>p</em>, and the negative pin connector <em>n</em>. It is assumed that the current flowing into pin p is identical to the current flowing out of pin n. This current is provided explicitly as current i.</p>
</html>",revisions="<html>
<ul>
<li><em> 1998   </em>
       by Christoph Clauss<br> initially implemented<br>
       </li>
</ul>
</html>"));
        end OnePort;
        annotation (Documentation(info="<html>
<p>This package contains connectors and interfaces (partial models) for analog electrical components. The partial models contain typical combinations of pins, and internal variables which are often used. Furthermore, the thermal heat port is in this package which can be included by inheritance.</p>
</html>",revisions="<html>
<dl>
<dt>
<strong>Main Authors:</strong>
</dt>
<dd>
Christoph Clau&szlig;
    &lt;<a href=\"mailto:christoph@clauss-it.com\">christoph@clauss-it.com</a>&gt;<br>
    Andr&eacute; Schneider
    &lt;<a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>&gt;<br>
    Fraunhofer Institute for Integrated Circuits<br>
    Design Automation Department<br>
    Zeunerstra&szlig;e 38<br>
    D-01069 Dresden
</dd>
</dl>

<ul>
<li><em> 1998</em>
       by Christoph Clauss<br> initially implemented<br>
       </li>
</ul>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"));
      end Interfaces;
      annotation (Documentation(info="<html>
<p>
This package contains packages for single-phase electrical components, see
<a href=\"modelica://Modelica.Electrical.Analog.UsersGuide\">User&#39;s Guide</a></p>
</html>"),     Icon(graphics={
            Line(
              points={{12,60},{12,-60}}),
            Line(
              points={{-12,60},{-12,-60}}),
            Line(points={{-80,0},{-12,0}}),
            Line(points={{12,0},{80,0}})}));
    end Analog;
    annotation (
    Documentation(info="<html>
<p>
This library contains electrical components to build up analog and digital circuits,
as well as machines to model electrical motors and generators,
especially three-phase induction machines such as an asynchronous motor.
</p>

</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Rectangle(
        origin={20.3125,82.8571},
        extent={{-45.3125,-57.8571},{4.6875,-27.8571}}),
      Line(
        origin={8.0,48.0},
        points={{32.0,-58.0},{72.0,-58.0}}),
      Line(
        origin={9.0,54.0},
        points={{31.0,-49.0},{71.0,-49.0}}),
      Line(
        origin={-2.0,55.0},
        points={{-83.0,-50.0},{-33.0,-50.0}}),
      Line(
        origin={-3.0,45.0},
        points={{-72.0,-55.0},{-42.0,-55.0}}),
      Line(
        origin={1.0,50.0},
        points={{-61.0,-45.0},{-61.0,-10.0},{-26.0,-10.0}}),
      Line(
        origin={7.0,50.0},
        points={{18.0,-10.0},{53.0,-10.0},{53.0,-45.0}}),
      Line(
        origin={6.2593,48.0},
        points={{53.7407,-58.0},{53.7407,-93.0},{-66.2593,-93.0},{-66.2593,-58.0}})}));
  end Electrical;

  package Mechanics
  "Library of 1-dim. and 3-dim. mechanical components (multi-body, rotational, translational)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package MultiBody "Library to model 3-dimensional mechanical systems"
      extends Modelica.Icons.Package;
      import Cv = Modelica.Units.Conversions;
      import C = Modelica.Constants;

      package Frames "Functions to transform rotational frame quantities"
        extends Modelica.Icons.Package;

        package TransformationMatrices "Functions for transformation matrices"
          extends Modelica.Icons.FunctionsPackage;

          type Orientation
            "Orientation type defining rotation from a frame 1 into a frame 2 with a transformation matrix"

            extends Internal.TransformationMatrix;

            encapsulated function equalityConstraint
              "Return the constraint residues to express that two frames have the same orientation"

              import Modelica;
              import Modelica.Mechanics.MultiBody.Frames.TransformationMatrices;
              extends Modelica.Icons.Function;
              input TransformationMatrices.Orientation T1
                "Orientation object to rotate frame 0 into frame 1";
              input TransformationMatrices.Orientation T2
                "Orientation object to rotate frame 0 into frame 2";
              output Real residue[3]
                "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
            algorithm
              residue := {
                cross(T1[1, :], T1[2, :]) * T2[2, :],
                -cross(T1[1, :], T1[2, :]) * T2[1, :],
                T1[2, :]*T2[1, :]};
              annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
residue = Orientation.<strong>equalityConstraint</strong>(T1, T2);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the Real residue vector with&nbsp;3 elements.
This vector has zero elements if transformation matrices T1 and T2 are identical,
i.e. they describe the same orientation. The residue vector is determined by computing the relative
transformation matrix between T1 and T2 and using the outer-diagonal elements of this matrix to
formulate the residue in such a way that only identical orientation objects lead to a zero residue vector.
</p>
</html>"));
            end equalityConstraint;
            annotation (Documentation(info="<html>
<p>
This type describes the <strong>rotation</strong> from a <strong>frame 1</strong> into a <strong>frame 2</strong>.
An instance <strong>R</strong> of type <strong>Orientation</strong> has the following interpretation:
</p>
<blockquote><pre>
<strong>T</strong> = [<strong>e</strong><sub>x</sub>, <strong>e</strong><sub>y</sub>, <strong>e</strong><sub>z</sub>];
    e.g., <strong>T</strong> = [1,0,0; 0,1,0; 0,0,1]
</pre></blockquote>
<p>
where <strong>e</strong><sub>x</sub>,<strong>e</strong><sub>y</sub>,<strong>e</strong><sub>z</sub>
are unit vectors in the direction of the x-axis, y-axis, and z-axis
of frame 1, resolved in frame 2, respectively. Therefore, if <strong>v</strong><sub>1</sub>
is vector <strong>v</strong> resolved in frame 1 and <strong>v</strong><sub>2</sub> is
vector <strong>v</strong> resolved in frame 2, the following relationship holds:
</p>
<blockquote><pre>
<strong>v</strong><sub>2</sub> = <strong>T</strong> * <strong>v</strong><sub>1</sub>
</pre></blockquote>
<p>
The <strong>inverse</strong> orientation
<strong>T_inv</strong> = <strong>T</strong><sup>T</sup> describes the rotation
from frame 2 into frame 1.
</p>
<p>
Since the orientation is described by 9 variables, there are
6 constraints between these variables. These constraints
are defined in function <strong>TransformationMatrices.orientationConstraint</strong>.
</p>
<p>
Note, that in the MultiBody library the rotation object is
never directly accessed but only with the access functions provided
in package TransformationMatrices. As a consequence, other implementations of
Rotation can be defined by adapting this package correspondingly.
</p>
</html>"));
          end Orientation;

          function planarRotation "Return orientation object of a planar rotation"
            import Modelica.Math;
            extends Modelica.Icons.Function;
            input Real e[3](each final unit="1")
              "Normalized axis of rotation (must have length=1)";
            input SI.Angle angle
              "Rotation angle to rotate frame 1 into frame 2 along axis e";
            output TransformationMatrices.Orientation T
              "Orientation object to rotate frame 1 into frame 2";
          algorithm
            T := outerProduct(e,e) + (identity(3) - outerProduct(e,e))*Math.cos(
              angle) - skew(e)*Math.sin(angle);
            annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
T = TransformationMatrices.<strong>planarRotation</strong>(e, angle);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation\">transformation matrix</a>&nbsp;T
that describes the orientation to rotate in the plane along unit
axis <strong>e</strong> from frame 1 into frame 2 with angle <strong>angle</strong>.
Note, \"e\" must be a unit vector. However, this is not checked in this function and the function will
return a wrong result, if length(e) is not one.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotationAngle\">planarRotationAngle</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.planarRotation\">Frames.planarRotation</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation\">Quaternions.planarRotation</a>.
</p>
</html>"));
          end planarRotation;

          function planarRotationAngle
            "Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2"

            extends Modelica.Icons.Function;
            input Real e[3](each final unit="1")
              "Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)";
            input Real v1[3]
              "A vector v resolved in frame 1 (shall not be parallel to e)";
            input Real v2[3]
              "Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)";
            output SI.Angle angle
              "Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi";
          algorithm
            /* Vector v is resolved in frame 1 and frame 2 according to:
        (1)  v2 = (e*transpose(e) + (identity(3) - e*transpose(e))*cos(angle) - skew(e)*sin(angle))*v1;
                = e*(e*v1) + (v1 - e*(e*v1))*cos(angle) - cross(e,v1)*sin(angle)
       Equation (1) is multiplied with "v1" resulting in (note: e*e = 1)
            v1*v2 = (e*v1)*(e*v2) + (v1*v1 - (e*v1)*(e*v1))*cos(angle)
       and therefore:
        (2) cos(angle) = ( v1*v2 - (e*v1)*(e*v2)) / (v1*v1 - (e*v1)*(e*v1))
       Similarly, equation (1) is multiplied with cross(e,v1), i.e., a
       a vector that is orthogonal to e and to v1:
              cross(e,v1)*v2 = - cross(e,v1)*cross(e,v1)*sin(angle)
       and therefore:
          (3) sin(angle) = -cross(e,v1)*v2/(cross(e,v1)*cross(e,v1));
       We have e*e=1; Therefore:
          (4) v1*v1 - (e*v1)*(e*v1) = |v1|^2 - (|v1|*cos(e,v1))^2
       and
          (5) cross(e,v1)*cross(e,v1) = (|v1|*sin(e,v1))^2
                                      = |v1|^2*(1 - cos(e,v1)^2)
                                      = |v1|^2 - (|v1|*cos(e,v1))^2
       The denominators of (2) and (3) are identical, according to (4) and (5).
       Furthermore, the denominators are always positive according to (5).
       Therefore, in the equation "angle = atan2(sin(angle), cos(angle))" the
       denominators of sin(angle) and cos(angle) can be removed,
       resulting in:
          angle = atan2(-cross(e,v1)*v2, v1*v2 - (e*v1)*(e*v2));
    */
            angle := Modelica.Math.atan2(-cross(e, v1)*v2, v1*v2 - (e*v1)*(e*v2));
            annotation (Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
angle = TransformationMatrices.<strong>planarRotationAngle</strong>(e, v1, v2);
</pre></blockquote>

<h4>Description</h4>
<p>
A call to this function of the form
</p>
<blockquote><pre>
  Real[3]                e, v1, v2;
  SI.Angle angle;
<strong>equation</strong>
  angle = <strong>planarRotationAngle</strong>(e, v1, v2);
</pre></blockquote>
<p>
computes the rotation angle \"<strong>angle</strong>\" of a planar
rotation along unit vector <strong>e</strong>, rotating frame 1 into frame 2, given
the coordinate representations of a vector \"v\" in frame 1 (<strong>v1</strong>)
and in frame 2 (<strong>v2</strong>). Therefore, the result of this function
fulfills the following equation:
</p>
<blockquote><pre>
v2 = <strong>resolve2</strong>(<strong>planarRotation</strong>(e,angle), v1)
</pre></blockquote>
<p>
The rotation angle is returned in the range
</p>
<blockquote><pre>
-&pi; &lt;= angle &lt;= &pi;
</pre></blockquote>
<p>
This function makes the following assumptions on the input arguments
</p>
<ul>
<li> Vector <strong>e</strong> has length 1, i.e., length(e) = 1</li>
<li> Vector \"v\" is not parallel to <strong>e</strong>, i.e.,
     length(cross(e,v1)) &ne; 0</li>
</ul>
<p>
The function does not check the above assumptions. If these
assumptions are violated, a wrong result will be returned
and/or a division by zero will occur.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation\">planarRotation</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.planarRotationAngle\">Frames.planarRotationAngle</a>.
</p>
</html>"));
          end planarRotationAngle;
          annotation (Documentation(info="<html>
<p>
Package <strong>Frames.TransformationMatrices</strong> contains type definitions and
functions to transform rotational frame quantities using
transformation matrices.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<blockquote><pre>
Orientation T, T1, T2, T_rel, T_inv;
Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
Real[6]     res_equal;
Real        L, angle;
</pre></blockquote>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><strong>Orientation T;</strong></td>
      <td>New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td><strong>der_Orientation</strong> der_T;</td>
      <td>New type defining the first time derivative
         of Frames.Orientation.
      </td>
  </tr>
  <tr><td>res_ori = <strong>orientationConstraint</strong>(T);</td>
      <td>Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td>w1 = <strong>angularVelocity1</strong>(T, der_T);</td>
      <td>Return angular velocity resolved in frame 1 from
          orientation object T<br> and its derivative der_T.
     </td>
  </tr>
  <tr><td>w2 = <strong>angularVelocity2</strong>(T, der_T);</td>
      <td>Return angular velocity resolved in frame 2 from
          orientation object T<br> and its derivative der_T.
     </td>
  </tr>
  <tr><td>v1 = <strong>resolve1</strong>(T,v2);</td>
      <td>Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>v2 = <strong>resolve2</strong>(T,v1);</td>
      <td>Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>[v1,w1] = <strong>multipleResolve1</strong>(T, [v2,w2]);</td>
      <td>Transform several vectors from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>[v2,w2] = <strong>multipleResolve2</strong>(T, [v1,w1]);</td>
      <td>Transform several vectors from frame 1 to frame 2.
      </td>
  </tr>
  <tr><td>D1 = <strong>resolveDyade1</strong>(T,D2);</td>
      <td>Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>D2 = <strong>resolveDyade2</strong>(T,D1);</td>
      <td>Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>T= <strong>nullRotation</strong>()</td>
      <td>Return orientation object T that does not rotate a frame.
     </td>
  </tr>
  <tr><td>T_inv = <strong>inverseRotation</strong>(T);</td>
      <td>Return inverse orientation object.
      </td>
  </tr>
  <tr><td>T_rel = <strong>relativeRotation</strong>(T1,T2);</td>
      <td>Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td>T2 = <strong>absoluteRotation</strong>(T1,T_rel);</td>
      <td>Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td>T = <strong>planarRotation</strong>(e, angle);</td>
      <td>Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td>angle = <strong>planarRotationAngle</strong>(e, v1, v2);</td>
      <td>Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td>T = <strong>axisRotation</strong>(i, angle);</td>
      <td>Return orientation object T for rotation around axis i of frame 1.
      </td>
  </tr>
  <tr><td>T = <strong>axesRotations</strong>(sequence, angles);</td>
      <td>Return rotation object to rotate in sequence around 3 axes. Example:<br>
          T = axesRotations({1,2,3},{90,45,-90});
      </td>
  </tr>
  <tr><td>angles = <strong>axesRotationsAngles</strong>(T, sequence);</td>
      <td>Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td>phi = <strong>smallRotation</strong>(T);</td>
      <td>Return rotation angles phi valid for a small rotation.
      </td>
  </tr>
  <tr><td>T = <strong>from_nxy</strong>(n_x, n_y);</td>
      <td>Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td>T = <strong>from_nxz</strong>(n_x, n_z);</td>
      <td>Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_T</strong>(T);</td>
      <td>Return orientation object R from transformation matrix T.
      </td>
  </tr>
  <tr><td>R = <strong>from_T_inv</strong>(T_inv);</td>
      <td>Return orientation object R from inverse transformation matrix T_inv.
      </td>
  </tr>
  <tr><td>T = <strong>from_Q</strong>(Q);</td>
      <td>Return orientation object T from quaternion orientation object Q.
      </td>
  </tr>
  <tr><td>T = <strong>to_T</strong>(R);</td>
      <td>Return transformation matrix T from orientation object R.
      </td>
  </tr>
  <tr><td>T_inv = <strong>to_T_inv</strong>(R);</td>
      <td>Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td>Q = <strong>to_Q</strong>(T);</td>
      <td>Return quaternion orientation object Q from orientation object T.
      </td>
  </tr>
  <tr><td>exy = <strong>to_exy</strong>(T);</td>
      <td>Return [e_x, e_y] matrix of an orientation object T,<br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
      </td>
  </tr>
</table>
</html>"));
        end TransformationMatrices;

        package Internal
        "Internal definitions that may be removed or changed (do not use)"
          extends Modelica.Icons.InternalPackage;

          type TransformationMatrix = Real[3, 3];
          annotation (Documentation(info="<html>
<p>
Package with classes that are used within package Frames.
The classes in this package should not be directly used by a user.
</p>
</html>"));
        end Internal;
        annotation (Documentation(info="<html>
<p>
Package <strong>Frames</strong> contains type definitions and
functions to transform rotational frame quantities. The basic idea is to
hide the actual definition of an <strong>orientation</strong> in this package
by providing essentially type <strong>Orientation</strong> together with
<strong>functions</strong> operating on instances of this type.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<blockquote><pre>
Frames.Orientation R, R1, R2, R_rel, R_inv;
Real[3,3]   T, T_inv;
Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
Real[6]     res_equal;
Real        L, angle;
</pre></blockquote>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><strong>Orientation R;</strong></td>
      <td>New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td>res_ori = <strong>orientationConstraint</strong>(R);</td>
      <td>Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td>w1 = <strong>angularVelocity1</strong>(R);</td>
      <td>Return angular velocity resolved in frame 1 from
          orientation object R.
     </td>
  </tr>
  <tr><td>w2 = <strong>angularVelocity2</strong>(R);</td>
      <td>Return angular velocity resolved in frame 2 from
          orientation object R.
     </td>
  </tr>
  <tr><td>v1 = <strong>resolve1</strong>(R,v2);</td>
      <td>Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>v2 = <strong>resolve2</strong>(R,v1);</td>
      <td>Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>v2 = <strong>resolveRelative</strong>(v1,R1,R2);</td>
      <td>Transform vector v1 from frame 1 to frame 2
          using absolute orientation objects R1 of frame 1 and R2 of frame 2.
      </td>
  </tr>
  <tr><td>D1 = <strong>resolveDyade1</strong>(R,D2);</td>
      <td>Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>D2 = <strong>resolveDyade2</strong>(R,D1);</td>
      <td>Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>R = <strong>nullRotation</strong>()</td>
      <td>Return orientation object R that does not rotate a frame.
     </td>
  </tr>
  <tr><td>R_inv = <strong>inverseRotation</strong>(R);</td>
      <td>Return inverse orientation object.
      </td>
  </tr>
  <tr><td>R_rel = <strong>relativeRotation</strong>(R1,R2);</td>
      <td>Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td>R2 = <strong>absoluteRotation</strong>(R1,R_rel);</td>
      <td>Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td>R = <strong>planarRotation</strong>(e, angle, der_angle);</td>
      <td>Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td>angle = <strong>planarRotationAngle</strong>(e, v1, v2);</td>
      <td>Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td>R = <strong>axisRotation</strong>(axis, angle, der_angle);</td>
      <td>Return orientation object R to rotate around angle along axis of frame 1.
      </td>
  </tr>
  <tr><td>R = <strong>axesRotations</strong>(sequence, angles, der_angles);</td>
      <td>Return rotation object to rotate in sequence around 3 axes. Example:<br>
          R = axesRotations({1,2,3},{pi/2,pi/4,-pi}, zeros(3));
      </td>
  </tr>
  <tr><td>angles = <strong>axesRotationsAngles</strong>(R, sequence);</td>
      <td>Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td>phi = <strong>smallRotation</strong>(R);</td>
      <td>Return rotation angles phi valid for a small rotation R.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxy</strong>(n_x, n_y);</td>
      <td>Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxz</strong>(n_x, n_z);</td>
      <td>Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_T</strong>(T,w);</td>
      <td>Return orientation object R from transformation matrix T and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_T2</strong>(T,der(T));</td>
      <td>Return orientation object R from transformation matrix T and
          its derivative der(T).
      </td>
  </tr>
  <tr><td>R = <strong>from_T_inv</strong>(T_inv,w);</td>
      <td>Return orientation object R from inverse transformation matrix T_inv and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_Q</strong>(Q,w);</td>
      <td>Return orientation object R from quaternion orientation object Q
          and its angular velocity w.
      </td>
  </tr>
  <tr><td>T = <strong>to_T</strong>(R);</td>
      <td>Return transformation matrix T from orientation object R.
      </td>
  </tr>
  <tr><td>T_inv = <strong>to_T_inv</strong>(R);</td>
      <td>Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td>Q = <strong>to_Q</strong>(R);</td>
      <td>Return quaternion orientation object Q from orientation object R.
      </td>
  </tr>
  <tr><td>exy = <strong>to_exy</strong>(R);</td>
      <td>Return [e_x, e_y] matrix of an orientation object R,<br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
      </td>
  </tr>
  <tr><td>L = <strong>length</strong>(n_x);</td>
      <td>Return length L of a vector n_x.
      </td>
  </tr>
  <tr><td>e_x = <strong>normalize</strong>(n_x);</td>
      <td>Return normalized vector e_x of n_x such that length of e_x is one.
      </td>
  </tr>
  <tr><td>e = <strong>axis</strong>(i);</td>
      <td>Return unit vector e directed along axis i
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions\">Quaternions</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on quaternions (also called Euler parameters).
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices\">TransformationMatrices</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on transformation matrices.
      </td>
  </tr>
</table>
</html>"),       Icon(graphics={
              Line(points={{-2,-18},{80,-60}}, color={95,95,95}),
              Line(points={{-2,-18},{-2,80}}, color={95,95,95}),
              Line(points={{-78,-56},{-2,-18}}, color={95,95,95})}));
      end Frames;

      package Interfaces
      "Connectors and partial models for 3-dim. mechanical components"
        extends Modelica.Icons.InterfacesPackage;

        partial function partialColorMap
          "Interface for a function returning a color map"
          extends Modelica.Icons.Function;
          input Integer n_colors=64 "Number of colors in the color map";
          output Real colorMap[n_colors,3] "Color map to map a scalar to a color";
          annotation (Documentation(info="<html>
<p>
This partial function defines the interface of a function that returns
a color map. Predefined color map functions are defined in package
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps</a>.
</p>
</html>"));
        end partialColorMap;
        annotation (Documentation(info="<html>
<p>
This package contains connectors and partial models (i.e., models
that are only used to build other models) of the MultiBody library.
</p>
</html>"));
      end Interfaces;

      package Visualizers "3-dimensional visual objects used for animation"
        extends Modelica.Icons.Package;

        package Colors "Library of functions operating on color"
          extends Modelica.Icons.FunctionsPackage;

          package ColorMaps "Library of functions returning color maps"
            extends Modelica.Icons.FunctionsPackage;

            function jet "Returns the \"jet\" color map"
              extends Modelica.Mechanics.MultiBody.Interfaces.partialColorMap;
          protected
               Real    a=ceil(n_colors/4);
               Real    d=1/a;
               Integer b=integer(ceil(a/2));
               Integer c=integer(floor(a/2));
               Real    v1[:]={1-(b-i)*d for i in 1:b};
               Real    v2[:]=0+d:d:1;
               Real    v3[:]=1-d:-d:0;
               Real    v4[:]={0.5+(c-i)*d for i in 1:c};
               Real    cm[integer(ceil(n_colors/4))*4,3];
            algorithm
               cm:=255*[zeros(size(v1,1)),zeros(size(v1,1)),  v1;
                        zeros(size(v2,1)), v2,  fill(1., size(v2,1));
                        v2,              fill(1, size(v2,1)), v3;
                        fill(1, size(v3,1)),v3, fill(0.,size(v3,1));
                        v4, fill(0,size(v4,1)),fill(0.,size(v4,1))];
               colorMap:=cm[1:n_colors,:];

              annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
ColorMaps.<strong>jet</strong>();
ColorMaps.<strong>jet</strong>(n_colors=64);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the color map \"jet.\" A color map
is a Real[:,3] array where every row represents a color.
With the optional argument \"n_colors\" the number of rows
of the returned array can be defined. The default value is
\"n_colors=64\" (it is usually best if n_colors is a multiple of 4).
Image of the \"jet\" color map:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/ColorMaps/jet.png\">
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.scalarToColor\">scalarToColor</a>.
</html>"));
            end jet;
            annotation (Documentation(info="<html>
<p>
This package contains functions that return color maps.
A color map is a Real[:,3] array where every row represents a color.
Currently the following color maps are returned from the
respective function:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Colors/ColorMaps/ColorMaps.png\">
</blockquote>
</html>"));
          end ColorMaps;

          function scalarToColor "Map a scalar to a color using a color map"
            extends Modelica.Icons.Function;

            input Real T "Scalar value" annotation(Dialog);
            input Real T_min "T <= T_min is mapped to colorMap[1,:]" annotation(Dialog);
            input Real T_max "T >= T_max is mapped to colorMap[end,:]" annotation(Dialog);
            input Real colorMap[:,3] "Color map" annotation(Dialog);
            output Real color[3] "Color of scalar value T";
          algorithm
            /* old version, that could give an error
  color :=colorMap[integer((size(colorMap, 1) - 1)/(T_max - T_min)*
                            min((max(T,T_min) - T_min), T_max) + 1), :];
  */
            color := colorMap[1 + integer((size(colorMap,1)-1)*(max(T_min,min(T,T_max))-T_min)
                                        / (T_max-T_min)), :];
            annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
//Real T, T_min, T_max, colorMap[:,3];
Colors.<strong>scalarToColor</strong>(T, T_min, T_max, colorMap);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns an rgb color Real[3] that corresponds to the value of \"T\".
The color is selected from the colorMap by interpolation so that
\"T_min\" corresponds to \"colorMap[1,:]\" and
\"T_max\" corresponds to \"colorMap[end,:]\".
</p>

<h4>See also</h4>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.ColorMaps\">ColorMaps</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Colors.colorMapToSvg\">colorMapToSvg</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a>.

</html>"));
          end scalarToColor;
          annotation (Documentation(info="<html>
<p>
This package contains functions to operate on colors.
Note, a color is represented as a Real array with 3 elements where
the elements are the red, green, blue values of the RGB color model.
Every element must be in the range 0&nbsp;&hellip;&nbsp;255.
The type of a color is Real and not Integer in order that a color
can be used with less problems in a model, since in a model an Integer
type could only be used in a when-clause. Typical declaration of a color value:
</p>

<blockquote><pre>
Real color[3](each min=0, each max=255);
</pre></blockquote>

<p>
This definition is also available as type
<a href=\"modelica://Modelica.Mechanics.MultiBody.Types.RealColor\">Modelica.Mechanics.MultiBody.Types.RealColor</a>.
</p>
</html>"));
        end Colors;
        annotation (Documentation(info="<html>
<p>
Package <strong>Visualizers</strong> contains components to visualize
3-dimensional shapes. These components are the basis for the
animation features of the MultiBody library.
</p>
<h4>Content</h4>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedShape\">FixedShape</a><br>
             <a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedShape2\">FixedShape2</a></td>
      <td>Visualizing an elementary shape with dynamically varying shape attributes.
      FixedShape has one connector frame_a, whereas FixedShape2 has additionally
          a frame_b for easier connection to further visual objects.
          The following shape types are supported:<br>&nbsp;<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/FixedShape.png\" alt=\"model Visualizers.FixedShape\">
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedFrame\">FixedFrame</a></td>
      <td>Visualizing a coordinate system including axes labels with fixed sizes:<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/FixedFrame_small.png\"
       alt=\"model Visualizers.FixedFrame2\">
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.FixedArrow\">FixedArrow</a>,<br>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.SignalArrow\">SignalArrow</a></td>
      <td>Visualizing an arrow. Model \"FixedArrow\" provides
      a fixed sized arrow, model \"SignalArrow\" provides
      an arrow with dynamically varying length that is defined
      by an input signal vector:<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/Arrow.png\">
      </td>
  </tr>

  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Torus\">Torus</a></td>
      <td>Visualizing a torus:<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/TorusIcon.png\">
      </td>
  </tr>

  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.VoluminousWheel\">VoluminousWheel</a></td>
      <td>Visualizing a wheel:<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/VoluminousWheelIcon.png\">
      </td>
  </tr>

  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField\">PipeWithScalarField</a></td>
      <td>Visualizing a pipe with a scalar field represented by a color coding:<br>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/PipeWithScalarFieldIcon.png\">
      </td>
  </tr>

<tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced\">Advanced</a></td>
      <td> <strong>Package</strong> that contains components to visualize
          3-dimensional shapes where all parts of the shape
          can vary dynamically. Basic knowledge of Modelica is
          needed in order to utilize the components of this package.
      </td>
  </tr>
</table>
<p>
The colors of the visualization components are declared with
the predefined type <strong>MultiBody.Types.Color</strong>.
This is a vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given as Integer[3] in the ranges 0&nbsp;&hellip;&nbsp;255,
respectively.
</p>
</html>"),Icon(
            coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}),
            graphics={
              Polygon(origin = {4.391, -1}, lineColor = {128, 128, 128}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid, points = {{-14.391, 86}, {75.609, 66}, {15.609, 26}, {-84.391, 56}}),
              Polygon(origin = {18.391, -30}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid, points = {{61.609, 95}, {1.609, 55}, {1.609, -55}, {61.609, -5}}),
              Polygon(origin = {-11.843, -48.757}, lineColor = {128, 128, 128}, fillColor = {191, 191, 191}, fillPattern = FillPattern.Solid, points = {{31.843, 73.757}, {31.843, -36.243}, {-68.157, 3.757}, {-68.157, 103.757}})}));
      end Visualizers;
    annotation (
      Documentation(info="<html>
<p>
Library <strong>MultiBody</strong> is a <strong>free</strong> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<strong>mechanical systems</strong>, such as robots, mechanisms, vehicles.
Typical animations generated with this library are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/MultiBody.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples\">MultiBody.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Polygon(
              points={{-58,76},{6,76},{-26,50},{-58,76}},
              lineColor={95,95,95},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-26,50},{28,-50}}),
            Ellipse(
              extent={{-4,-14},{60,-78}},
              lineColor={135,135,135},
              fillPattern=FillPattern.Sphere,
              fillColor={255,255,255})}));
    end MultiBody;

    package Rotational
    "Library to model 1-dimensional, rotational mechanical systems"
      extends Modelica.Icons.Package;

      package Examples
      "Demonstration examples of the components of this package"
        extends Modelica.Icons.ExamplesPackage;

        model CoupledClutches "Drive train with 3 dynamically coupled clutches"
          extends Modelica.Icons.Example;
          parameter SI.Frequency f=0.2
            "Frequency of sine function to invoke clutch1";
          parameter SI.Time T2=0.4 "Time when clutch2 is invoked";
          parameter SI.Time T3=0.9 "Time when clutch3 is invoked";

          Rotational.Components.Inertia J1(
            J=1,
            phi(fixed=true, start=0),
            w(start=10, fixed=true)) annotation (Placement(transformation(extent={{
                    -70,-10},{-50,10}})));
          Rotational.Sources.Torque torque(useSupport=true) annotation (Placement(
                transformation(extent={{-100,-10},{-80,10}})));
          Rotational.Components.Clutch clutch1(peak=1.1, fn_max=20) annotation (
              Placement(transformation(extent={{-40,-10},{-20,10}})));
          Modelica.Blocks.Sources.Sine sin1(amplitude=10, f=5) annotation (
              Placement(transformation(extent={{-130,-10},{-110,10}})));
          Modelica.Blocks.Sources.Step step1(startTime=T2) annotation (Placement(
                transformation(
                origin={25,35},
                extent={{-5,-5},{15,15}},
                rotation=270)));
          Rotational.Components.Inertia J2(
            J=1,
            phi(fixed=true, start=0),
            w(fixed=true, start=0)) annotation (Placement(transformation(extent={{-10,
                    -10},{10,10}})));
          Rotational.Components.Clutch clutch2(peak=1.1, fn_max=20) annotation (
              Placement(transformation(extent={{20,-10},{40,10}})));
          Rotational.Components.Inertia J3(
            J=1,
            phi(fixed=true, start=0),
            w(fixed=true, start=0)) annotation (Placement(transformation(extent={{
                    50,-10},{70,10}})));
          Rotational.Components.Clutch clutch3(peak=1.1, fn_max=20) annotation (
              Placement(transformation(extent={{80,-10},{100,10}})));
          Rotational.Components.Inertia J4(
            J=1,
            phi(fixed=true, start=0),
            w(fixed=true, start=0)) annotation (Placement(transformation(extent={{
                    110,-10},{130,10}})));
          Modelica.Blocks.Sources.Sine sin2(
            amplitude=1,
            f=f,
            phase=1.570796326794897) annotation (Placement(transformation(
                origin={-35,35},
                extent={{-5,-5},{15,15}},
                rotation=270)));
          Modelica.Blocks.Sources.Step step2(startTime=T3) annotation (Placement(
                transformation(
                origin={85,35},
                extent={{-5,-5},{15,15}},
                rotation=270)));
          Rotational.Components.Fixed fixed annotation (Placement(transformation(
                  extent={{-100,-30},{-80,-10}})));
        equation
          connect(torque.flange, J1.flange_a)
            annotation (Line(points={{-80,0},{-70,0}}));
          connect(J1.flange_b, clutch1.flange_a)
            annotation (Line(points={{-50,0},{-40,0}}));
          connect(clutch1.flange_b, J2.flange_a)
            annotation (Line(points={{-20,0},{-10,0}}));
          connect(J2.flange_b, clutch2.flange_a)
            annotation (Line(points={{10,0},{10,0},{20,0}}));
          connect(clutch2.flange_b, J3.flange_a)
            annotation (Line(points={{40,0},{50,0}}));
          connect(J3.flange_b, clutch3.flange_a)
            annotation (Line(points={{70,0},{80,0}}));
          connect(clutch3.flange_b, J4.flange_a)
            annotation (Line(points={{100,0},{110,0}}));
          connect(sin1.y, torque.tau)
            annotation (Line(points={{-109,0},{-102,0}}, color={0,0,127}));
          connect(sin2.y, clutch1.f_normalized) annotation (Line(points={{-30,19},{
                  -30,19},{-30,11}}, color={0,0,127}));
          connect(step1.y, clutch2.f_normalized) annotation (Line(points={{30,19},{
                  30,19},{30,10},{30,11}}, color={0,0,127}));
          connect(step2.y, clutch3.f_normalized)
            annotation (Line(points={{90,19},{90,19},{90,11}}, color={0,0,127}));
          connect(fixed.flange, torque.support) annotation (Line(points={{-90,-20},
                  {-90,-11},{-90,-10}}));
          annotation (
            Documentation(info="<html>
<p>This example demonstrates how variable structure
drive trains are handled. The drive train consists
of 4 inertias and 3 clutches, where the clutches
are controlled by input signals. The system has
2^3=8 different configurations and 3^3 = 27
different states (every clutch may be in forward
sliding, backward sliding or locked mode when the
relative angular velocity is zero). By invoking the
clutches at different time instances, the switching
of the configurations can be studied.</p>
<p>Simulate the system for 1.2 seconds with the
following initial values:<br>
J1.w = 10.</p>
<p>Plot the following variables:<br>
angular velocities of inertias (J1.w, J2.w, J3.w,
J4.w), frictional torques of clutches (clutchX.tau),
frictional mode of clutches (clutchX.mode) where
mode = -1/0/+1 means backward sliding,
locked, forward sliding.</p>

</html>"),  __Dymola_Commands(file=
                  "modelica://Modelica/Resources/Scripts/Dymola/Mechanics/Rotational/CoupledClutches.mos"
                "Simulate and Plot"),
            experiment(StopTime=1.5, Interval=0.001),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},
                    {140,100}})));
        end CoupledClutches;

        model LossyGearDemo1
          "Example to show that gear efficiency may lead to stuck motion"
          extends Modelica.Icons.Example;
          SI.Power PowerLoss=gear.flange_a.tau*der(gear.flange_a.phi) + gear.flange_b.tau
              *der(gear.flange_b.phi) "Power lost in the gear";
          Rotational.Components.LossyGear gear(
            ratio=2,
            lossTable=[0, 0.5, 0.5, 0, 0],
            useSupport=true) annotation (Placement(transformation(extent={{-10,0},{
                    10,20}})));
          Rotational.Components.Inertia Inertia1(J=1) annotation (Placement(
                transformation(extent={{-40,0},{-20,20}})));
          Rotational.Components.Inertia Inertia2(
            J=1.5,
            phi(fixed=true, start=0, nominal=0.001),
            w(fixed=true, start=0, nominal=0.01)) annotation (Placement(transformation(extent={{
                    20,0},{40,20}})));
          Rotational.Sources.Torque torque1(useSupport=true) annotation (Placement(
                transformation(extent={{-70,0},{-50,20}})));
          Rotational.Sources.Torque torque2(useSupport=true) annotation (Placement(
                transformation(extent={{70,0},{50,20}})));
          Modelica.Blocks.Sources.Sine DriveSine(amplitude=10, f=1)
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          Modelica.Blocks.Sources.Ramp load(
            height=5,
            duration=2,
            offset=-10) annotation (Placement(transformation(extent={{100,0},{80,20}})));
          Rotational.Components.Fixed fixed annotation (Placement(transformation(
                  extent={{-10,-30},{10,-10}})));
        equation
          connect(Inertia1.flange_b, gear.flange_a)
            annotation (Line(points={{-20,10},{-10,10}}));
          connect(gear.flange_b, Inertia2.flange_a)
            annotation (Line(points={{10,10},{20,10}}));
          connect(torque1.flange, Inertia1.flange_a)
            annotation (Line(points={{-50,10},{-40,10}}));
          connect(torque2.flange, Inertia2.flange_b)
            annotation (Line(points={{50,10},{40,10}}));
          connect(DriveSine.y, torque1.tau)
            annotation (Line(points={{-79,10},{-72,10}}, color={0,0,127}));
          connect(load.y, torque2.tau)
            annotation (Line(points={{79,10},{72,10}}, color={0,0,127}));
          connect(fixed.flange, gear.support)
            annotation (Line(points={{0,-20},{0,0}}));
          connect(fixed.flange, torque1.support)
            annotation (Line(points={{0,-20},{-60,-20},{-60,0}}));
          connect(fixed.flange, torque2.support)
            annotation (Line(points={{0,-20},{60,-20},{60,0}}));
          annotation (Documentation(info="<html>
<p>
This model contains two inertias which are connected by an ideal
gear where the friction between the teeth of the gear is modeled in
a physical meaningful way (friction may lead to stuck mode which
locks the motion of the gear). The friction is defined by an
efficiency factor (= 0.5) for forward and backward driving condition leading
to a torque dependent friction loss. Simulate for about 0.5 seconds.
The friction in the gear will take all modes
(forward and backward rolling, as well as stuck).
</p>
<p>
You may plot:
</p>
<blockquote><pre>
Inertia1.w,
Inertia2.w : angular velocities of inertias
powerLoss  : power lost in the gear
gear.mode  :  1 = forward rolling
              0 = stuck (w=0)
             -1 = backward rolling
</pre></blockquote>

<p>
Note, <code>powerLoss</code> (= sum of the power flows of the connectors) and
<code>gear.powerLoss</code> (= <code>gear.tau_loss</code>*<code>gear.w_a</code>,
where <code>gear.tau_loss</code> is determined in a non-trivial way
from the stuck/sliding situation of the bearing and teeth friction;
= equation (16) in [<a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.References\">Pelchen2002</a>])
should be identical, or the difference should be close to zero, if model
<a href=\"modelica://Modelica.Mechanics.Rotational.Components.LossyGear\">LossyGear</a>
is correctly implemented.
</p>
</html>"),     experiment(StopTime=0.5, Interval=0.001));
        end LossyGearDemo1;
        annotation (Documentation(info="<html>
<p>
This package contains example models to demonstrate the usage of the
Modelica.Mechanics.Rotational package. Open the models and
simulate them according to the provided description in the models.
</p>

</html>"));
      end Examples;

      package Components "Components for 1D rotational mechanical drive trains"
        extends Modelica.Icons.Package;

        model Fixed "Flange fixed in housing at a given angle"
          parameter SI.Angle phi0=0 "Fixed offset angle of housing";

          Interfaces.Flange_b flange "(right) flange fixed in housing" annotation (
              Placement(transformation(extent={{10,-10},{-10,10}})));

        equation
          flange.phi = phi0;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Text(
                  extent={{-150,-90},{150,-130}},
                  textColor={0,0,255},
                  textString="%name"),
                Line(points={{-80,-40},{80,-40}}),
                Line(points={{80,-40},{40,-80}}),
                Line(points={{40,-40},{0,-80}}),
                Line(points={{0,-40},{-40,-80}}),
                Line(points={{-40,-40},{-80,-80}}),
                Line(points={{0,-40},{0,-10}})}),
            Documentation(info="<html>
<p>
The <strong>flange</strong> of a 1D rotational mechanical system is <strong>fixed</strong>
at an angle phi0 in the <strong>housing</strong>. May be used:
</p>
<ul>
<li> to connect a compliant element, such as a spring or a damper,
     between an inertia or gearbox component and the housing.</li>
<li> to fix a rigid element, such as an inertia, with a specific
     angle to the housing.</li>
</ul>

</html>"));
        end Fixed;

        model Inertia "1D-rotational component with inertia"
          extends Rotational.Interfaces.PartialTwoFlanges;
          parameter SI.Inertia J(min=0, start=1) "Moment of inertia";
          parameter StateSelect stateSelect=StateSelect.default
            "Priority to use phi and w as states"
            annotation (HideResult=true, Dialog(tab="Advanced"));
          SI.Angle phi(stateSelect=stateSelect)
            "Absolute rotation angle of component"
            annotation (Dialog(group="Initialization", showStartAttribute=true));
          SI.AngularVelocity w(stateSelect=stateSelect)
            "Absolute angular velocity of component (= der(phi))"
            annotation (Dialog(group="Initialization", showStartAttribute=true));
          SI.AngularAcceleration a
            "Absolute angular acceleration of component (= der(w))"
            annotation (Dialog(group="Initialization", showStartAttribute=true));

        equation
          phi = flange_a.phi;
          phi = flange_b.phi;
          w = der(phi);
          a = der(w);
          J*a = flange_a.tau + flange_b.tau;
          annotation (Documentation(info="<html>
<p>
Rotational component with <strong>inertia</strong> and two rigidly connected flanges.
</p>
</html>"),     Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
          graphics={
            Rectangle(lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-10.0},{-50.0,10.0}}),
            Rectangle(lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{50.0,-10.0},{100.0,10.0}}),
            Line(points={{-80.0,-25.0},{-60.0,-25.0}}),
            Line(points={{60.0,-25.0},{80.0,-25.0}}),
            Line(points={{-70.0,-25.0},{-70.0,-70.0}}),
            Line(points={{70.0,-25.0},{70.0,-70.0}}),
            Line(points={{-80.0,25.0},{-60.0,25.0}}),
            Line(points={{60.0,25.0},{80.0,25.0}}),
            Line(points={{-70.0,45.0},{-70.0,25.0}}),
            Line(points={{70.0,45.0},{70.0,25.0}}),
            Line(points={{-70.0,-70.0},{70.0,-70.0}}),
            Rectangle(lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-50.0,-50.0},{50.0,50.0}},
              radius=10.0),
            Text(textColor={0,0,255},
              extent={{-150.0,60.0},{150.0,100.0}},
              textString="%name"),
            Text(extent={{-150.0,-120.0},{150.0,-80.0}},
              textString="J=%J"),
            Rectangle(
              lineColor = {64,64,64},
              fillColor = {255,255,255},
              extent = {{-50,-50},{50,50}},
              radius = 10)}));
        end Inertia;

        model Clutch "Clutch based on Coulomb friction"
          extends Modelica.Mechanics.Rotational.Icons.Clutch;
          extends
          Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;

          parameter Real mu_pos[:, 2]=[0, 0.5]
            "Positive sliding friction coefficient [-] as function of w_rel [rad/s] (w_rel>=0)";
          parameter Real peak(final min=1) = 1
            "Peak for maximum value of mu at w==0 (mu0_max = peak*mu_pos[1,2])";
          parameter Real cgeo(final min=0) = 1
            "Geometry constant containing friction distribution assumption";
          parameter SI.Force fn_max(final min=0, start=1) "Maximum normal force";

          extends Rotational.Interfaces.PartialFriction;
          extends
          Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

          Real mu0 "Friction coefficient for w=0 and forward sliding";
          SI.Force fn "Normal force (fn=fn_max*f_normalized)";
          Modelica.Blocks.Interfaces.RealInput f_normalized
            "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)"
            annotation (Placement(transformation(
                origin={0,110},
                extent={{20,-20},{-20,20}},
                rotation=90)));

        equation
          // Constant auxiliary variable
          mu0 = Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], 0, 1);

          // Relative quantities
          w_relfric = w_rel;
          a_relfric = a_rel;

          // Normal force and friction torque for w_rel=0
          fn = fn_max*f_normalized;
          free = fn <= 0;
          tau0 = mu0*cgeo*fn;
          tau0_max = peak*tau0;

          // Friction torque
          tau = if locked then sa*unitTorque else if free then 0 else cgeo*fn*(
            if startForward then
              Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], w_rel, 1)
            else if startBackward then
              -Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], w_rel, 1)
            else if pre(mode) == Forward then
              Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], w_rel, 1)
            else
              -Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], -w_rel, 1));
          lossPower = tau*w_relfric;
          annotation (Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={
              Text(extent={{-150,-110},{150,-70}},
                textString="%name",
                textColor={0,0,255}),
              Line(visible=useHeatPort,
                points={{-100,-100},{-100,-40},{0,-40}},
                color={191,0,0},
                pattern=LinePattern.Dot)}), Documentation(info="<html>
<p>
This component models a <strong>clutch</strong>, i.e., a component with
two flanges where friction is present between the two flanges
and these flanges are pressed together via a normal force.
The normal force fn has to be provided as input signal f_normalized in a normalized form
(0 &le; f_normalized &le; 1),
fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
clutch is modelled in the following way:
</p>
<p>
When the relative angular velocity is not zero, the friction torque is a
function of the velocity dependent friction coefficient mu(w_rel), of
the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
account the geometry of the device and the assumptions on the friction
distributions:
</p>
<blockquote><pre>
frictional_torque = <strong>cgeo</strong> * <strong>mu</strong>(w_rel) * <strong>fn</strong>
</pre></blockquote>
<p>
   Typical values of coefficients of friction <strong>mu</strong>:
</p>
<ul>
  <li>0.2&nbsp;&hellip;&nbsp;0.4 for dry operation,</li>
  <li>0.05&nbsp;&hellip;&nbsp;0.1 when operating in oil.</li>
</ul>
<p>
   When plates are pressed together, where  <strong>ri</strong>  is the inner radius,
   <strong>ro</strong> is the outer radius and <strong>N</strong> is the number of friction interfaces,
   the geometry constant is calculated in the following way under the
   assumption of a uniform rate of wear at the interfaces:
</p>
<blockquote><pre>
<strong>cgeo</strong> = <strong>N</strong>*(<strong>r0</strong> + <strong>ri</strong>)/2
</pre></blockquote>
<p>
    The positive part of the friction characteristic <strong>mu</strong>(w_rel),
    w_rel >= 0, is defined via table mu_pos (first column = w_rel,
    second column = mu). Currently, only linear interpolation in
    the table is supported.
</p>
<p>
   When the relative angular velocity becomes zero, the elements
   connected by the friction element become stuck, i.e., the relative
   angle remains constant. In this phase the friction torque is
   calculated from a torque balance due to the requirement, that
   the relative acceleration shall be zero.  The elements begin
   to slide when the friction torque exceeds a threshold value,
   called the  maximum static friction torque, computed via:
</p>
<blockquote><pre>
frictional_torque = <strong>peak</strong> * <strong>cgeo</strong> * <strong>mu</strong>(w_rel=0) * <strong>fn</strong>   (<strong>peak</strong> >= 1)
</pre></blockquote>
<p>
This procedure is implemented in a \"clean\" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled. The method is described in
(see also a short sketch in <a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.ModelingOfFriction\">UsersGuide.ModelingOfFriction</a>):
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):</dt>
<dd><strong>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</dd>
</dl>
<p>
More precise friction models take into account the elasticity of the
material when the two elements are \"stuck\", as well as other effects,
like hysteresis. This has the advantage that the friction element can
be completely described by a differential equation without events. The
drawback is that the system becomes stiff (about 10-20 times slower
simulation) and that more material constants have to be supplied which
requires more sophisticated identification. For more details, see the
following references, especially (Armstrong and Canudas de Wit 1996):
</p>
<dl>
<dt>Armstrong B. (1991):</dt>
<dd><strong>Control of Machines with Friction</strong>. Kluwer Academic
    Press, Boston MA.<br></dd>
<dt>Armstrong B., and Canudas de Wit C. (1996):</dt>
<dd><strong>Friction Modeling and Compensation.</strong>
    The Control Handbook, edited by W.S.Levine, CRC Press,
    pp. 1369-1382.<br></dd>
<dt>Canudas de Wit C., Olsson H., &Aring;str&ouml;m K.J., and Lischinsky P. (1995):</dt>
<dd><strong>A new model for control of systems with friction.</strong>
    IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.</dd>
</dl>

<p>
See also the discussion
<a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.StateSelection\">State Selection</a>
in the User's Guide of the Rotational library.
</p>
</html>"));
        end Clutch;

        model IdealGear "Ideal gear without inertia"
          extends Modelica.Mechanics.Rotational.Icons.Gear;
          extends
          Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;
          parameter Real ratio(start=1)
            "Transmission ratio (flange_a.phi/flange_b.phi)";
          SI.Angle phi_a
            "Angle between left shaft flange and support";
          SI.Angle phi_b
            "Angle between right shaft flange and support";

        equation
          phi_a = flange_a.phi - phi_support;
          phi_b = flange_b.phi - phi_support;
          phi_a = ratio*phi_b;
          0 = ratio*flange_a.tau + flange_b.tau;
          annotation (
            Documentation(info="<html>
<p>
This element characterizes any type of gear box which is fixed in the
ground and which has one driving shaft and one driven shaft.
The gear is <strong>ideal</strong>, i.e., it does not have inertia, elasticity, damping
or backlash. If these effects have to be considered, the gear has to be
connected to other elements in an appropriate way.
</p>

</html>"),     Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}),
            graphics={
              Text(extent={{-153,145},{147,105}},
                textColor={0,0,255},
                textString="%name"),
              Text(extent={{-146,-49},{154,-79}},
                textString="ratio=%ratio")}));
        end IdealGear;

        model LossyGear
          "Gear with mesh efficiency and bearing friction (stuck/rolling possible)"

          extends Modelica.Mechanics.Rotational.Icons.Gear;
          extends
          Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

          parameter Real ratio(start=1)
            "Transmission ratio (flange_a.phi/flange_b.phi)";
          parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0]
            "Array for mesh efficiencies and bearing friction depending on speed";
          extends
          Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
          SI.Angle phi_a
            "Angle between left shaft flange and support";
          SI.Angle phi_b
            "Angle between right shaft flange and support";

          Real sa(final unit="1") "Path parameter for acceleration and torque loss";
          SI.AngularVelocity w_a
            "Angular velocity of flange_a with respect to support";
          SI.AngularAcceleration a_a
            "Angular acceleration of flange_a with respect to support";

          Real interpolation_result[1, 4]
            "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])";
          Real eta_mf1(unit="1") "Mesh efficiency in case that flange_a is driving";
          Real eta_mf2(unit="1") "Mesh efficiency in case that flange_b is driving";
          SI.Torque tau_bf_a "Bearing friction torque on flange_a side";
          SI.Torque tau_eta
            "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau)";

          SI.Torque tau_bf1
            "Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)";
          SI.Torque tau_bf2
            "Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)";

          SI.Torque quadrant1 "Torque loss if w_a > 0 and flange_a.tau >= 0";
          SI.Torque quadrant2 "Torque loss if w_a > 0 and flange_a.tau < 0";
          SI.Torque quadrant3 "Torque loss if w_a < 0 and flange_a.tau >= 0";
          SI.Torque quadrant4 "Torque loss if w_a < 0 and flange_a.tau < 0";

          // Resultant friction torques at quadrant values for angular velocities near zero
          SI.Torque quadrant1_p
            "Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0)";
          SI.Torque quadrant2_p
            "Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0)";
          SI.Torque quadrant3_m
            "Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0)";
          SI.Torque quadrant4_m
            "Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0)";

          SI.Torque tauLoss
            "Torque loss due to friction in the gear teeth and in the bearings";
          SI.Torque tauLossMax "Torque loss for positive speed";
          SI.Torque tauLossMin "Torque loss for negative speed";

          SI.Torque tauLossMax_p "Torque loss for positive speed";
          SI.Torque tauLossMin_m "Torque loss for negative speed";

          Boolean tau_aPos(start=true)
            "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative)";
          Boolean tau_etaPos(start=true) "= true, if torque tau_eta is not negative";
          Boolean startForward(start=false) "= true, if starting to roll forward";
          Boolean startBackward(start=false) "= true, if starting to roll backward";
          Boolean locked(start=false) "= true, if gear is locked";

          Boolean ideal
            "= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0])";

          constant Integer Unknown=3 "Value of mode is not known";
          constant Integer Free=2 "Element is not active";
          constant Integer Forward=1 "w_a > 0 (forward rolling)";
          constant Integer Stuck=0
            "w_a = 0 (forward rolling, locked or backward rolling)";
          constant Integer Backward=-1 "w_a < 0 (backward rolling)";
          Integer mode(
            final min=Backward,
            final max=Unknown,
            start=Free,
            fixed=true)
            "Mode of friction element (unknown, not active, forward/backward rolling, stuck)";

          SI.Torque tau_eta_p "tau_eta assuming positive omega";
          SI.Torque tau_eta_m "tau_eta assuming negative omega";
      protected
          constant SI.AngularAcceleration unitAngularAcceleration=1;
          constant SI.Torque unitTorque=1;

          // get friction and eta information for omega=0
          parameter Real eta_mf1_0(unit="1")=Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,2], 0, 1);
          parameter Real eta_mf2_0(unit="1")=Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,3], 0, 1);
          parameter SI.Torque tau_bf1_0=abs(Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,4], 0, 1));
          parameter SI.Torque tau_bf2_0=abs(Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,5], 0, 1));
          parameter SI.Torque tau_bf_a_0=if Modelica.Math.isEqual(
                  eta_mf1_0,
                  1.0,
                  Modelica.Constants.eps) and Modelica.Math.isEqual(
                  eta_mf2_0,
                  1.0,
                  Modelica.Constants.eps) then tau_bf1_0/2 else (tau_bf1_0 -
              tau_bf2_0)/(eta_mf1_0 - 1.0/eta_mf2_0);
          // For eta_mf1_0=eta_mf2_0=1 the given bearing
          // friction can not be separated into a part
          // on side A or B, so it is done arbitrarily.
          // Calculate tau_bf_a_0 from the following equations
          //  tau_bf1_0=eta_mf1_0*tau_bf_a_0 + 1/ratio a_0
          //  tau_bf2_0=1/eta_mf2*tau_bf_a_0 + 1/ratio tau_bf_a_0
        equation
          assert(abs(ratio) > 0,
            "Error in initialization of LossyGear: ratio may not be zero");

          ideal = Modelica.Math.Matrices.isEqual(
                lossTable,
                [0, 1, 1, 0, 0],
                Modelica.Constants.eps);

          if ideal then
            interpolation_result = [1, 1, 0, 0];
            eta_mf1 = 1;
            eta_mf2 = 1;
            tau_bf1 = 0;
            tau_bf2 = 0;
          else
            interpolation_result = [
              Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,2], noEvent(abs(w_a)), 1),
              Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,3], noEvent(abs(w_a)), 1),
              Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,4], noEvent(abs(w_a)), 1),
              Modelica.Math.Vectors.interpolate(lossTable[:,1], lossTable[:,5], noEvent(abs(w_a)), 1)];
            eta_mf1 = interpolation_result[1, 1];
            eta_mf2 = interpolation_result[1, 2];
            tau_bf1 = noEvent(abs(interpolation_result[1, 3]));
            tau_bf2 = noEvent(abs(interpolation_result[1, 4]));
          end if;

          if Modelica.Math.isEqual(
                  eta_mf1,
                  1.0,
                  Modelica.Constants.eps) and Modelica.Math.isEqual(
                  eta_mf2,
                  1.0,
                  Modelica.Constants.eps) then
            // For eta_mf1=eta_mf2=1 the given bearing friction can not be
            // separated into a part on side A or B, so it is done arbitrarily.
            tau_bf_a = tau_bf1/2;
          else
            //calculate tau_bf_a from the following equations
            //tau_bf1 = eta_mf1*tau_bf_a + tau_bf_b / ratio
            //tau_bf2 = 1/eta_mf2*tau_bf_a + tau_bf_b / ratio
            tau_bf_a = (tau_bf1 - tau_bf2)/(eta_mf1 - 1.0/eta_mf2);
          end if;

          phi_a = flange_a.phi - phi_support;
          phi_b = flange_b.phi - phi_support;
          phi_a = ratio*phi_b;

          // Torque balance (no inertias)
          0 = flange_b.tau + ratio*(flange_a.tau - tauLoss);

          // Speed for friction element
          w_a = der(phi_a);
          a_a = der(w_a);

          // Determine driving side
          //assuming positive omega
          tau_eta_p = flange_a.tau - tau_bf_a_0;
          //assuming negative omega
          tau_eta_m = flange_a.tau + tau_bf_a_0;

          // assuming w>=0, take value at w=0 to decide rolling/stuck mode
          quadrant1_p = (1 - eta_mf1_0)*flange_a.tau + tau_bf1_0;
          quadrant2_p = (1 - 1/eta_mf2_0)*flange_a.tau + tau_bf2_0;
          tauLossMax_p = if noEvent(tau_eta_p > 0) then quadrant1_p else
            quadrant2_p;

          // assuming w<=0, take value at w=0 to decide rolling/stuck mode
          quadrant4_m = (1 - 1/eta_mf2_0)*flange_a.tau - tau_bf2_0;
          quadrant3_m = (1 - eta_mf1_0)*flange_a.tau - tau_bf1_0;
          tauLossMin_m = if noEvent(tau_eta_m > 0) then quadrant4_m else
            quadrant3_m;

          quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
          quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
          quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
          quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

          //tau eta: only for determination of driving side for calculation of tauloss
          tau_eta = if ideal then flange_a.tau else (if locked then flange_a.tau
             else (if (startForward or pre(mode) == Forward) then flange_a.tau -
            tau_bf_a else flange_a.tau + tau_bf_a));

          // Torque Losses
          tau_etaPos = tau_eta >= 0;
          tau_aPos = tau_etaPos;
          tauLossMax = if tau_etaPos then quadrant1 else quadrant2;
          tauLossMin = if tau_etaPos then quadrant4 else quadrant3;

          // Determine rolling/stuck mode when w_rel = 0
          startForward = pre(mode) == Stuck and sa > tauLossMax_p/unitTorque or
            initial() and w_a > 0;
          startBackward = pre(mode) == Stuck and sa < tauLossMin_m/unitTorque or
            initial() and w_a < 0;
          locked = not (ideal or pre(mode) == Forward or startForward or pre(mode)
             == Backward or startBackward);

          /* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */
          tauLoss = if ideal then 0 else (if locked then sa*unitTorque else (if (
            startForward or pre(mode) == Forward) then tauLossMax else tauLossMin));

          a_a = unitAngularAcceleration*(if locked then 0 else sa - tauLoss/
            unitTorque);

          /* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */
          mode = if ideal then Free else (if (pre(mode) == Forward or startForward)
             and w_a > 0 then Forward else if (pre(mode) == Backward or
            startBackward) and w_a < 0 then Backward else Stuck);

          lossPower = tauLoss*w_a;
          annotation (
            Documentation(info="<html>
<p>
This component models the gear ratio and the <strong>losses</strong> of
a standard gear box in a <strong>reliable</strong> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handled are fixed in the ground or on a moving support, have one input and one
output shaft, and are essentially described by the equations:
</p>
<blockquote><pre>
             flange_a.phi  = i*flange_b.phi;
-(flange_b.tau - tau_bf_b) = i*eta_mf*(flange_a.tau - tau_bf_a);

// or        -flange_b.tau = i*eta_mf*(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));
</pre></blockquote>
<p>
where
</p>

<ul>
<li> <strong>i</strong> is the constant <strong>gear ratio</strong>,</li>

<li> <strong>eta_mf</strong> = eta_mf(w_a) is the <strong>mesh efficiency</strong> due to the
     friction between the teeth of the gear wheels,</li>

<li> <strong>tau_bf_a</strong> = tau_bf_a(w_a) is the <strong>bearing friction torque</strong>
     on the flange_a side,</li>

<li> <strong>tau_bf_b</strong> = tau_bf_b(w_a) is the <strong>bearing friction torque</strong>
     on the flange_b side, and</li>

<li><strong>w_a</strong> = der(flange_a.phi) is the speed of flange_a</li>
</ul>

<p>
The loss terms \"eta_mf\", \"tau_bf_a\" and \"tau_bf_b\" are functions of the
<em>absolute value</em> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <strong>lossTable[:,5]
</strong> where the columns of this table have the following
meaning:
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tbody>
    <tr>
      <td>|w_a|</td>
      <td>eta_mf1</td>
      <td>eta_mf2</td>
      <td>|tau_bf1|</td>
      <td>|tau_bf2|</td>
    </tr>
    <tr>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
    </tr>
    <tr>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
      <td align=\"center\">&hellip;</td>
    </tr>
  </tbody>
</table>

<p>with</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tbody>
    <tr>
      <td>|w_a|</td>
      <td>Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td>eta_mf1</td>
      <td>Mesh efficiency in case that flange_a is driving</td>
    </tr>
    <tr>
      <td>eta_mf2</td>
      <td>Mesh efficiency in case that flange_b is driving</td>
    </tr>
    <tr>
      <td>|tau_bf1|</td>
      <td> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_a is driving<br>
                        (= |tau_bf_a*eta_mf1 + tau_bf_b/i|)
                        </td>
    </tr>
    <tr>
      <td>|tau_bf2|</td>
      <td> Absolute resultant bearing friction torque with respect to flange_a
                        in case that flange_b is driving<br>
                        (= |tau_bf_a/eta_mf2 + tau_bf_b/i|)
                        </td>
    </tr>
  </tbody>
</table>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>

<blockquote><pre>
<strong>if</strong> (flange_a.tau - tau_bf_a)*w_a &gt; 0 <strong>or</strong>
   (flange_a.tau - tau_bf_a) == 0 <strong>and</strong> w_a &gt; 0 <strong>then</strong>
   eta_mf := eta_mf1
   tau_bf := tau_bf1
<strong>elseif</strong> (flange_a.tau - tau_bf_a)*w_a &lt; 0 <strong>or</strong>
       (flange_a.tau - tau_bf_a) == 0 <strong>and</strong> w_a &lt; 0 <strong>then</strong>
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
<strong>else</strong> // w_a == 0
   eta_mf and tau_bf are computed such that <strong>der</strong>(w_a) = 0
<strong>end if</strong>;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);
</pre></blockquote>

<p>
Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>

<h4>Acknowledgement</h4>
<ul>
<li> The essential idea to model efficiency
     in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li> The article (Pelchen et.al. 2002), see Literature below,
     and the first implementation of LossyGear (up to version 3.1 of package Modelica)
     contained a bug leading to a non-converging solution in cases where the
     driving side is not obvious.
     This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch,
     and Christian Bertsch proposed a concrete solution how to fix this
     bug, see Literature below.</li>
</ul>

<h4>Literature</h4>

<ul>
<li>Pelchen C.,
Schweiger C.,
and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
&quot;<a href=\"https://www.modelica.org/events/Conference2002/papers/p33_Pelchen.pdf\">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</a>,&quot; in
<em>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</em>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</li>

<li>Bertsch C. (2009):
&quot;<a href=\"modelica://Modelica/Resources/Documentation/Mechanics/Lossy-Gear-Bug_Solution.pdf\">Problem
with model LossyGear and a proposed solution</a>&quot;,
Ticket <a href=\"https://github.com/modelica/ModelicaStandardLibrary/issues/108\">#108</a>,
Sept. 11, 2009.</li>
</ul>

</html>"),     Icon(
            coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
            Polygon(fillColor={161,35,41},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-110,50},{-80,50},{-80,80},{-90,80},{-70,100},{-50,80},{-60,80},{-60,30},{-110,30},{-110,50}}),
            Line(points={{-80.0,20.0},{-60.0,20.0}}),
            Text(textColor={0,0,255},
              extent={{-148.0,105.0},{152.0,145.0}},
              textString="%name"),
            Text(extent={{-145.0,-79.0},{155.0,-49.0}},
              textString="ratio=%ratio"),
            Line(visible=useHeatPort,
              points={{-100.0,-100.0},{-100.0,-30.0},{0.0,-30.0},{0.0,0.0}},
              color={191,0,0},
              pattern=LinePattern.Dot)}));
        end LossyGear;

        model IdealGearR2T
          "Gearbox transforming rotational into translational motion"
          extends
          Rotational.Interfaces.PartialElementaryRotationalToTranslational;
          parameter Real ratio(final unit="rad/m", start=1)
            "Transmission ratio (flange_a.phi/flange_b.s)";

        equation
          (flangeR.phi - internalSupportR.phi) = ratio*(flangeT.s -
            internalSupportT.s);
          0 = ratio*flangeR.tau + flangeT.f;
          annotation (
            Documentation(info="<html>
<p>
This is an ideal mass- and inertialess gearbox which transforms a
1D-rotational into a 1D-translational motion. If elasticity, damping
or backlash has to be considered, this ideal gearbox has to be
connected with corresponding elements.
This component defines the kinematic constraint:
</p>

<blockquote><pre>
(flangeR.phi - internalSupportR.phi) = ratio*(flangeT.s - internalSupportT.s);
</pre></blockquote>
</html>"),     Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(origin={133.3333,0.0},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-233.3333,-10.0},{-163.3333,10.0}}),
            Text(textColor={0,0,255},
              extent={{-150.0,85.0},{150.0,125.0}},
              textString="%name"),
            Rectangle(
              fillColor={131,175,131},
              fillPattern=FillPattern.Solid,
              extent={{95.0,-60.0},{106.0,-10.0}}),
            Rectangle(
              fillColor={131,175,131},
              fillPattern=FillPattern.Solid,
              extent={{-74.411,-80},{106.589,-60}}),
            Text(extent={{-150.0,50.0},{150.0,80.0}},
              textString="ratio=%ratio"),
            Line(points={{-100,16},{-80,16}}),
            Line(points={{-100,-16},{-80,-16}}),
            Line(points={{-100.0,-16.0},{-100.0,-100.0}}),
            Line(points={{100,-80},{100,-100}}, color={0,127,0}),
            Polygon(
                  origin={16.875,-50.0},
                  fillColor={131,175,131},
                  fillPattern=FillPattern.Solid,
                  points={{-84.375,-10.0},{-79.375,10.0},{-69.375,10.0},{-64.375,-10.0},{-54.375,-10.0},{-49.375,10.0},{-39.375,10.0},{-34.375,-10.0},{-24.375,-10.0},{-19.375,10.0},{-9.375,10.0},{-4.375,-10.0},
                      {5.625,-10.0},{10.625,10.0},{20.625,10.0},{25.625,-10.0},{35.625,-10.0},{40.625,10.0},{50.625,10.0},{55.625,-10.0},{65.625,-10.0},{70.625,10.0},{78.125,10.0},{78.125,-10.0}}),
            Polygon(origin={-20.0,-0.0},
              rotation=10.0,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-5.0,45.0},{-10.0,10.0},{-45.0,5.0},{-45.0,-5.0},{-10.0,-10.0},{-5.0,-45.0},{5.0,-45.0},{10.0,-10.0},{45.0,-5.0},{45.0,5.0},{10.0,10.0},{5.0,45.0}}),
            Polygon(origin={-20.0,-0.0},
              rotation=55.0,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-5.0,45.0},{-10.0,10.0},{-45.0,5.0},{-45.0,-5.0},{-10.0,-10.0},{-5.0,-45.0},{5.0,-45.0},{10.0,-10.0},{45.0,-5.0},{45.0,5.0},{10.0,10.0},{5.0,45.0}}),
            Ellipse(origin={-20.0,-0.0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-30.0,-30.0},{30.0,30.0}}),
            Ellipse(origin={-20.0,-0.0},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid,
              extent={{-10.0,-10.0},{10.0,10.0}})}));
        end IdealGearR2T;
        annotation (Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(origin={13.5135,76.9841},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-63.5135,-126.9841},{36.4865,-26.9841}},
              radius=10.0),
            Rectangle(origin={13.5135,76.9841},
              lineColor={64,64,64},
              extent={{-63.5135,-126.9841},{36.4865,-26.9841}},
              radius=10.0),
            Rectangle(origin={-3.0,73.0769},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-87.0,-83.0769},{-47.0,-63.0769}}),
            Rectangle(origin={22.3077,70.0},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{27.6923,-80.0},{67.6923,-60.0}})}), Documentation(info="<html>
<p>
This package contains basic components 1D mechanical rotational drive trains.
</p>
</html>"));
      end Components;

      package Sources "Sources to drive 1D rotational mechanical components"
        extends Modelica.Icons.SourcesPackage;

        model Torque "Input signal acting as external torque on a flange"
          extends
          Modelica.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport2;
          Modelica.Blocks.Interfaces.RealInput tau(unit="N.m")
            "Accelerating torque acting at flange (= -flange.tau)" annotation (
              Placement(transformation(extent={{-140,-20},{-100,20}})));

        equation
          flange.tau = -tau;
          annotation (
            Documentation(info="<html>
<p>
The input signal <strong>tau</strong> defines an external
torque in [Nm] which acts (with negative sign) at
a flange connector, i.e., the component connected to this
flange is driven by torque <strong>tau</strong>.</p>
<p>
The input signal can be provided from one of the signal generator
blocks of Modelica.Blocks.Sources.
</p>
</html>"),  Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}),
              graphics={
            Text(extent={{-150,110},{150,70}},
              textString="%name",
              textColor={0,0,255}),
            Text(extent={{-62,-29},{-141,-70}},
              textString="tau"),
            Polygon(points={{86,0},{66,58},{37,27},{86,0}},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-10},{0,-101}}),
            Polygon(points={{-53,-54},{-36,-30},{-50,-24},{-53,-54}},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-84,0},{-78,18},{-56,46},{-20,60},{20,60},{60,40},{82,8}},
              smooth=Smooth.Bezier,
              thickness=0.5),
            Line(
              points={{-50,-40},{-38,-24},{-18,-12},{0,-10},{18,-12},{38,-24},{50,-40}},
              smooth=Smooth.Bezier)}));
        end Torque;
        annotation (Documentation(info="<html>
<p>
This package contains ideal sources to drive 1D mechanical rotational drive trains.
</p>
</html>"));
      end Sources;

      package Interfaces
      "Connectors and partial models for 1D rotational mechanical components"
        extends Modelica.Icons.InterfacesPackage;

        connector Flange "One-dimensional rotational flange"

          SI.Angle phi "Absolute rotation angle of flange";
          flow SI.Torque tau "Cut torque in the flange";
          annotation (
            Documentation(info="<html>
<p>
This is a connector for 1D rotational mechanical systems.
It has no icon definition and is only used by inheritance from
flange connectors to define different icons.
</p>
<p>
The following variables are defined in this connector:
</p>

<blockquote><pre>
phi: Absolute rotation angle of the flange in [rad].
tau: Cut-torque in the flange in [Nm].
</pre></blockquote>
</html>"));
        end Flange;

        connector Flange_a
          "One-dimensional rotational flange of a shaft (filled circle icon)"
          extends Flange;

          annotation (
            defaultComponentName="flange_a",
            Documentation(info="<html>
<p>
This is a connector for 1-dim. rotational mechanical systems and models which represents
a mechanical flange of a shaft. The following variables are defined in this connector:
</p>

<blockquote><pre>
phi: Absolute rotation angle of the shaft flange in [rad].
tau: Cut-torque in the shaft flange in [Nm].
</pre></blockquote>

<p>
There is a second connector for flanges:
<a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.Flange_b\">Flange_b</a>.
The connectors
Flange_a and Flange_b are completely identical. There is only a difference
in the icons, in order to easier identify a flange variable in a diagram.
For a discussion on the actual direction of the cut-torque tau and
of the rotation angle, see section
<a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.SignConventions\">Sign Conventions</a>
in the user's guide of Rotational.
</p>

<p>
If needed, the absolute angular velocity w and the
absolute angular acceleration a of the flange can be determined by
differentiation of the flange angle phi:
</p>

<blockquote><pre>
w = der(phi);
a = der(w);
</pre></blockquote>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={Text(
                      extent={{-160,90},{40,50}},
                      textString="%name"),Ellipse(
                      extent={{-40,40},{40,-40}},
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid)}));
        end Flange_a;

        connector Flange_b
          "One-dimensional rotational flange of a shaft (non-filled circle icon)"
          extends Flange;

          annotation (
            defaultComponentName="flange_b",
            Documentation(info="<html>
<p>
This is a connector for 1-dim. rotational mechanical systems and models which represents
a mechanical flange of a shaft. The following variables are defined in this connector:
</p>

<blockquote><pre>
phi: Absolute rotation angle of the shaft flange in [rad].
tau: Cut-torque in the shaft flange in [Nm].
</pre></blockquote>

<p>
There is a second connector for flanges:
<a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.Flange_a\">Flange_a</a>.
The connectors
Flange_a and Flange_b are completely identical. There is only a difference
in the icons, in order to easier identify a flange variable in a diagram.
For a discussion on the actual direction of the cut-torque tau and
of the rotation angle, see section
<a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.SignConventions\">Sign Conventions</a>
in the user's guide of Rotational.
</p>

<p>
If needed, the absolute angular velocity w and the
absolute angular acceleration a of the flange can be determined by
differentiation of the flange angle phi:
</p>

<blockquote><pre>
w = der(phi);
a = der(w);
</pre></blockquote>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={Ellipse(
                      extent={{-100,100},{100,-100}},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={Ellipse(
                      extent={{-40,40},{40,-40}},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),Text(
                      extent={{-40,90},{160,50}},
                      textString="%name")}));
        end Flange_b;

        connector Support "Support/housing flange of a one-dimensional rotational shaft"
          extends Flange;

          annotation (
            Documentation(info="<html>
<p>
This is a connector for 1-dim. rotational mechanical systems and models which represents
a support or housing of a shaft. The following variables are defined in this connector:
</p>

<blockquote><pre>
phi: Absolute rotation angle of the support/housing in [rad].
tau: Reaction torque in the support/housing in [Nm].
</pre></blockquote>

<p>
The support connector is usually defined as conditional connector.
It is most convenient to utilize it
</p>

<ul>
<li> For models to be build graphically (i.e., the model is build up by drag-and-drop
     from elementary components):<br>
     <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialOneFlangeAndSupport\">PartialOneFlangeAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport\">PartialTwoFlangesAndSupport</a>.<br> &nbsp;</li>

<li> For models to be build textually (i.e., elementary models):<br>
     <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport2\">PartialElementaryOneFlangeAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2\">PartialElementaryTwoFlangesAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational\">PartialElementaryRotationalToTranslational</a>.</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-150,150},{150,-150}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={Rectangle(
                      extent={{-60,60},{60,-60}},
                      lineColor={192,192,192},
                      fillColor={192,192,192},
                      fillPattern=FillPattern.Solid),Text(
                      extent={{-160,100},{40,60}},
                      textString="%name"),Ellipse(
                      extent={{-40,40},{40,-40}},
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid)}));
        end Support;

        model InternalSupport
          "Adapter model to utilize conditional support connector"
          input SI.Torque tau
            "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)";
          SI.Angle phi "External support angle (= flange.phi)";
          Flange_a flange
            "Internal support flange (must be connected to the conditional support connector for useSupport=true and to conditional fixed model for useSupport=false)"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation
          flange.tau = tau;
          flange.phi = phi;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Ellipse(
                      extent={{-20,20},{20,-20}},
                      lineColor={135,135,135},
                      fillColor={175,175,175},
                      fillPattern=FillPattern.Solid),Text(
                      extent={{-200,80},{200,40}},
                      textColor={0,0,255},
                      textString="%name")}), Documentation(info="<html>
<p>
This is an adapter model to utilize a&nbsp;conditional
<a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.Support\">support connector</a>
in a&nbsp;component. It could be applied to both textually (equations based) and graphically
defined components:
</p>

<ul>
<li> If <em>useSupport = true</em>, this flange has to be connected to the conditional
     support connector.</li>
<li> If <em>useSupport = false</em>, this flange has to be connected to the conditional
     fixed model.</li>
</ul>

<p>
Variable <strong>tau</strong> is defined as <strong>input</strong>. It must be
provided as a&nbsp;modifier and computed via a&nbsp;torque balance when using this
model in textually defined components.
This approach of internal support is utilized, e.g., via the following partial models:
</p>

<ul>
<li> <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialOneFlangeAndSupport\">PartialOneFlangeAndSupport</a>,</li>
<li> <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport\">PartialTwoFlangesAndSupport</a>,</li>
<li> <a href=\"modelica://Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational\">PartialElementaryRotationalToTranslational</a>.</li>
</ul>

<p>
Note, the support angle can always be accessed as internalSupport.phi, and
the support torque can always be accessed as internalSupport.tau.
</p>
</html>"));
        end InternalSupport;

        partial model PartialTwoFlanges
          "Partial model for a component with two rotational 1-dim. shaft flanges"

          Flange_a flange_a "Flange of left shaft" annotation (Placement(
                transformation(extent={{-110,-10},{-90,10}})));
          Flange_b flange_b "Flange of right shaft" annotation (Placement(
                transformation(extent={{90,-10},{110,10}})));
          annotation (Documentation(info="<html>
<p>
This is a 1-dim. rotational component with two flanges.
It is used e.g., to build up parts of a drive train consisting
of several components.
</p>
</html>"));
        end PartialTwoFlanges;

        partial model PartialCompliantWithRelativeStates
          "Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states"

          SI.Angle phi_rel(
            start=0,
            stateSelect=stateSelect,
            nominal=if phi_nominal >= Modelica.Constants.eps then phi_nominal else
                1) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
          SI.AngularVelocity w_rel(start=0, stateSelect=stateSelect)
            "Relative angular velocity (= der(phi_rel))";
          SI.AngularAcceleration a_rel(start=0)
            "Relative angular acceleration (= der(w_rel))";
          SI.Torque tau "Torque between flanges (= flange_b.tau)";
          Flange_a flange_a "Left flange of compliant 1-dim. rotational component"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Flange_b flange_b "Right flange of compliant 1-dim. rotational component"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          parameter SI.Angle phi_nominal(
            displayUnit="rad",
            min=0.0) = 1e-4 "Nominal value of phi_rel (used for scaling)"
            annotation (Dialog(tab="Advanced"));
          parameter StateSelect stateSelect=StateSelect.prefer
            "Priority to use phi_rel and w_rel as states"
            annotation (HideResult=true, Dialog(tab="Advanced"));

        equation
          phi_rel = flange_b.phi - flange_a.phi;
          w_rel = der(phi_rel);
          a_rel = der(w_rel);
          flange_b.tau = tau;
          flange_a.tau = -tau;
          annotation (Documentation(info="<html>
<p>
This is a 1-dim. rotational component with a compliant connection of two
rotational 1-dim. flanges where inertial effects between the two
flanges are neglected. The basic assumption is that the cut-torques
of the two flanges sum-up to zero, i.e., they have the same absolute value
but opposite sign: flange_a.tau + flange_b.tau = 0. This base class
is used to built up force elements such as springs, dampers, friction.
</p>

<p>
The relative angle and the relative speed are defined as preferred states.
The reason is that for some drive trains, such as drive
trains in vehicles, the absolute angle is quickly increasing during operation.
Numerically, it is better to use relative angles between drive train components
because they remain in a limited size. For this reason, StateSelect.prefer
is set for the relative angle of this component.
</p>

<p>
In order to improve the numerics, a nominal value for the relative angle
can be provided via parameter <strong>phi_nominal</strong> in the Advanced menu.
The default is 1e-4 rad since relative angles are usually
in this order and the step size control of an integrator would be
practically switched off, if a default of 1 rad would be used.
This nominal value might also be computed from other values, such
as \"phi_nominal = tau_nominal / c\" for a rotational spring, if tau_nominal
and c are more meaningful for the user.
</p>

<p>
See also the discussion
<a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.StateSelection\">State Selection</a>
in the User's Guide of the Rotational library.
</p>
</html>"));
        end PartialCompliantWithRelativeStates;

        partial model PartialElementaryOneFlangeAndSupport2
          "Partial model for a component with one rotational 1-dim. shaft flange and a support used for textual modeling, i.e., for elementary models"
          parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(checkBox=true));
          Flange_b flange "Flange of shaft" annotation (Placement(transformation(
                  extent={{90,-10},{110,10}})));
          Support support(phi=phi_support, tau=-flange.tau) if useSupport
            "Support/housing of component"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
      protected
          SI.Angle phi_support "Absolute angle of support flange";
        equation
          if not useSupport then
            phi_support = 0;
          end if;
          annotation (Documentation(info="<html>
<p>
This is a 1-dim. rotational component with one flange and a support/housing.
It is used to build up elementary components of a drive train with
equations in the text layer.
</p>

<p>
If <em>useSupport=true</em>, the support connector is conditionally enabled
and needs to be connected.<br>
If <em>useSupport=false</em>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),graphics={Line(
                      visible=not useSupport,
                      points={{-50,-120},{-30,-100}}),Line(
                      visible=not useSupport,
                      points={{-30,-120},{-10,-100}}),Line(
                      visible=not useSupport,
                      points={{-10,-120},{10,-100}}),Line(
                      visible=not useSupport,
                      points={{10,-120},{30,-100}}),Line(
                      visible=not useSupport,
                      points={{-30,-100},{30,-100}})}));
        end PartialElementaryOneFlangeAndSupport2;

        partial model PartialElementaryTwoFlangesAndSupport2
          "Partial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models"
          parameter Boolean useSupport=false
            "= true, if support flange enabled, otherwise implicitly grounded"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(checkBox=true));
          Flange_a flange_a "Flange of left shaft" annotation (Placement(
                transformation(extent={{-110,-10},{-90,10}})));
          Flange_b flange_b "Flange of right shaft" annotation (Placement(
                transformation(extent={{90,-10},{110,10}})));
          Support support(phi=phi_support, tau=-flange_a.tau - flange_b.tau)
         if useSupport "Support/housing of component"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
      protected
          SI.Angle phi_support "Absolute angle of support flange";
        equation
          if not useSupport then
            phi_support = 0;
          end if;

          annotation (Documentation(info="<html>
<p>
This is a 1-dim. rotational component with two flanges and a support/housing.
It is used to build up elementary components of a drive train with
equations in the text layer.
</p>

<p>
If <em>useSupport=true</em>, the support connector is conditionally enabled
and needs to be connected.<br>
If <em>useSupport=false</em>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),graphics={Line(
                      visible=not useSupport,
                      points={{-50,-120},{-30,-100}}),Line(
                      visible=not useSupport,
                      points={{-30,-120},{-10,-100}}),Line(
                      visible=not useSupport,
                      points={{-10,-120},{10,-100}}),Line(
                      visible=not useSupport,
                      points={{10,-120},{30,-100}}),Line(
                      visible=not useSupport,
                      points={{-30,-100},{30,-100}})}));
        end PartialElementaryTwoFlangesAndSupport2;

        partial model PartialElementaryRotationalToTranslational
          "Partial model to transform rotational into translational motion"
          parameter Boolean useSupportR=false
            "= true, if rotational support flange enabled, otherwise implicitly grounded"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(checkBox=true));
          parameter Boolean useSupportT=false
            "= true, if translational support flange enabled, otherwise implicitly grounded"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(checkBox=true));
          Rotational.Interfaces.Flange_a flangeR "Flange of rotational shaft"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Mechanics.Translational.Interfaces.Flange_b flangeT
            "Flange of translational rod" annotation (Placement(transformation(
                  extent={{90,10},{110,-10}})));
          Rotational.Interfaces.Support supportR if useSupportR
            "Rotational support/housing of component" annotation (Placement(
                transformation(extent={{-110,-110},{-90,-90}})));
          Translational.Interfaces.Support supportT if useSupportT
            "Translational support/housing of component"
            annotation (Placement(transformation(extent={{110,-110},{90,-90}})));

      protected
          Rotational.Interfaces.InternalSupport internalSupportR(tau=-flangeR.tau)
            annotation (Placement(transformation(extent={{-110,-90},{-90,-70}})));
          Translational.Interfaces.InternalSupport internalSupportT(f=-flangeT.f)
            annotation (Placement(transformation(extent={{90,-90},{110,-70}})));
          Rotational.Components.Fixed fixedR if not useSupportR
            annotation (Placement(transformation(extent={{-90,-94},{-70,-74}})));
          Translational.Components.Fixed fixedT if not useSupportT
            annotation (Placement(transformation(extent={{70,-94},{90,-74}})));
        equation
          connect(internalSupportR.flange, supportR) annotation (Line(
              points={{-100,-80},{-100,-100}}));
          connect(internalSupportR.flange, fixedR.flange) annotation (Line(
              points={{-100,-80},{-80,-80},{-80,-84}}));
          connect(fixedT.flange, internalSupportT.flange) annotation (Line(
              points={{80,-84},{80,-80},{100,-80}},
                                           color={0,127,0}));
          connect(internalSupportT.flange, supportT) annotation (Line(
              points={{100,-80},{100,-100}}, color={0,127,0}));
          annotation (Documentation(info="<html>

<p>
This is a 1-dim. rotational component with
</p>

<ul>
<li> one rotational flange,</li>
<li> one rotational support/housing,</li>
<li> one translational flange, and</li>
<li> one translational support/housing</li>
</ul>

<p>
This model is used to build up elementary components of a drive train
transforming rotational into translational motion with
equations in the text layer.
</p>

<p>
If <em>useSupportR=true</em>, the rotational support connector is conditionally enabled
and needs to be connected.<br>
If <em>useSupportR=false</em>, the rotational support connector is conditionally disabled
and instead the rotational part is internally fixed to ground.<br>
If <em>useSupportT=true</em>, the translational support connector is conditionally enabled
and needs to be connected.<br>
If <em>useSupportT=false</em>, the translational support connector is conditionally disabled
and instead the translational part is internally fixed to ground.
</p>
</html>"),     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Line(
                  visible=not useSupportT,
                  points={{85,-110},{95,-100}}, color={0,127,0}),
                Line(
                  visible=not useSupportT,
                  points={{95,-110},{105,-100}}, color={0,127,0}),
                Line(
                  visible=not useSupportT,
                  points={{105,-110},{115,-100}}, color={0,127,0}),
                Line(
                  visible=not useSupportT,
                  points={{85,-100},{115,-100}}, color={0,127,0}),
                Line(
                  visible=not useSupportR,
                  points={{-115,-110},{-105,-100}}),
                Line(
                  visible=not useSupportR,
                  points={{-105,-110},{-95,-100}}),
                Line(
                  visible=not useSupportR,
                  points={{-95,-110},{-85,-100}}),
                Line(
                  visible=not useSupportR,
                  points={{-115,-100},{-85,-100}})}));
        end PartialElementaryRotationalToTranslational;

        partial model PartialTorque
          "Partial model of a torque acting at the flange (accelerates the flange)"
          extends
          Modelica.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport2;
          SI.Angle phi
            "Angle of flange with respect to support (= flange.phi - support.phi)";

        equation
          phi = flange.phi - phi_support;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-96,96},{96,-96}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,-62},{0,-100}}),
                Text(
                  extent={{-150,150},{150,110}},
                  textColor={0,0,255},
                  textString="%name"),
                Polygon(
                  points={{94,26},{80,84},{50,62},{94,26}},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,-98},{-30,-80},{-42,-72},{-50,-98}},
                  fillPattern=FillPattern.Solid),
                Line(
                  visible=not useSupport,
                  points={{-50,-120},{-30,-100}}),
                Line(
                  visible=not useSupport,
                  points={{-30,-120},{-10,-100}}),
                Line(
                  visible=not useSupport,
                  points={{-10,-120},{10,-100}}),
                Line(
                  visible=not useSupport,
                  points={{10,-120},{30,-100}}),
                Line(
                  visible=not useSupport,
                  points={{-30,-100},{30,-100}}),
            Line(
              points={{-48,-92},{-38,-76},{-18,-64},{0,-60},{18,-64},{38,-76},{48,-92}},
              smooth=Smooth.Bezier),
            Line(
              points={{-86,40},{-74,66},{-56,86},{-20,100},{20,100},{60,80},{82,48}},
              smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
Partial model of torque that accelerates the flange.
</p>

<p>
If <em>useSupport=true</em>, the support connector is conditionally enabled
and needs to be connected.<br>
If <em>useSupport=false</em>, the support connector is conditionally disabled
and instead the component is internally fixed to ground.
</p>
</html>"));
        end PartialTorque;

        partial model PartialFriction "Partial model of Coulomb friction elements"

          // parameter SI.AngularVelocity w_small=1 "Relative angular velocity near to zero (see model info text)";
          parameter SI.AngularVelocity w_small=1.0e10
            "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)"
            annotation (Dialog(tab="Advanced"));
          // Equations to define the following variables have to be defined in subclasses
          SI.AngularVelocity w_relfric
            "Relative angular velocity between frictional surfaces";
          SI.AngularAcceleration a_relfric
            "Relative angular acceleration between frictional surfaces";
          //SI.Torque tau "Friction torque (positive, if directed in opposite direction of w_rel)";
          SI.Torque tau0 "Friction torque for w_relfric=0 and forward sliding";
          SI.Torque tau0_max "Maximum friction torque for w_relfric=0 and locked";
          Boolean free "= true, if frictional element is not active";
          // Equations to define the following variables are given in this class
          Real sa(final unit="1")
            "Path parameter of friction characteristic tau = f(a_relfric)";
          Boolean startForward(start=false, fixed=true)
            "= true, if w_relfric=0 and start of forward sliding";
          Boolean startBackward(start=false, fixed=true)
            "= true, if w_relfric=0 and start of backward sliding";
          Boolean locked(start=false) "= true, if w_rel=0 and not sliding";
          constant Integer Unknown=3 "Value of mode is not known";
          constant Integer Free=2 "Element is not active";
          constant Integer Forward=1 "w_relfric > 0 (forward sliding)";
          constant Integer Stuck=0
            "w_relfric = 0 (forward sliding, locked or backward sliding)";
          constant Integer Backward=-1 "w_relfric < 0 (backward sliding)";
          Integer mode(
            final min=Backward,
            final max=Unknown,
            start=Unknown,
            fixed=true)
            "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown)";
      protected
          constant SI.AngularAcceleration unitAngularAcceleration=1
            annotation (HideResult=true);
          constant SI.Torque unitTorque=1 annotation (HideResult=true);
        equation
          /* Friction characteristic
   locked is introduced to help the Modelica translator determining
   the different structural configurations,
   if for each configuration special code shall be generated
*/
          startForward = pre(mode) == Stuck and (sa > tau0_max/unitTorque or pre(
            startForward) and sa > tau0/unitTorque) or pre(mode) == Backward and
            w_relfric > w_small or initial() and (w_relfric > 0);
          startBackward = pre(mode) == Stuck and (sa < -tau0_max/unitTorque or pre(
            startBackward) and sa < -tau0/unitTorque) or pre(mode) == Forward and
            w_relfric < -w_small or initial() and (w_relfric < 0);
          locked = not free and not (pre(mode) == Forward or startForward or pre(
            mode) == Backward or startBackward);

          a_relfric/unitAngularAcceleration = if locked then 0 else if free then sa
             else if startForward then sa - tau0_max/unitTorque else if
            startBackward then sa + tau0_max/unitTorque else if pre(mode) ==
            Forward then sa - tau0_max/unitTorque else sa + tau0_max/unitTorque;

          /* Friction torque has to be defined in a subclass. Example for a clutch:
   tau = if locked then sa else
         if free then   0 else
         cgeo*fn*(if startForward then          Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], w_relfric, 1) else
                  if startBackward then        -Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], -w_relfric, 1) else
                  if pre(mode) == Forward then  Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], w_relfric, 1) else
                                               -Modelica.Math.Vectors.interpolate(mu_pos[:,1], mu_pos[:,2], -w_relfric, 1));
*/
          // finite state machine to determine configuration
          mode = if free then Free else (if (pre(mode) == Forward or pre(mode) ==
            Free or startForward) and w_relfric > 0 then Forward else if (pre(mode)
             == Backward or pre(mode) == Free or startBackward) and w_relfric < 0
             then Backward else Stuck);
          annotation (Documentation(info="<html>
<p>
Basic model for Coulomb friction that models the stuck phase in a reliable way.
</p>

<p>
This procedure is implemented in a \"clean\" way by state events and
leads to a mixed continuous/discrete systems of equations if friction elements
are dynamically coupled which have to be solved by appropriate
numerical methods. The method is described in
(see also a short sketch in <a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide.ModelingOfFriction\">UsersGuide.ModelingOfFriction</a>):
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):</dt>
<dd><strong>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</dd>
</dl>
</html>"));
        end PartialFriction;
        annotation (Documentation(info="<html>
<p>
This package contains connectors and partial models for 1-dim.
rotational mechanical components. The components of this package can
only be used as basic building elements for models.
</p>
</html>"));
      end Interfaces;

      package Icons "Icons for Rotational package"
        extends Modelica.Icons.IconsPackage;

        partial class Gear "Icon of a rotational gear"

          annotation (Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
              Rectangle(
                origin={-35.0,60.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-15.0,-40.0},{15.0,40.0}}),
              Rectangle(
                origin={-35.0,0.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-15.0,-21.0},{15.0,21.0}}),
              Line(
                points={{-80.0,20.0},{-60.0,20.0}}),
              Line(
                points={{-80.0,-20.0},{-60.0,-20.0}}),
              Line(
                points={{-70.0,-20.0},{-70.0,-86.0}}),
              Line(
                points={{0.0,40.0},{0.0,-86.0}}),
              Line(
                points={{-10.0,40.0},{10.0,40.0}}),
              Line(
                points={{-10.0,80.0},{10.0,80.0}}),
              Line(
                points={{60.0,-20.0},{80.0,-20.0}}),
              Line(
                points={{60.0,20.0},{80.0,20.0}}),
              Line(
                points={{70.0,-20.0},{70.0,-86.0}}),
              Line(
                points={{70.0,-86.0},{-70.0,-86.0}}),
              Rectangle(
                origin={-75.0,0.0},
                lineColor={64,64,64},
                fillColor={191,191,191},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-25.0,-10.0},{25.0,10.0}}),
              Rectangle(
                origin={75.0,0.0},
                lineColor={64,64,64},
                fillColor={191,191,191},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-25.0,-10.0},{25.0,10.0}}),
              Rectangle(
                origin={-35.0,-19.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={-35.0,-8.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={-35.0,19.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={-35.0,8.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={0.0,60.0},
                lineColor={64,64,64},
                fillColor={191,191,191},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-20.0,-10.0},{20.0,10.0}}),
              Rectangle(
                origin={-35.0,98.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={-35.0,87.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={-35.0,50.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-4.0},{15.0,4.0}}),
              Rectangle(
                origin={-35.0,22.0},
                fillColor={102,102,102},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={-35.0,33.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={-35.0,70.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-4.0},{15.0,4.0}}),
              Rectangle(
                origin={35.0,60.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-15.0,-21.0},{15.0,21.0}}),
              Rectangle(
                origin={35.0,41.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={35.0,52.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={35.0,79.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={35.0,68.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={35.0,0.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-15.0,-40.0},{15.0,40.0}}),
              Rectangle(
                origin={35.0,38.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={35.0,27.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={35.0,-10.0},
                fillColor={204,204,204},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-4.0},{15.0,4.0}}),
              Rectangle(
                origin={35.0,-38.0},
                fillColor={102,102,102},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-2.0},{15.0,2.0}}),
              Rectangle(
                origin={35.0,-27.0},
                fillColor={153,153,153},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-3.0},{15.0,3.0}}),
              Rectangle(
                origin={35.0,10.0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-15.0,-4.0},{15.0,4.0}}),
              Rectangle(
                origin = {-35,40},
                fillColor = {255,255,255},
                extent = {{-15,-61},{15,60}}),
              Rectangle(
                origin = {35,21},
                fillColor = {255,255,255},
                extent = {{-15,-61},{15,60}})}), Documentation(
                info="<html>
<p>
This is the icon of a gear from the rotational package.
</p>
</html>"));
        end Gear;

        model Clutch "Icon of a clutch"

          annotation (Icon(graphics={
              Rectangle(  lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-10.0},{-30.0,10.0}}),
              Rectangle(  lineColor={64,64,64},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-30.0,-60.0},{-10.0,60.0}}),
              Rectangle(  lineColor={64,64,64},
                extent={{-30.0,-60.0},{-10.0,60.0}}),
              Rectangle(  lineColor={64,64,64},
                fillColor={255,255,255},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{10.0,-60.0},{30.0,60.0}}),
              Rectangle(  lineColor={64,64,64},
                extent={{10.0,-60.0},{30.0,60.0}}),
              Rectangle(  lineColor={64,64,64},
                fillColor={192,192,192},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{30.0,-10.0},{100.0,10.0}}),
              Polygon(  lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                points={{-30.0,40.0},{-60.0,50.0},{-60.0,30.0},{-30.0,40.0}}),
              Polygon(  lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                points={{30.0,40.0},{60.0,50.0},{60.0,30.0},{30.0,40.0}}),
              Line(  points={{0.0,90.0},{90.0,70.0},{90.0,40.0},{30.0,40.0}},
                color={0,0,127}),
              Line(  points={{0.0,90.0},{-90.0,70.0},{-90.0,40.0},{-30.0,40.0}},
                color={0,0,127})},
              coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
                preserveAspectRatio=true)),
              Documentation(info="<html>
<p>
This is the icon of a clutch from the rotational package.
</p>
</html>"));

        end Clutch;
        annotation (
          Documentation(info="<html>
<p>
This package contains icons for the Rotational library
(that is, all the components have only graphical annotations
without any equations).
</p>
</html>"));
      end Icons;
      annotation (Documentation(info="<html>

<p>
Library <strong>Rotational</strong> is a <strong>free</strong> Modelica package providing
1-dimensional, rotational mechanical components to model in a convenient way
drive trains with frictional losses. A typical, simple example is shown
in the next figure:
</p>

<div><img src=\"modelica://Modelica/Resources/Images/Mechanics/Rotational/driveExample.png\"></div>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Mechanics.Rotational.UsersGuide\">Rotational.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.Mechanics.Rotational.Examples\">Rotational.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
In version 3.0 of the Modelica Standard Library, the basic design of the
library has changed: Previously, bearing connectors could or could not be connected.
In 3.0, the bearing connector is renamed to \"<strong>support</strong>\" and this connector
is enabled via parameter \"useSupport\". If the support connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
</p>

<p>
In version 3.2 of the Modelica Standard Library, all <strong>dissipative</strong> components
of the Rotational library got an optional <strong>heatPort</strong> connector to which the
dissipated energy is transported in form of heat. This connector is enabled
via parameter \"useHeatPort\". If the heatPort connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
Independently, whether the heatPort is enabled or not,
the dissipated power is available from the new variable \"<strong>lossPower</strong>\" (which is
positive if heat is flowing out of the heatPort). For an example, see
<a href=\"modelica://Modelica.Mechanics.Rotational.Examples.HeatLosses\">Examples.HeatLosses</a>.
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",     revisions=""), Icon(
        coordinateSystem(preserveAspectRatio=true,
          extent={{-100.0,-100.0},{100.0,100.0}}),
          graphics={
        Line(origin={-2.0,46.0},
          points={{-83.0,-66.0},{-63.0,-66.0}}),
        Line(origin={29.0,48.0},
          points={{36.0,-68.0},{56.0,-68.0}}),
        Line(origin={-2.0,49.0},
          points={{-83.0,-29.0},{-63.0,-29.0}}),
        Line(origin={29.0,52.0},
          points={{36.0,-32.0},{56.0,-32.0}}),
        Line(origin={-2.0,49.0},
          points={{-73.0,-9.0},{-73.0,-29.0}}),
        Line(origin={29.0,52.0},
          points={{46.0,-12.0},{46.0,-32.0}}),
        Line(origin={-0.0,-47.5},
          points={{-75.0,27.5},{-75.0,-27.5},{75.0,-27.5},{75.0,27.5}}),
        Rectangle(origin={13.5135,76.9841},
          lineColor={64,64,64},
          fillColor={255,255,255},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-63.5135,-126.9841},{36.4865,-26.9841}},
          radius=10.0),
        Rectangle(origin={13.5135,76.9841},
          lineColor={64,64,64},
          extent={{-63.5135,-126.9841},{36.4865,-26.9841}},
          radius=10.0),
        Rectangle(origin={-3.0,73.0769},
          lineColor={64,64,64},
          fillColor={192,192,192},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-87.0,-83.0769},{-47.0,-63.0769}}),
        Rectangle(origin={22.3077,70.0},
          lineColor={64,64,64},
          fillColor={192,192,192},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{27.6923,-80.0},{67.6923,-60.0}})}));
    end Rotational;

    package Translational
    "Library to model 1-dimensional, translational mechanical systems"
      extends Modelica.Icons.Package;

      package Components
      "Components for 1D translational mechanical drive trains"
        extends Modelica.Icons.Package;

        model Fixed "Fixed flange"
          parameter SI.Position s0=0 "Fixed offset position of housing";

          Interfaces.Flange_b flange annotation (Placement(transformation(
                extent={{-10,10},{10,-10}},
                rotation=180)));
        equation
          flange.s = s0;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(points={{-80,-40},{80,-40}}, color={0,127,0}),
                Line(points={{80,-40},{40,-80}}, color={0,127,0}),
                Line(points={{40,-40},{0,-80}}, color={0,127,0}),
                Line(points={{0,-40},{-40,-80}}, color={0,127,0}),
                Line(points={{-40,-40},{-80,-80}}, color={0,127,0}),
                Line(points={{0,-40},{0,-10}}, color={0,127,0}),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  textColor={0,0,255})}), Documentation(info="<html>
<p>
The <em>flange</em> of a 1D translational mechanical system <em>fixed</em>
at an position s0 in the <em>housing</em>. May be used:
</p>
<ul>
<li> to connect a compliant element, such as a spring or a damper,
     between a sliding mass and the housing.</li>
<li> to fix a rigid element, such as a sliding mass, at a specific
     position.</li>
</ul>

</html>"));
        end Fixed;

        model Mass "Sliding mass with inertia"
          parameter SI.Mass m(min=0, start=1) "Mass of the sliding mass";
          parameter StateSelect stateSelect=StateSelect.default
            "Priority to use s and v as states" annotation (Dialog(tab="Advanced"));
          extends Translational.Interfaces.PartialRigid(L=0,s(start=0, stateSelect=
                  stateSelect));
          SI.Velocity v(start=0, stateSelect=stateSelect)
            "Absolute velocity of component";
          SI.Acceleration a(start=0) "Absolute acceleration of component";

        equation
          v = der(s);
          a = der(v);
          m*a = flange_a.f + flange_b.f;
          annotation (
            Documentation(info="<html>
<p>
Sliding mass with <em>inertia, without friction</em> and two rigidly connected flanges.
</p>
<p>
The sliding mass has the length L, the position coordinate s is in the middle.
Sign convention: A positive force at flange flange_a moves the sliding mass in the positive direction.
A negative force at flange flange_a moves the sliding mass to the negative direction.
</p>

</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-100,0},{100,0}}, color={0,127,0}),
                Rectangle(
                  extent={{-55,-30},{56,30}},
                  fillPattern=FillPattern.Sphere,
                  fillColor={160,215,160},
                  lineColor={0,127,0}),
                Polygon(
                  points={{50,-90},{20,-80},{20,-100},{50,-90}},
                  lineColor={95,127,95},
                  fillColor={95,127,95},
                  fillPattern=FillPattern.Solid),
                Line(points={{-60,-90},{20,-90}}, color={95,127,95}),
                Text(
                  extent={{-150,85},{150,45}},
                  textString="%name",
                  textColor={0,0,255},
                  fillColor={110,210,110},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-45},{150,-75}},
                  textString="m=%m",
                  fillColor={110,221,110},
                  fillPattern=FillPattern.Solid,
                  fontSize=0)}));
        end Mass;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Rectangle(
                origin={11.5,31.183},
                lineColor={64,64,64},
                fillColor={255,255,255},
                fillPattern=FillPattern.Sphere,
                extent={{-67,-66},{44,-6}})}), Documentation(info="<html>
<p>
This package contains basic components 1D mechanical translational drive trains.
</p>
</html>"));
      end Components;

      package Interfaces
      "Interfaces for 1-dim. translational mechanical components"
        extends Modelica.Icons.InterfacesPackage;

        connector Flange "One-dimensional translational flange"

          SI.Position s "Absolute position of flange";
          flow SI.Force f "Cut force directed into flange";
          annotation (
            Documentation(info="<html>
<p>
This is a connector for 1D translational mechanical systems.
It has no icon definition and is only used by inheritance from
flange connectors to define different icons.
</p>
<p>
The following variables are defined in this connector:
</p>

<blockquote><pre>
s: Absolute position of the flange in [m]. A positive translation
   means that the flange is translated along the flange axis.
f: Cut-force in direction of the flange axis in [N].
</pre></blockquote>
</html>"));
        end Flange;

        connector Flange_a
          "One-dimensional translational flange (left, flange axis directed INTO cut plane)"
          extends Flange;

          annotation (
            defaultComponentName="flange_a",
            Documentation(info="<html>
<p>
This is a connector for 1-dim. translational mechanical systems which represents
a mechanical flange. In the cut plane of
the flange a unit vector n, called flange axis, is defined which is directed
INTO the cut plane, i. e. from left to right. All vectors in the cut plane are
resolved with respect to
this unit vector. E.g. force f characterizes a vector which is directed in
the direction of n with value equal to f. When this flange is connected to
other 1D translational flanges, this means that the axes vectors of the connected
flanges are identical.
</p>
<p>
The following variables are transported through this connector:
</p>

<blockquote><pre>
s: Absolute position of the flange in [m]. A positive translation
   means that the flange is translated along the flange axis.
f: Cut-force in direction of the flange axis in [N].
</pre></blockquote>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,127,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,127,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-160,110},{40,50}},
                  textColor={0,127,0},
                  textString="%name")}));
        end Flange_a;

        connector Flange_b
          "One-dimensional translational flange (right, flange axis directed OUT OF cut plane)"
          extends Flange;

          annotation (
            defaultComponentName="flange_b",
            Documentation(info="<html>
<p>
This is a connector for 1-dim. translational mechanical systems which represents
a mechanical flange. In the cut plane of
the flange a unit vector n, called flange axis, is defined which is directed
OUT OF the cut plane. All vectors in the cut plane are resolved with respect to
this unit vector. E.g. force f characterizes a vector which is directed in
the direction of n with value equal to f. When this flange is connected to
other 1D translational flanges, this means that the axes vectors of the connected
flanges are identical.
</p>
<p>
The following variables are transported through this connector:
</p>

<blockquote><pre>
s: Absolute position of the flange in [m]. A positive translation
   means that the flange is translated along the flange axis.
f: Cut-force in direction of the flange axis in [N].
</pre></blockquote>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,127,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-40,-40},{40,40}},
                  lineColor={0,127,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-40,110},{160,50}},
                  textColor={0,127,0},
                  textString="%name")}));
        end Flange_b;

        connector Support "Support/housing flange of a one-dimensional translational component"
          extends Flange;

          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                      extent={{-60,60},{60,-60}},
                      fillColor={175,190,175},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),           Text(
                      extent={{-160,110},{40,50}},
                      textColor={0,127,0},
                      textString="%name"),Rectangle(
                      extent={{-40,-40},{40,40}},
                      lineColor={0,127,0},
                      fillColor={0,127,0},
                      fillPattern=FillPattern.Solid)}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                      extent={{-90,-90},{90,90}},
                      lineColor={0,127,0},
                      fillColor={175,175,175},
                      fillPattern=FillPattern.Solid),Rectangle(
                  extent={{-150,150},{150,-150}},
                  fillColor={175,190,175},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),    Rectangle(
                      extent={{-90,-90},{90,90}},
                      lineColor={0,127,0},
                      fillColor={0,127,0},
                      fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This is a connector for 1-dim. translational mechanical systems and models
the support or housing of a shaft.
The following variables are defined in this connector:
</p>

<blockquote><pre>
s: Absolute position of the support/housing in [m].
f: Reaction force in the support/housing in [N].
</pre></blockquote>

<p>
The support connector is usually defined as conditional connector. It is most convenient to utilize it
</p>
<ul>
<li> For models to be build graphically (i.e., the model is build up by drag-and-drop
     from elementary components):<br>
     <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialOneFlangeAndSupport\">PartialOneFlangeAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialTwoFlangesAndSupport\">PartialTwoFlangesAndSupport</a>.<br>&nbsp;</li>
<li> For models to be build textually (i.e., elementary models):<br>
     <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialElementaryOneFlangeAndSupport2\">PartialElementaryOneFlangeAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialElementaryTwoFlangesAndSupport2\">PartialElementaryTwoFlangesAndSupport</a>,<br>
     <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational\">PartialElementaryRotationalToTranslational</a>.</li>
</ul>
</html>"));
        end Support;

        model InternalSupport
          "Adapter model to utilize conditional support connector"
          input SI.Force f
            "External support force (must be computed via force balance in model where InternalSupport is used; = flange.f)";
          SI.Position s "External support position (= flange.s)";
          Flange_a flange
            "Internal support flange (must be connected to the conditional support connector for useSupport=true and to conditional fixed model for useSupport=false)"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation
          flange.f = f;
          flange.s = s;
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-200,80},{200,40}},
                      textColor={0,0,255},
                      textString="%name"),Rectangle(
                      extent={{-20,20},{20,-20}},
                      lineColor={0,127,0},
                      fillColor={175,190,175},
                      fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
This is an adapter model to utilize a&nbsp;conditional
<a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.Support\">support connector</a>
in a&nbsp;component. It could be applied to both textually (equations based) and graphically
defined components:
</p>

<ul>
<li> If <em>useSupport = true</em>, this flange has to be connected to the conditional
     support connector.</li>
<li> If <em>useSupport = false</em>, this flange has to be connected to the conditional
     fixed model.</li>
</ul>

<p>
Variable <strong>f</strong> is defined as <strong>input</strong>. It must be
provided as a&nbsp;modifier and computed via a&nbsp;force balance when using this
model in textually defined components.
This approach of internal support is utilized, e.g., via the following partial models:
</p>

<ul>
<li> <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialOneFlangeAndSupport\">PartialOneFlangeAndSupport</a>,</li>
<li> <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialTwoFlangesAndSupport\">PartialTwoFlangesAndSupport</a>,</li>
<li> <a href=\"modelica://Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational\">PartialElementaryRotationalToTranslational</a>.</li>
</ul>

<p>
Note, the support position can always be accessed as internalSupport.s, and
the support force can always be accessed as internalSupport.f.
</p>
</html>"));
        end InternalSupport;

        partial model PartialTwoFlanges
          "Component with two translational 1D flanges"

          Flange_a flange_a
            "(left) driving flange (flange axis directed into cut plane, e. g. from left to right)"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Flange_b flange_b
            "(right) driven flange (flange axis directed out of cut plane)"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          annotation (Documentation(info="<html>
<p>
This is a 1D translational component with two flanges.
It is used e.g., to built up parts of a drive train consisting
of several base components.
</p>
</html>"));
        end PartialTwoFlanges;

        partial model PartialRigid
          "Rigid connection of two translational 1D flanges"
          SI.Position s
            "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
          parameter SI.Length L(start=0)
            "Length of component, from left flange to right flange (= flange_b.s - flange_a.s)";
          extends Translational.Interfaces.PartialTwoFlanges;
        equation
          flange_a.s = s - L/2;
          flange_b.s = s + L/2;
          annotation (Documentation(info="<html>
<p>
This is a 1-dim. translational component with two <em>rigidly</em> connected flanges.
The fixed distance between the left and the right flange is defined by parameter \"L\".
The forces at the right and left flange can be different.
It is used e.g., to built up sliding masses.
</p>
</html>"));
        end PartialRigid;

        partial model PartialCompliant
          "Compliant connection of two translational 1D flanges"

          extends Translational.Interfaces.PartialTwoFlanges;
          SI.Position s_rel(start=0)
            "Relative distance (= flange_b.s - flange_a.s)";
          SI.Force f
            "Force between flanges (positive in direction of flange axis R)";

        equation
          s_rel = flange_b.s - flange_a.s;
          flange_b.f = f;
          flange_a.f = -f;
          annotation (Documentation(info="<html>
<p>
This is a 1D translational component with a <em>compliant</em> connection of two
translational 1D flanges where inertial effects between the two
flanges are not included. The absolute value of the force at the left and the right
flange is the same. It is used to built up springs, dampers etc.
</p>

</html>"));
        end PartialCompliant;
        annotation (Documentation(info="<html>
<p>
This package contains connectors and partial models for 1-dim.
translational mechanical components. The components of this package can
only be used as basic building elements for models.
</p>
</html>"));
      end Interfaces;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                {100,100}}), graphics={
            Line(origin={14,53}, points={{-84,-73},{66,-73}}),
            Rectangle(
              origin={14,53},
              lineColor={64,64,64},
              fillColor={192,192,192},
              fillPattern=FillPattern.Sphere,
              extent={{-81,-65},{-8,-22}}),
            Line(
              origin={14,53},
              points={{-8,-43},{-1,-43},{6,-64},{17,-23},{29,-65},{40,-23},{50,-44},
                  {61,-44}}),
            Line(origin={14,53}, points={{-59,-73},{-84,-93}}),
            Line(origin={14,53}, points={{-11,-73},{-36,-93}}),
            Line(origin={14,53}, points={{-34,-73},{-59,-93}}),
            Line(origin={14,53}, points={{14,-73},{-11,-93}}),
            Line(origin={14,53}, points={{39,-73},{14,-93}}),
            Line(origin={14,53}, points={{63,-73},{38,-93}})}), Documentation(info="<html>
<p>
This package contains components to model <em>1-dimensional translational
mechanical</em> systems.
</p>
<p>
The <em>filled</em> and <em>non-filled green squares</em> at the left and
right side of a component represent <em>mechanical flanges</em>.
Drawing a line between such squares means that the corresponding
flanges are <em>rigidly attached</em> to each other. The components of this
library can be usually connected together in an arbitrary way. E.g. it is
possible to connect two springs or two sliding masses with inertia directly
together.
</p>
<p> The only <em>connection restriction</em> is that the Coulomb friction
elements (e.g., MassWithStopAndFriction) should be only connected
together provided a compliant element, such as a spring, is in between.
The reason is that otherwise the frictional force is not uniquely
defined if the elements are stuck at the same time instant (i.e., there
does not exist a unique solution) and some simulation systems may not be
able to handle this situation, since this leads to a singularity during
simulation. It can only be resolved in a \"clean way\" by combining the
two connected friction elements into
one component and resolving the ambiguity of the frictional force in the
stuck mode.
</p>
<p> Another restriction arises if the hard stops in model MassWithStopAndFriction are used, i. e.
the movement of the mass is limited by a stop at smax or smin.
<font color=\"#ff0000\"> <strong>This requires the states Stop.s and Stop.v</strong> </font>. If these states are eliminated during the index reduction
the model will not work. To avoid this any inertias should be connected via springs
to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided.</p>
<p>
In the <em>icon</em> of every component an <em>arrow</em> is displayed in grey
color. This arrow characterizes the coordinate system in which the vectors
of the component are resolved. It is directed into the positive
translational direction (in the mathematical sense).
In the flanges of a component, a coordinate system is rigidly attached
to the flange. It is called <em>flange frame</em> and is directed in parallel
to the component coordinate system. As a result, e.g., the positive
cut-force of a \"left\" flange (flange_a) is directed into the flange, whereas
the positive cut-force of a \"right\" flange (flange_b) is directed out of the
flange. A flange is described by a Modelica connector containing
the following variables:
</p>
<blockquote><pre>
Modelica.Units.SI.Position s    \"Absolute position of flange\";
<strong>flow</strong> Modelica.Units.SI.Force f  \"Cut-force in the flange\";
</pre></blockquote>

<p>
This library is designed in a fully object oriented way in order that
components can be connected together in every meaningful combination
(e.g., direct connection of two springs or two shafts with inertia).
As a consequence, most models lead to a system of
differential-algebraic equations of <em>index 3</em> (= constraint
equations have to be differentiated twice in order to arrive at
a state space representation) and the Modelica translator or
the simulator has to cope with this system representation.
According to our present knowledge, this requires that the
Modelica translator is able to symbolically differentiate equations
(otherwise it is e.g., not possible to provide consistent initial
conditions; even if consistent initial conditions are present, most
numerical DAE integrators can cope at most with index 2 DAEs).
</p>

<p>
In version 3.2 of the Modelica Standard Library, all <strong>dissipative</strong> components
of the Translational library got an optional <strong>heatPort</strong> connector to which the
dissipated energy is transported in form of heat. This connector is enabled
via parameter \"useHeatPort\". If the heatPort connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
Independently, whether the heatPort is enabled or not,
the dissipated power is available from the new variable \"<strong>lossPower</strong>\" (which is
positive if heat is flowing out of the heatPort). For an example, see
<a href=\"modelica://Modelica.Mechanics.Translational.Examples.HeatLosses\">Examples.HeatLosses</a>.
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",     revisions="<html>
<ul>
<li><em>Version 1.2.0 2010-07-22</em>
       by Anton Haumer and Martin Otter<br>
       heatPort introduced for all dissipative elements, and
       text in icons improved.
       <br></li>

<li><em>Version 1.1.0 2007-11-16</em>
       by Anton Haumer<br>
       Redesign for Modelica 3.0-compliance<br>
       Added new components according to Mechanics.Rotational library
       <br></li>

<li><em>Version 1.01 (July 18, 2001)</em>
       by Peter Beater<br>
       Assert statement added to \"Stop\", small bug fixes in examples.
       <br></li>

<li><em>Version 1.0 (January 5, 2000)</em>
       by Peter Beater<br>
       Realized a first version based on Modelica library Mechanics.Rotational
       by Martin Otter and an existing Dymola library onedof.lib by Peter Beater.</li>
</ul>
</html>"));
    end Translational;
    annotation (
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={8.6,63.3333},
          lineColor={64,64,64},
          fillColor={192,192,192},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-4.6,-93.3333},{41.4,-53.3333}}),
        Ellipse(
          origin={9.0,46.0},
          extent={{-90.0,-60.0},{-80.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-85.0,-55.0},{-60.0,-21.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          extent={{-65.0,-26.0},{-55.0,-16.0}}),
        Line(
          origin={9.0,46.0},
          points={{-60.0,-21.0},{9.0,-55.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          fillPattern=FillPattern.Solid,
          extent={{4.0,-60.0},{14.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-10.0,-26.0},{72.0,-26.0},{72.0,-86.0},{-10.0,-86.0}})}),
    Documentation(info="<html>
<p>
This package contains components to model the movement
of 1-dim. rotational, 1-dim. translational, and
3-dim. <strong>mechanical systems</strong>.
</p>

<p>
Note, all <strong>dissipative</strong> components of the Modelica.Mechanics library have
an optional <strong>heatPort</strong> connector to which the
dissipated energy is transported in form of heat. This connector is enabled
via parameter \"useHeatPort\". If the heatPort connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
Independently, whether the heatPort is enabled or not,
the dissipated power is available from variable \"<strong>lossPower</strong>\" (which is
positive if heat is flowing out of the heatPort).
</p>
</html>"));
  end Mechanics;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      extends Modelica.Icons.Package;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          SI.Temperature T "Port temperature";
          flow SI.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
          "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<blockquote><pre>
T       Temperature in [Kelvin].
Q_flow  Heat flow rate in [Watt].
</pre></blockquote>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  textColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        partial model PartialElementaryConditionalHeatPortWithoutT
          "Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models"
          parameter Boolean useHeatPort = false "= true, if heatPort is enabled"
            annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
          HeatTransfer.Interfaces.HeatPort_a heatPort(final Q_flow=-lossPower)
         if useHeatPort
            "Optional port to which dissipated losses are transported in form of heat"
            annotation (Placement(transformation(extent={{-110,-110},{-90,-90}}),
                iconTransformation(extent={{-110,-110},{-90,-90}})));
          SI.Power lossPower
            "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)";
          annotation (Documentation(info="<html>
<p>
This partial model provides a conditional heat port for dissipating losses.
</p>
<ul>
<li>If <strong>useHeatPort</strong> is set to <strong>false</strong> (default), no heat port is available, and the thermal loss power is dissipated internally.</li>
<li>If <strong>useHeatPort</strong> is set to <strong>true</strong>, the heat port is available and must be connected from the outside.</li>
</ul>
<p>
If this model is used, the loss power has to be provided by an equation in the model which inherits from the PartialElementaryConditionalHeatPortWithoutT model
(<strong>lossPower = ...</strong>).
</p>

<p>
Note, this partial model is used in cases, where heatPort.T (that is the device temperature) is not utilized in the model. If this is desired, inherit instead from partial model
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort\">PartialElementaryConditionalHeatPort</a>.
</p>
</html>"));
        end PartialElementaryConditionalHeatPortWithoutT;
        annotation (Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Polygon(
            origin = {13.758,27.517},
            lineColor = {128,128,128},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
        Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {160,160,164},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
          Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
          Line(
            origin = {13.758,27.517},
            points = {{-41,-17},{-9,-17}},
            color = {191,0,0},
            thickness = 0.5),
          Line(
            origin = {13.758,27.517},
            points = {{-17,-40},{15,-40}},
            color = {191,0,0},
            thickness = 0.5),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}),
                                Documentation(info="<html>
<p>
This package contains components to model <strong>1-dimensional heat transfer</strong>
with lumped elements.</p>
</html>",     revisions="<html>
<ul>
<li><em>July 15, 2002</em>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Nikolaus Sch&uuml;rmann:<br>
       Implemented.
</li>
<li><em>June 13, 2005</em>
       by <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       components moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
    annotation (
     Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Line(
      origin={-47.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={-50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={2.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={0.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={52.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}})}),
      Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
    extends Modelica.Icons.Package;

  package Vectors "Library of functions operating on vectors"
    extends Modelica.Icons.Package;

    function toString "Convert a real vector in to a string representation"
      extends Modelica.Icons.Function;
      import Modelica.Utilities.Strings;

      input Real v[:] "Real vector";
      input String name="" "Independent variable name used for printing";
      input Integer significantDigits=6
        "Number of significant digits that are shown";
      output String s="";
  protected
      String blanks=Strings.repeat(significantDigits);
      String space=Strings.repeat(8);
      Integer r=size(v, 1);

    algorithm
      if r == 0 then
        s := if name == "" then "[]" else name + " = []";
      else
        s := if name == "" then "\n" else "\n" + name + " = \n";
        for i in 1:r loop
          s := s + space;

          if v[i] >= 0 then
            s := s + " ";
          end if;
          s := s + String(v[i], significantDigits=significantDigits) +
            Strings.repeat(significantDigits + 8 - Strings.length(String(abs(v[i]))));

          s := s + "\n";
        end for;

      end if;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>toString</strong>(v);
Vectors.<strong>toString</strong>(v,name=\"\",significantDigits=6);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>toString</strong>(v)</code>\" returns the string representation of vector <strong>v</strong>.
With the optional arguments \"name\" and \"significantDigits\" a name and the number of the digits are defined.
The default values of \"name\" and \"significantDigits\" are \"\" and 6 respectively. If name==\"\" (empty string) then the prefix \"&lt;name&gt; =\" is left out at the output-string.
</p>
<h4>Example</h4>
<blockquote><pre>
v = {2.12, -4.34, -2.56, -1.67};
<strong>toString</strong>(v);
                       // = \"
                       //           2.12
                       //          -4.34
                       //          -2.56
                       //          -1.67\"
<strong>toString</strong>(v,\"vv\",1);
                       // = \"vv =
                       //           2
                       //          -4
                       //          -3
                       //          -2\"
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.toString\">Matrices.toString</a>,
</p>
</html>",   revisions="<html>

</html>"));
    end toString;

    function isEqual "Determine if two Real vectors are numerically identical"
      extends Modelica.Icons.Function;
      input Real v1[:] "First vector";
      input Real v2[:] "Second vector (may have different length as v1)";
      input Real eps(min=0) = 0
        "Two elements e1 and e2 of the two vectors are identical if abs(e1-e2) <= eps";
      output Boolean result
        "= true, if vectors have the same length and the same elements";

  protected
      Integer n=size(v1, 1) "Dimension of vector v1";
      Integer i=1;
    algorithm
      result := false;
      if size(v2, 1) == n then
        result := true;
        while i <= n loop
          if abs(v1[i] - v2[i]) > eps then
            result := false;
            i := n;
          end if;
          i := i + 1;
        end while;
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>isEqual</strong>(v1, v2);
Vectors.<strong>isEqual</strong>(v1, v2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.isEqual(v1, v2)</code>\" returns <strong>true</strong>,
if the two Real vectors v1 and v2 have the same dimensions and
the same elements. Otherwise the function
returns <strong>false</strong>. Two elements e1 and e2 of the two vectors
are checked on equality by the test \"abs(e1-e2) &le; eps\", where \"eps\"
can be provided as third argument of the function. Default is \"eps = 0\".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real v1[3] = {1, 2, 3};
  Real v2[4] = {1, 2, 3, 4};
  Real v3[3] = {1, 2, 3.0001};
  Boolean result;
<strong>algorithm</strong>
  result := Vectors.isEqual(v1,v2);     // = <strong>false</strong>
  result := Vectors.isEqual(v1,v3);     // = <strong>false</strong>
  result := Vectors.isEqual(v1,v1);     // = <strong>true</strong>
  result := Vectors.isEqual(v1,v3,0.1); // = <strong>true</strong>
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.find\">Vectors.find</a>,
<a href=\"modelica://Modelica.Math.Matrices.isEqual\">Matrices.isEqual</a>,
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">Strings.isEqual</a>
</p>
</html>"));
    end isEqual;

    function norm "Return the p-norm of a vector"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector";
      input Real p(min=1) = 2
        "Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)";
      output Real result=0.0 "p-norm of vector v";
  protected
      Real eps = 10*Modelica.Constants.eps;
    algorithm
     if size(v,1) > 0 then
      if p >= 2-eps and p <= 2+eps then
        result := sqrt(v*v);
      elseif p >= Modelica.Constants.inf then
        result := max(abs(v));
      elseif p >= 1-eps and p <= 1+eps then
        result := sum(abs(v));
      elseif p >= 1 then
        result := (sum(abs(v[i])^p for i in 1:size(v, 1)))^(1/p);
      else
        assert(false, "Optional argument \"p\" (= " + String(p) + ") of function \"norm\" >= 1 required");
      end if;
     end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>norm</strong>(v);
Vectors.<strong>norm</strong>(v,p=2);   // 1 &le; p &le; &#8734;
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>norm</strong>(v)</code>\" returns the
<strong>Euclidean norm</strong> \"<code>sqrt(v*v)</code>\" of vector v.
With the optional
second argument \"p\", any other p-norm can be computed:
</p>
<center>
<img src=\"modelica://Modelica/Resources/Images/Math/Vectors/vectorNorm.png\" alt=\"function Vectors.norm\">
</center>
<p>
Besides the Euclidean norm (p=2), also the 1-norm and the
infinity-norm are sometimes used:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td><strong>1-norm</strong></td>
      <td>= sum(abs(v))</td>
      <td><strong>norm</strong>(v,1)</td>
  </tr>
  <tr><td><strong>2-norm</strong></td>
      <td>= sqrt(v*v)</td>
      <td><strong>norm</strong>(v) or <strong>norm</strong>(v,2)</td>
  </tr>
  <tr><td><strong>infinity-norm</strong></td>
      <td>= max(abs(v))</td>
      <td><strong>norm</strong>(v,Modelica.Constants.<strong>inf</strong>)</td>
  </tr>
</table>
<p>
Note, for any vector norm the following inequality holds:
</p>
<blockquote><pre>
<strong>norm</strong>(v1+v2,p) &le; <strong>norm</strong>(v1,p) + <strong>norm</strong>(v2,p)
</pre></blockquote>
<h4>Example</h4>
<blockquote><pre>
v = {2, -4, -2, -1};
<strong>norm</strong>(v,1);    // = 9
<strong>norm</strong>(v,2);    // = 5
<strong>norm</strong>(v);      // = 5
<strong>norm</strong>(v,10.5); // = 4.00052597412635
<strong>norm</strong>(v,Modelica.Constants.inf);  // = 4
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.norm\">Matrices.norm</a>
</p>
</html>"));
    end norm;

    function length
      "Return length of a vector (better as norm(), if further symbolic processing is performed)"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector";
      output Real result "Length of vector v";
    algorithm
      result := sqrt(v*v);
      annotation (Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>length</strong>(v);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>length</strong>(v)</code>\" returns the
<strong>Euclidean length</strong> \"<code>sqrt(v*v)</code>\" of vector v.
The function call is equivalent to Vectors.norm(v). The advantage of
length(v) over norm(v) is that function length(..) is implemented
in one statement and therefore the function is usually automatically
inlined. Further symbolic processing is therefore possible, which is
not the case with function norm(..).
</p>
<h4>Example</h4>
<blockquote><pre>
v = {2, -4, -2, -1};
<strong>length</strong>(v);  // = 5
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.norm\">Vectors.norm</a>
</p>
</html>"));
    end length;

    function reverse "Reverse vector elements (e.g., v[1] becomes last element)"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector";
      output Real result[size(v, 1)] "Elements of vector v in reversed order";

    algorithm
      result := {v[end - i + 1] for i in 1:size(v, 1)};
      annotation (Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>reverse</strong>(v);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.<strong>reverse</strong>(v)</code>\" returns the
vector elements in reverse order.
</p>
<h4>Example</h4>
<blockquote><pre>
<strong>reverse</strong>({1,2,3,4});  // = {4,3,2,1}
</pre></blockquote>
</html>"));
    end reverse;

    function sort "Sort elements of vector in ascending or descending order"
      extends Modelica.Icons.Function;
      input Real v[:] "Real vector to be sorted";
      input Boolean ascending=true
        "= true, if ascending order, otherwise descending order";
      output Real sorted_v[size(v, 1)]=v "Sorted vector";
      output Integer indices[size(v, 1)]=1:size(v, 1) "sorted_v = v[indices]";

      /* shellsort algorithm; should be improved later */
  protected
      Integer gap;
      Integer i;
      Integer j;
      Real wv;
      Integer wi;
      Integer nv=size(v, 1);
      Boolean swap;
    algorithm
      gap := div(nv, 2);

      while gap > 0 loop
        i := gap;
        while i < nv loop
          j := i - gap;
          if j >= 0 then
            if ascending then
              swap := sorted_v[j + 1] > sorted_v[j + gap + 1];
            else
              swap := sorted_v[j + 1] < sorted_v[j + gap + 1];
            end if;
          else
            swap := false;
          end if;

          while swap loop
            wv := sorted_v[j + 1];
            wi := indices[j + 1];
            sorted_v[j + 1] := sorted_v[j + gap + 1];
            sorted_v[j + gap + 1] := wv;
            indices[j + 1] := indices[j + gap + 1];
            indices[j + gap + 1] := wi;
            j := j - gap;
            if j >= 0 then
              if ascending then
                swap := sorted_v[j + 1] > sorted_v[j + gap + 1];
              else
                swap := sorted_v[j + 1] < sorted_v[j + gap + 1];
              end if;
            else
              swap := false;
            end if;
          end while;
          i := i + 1;
        end while;
        gap := div(gap, 2);
      end while;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_v = Vectors.<strong>sort</strong>(v);
(sorted_v, indices) = Vectors.<strong>sort</strong>(v, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>sort</strong>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument \"ascending\" is <strong>false</strong>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>
<h4>Example</h4>
<blockquote><pre>
(v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
     -> v2 = {-1, 2, 3, 6, 8}
        i2 = {1, 5, 3, 4, 2}
</pre></blockquote>
</html>"));
    end sort;

    function find "Find element in a vector"
      extends Modelica.Icons.Function;
      input Real e "Search for e";
      input Real v[:] "Real vector";
      input Real eps(min=0) = 0
        "Element e is equal to a element v[i] of vector v if abs(e-v[i]) <= eps";
      output Integer result
        "v[result] = e (first occurrence of e); result=0, if not found";
  protected
      Integer i;
    algorithm
      result := 0;
      i := 1;
      while i <= size(v, 1) loop
        if abs(v[i] - e) <= eps then
          result := i;
          i := size(v, 1) + 1;
        else
          i := i + 1;
        end if;
      end while;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<strong>find</strong>(e, v);
Vectors.<strong>find</strong>(e, v, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.find(e, v)</code>\" returns the index of the first occurrence of input e in vector <strong>v</strong>.
The test of equality is performed by \"abs(e-v[i]) &le; eps\", where \"eps\"
can be provided as third argument of the function. Default is \"eps = 0\".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real v[3] = {1, 2, 3};
  Real e1 = 2;
  Real e2 = 3.01;
  Boolean result;
<strong>algorithm</strong>
  result := Vectors.find(e1,v);          // = <strong>2</strong>
  result := Vectors.find(e2,v);          // = <strong>0</strong>
  result := Vectors.find(e2,v,eps=0.1);  // = <strong>3</strong>
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.isEqual\">Vectors.isEqual</a>
</p>
</html>"));
    end find;

    function interpolate "Interpolate linearly in a vector"
      extends Modelica.Icons.Function;
      input Real x[:]
        "Abscissa table vector (strict monotonically increasing values required)";
      input Real y[size(x, 1)] "Ordinate table vector";
      input Real xi "Desired abscissa value";
      input Integer iLast=1 "Index used in last search";
      output Real yi "Ordinate value corresponding to xi";
      output Integer iNew=1 "xi is in the interval x[iNew] <= xi < x[iNew+1]";
  protected
      Integer i;
      Integer nx=size(x, 1);
      Real x1;
      Real x2;
      Real y1;
      Real y2;
    algorithm
      assert(nx > 0, "The table vectors must have at least 1 entry.");
      if nx == 1 then
        yi := y[1];
      else
        // Search interval
        i := min(max(iLast, 1), nx - 1);
        if xi >= x[i] then
          // search forward
          while i < nx and xi >= x[i] loop
            i := i + 1;
          end while;
          i := i - 1;
        else
          // search backward
          while i > 1 and xi < x[i] loop
            i := i - 1;
          end while;
        end if;

        // Get interpolation data
        x1 := x[i];
        x2 := x[i + 1];
        y1 := y[i];
        y2 := y[i + 1];

        assert(x2 > x1, "Abscissa table vector values must be increasing");
        // Interpolate
        yi := y1 + (y2 - y1)*(xi - x1)/(x2 - x1);
        iNew := i;
      end if;

      annotation (smoothOrder( normallyConstant=x, normallyConstant=y)=100,
        Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
// Real    x[:], y[:], xi, yi;
// Integer iLast, iNew;
        yi = Vectors.<strong>interpolate</strong>(x,y,xi);
(yi, iNew) = Vectors.<strong>interpolate</strong>(x,y,xi,iLast=1);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Vectors.interpolate(x,y,xi)</code>\" interpolates
<strong>linearly</strong> in vectors
(x,y) and returns the value yi that corresponds to xi. Vector x[:] must consist
of monotonically increasing values. If xi &lt; x[1] or &gt; x[end], then
extrapolation takes places through the first or last two x[:] values, respectively.
If the x and y vectors have length 1, then always y[1] is returned.
The search for the interval x[iNew] &le; xi &lt; x[iNew+1] starts at the optional
input argument \"iLast\". The index \"iNew\" is returned as output argument.
The usage of \"iLast\" and \"iNew\" is useful to increase the efficiency of the call,
if many interpolations take place.
If x has two or more identical values then interpolation utilizes the x-value
with the largest index.
</p>

<h4>Example</h4>

<blockquote><pre>
  Real x1[:] = { 0,  2,  4,  6,  8, 10};
  Real x2[:] = { 1,  2,  3,  3,  4,  5};
  Real y[:]  = {10, 20, 30, 40, 50, 60};
<strong>algorithm</strong>
  (yi, iNew) := Vectors.interpolate(x1,y,5);  // yi = 35, iNew=3
  (yi, iNew) := Vectors.interpolate(x2,y,4);  // yi = 50, iNew=5
  (yi, iNew) := Vectors.interpolate(x2,y,3);  // yi = 40, iNew=4
</pre></blockquote>
</html>"));
    end interpolate;
    annotation (preferredView="info", Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on vectors:
</p>

<ul>
<li> <a href=\"modelica://Modelica.Math.Vectors.toString\">toString</a>(v)
     - returns the string representation of vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.isEqual\">isEqual</a>(v1, v2)
     - returns true if vectors v1 and v2 have the same size and the same elements.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.norm\">norm</a>(v,p)
     - returns the p-norm of vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.length\">length</a>(v)
     - returns the length of vector v (= norm(v,2), but inlined and therefore usable in
       symbolic manipulations)</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.normalize\">normalize</a>(v)
     - returns vector in direction of v with length = 1 and prevents
       zero-division for zero vector.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.reverse\">reverse</a>(v)
     - reverses the vector elements of v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.sort\">sort</a>(v)
     - sorts the elements of vector v in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.find\">find</a>(e, v)
     - returns the index of the first occurrence of scalar e in vector v.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.interpolate\">interpolate</a>(x, y, xi)
     - returns the interpolated value in (x,y) that corresponds to xi.</li>

<li> <a href=\"modelica://Modelica.Math.Vectors.relNodePositions\">relNodePositions</a>(nNodes)
     - returns a vector of relative node positions (0..1).</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices\">Matrices</a>
</html>"),
      Icon(graphics={Rectangle(
            extent={{-16,66},{14,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid), Rectangle(
            extent={{-16,-14},{14,-62}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Vectors;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function isEqual "Compare whether two Real matrices are identical"
      extends Modelica.Icons.Function;
      input Real M1[:, :] "First matrix";
      input Real M2[:, :] "Second matrix (may have different size as M1)";
      input Real eps(min=0) = 0
        "Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) <= eps";
      output Boolean result
        "= true, if matrices have the same size and the same elements";

  protected
      Integer nrow=size(M1, 1) "Number of rows of matrix M1";
      Integer ncol=size(M1, 2) "Number of columns of matrix M1";
      Integer i=1;
      Integer j;
    algorithm
      result := false;
      if size(M2, 1) == nrow and size(M2, 2) == ncol then
        result := true;
        while i <= nrow loop
          j := 1;
          while j <= ncol loop
            if abs(M1[i, j] - M2[i, j]) > eps then
              result := false;
              i := nrow;
              j := ncol;
            end if;
            j := j + 1;
          end while;
          i := i + 1;
        end while;
      end if;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>isEqual</strong>(M1, M2);
Matrices.<strong>isEqual</strong>(M1, M2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Matrices.isEqual(M1, M2)</code>\" returns <strong>true</strong>,
if the two Real matrices M1 and M2 have the same dimensions and
the same elements. Otherwise the function
returns <strong>false</strong>. Two elements e1 and e2 of the two matrices
are checked on equality by the test \"abs(e1-e2) &le; eps\", where \"eps\"
can be provided as third argument of the function. Default is \"eps = 0\".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A1[2,2] = [1,2; 3,4];
  Real A2[3,2] = [1,2; 3,4; 5,6];
  Real A3[2,2] = [1,2, 3,4.0001];
  Boolean result;
<strong>algorithm</strong>
  result := Matrices.isEqual(M1,M2);     // = <strong>false</strong>
  result := Matrices.isEqual(M1,M3);     // = <strong>false</strong>
  result := Matrices.isEqual(M1,M1);     // = <strong>true</strong>
  result := Matrices.isEqual(M1,M3,0.1); // = <strong>true</strong>
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors.isEqual\">Vectors.isEqual</a>,
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">Strings.isEqual</a>
</html>"));
    end isEqual;

    function solve
      "Solve real system of linear equations A*x=b with a b vector (Gaussian elimination with partial pivoting)"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "Matrix A of A*x = b";
      input Real b[size(A, 1)] "Vector b of A*x = b";
      output Real x[size(b, 1)] "Vector x such that A*x = b";

  protected
      Integer info;
    algorithm
      (x,info) := LAPACK.dgesv_vec(A, b);
      assert(info == 0, "Solving a linear system of equations with function
\"Matrices.solve\" is not possible, because the system has either
no or infinitely many solutions (A is singular).");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>solve</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <strong>x</strong> of the linear system of equations
</p>
<blockquote>
<p>
<strong>A</strong>*<strong>x</strong> = <strong>b</strong>
</p>
</blockquote>
<p>
If a unique solution <strong>x</strong> does not exist (since <strong>A</strong> is singular),
an assertion is triggered. If this is not desired, use instead
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>
and inquire the singularity of the solution with the return argument rank
(a unique solution is computed if rank = size(A,1)).
</p>

<p>
Note, the solution is computed with the LAPACK function \"dgesv\",
i.e., by Gaussian elimination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<strong>algorithm</strong>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a>,
<a href=\"modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>.
</html>"));
    end solve;

    function solve2
      "Solve real system of linear equations A*X=B with a B matrix (Gaussian elimination with partial pivoting)"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "Matrix A of A*X = B";
      input Real B[size(A, 1), :] "Matrix B of A*X = B";
      output Real X[size(B, 1), size(B, 2)] "Matrix X such that A*X = B";

  protected
      Integer info;
    algorithm
      (X,info) := LAPACK.dgesv(A, B);
      assert(info == 0, "Solving a linear system of equations with function
\"Matrices.solve2\" is not possible, because the system has either
no or infinitely many solutions (A is singular).");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>solve2</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <strong>X</strong> of the linear system of equations
</p>
<blockquote>
<p>
<strong>A</strong>*<strong>X</strong> = <strong>B</strong>
</p>
</blockquote>
<p>
If a unique solution <strong>X</strong> does not exist (since <strong>A</strong> is singular),
an assertion is triggered. If this is not desired, use instead
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
and inquire the singularity of the solution with the return argument rank
(a unique solution is computed if rank = size(A,1)).

</p>
<p>
Note, the solution is computed with the LAPACK function \"dgesv\",
i.e., by Gaussian elimination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<strong>algorithm</strong>
  X := Matrices.solve2(A, B);  /* X = [3, 6;
                                       2, 4;
                                       1, 2] */
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a>,
<a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">Matrices.LU_solve2</a>,
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>.
</p>
</html>"));
    end solve2;

    function leastSquares
      "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
        "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A, 1), size(A, 2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsy_vec(
              A,
              b,
              rcond);
        x := xx[1:size(A, 2)];
        assert(info == 0,
          "Solving an overdetermined or underdetermined linear system\n" +
          "of equations with function \"Matrices.leastSquares\" failed.");
      else
        x := fill(0.0, size(A, 2));
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>leastSquares</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<blockquote><pre>
minimize | A*x - b |
</pre></blockquote>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<blockquote><pre>
A * P = Q * [ R11 R12 ]
            [  0  R22 ]
</pre></blockquote>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<blockquote><pre>
A * P = Q * [ T11 0 ] * Z
            [  0  0 ]
</pre></blockquote>

<p>
The minimum-norm solution is then
</p>

<blockquote><pre>
x = P * Z' [ inv(T11)*Q1'*b ]
           [        0       ]
</pre></blockquote>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    function leastSquares2
      "Solve linear equation A*X = B (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real B[size(A, 1), :] "Matrix B";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate rank of A";
      output Real X[size(A, 2), size(B, 2)]
        "Matrix X such that min|A*X-B|^2 if size(A,1) >= size(A,2) or min|X|^2 and A*X=B, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real XX[max(size(A, 1), size(A, 2)), size(B, 2)];
    algorithm
      (XX,info,rank) := LAPACK.dgelsy(
            A,
            B,
            rcond);
      X := XX[1:size(A, 2), :];
      assert(info == 0, "Solving an overdetermined or underdetermined linear system of
equations with function \"Matrices.leastSquares2\" failed.");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
X = Matrices.<strong>leastSquares2</strong>(A,B);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*X = B in a least
square sense (A may be rank deficient):
</p>
<blockquote><pre>
minimize | A*X - B |
</pre></blockquote>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution X fulfills the equation
     A*X = B uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*X = B exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, X is selected such that |A*X - B| is as small as
           possible (but A*X - B is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*X = B has no unique solution. The solution X is selected such that
|A*X - B| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*X - B|. From these infinite number of solutions, the one with the
minimum norm |X| is selected. This gives a unique solution that minimizes both
|A*X - B| and |X|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*X = B.
     From this infinite number, the unique solution is selected that minimizes |X|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*X = B, or there are again an infinite
     number of solutions. The unique solution X is returned that minimizes
      both |A*X - B| and |X|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<blockquote><pre>
A * P = Q * [ R11 R12 ]
            [  0  R22 ]
</pre></blockquote>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<blockquote><pre>
A * P = Q * [ T11 0 ] * Z
            [  0  0 ]
</pre></blockquote>

<p>
The minimum-norm solution is then
</p>

<blockquote><pre>
X = P * Z' [ inv(T11)*Q1'*B ]
           [        0       ]
</pre></blockquote>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>
(same as leastSquares2, but with a right hand side vector),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares2;

    function equalityLeastSquares
      "Solve a linear equality constrained least squares problem"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Minimize |A*x - a|^2";
      input Real a[size(A, 1)];
      input Real B[:, size(A, 2)] "Subject to B*x=b";
      input Real b[size(B, 1)];
      output Real x[size(A, 2)] "Solution vector";

  protected
      Integer info;
    algorithm
      assert(size(A, 2) >= size(B, 1) and size(A, 2) <= size(A, 1) + size(B, 1),
        "It is required that size(B,1) <= size(A,2) <= size(A,1) + size(B,1)\n"
         +
        "This relationship is not fulfilled, since the matrices are declared as:\n"
         + "  A[" + String(size(A, 1)) + "," + String(size(A, 2)) + "], B[" +
        String(size(B, 1)) + "," + String(size(B, 2)) + "]\n");

      (x,info) := LAPACK.dgglse_vec(
            A,
            a,
            B,
            b);

      assert(info == 0, "Solving a linear equality-constrained least squares problem
with function \"Matrices.equalityLeastSquares\" failed.");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>equalityLeastSquares</strong>(A,a,B,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the
solution <strong>x</strong> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<strong>A</strong>*<strong>x</strong> - <strong>a</strong>|^2 over <strong>x</strong>, subject to <strong>B</strong>*<strong>x</strong> = <strong>b</strong>
</p>
</blockquote>

<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>

<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>

<p>
Note, the solution is computed with the LAPACK function \"dgglse\"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
</html>"));
    end equalityLeastSquares;

    pure function LU "LU decomposition of square or rectangular matrix"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Square or rectangular matrix";
      output Real LU[size(A, 1), size(A, 2)]=A
        "L,U factors (used with LU_solve(..))";
      output Integer pivots[min(size(A, 1), size(A, 2))]
        "Pivot indices (used with LU_solve(..))";
      output Integer info "Information";
  protected
      Integer m=size(A, 1);
      Integer n=size(A, 2);
      Integer lda=max(1, size(A, 1));
    external"FORTRAN 77" dgetrf(
            m,
            n,
            LU,
            lda,
            pivots,
            info) annotation (Library="lapack");

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<strong>LU</strong>(A);
(LU, pivots, info) = Matrices.<strong>LU</strong>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a \"Real[m,n]\" matrix A, i.e.,
</p>
<blockquote>
<p>
<strong>P</strong>*<strong>L</strong>*<strong>U</strong> = <strong>A</strong>
</p>
</blockquote>
<p>
where <strong>P</strong> is a permutation matrix (implicitly
defined by vector <code>pivots</code>),
<strong>L</strong> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<strong>U</strong> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <strong>L</strong> and <strong>U</strong> are stored in the returned
matrix <code>LU</code> (the diagonal of <strong>L</strong> is not stored).
With the companion function
<a href=\"modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<strong>P</strong>*<strong>L</strong>*<strong>U</strong>)*<strong>x</strong> = <strong>b</strong> with different right
hand side vectors <strong>b</strong>. If a linear system of equations with
just one right hand side vector <strong>b</strong> shall be solved, it is
more convenient to just use the function
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:</p>
<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td>info = 0:</td>
      <td>successful exit</td></tr>
  <tr><td>info &gt; 0:</td>
      <td>if info = i, U[i,i] is exactly zero. The factorization
          has been completed,<br>
          but the factor U is exactly
          singular, and division by zero will occur<br> if it is used
          to solve a system of equations.</td></tr>
</table>
<p>
The LU factorization is computed
with the LAPACK function \"dgetrf\",
i.e., by Gaussian elimination using partial pivoting
with row interchanges. Vector \"pivots\" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<strong>algorithm</strong>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>,
</p>
</html>"));
    end LU;

    function LU_solve2
      "Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))"

      extends Modelica.Icons.Function;
      input Real LU[:, size(LU, 1)]
        "L,U factors of Matrices.LU(..) for a square matrix";
      input Integer pivots[size(LU, 1)] "Pivots indices of Matrices.LU(..)";
      input Real B[size(LU, 1), :] "Right hand side matrix of P*L*U*X=B";
      output Real X[size(B, 1), size(B, 2)]
        "Solution matrix such that P*L*U*X = B";

    algorithm
      for i in 1:size(LU, 1) loop
        assert(LU[i, i] <> 0, "Solving a linear system of equations with function
\"Matrices.LU_solve2\" is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.");
      end for;
      X := Modelica.Math.Matrices.LAPACK.dgetrs(
            LU,
            pivots,
            B);
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>LU_solve2</strong>(LU, pivots, B);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <strong>X</strong> of the linear systems of equations
</p>
<blockquote>
<p>
<strong>P</strong>*<strong>L</strong>*<strong>U</strong>*<strong>X</strong> = <strong>B</strong>;
</p>
</blockquote>
<p>
where <strong>P</strong> is a permutation matrix (implicitly
defined by vector <code>pivots</code>),
<strong>L</strong> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<strong>U</strong> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve2</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve2</code>
it is possible to efficiently solve linear systems
with different right hand side <strong>matrices</strong>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>.
</p>
<p>
If a unique solution <strong>X</strong> does not exist (since the
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function \"dgetrf\",
i.e., by Gaussian elimination using partial pivoting
with row interchanges. Vector \"pivots\" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<strong>algorithm</strong>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a>,
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>,
</html>"));
    end LU_solve2;

    function eigenValues
      "Return eigenvalues and eigenvectors for a real, nonsymmetric matrix in a Real representation"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "Matrix";
      output Real eigenvalues[size(A, 1), 2]
        "Eigenvalues of matrix A (Re: first column, Im: second column)";
      output Real eigenvectors[size(A, 1), size(A, 2)]
        "Real-valued eigenvector matrix";

  protected
      Integer info;
      Boolean onlyEigenvalues=false;
    algorithm
      if size(A, 1) > 0 then
        if onlyEigenvalues then
          (eigenvalues[:, 1],eigenvalues[:, 2],info) := LAPACK.dgeev_eigenValues(A);
          eigenvectors := zeros(size(A, 1), size(A, 1));
        else
          (eigenvalues[:, 1],eigenvalues[:, 2],eigenvectors,info) := LAPACK.dgeev(A);
        end if;
        assert(info == 0, "Calculating the eigen values with function
\"Matrices.eigenvalues\" is not possible, since the
numerical algorithm does not converge.");
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<strong>eigenValues</strong>(A);
(eigenvalues, eigenvectors) = Matrices.<strong>eigenValues</strong>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues and
optionally the (right) eigenvectors of a square matrix
<strong>A</strong>. The first column of \"eigenvalues\" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function
<a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues
such that
</p>
<blockquote><pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
</pre></blockquote>
<p>
provided the eigenvector matrix \"eigenvectors\" can be inverted
(an inversion is possible, if all eigenvalues are different;
in some cases, an inversion is also possible if some eigenvalues are
the same).
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real eval[3,2];
<strong>algorithm</strong>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0;
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre></blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
</p>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
<a href=\"modelica://Modelica.Math.Matrices.singularValues\">Matrices.singularValues</a>
</html>"));
    end eigenValues;

    function singularValues
      "Return singular values and left and right singular vectors"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix";
      output Real sigma[min(size(A, 1), size(A, 2))] "Singular values";
      output Real U[size(A, 1), size(A, 1)]=identity(size(A, 1))
        "Left orthogonal matrix";
      output Real VT[size(A, 2), size(A, 2)]=identity(size(A, 2))
        "Transposed right orthogonal matrix";

  protected
      Integer info;
      Integer n=min(size(A, 1), size(A, 2)) "Number of singular values";
    algorithm
      if n > 0 then
        (sigma,U,VT,info) := Modelica.Math.Matrices.LAPACK.dgesvd(A);
        assert(info == 0, "The numerical algorithm to compute the
singular value decomposition did not converge");
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
         sigma = Matrices.<strong>singularValues</strong>(A);
(sigma, U, VT) = Matrices.<strong>singularValues</strong>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the singular values and optionally the
singular vectors of matrix A. Basically the singular
value decomposition of A is computed, i.e.,
</p>
<blockquote><pre>
<strong>A</strong> = <strong>U</strong> <strong>&Sigma;</strong> <strong>V</strong><sup>T</sup>
  = U*Sigma*VT
</pre></blockquote>
<p>
where <strong>U</strong> and <strong>V</strong> are orthogonal matrices (<strong>UU</strong><sup>T</sup>=<strong>I,
</strong><strong>VV</strong><sup>T</sup>=<strong>I</strong>).
<strong>&Sigma;</strong> = [diagonal(&sigma;<sub>i</sub>), zeros(n,m-n)], if n=size(A,1) &le;
m=size(A,2)) or [diagonal(&sigma;<sub>i</sub>); zeros(n-m,m)], if n &gt;
m=size(A,2)). <strong>&Sigma;</strong> has the same size as matrix A with
nonnegative diagonal elements in decreasing order and with all other elements zero
(&sigma;<sub>1</sub> is the largest element). The function
returns the singular values &sigma;<sub>i</sub>
in vector <code>sigma</code> and the orthogonal matrices in
matrices <code>U</code> and <code>VT</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
A = [1, 2,  3,  4;
     3, 4,  5, -2;
    -1, 2, -3,  5];
(sigma, U, VT) = singularValues(A);
results in:
   sigma = {8.33, 6.94, 2.31};
i.e.
   Sigma = [8.33,    0,    0, 0;
               0, 6.94,    0, 0;
               0,    0, 2.31, 0]
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.eigenValues\">Matrices.eigenValues</a>
</html>"));
    end singularValues;

    function QR
      "Return the QR decomposition of a square matrix with optional column pivoting (A(:,p) = Q*R)"

      extends Modelica.Icons.Function;
      input Real A[:, :] "Rectangular matrix with size(A,1) >= size(A,2)";
      input Boolean pivoting=true
        "= true, if column pivoting is performed. True is default";
      output Real Q[size(A, 1), size(A, 2)]
        "Rectangular matrix with orthonormal columns such that Q*R=A[:,p]";
      output Real R[size(A, 2), size(A, 2)] "Square upper triangular matrix";
      output Integer p[size(A, 2)] "Column permutation vector";

  protected
      Integer nrow=size(A, 1);
      Integer ncol=size(A, 2);
      Real tau[size(A, 2)];
    algorithm
      assert(nrow >= ncol, "\nInput matrix A[" + String(nrow) + "," + String(ncol)
         + "] has more columns than rows.
This is not allowed when calling Modelica.Math.Matrices.QR(A).");
      if pivoting then
        (Q,tau,p) := LAPACK.dgeqp3(A);
      else
        (Q,tau) := LAPACK.dgeqrf(A);
        p := 1:ncol;
      end if;

      // determine R
      R := zeros(ncol, ncol);
      for i in 1:ncol loop
        for j in i:ncol loop
          R[i, j] := Q[i, j];
        end for;
      end for;

      Q := LAPACK.dorgqr(Q, tau);
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<strong>QR</strong>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <strong>A</strong> (the number of columns of <strong>A</strong>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<strong>Q</strong>*<strong>R</strong> = <strong>A</strong>[:,<strong>p</strong>]
</p>
</blockquote>
<p>
where <strong>Q</strong> is a rectangular matrix that has orthonormal columns and
has the same size as A (<strong>Q</strong><sup>T</sup><strong>Q</strong>=<strong>I</strong>),
<strong>R</strong> is a square, upper triangular matrix and <strong>p</strong> is a permutation
vector. Matrix <strong>R</strong> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <strong>R</strong> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <strong>R</strong> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j.</li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <strong>R</strong> have
small elements and can be treated as being zero.
This allows to, e.g., estimate the row-rank
of <strong>R</strong> (which is the same row-rank as <strong>A</strong>). Furthermore,
<strong>R</strong> can be partitioned in two parts
</p>
<blockquote><pre>
<strong>A</strong>[:,<strong>p</strong>] = <strong>Q</strong> * [<strong>R</strong><sub>1</sub>, <strong>R</strong><sub>2</sub>;
              <strong>0</strong>,  <strong>0</strong>]
</pre></blockquote>
<p>
where <strong>R</strong><sub>1</sub> is a regular, upper triangular matrix.
</p>
<p>
Note, the solution is computed with the LAPACK functions \"dgeqp3\"
and \"dorgqr\", i.e., by Householder transformations with
column pivoting. If <strong>Q</strong> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<strong>algorithm</strong>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
</html>"));
    end QR;

    function realSchur
      "Return the real Schur form (rsf) S of a square matrix A, A=QZ*S*QZ'"
      extends Modelica.Icons.Function;
      import Modelica.Math.Matrices;

      input Real A[:, size(A, 1)] "Square matrix";

  public
      output Real S[size(A, 1), size(A, 2)] "Real Schur form of A";
      output Real QZ[size(A, 1), size(A, 2)] "Schur vector Matrix";
      output Real alphaReal[size(A, 1)]
        "Real part of eigenvalue=alphaReal+i*alphaImag";
      output Real alphaImag[size(A, 1)]
        "Imaginary part of eigenvalue=alphaReal+i*alphaImag";

  protected
      Integer info;

    algorithm
      if size(A, 1) > 1 then
        (S,QZ,alphaReal,alphaImag,info) := Matrices.LAPACK.dgees(A);
        assert(info == 0, "The output info of LAPACK.dgees should be zero, else if\n
     info < 0:  if info = -i, the i-th argument of dgees had an illegal value\n
     info > 0:  if INFO = i, and i is
               <= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = 'V', VS contains the matrix which reduces A
                     to its partially converged Schur form.\n");
      else
        S := A;
        QZ := fill(1, size(A, 1), size(A, 2));
        alphaReal := fill(1, size(A, 1));
        alphaImag := fill(0, size(A, 1));
      end if;

      annotation (Documentation(info="<html>
<h4>Syntax</h4>

<blockquote><pre>
                            S = Matrices.<strong>realSchur</strong>(A);
(S, QZ, alphaReal, alphaImag) = Matrices.<strong>realSchur</strong>(A);
</pre></blockquote>

<h4>Description</h4>

<p>
Function <strong>realSchur</strong> calculates the real Schur form of a real square matrix <strong>A</strong>, i.e.
</p>

<blockquote><pre>
<strong>A</strong> = <strong>QZ</strong>*<strong>S</strong>*transpose(<strong>QZ</strong>)
</pre></blockquote>

<p>
with the real nxn matrices <strong>S</strong> and <strong>QZ</strong>. <strong>S</strong> is a block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal. <strong>QZ</strong> is an orthogonal matrix.
The 1x1 blocks contains the real eigenvalues of <strong>A</strong>. The 2x2 blocks [s11, s12; s21, s11] represents the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues
are the elements of the diagonal (s11). The imaginary parts are the positive and negative square roots of the product of the two elements s12 and s21 (imag = +-sqrt(s12*s21)).
</p>

<p>
The calculation in lapack.dgees is performed stepwise, i.e., using the internal methods of balancing and scaling of dgees.
</p>

<h4>Example</h4>
<blockquote><pre>
   Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
   Real T[3,3];
   Real Z[3,3];
   Real alphaReal[3];
   Real alphaImag[3];

<strong>algorithm</strong>
  (T, Z, alphaReal, alphaImag):=Modelica.Math.Matrices.realSchur(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}
</pre></blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.Utilities.reorderRSF\">Math.Matrices.Utilities.reorderRSF</a>

</html>",   revisions="<html>
<ul>
<li><em>2010/05/31 </em>
       by Marcus Baur, DLR-RM</li>
</ul>
</html>"));
    end realSchur;

    function balance
      "Return a balanced form of matrix A to improve the condition of A"
      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      output Real D[size(A, 1)] "diagonal(D)=T is transformation matrix, such that
          B = inv(T)*A*T has smaller condition as A";
      output Real B[size(A, 1), size(A, 1)]
        "Balanced matrix (= inv(diagonal(D))*A*diagonal(D) )";
  protected
      Integer na=size(A, 1);
      Integer radix=2 "Radix of exponent representation must be 'radix'
          or a multiple of 'radix'";
      Integer radix2=radix*radix;
      Boolean noconv=true;
      Integer i=1;
      Integer j=1;
      Real CO;
      Real RO;
      Real G;
      Real F;
      Real S;
      /*auxiliary variables*/

    algorithm
      // B = inv(D)*A*D, so that cond(B)<=cond(A)
      D := ones(na);
      B := A;
      while noconv loop
        noconv := false;
        for i in 1:na loop
          CO := sum(abs(B[:, i])) - abs(B[i, i]);
          RO := sum(abs(B[i, :])) - abs(B[i, i]);
          G := RO/radix;
          F := 1;
          S := CO + RO;
          while not (CO >= G or CO == 0) loop
            F := F*radix;
            CO := CO*radix2;
          end while;
          G := RO*radix;
          while not (CO < G or RO == 0) loop
            F := F/radix;
            CO := CO/radix2;
          end while;
          if not ((CO + RO)/F >= 0.95*S) then
            G := 1/F;
            D[i] := D[i]*F;
            B[i, :] := B[i, :]*G;
            B[:, i] := B[:, i]*F;
            noconv := true;
          end if;
        end for;
      end while;
      annotation (Documentation(info="<html>

<h4>Syntax</h4>
<blockquote><pre>
(D,B) = Matrices.<strong>balance</strong>(A);
</pre></blockquote>

<h4>Description</h4>

<p>
This function returns a vector D, such that B=inv(diagonal(D))*A*diagonal(D) has a
better condition as matrix A, i.e., conditionNumber(B) &le; conditionNumber(A). The elements of D
are multiples of 2 which means that this function does not introduce round-off errors.
Balancing attempts to make the norm of each row of B equal to the
norm of the respective column.
</p>

<p>
Balancing is used to minimize roundoff errors induced
through large matrix calculations like Taylor-series approximation
or computation of eigenvalues.
</p>

<h4>Example</h4>

<blockquote><pre>
- A = [1, 10,  1000; 0.01,  0,  10; 0.005,  0.01,  10]
- Matrices.norm(A, 1);
  = 1020.0
- (T,B)=Matrices.balance(A)
- T
  = {256, 16, 0.5}
- B
  =  [1,     0.625,   1.953125;
      0.16,  0,       0.3125;
      2.56,  0.32,   10.0]
- Matrices.norm(B, 1);
  = 12.265625
</pre></blockquote>

<p>
The Algorithm is taken from
</p>
<dl>
<dt>H. D. Joos, G. Gr&uuml;bel:</dt>
<dd><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong><br>
    DLR - Control Systems Group 1991</dd>
</dl>
<p>
which based on the <code>balance</code> function from EISPACK.
</p>

</html>",   revisions="<html>
<h4>Release Notes</h4>
<ul>
<li><em>July 5, 2002</em>
       by H. D. Joos and Nico Walther<br>
       Implemented.
</li>
</ul>
</html>"));
    end balance;

    function trace
      "Return the trace of matrix A, i.e., the sum of the diagonal elements"
      extends Modelica.Icons.Function;

      input Real A[:, size(A, 1)] "Square matrix A";
      output Real result "Trace of A";
    algorithm
      result := sum(A[i, i] for i in 1:size(A, 1));
      annotation (Inline=true,Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<strong>trace</strong>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the trace, i.e., the sum of the elements in the diagonal of matrix <strong>A</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
A = [1, 3;
     2, 1];
r = trace(A);

results in:

r = 2.0
</pre></blockquote>

</html>",   revisions="<html>
<ul>
<li><em>2010/05/31 </em>
       by Marcus Baur, DLR-RM</li>
</ul>
</html>"));
    end trace;

    function inv "Return inverse of a matrix (try to avoid inv(..))"
      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      output Real invA[size(A, 1), size(A, 2)] "Inverse of matrix A";
  protected
      Integer info;
      Integer pivots[size(A, 1)] "Pivot vector";
      Real LU[size(A, 1), size(A, 2)] "LU factors of A";
    algorithm
      (LU,pivots,info) := LAPACK.dgetrf(A);

      assert(info == 0, "Calculating an inverse matrix with function
\"Matrices.inv\" is not possible, since matrix A is singular.");

      invA := LAPACK.dgetri(LU, pivots);

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
invA = Matrices.<strong>inv</strong>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the inverse of matrix A, i.e., A*inv(A) = identity(size(A,1))
computed by a LU decomposition with row pivoting.
Usually, this function should not be used, because
there are nearly always better numerical algorithms
as by computing directly the inverse. Example:
</p>

<blockquote>
Use x = <a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>(A,b)
to solve the linear equation A*x = b, instead of computing the solution by
x = inv(A)*b, because this is much more efficient and much more reliable.
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>
</html>"));
    end inv;

    function rank
      "Return rank of a rectangular matrix (computed with singular values)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix";
      input Real eps=0
        "If eps > 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used";
      output Integer result "Rank of matrix A";

  protected
      Integer n=min(size(A, 1), size(A, 2));
      Integer i=n;
      Real sigma[min(size(A, 1), size(A, 2))];
      Real eps2;
    algorithm
      result := 0;
      if n > 0 then
        sigma := Modelica.Math.Matrices.singularValues(A);
        eps2 := if eps > 0 then eps else max(size(A))*sigma[1]*Modelica.Constants.eps;
        while i > 0 loop
          if sigma[i] > eps2 then
            result := i;
            i := 0;
          end if;
          i := i - 1;
        end while;
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Matrices.<strong>rank</strong>(A);
result = Matrices.<strong>rank</strong>(A,eps=0);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the rank of a square or rectangular matrix A computed by singular value decomposition.
For details about the rank of a matrix, see
<a href=\"http://en.wikipedia.org/wiki/Matrix_rank\">http://en.wikipedia.org/wiki/Matrix_rank</a>.
To be more precise:
</p>

<ul>
<li> rank(A) returns the number of singular values of A that are larger than
     max(size(A))*norm(A)*Modelica.Constants.eps.</li>
<li> rank(A, eps) returns the number of singular values of A that are larger than \"eps\".</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.rcond\">Matrices.rcond</a>.
</html>"));
    end rank;

    function norm "Return the p-norm of a matrix"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Input matrix";
      input Real p(min=1) = 2
        "Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)";
      output Real result=0.0 "p-norm of matrix A";
  protected
      Real eps = 10*Modelica.Constants.eps;
    algorithm
     if min(size(A)) > 0 then
      if p >= 1-eps and p <= 1+eps then
        // column sum norm
        for i in 1:size(A, 2) loop
          result := max(result, sum(abs(A[:, i])));
        end for;
      elseif p >= 2-eps and p <= 2+eps then
        // largest singular value
        result := max(singularValues(A));
      elseif p >= Modelica.Constants.inf then
        // row sum norm
        for i in 1:size(A, 1) loop
          result := max(result, sum(abs(A[i, :])));
        end for;
      else
        assert(false, "Optional argument \"p\" (= " + String(p) + ") of function \"norm\" must be
1, 2 or Modelica.Constants.inf");
      end if;
     end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>norm</strong>(A);
Matrices.<strong>norm</strong>(A, p=2);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call \"<code>Matrices.norm(A)</code>\" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call \"<code>Matrices.norm(A, p)</code>\" returns the
p-norm of matrix A. The only allowed values for p are
</p>

<ul>
<li> \"p=1\": the largest column sum of A</li>
<li> \"p=2\": the largest singular value of A</li>
<li> \"p=Modelica.Constants.inf\": the largest row sum of A</li>
</ul>

<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>

<blockquote><pre>
Matrices.<strong>norm</strong>(A1+A2,p) &le; Matrices.<strong>norm</strong>(A1,p) + Matrices.<strong>norm</strong>(A2,p)
</pre></blockquote>

<p>
Note, for any matrix A and vector v the following inequality holds:
</p>

<blockquote><pre>
Vectors.<strong>norm</strong>(A*v,p) &le; Matrices.<strong>norm</strong>(A,p)*Vectors.<strong>norm</strong>(A,p)
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">Matrices.frobeniusNorm</a>
</p>

</html>"));
    end norm;

    function exp
      "Return the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      input Real T=1;
      output Real phi[size(A, 1), size(A, 1)] "= exp(A*T)";

  protected
      parameter Integer nmax=21;
      /*max number of iterations*/
      parameter Integer na=size(A, 1);
      Integer j=1;
      Integer k=0;
      Boolean done=false;
      Real Anorm;
      Real Tscaled=1;
      Real Atransf[na, na];
      Real D[na, na];
      /*D: dummy variable for psi*/
      Real M[na, na];
      /*M: dummy matrix*/
      Real Diag[na];
      /*diagonal transformation matrix for balancing*/

      encapsulated function columnNorm "Returns the column norm of a matrix"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real A[:, :] "Input matrix";
        output Real result=0.0 "1-norm of matrix A";
      algorithm
        for i in 1:size(A, 2) loop
          result := max(result, sum(abs(A[:, i])));
        end for;
      end columnNorm;

    algorithm
      // balancing of A
      (Diag,Atransf) := balance(A);

      // scaling of T until norm(A)*/(2^k) < 1
      Tscaled := T;
      /*Anorm: column-norm of matrix A*/
      Anorm := columnNorm(Atransf);
      Anorm := Anorm*T;
      while Anorm >= 0.5 loop
        Anorm := Anorm/2;
        Tscaled := Tscaled/2;
        k := k + 1;
      end while;

      // Computation of psi by Taylor-series approximation
      M := identity(na);
      D := M;
      while j < nmax and not done loop
        M := Atransf*M*Tscaled/j;
        //stop if the new element of the series is small
        if columnNorm((D + M) - D) == 0 then
          done := true;
        else
          D := M + D;
          j := j + 1;
        end if;
      end while;

      // re-scaling
      for i in 1:k loop
        D := D*D;
      end for;

      // re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));
      for j in 1:na loop
        for k in 1:na loop
          phi[j, k] := D[j, k]*Diag[j]/Diag[k];
        end for;
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
phi = Matrices.<strong>exp</strong>(A);
phi = Matrices.<strong>exp</strong>(A,T=1);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the exponential e<sup><strong>A</strong>T</sup> of matrix <strong>A</strong>, i.e.
</p>
<blockquote><pre>
                       (<strong>A</strong>T)^2   (<strong>A</strong>T)^3
<font size=\"4\"> <strong>&Phi;</strong></font> = e^(<strong>A</strong>T) = <strong>I</strong> + <strong>A</strong>T + ------ + ------ + ....
                         2!       3!
</pre></blockquote>

<p>where e=2.71828..., <strong>A</strong> is an n x n matrix with real elements and T is a real number,
e.g., the sampling time.
<strong>A</strong> may be singular. With the exponential of a matrix it is, e.g., possible
to compute the solution of a linear system of differential equations</p>
<blockquote><pre>
der(<strong>x</strong>) = <strong>A</strong>*<strong>x</strong>   ->   <strong>x</strong>(t0 + T) = e^(<strong>A</strong>T)*x(t0)
</pre></blockquote>

<h4>Algorithmic details</h4>

<p>The algorithm is taken from</p>
<dl>
<dt>H. D. Joos, G. Gr&uuml;bel:</dt>
<dd><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong><br>
    DLR - Control Systems Group 1991</dd>
</dl>
<p>The following steps are performed to calculate the exponential of A:</p>
<ol>
  <li>Matrix <strong>A</strong> is balanced<br>
  (= is transformed with a diagonal matrix <strong>D</strong>, such that inv(<strong>D</strong>)*<strong>A</strong>*<strong>D</strong>
  has a smaller condition as <strong>A</strong>).</li>
  <li>The scalar T is divided by a multiple of 2 such that norm(
       inv(<strong>D</strong>)*<strong>A</strong>*<strong>D</strong>*T/2^k ) &lt; 0.5. Note, that (1) and (2) are implemented such that no round-off errors
  are introduced.</li>
  <li>The matrix from (2) is approximated by explicitly performing the Taylor
  series expansion with a variable number of terms.
  Truncation occurs if a new term does no longer contribute to the value of <strong>&Phi;</strong>
  from the previous iteration.</li>
  <li>The resulting matrix is transformed back, by reverting the steps of (2)
  and (1).</li>
</ol>
<p>In several sources it is not recommended to use Taylor series expansion to
calculate the exponential of a matrix, such as in 'C.B. Moler and C.F. Van Loan:
Nineteen dubious ways to compute the exponential of a matrix. SIAM Review 20,
pp. 801-836, 1979' or in the documentation of m-file expm2 in MATLAB version 6
(<a href=\"http://www.mathworks.com\">http://www.mathworks.com</a>) where it is
stated that 'As a practical numerical method, this is often slow and inaccurate'.
These statements are valid for a direct implementation of the Taylor series
expansion, but <em>not</em> for the implementation variant used in this function.
</p>

</html>",   revisions="<html>
<p><strong>Release Notes:</strong></p>
<ul>
<li><em>July 5, 2002</em>
       by H. D. Joos and Nico Walther<br>
       Implemented.
</li>
</ul>
</html>"));
    end exp;

    function integralExp
      "Return the exponential and the integral of the exponential of a matrix"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      input Real B[size(A, 1), :];
      input Real T=1;
      output Real phi[size(A, 1), size(A, 1)] "= exp(A*T)";
      output Real gamma[size(A, 1), size(B, 2)] "= integral(phi)*B";
  protected
      parameter Integer nmax=21;
      /*max number of iterations*/
      parameter Integer na=size(A, 1);
      Integer j=2;
      Integer k=0;
      Boolean done=false;
      Real Anorm;
      Real Tscaled=1;
      Real Atransf[na, na];
      Real Psi[na, na];
      /*Psi: dummy variable for psi*/
      Real M[na, na];
      /*M: dummy matrix*/
      Real Diag[na];
      /*diagonal transformation matrix for balancing*/

      encapsulated function columnNorm "Returns the column norm of a matrix"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real A[:, :] "Input matrix";
        output Real result=0.0 "1-norm of matrix A";
      algorithm
        for i in 1:size(A, 2) loop
          result := max(result, sum(abs(A[:, i])));
        end for;
      end columnNorm;
    algorithm
      // balancing of A
      (Diag,Atransf) := balance(A);

      // scaling of T until norm(A)*/(2^k) < 0.5
      Tscaled := T;
      /*Anorm: column-norm of matrix A*/
      // Anorm := norm(Atransf, 1);
      Anorm := columnNorm(Atransf);
      Anorm := Anorm*T;
      while Anorm >= 0.5 loop
        Anorm := Anorm/2;
        Tscaled := Tscaled/2;
        k := k + 1;
      end while;

      // Computation of psi by Taylor-series approximation
      M := identity(na)*Tscaled;
      Psi := M;
      while j < nmax and not done loop
        M := Atransf*M*Tscaled/j;
        //stop if the new element of the series is small
        // if norm((Psi + M) - Psi, 1) == 0 then
        if columnNorm((Psi + M) - Psi) == 0 then
          done := true;
        else
          Psi := M + Psi;
          j := j + 1;
        end if;
      end while;

      // re-scaling
      for j in 1:k loop
        Psi := Atransf*Psi*Psi + 2*Psi;
      end for;

      // re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));
      for j in 1:na loop
        for k in 1:na loop
          Psi[j, k] := Psi[j, k]*Diag[j]/Diag[k];
        end for;
      end for;
      gamma := Psi*B;
      phi := A*Psi + identity(na);

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(phi,gamma) = Matrices.<strong>integralExp</strong>(A,B);
(phi,gamma) = Matrices.<strong>integralExp</strong>(A,B,T=1);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the exponential phi = e^(<strong>A</strong>T) of matrix <strong>A</strong>
and the integral gamma = integral(phi*dt)*B.
</p>

<p>
The function uses a Taylor series expansion with Balancing and
scaling/squaring to approximate the integral <strong>&Psi;</strong> of the matrix
exponential <strong>&Phi;</strong>=e^(AT):
</p>
<blockquote><pre>
                         AT^2   A^2 * T^3          A^k * T^(k+1)
<strong>&Psi;</strong> = int(e^(As))ds = IT + ---- + --------- + ... + --------------
                          2!        3!                (k+1)!
</pre></blockquote>
<p>
<strong>&Phi;</strong> is calculated through <strong>&Phi;</strong> = I + A*<strong>&Psi;</strong>, so A may be singular. <strong>&Gamma;</strong> is
simply <strong>&Psi;</strong>*B.
</p>
<p>The algorithm runs in the following steps:</p>
<ol>
  <li>Balancing</li>
  <li>Scaling</li>
  <li>Taylor series expansion</li>
  <li>Re-scaling</li>
  <li>Re-Balancing</li>
</ol>
<p>Balancing put the bad condition of a square matrix <em>A</em> into a diagonal
transformation matrix <em>D</em>. This reduce the effort of following calculations.
Afterwards the result have to be re-balanced by transformation D*A<small>transf</small>
*inv(D).<br>
Scaling halfen T&nbsp; k-times, until the norm of A*T is less than 0.5. This
guarantees minimum rounding errors in the following series
expansion. The re-scaling based on the equation&nbsp; exp(A*2T) = exp(AT)^2.
The needed re-scaling formula for psi thus becomes:
</p>
<blockquote><pre>
      <strong>&Phi;</strong> = <strong>&Phi;</strong>'*<strong>&Phi;</strong>'
I + A*<strong>&Psi;</strong> = I + 2A*<strong>&Psi;</strong>' + A^2*<strong>&Psi;</strong>'^2
      <strong>&Psi;</strong> = A*<strong>&Psi;</strong>'^2 + 2*<strong>&Psi;</strong>'
</pre></blockquote>
<p>
where psi' is the scaled result from the series expansion while psi is the
re-scaled matrix.
</p>
<p>
The function is normally used to discretize a state-space system as the
zero-order-hold equivalent:
</p>
<blockquote><pre>
x(k+1) = <strong>&Phi;</strong>*x(k) + <strong>&Gamma;</strong>*u(k)
  y(k) = C*x(k) + D*u(k)
</pre></blockquote>
<p>
The zero-order-hold sampling, also known as step-invariant method, gives
exact values of the state variables, under the assumption that the control
signal u is constant between the sampling instants. Zero-order-hold sampling
is described in
</p>
<dl>
<dt>K. J. &Aring;str&ouml;m, B. Wittenmark:</dt>
<dd><strong>Computer Controlled Systems - Theory and Design</strong><br>
    Third Edition, p. 32</dd>
</dl>
<blockquote><pre><strong>Syntax:</strong>
      (phi,gamma) = Matrices.expIntegral(A,B,T)
                       A,phi: [n,n] square matrices
                     B,gamma: [n,m] input matrix
                           T: scalar, e.g., sampling time
</pre></blockquote>
<p>
The Algorithm to calculate psi is taken from
</p>
<dl>
<dt>H. D. Joos, G. Gr&uuml;bel:</dt>
<dd><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong><br>
    DLR - Control Systems Group 1991</dd>
</dl>
</html>",   revisions="<html>
<p><strong>Release Notes:</strong></p>
<ul>
<li><em>July 5, 2002</em>
       by H. D. Joos and Nico Walther<br>
       Implemented.
</li>
</ul>
</html>"));
    end integralExp;

    function integralExpT
      "Return the exponential, the integral of the exponential, and time-weighted integral of the exponential of a matrix"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      input Real B[size(A, 1), :];
      input Real T=1;
      output Real phi[size(A, 1), size(A, 1)] "= exp(A*T)";
      output Real gamma[size(A, 1), size(B, 2)] "= integral(phi)*B";
      output Real gamma1[size(A, 1), size(B, 2)] "= integral((T-t)*exp(A*t))*B";
  protected
      Integer nmax=200;
      /*max number of iterations*/
      parameter Integer na=size(A, 1);
      parameter Integer nb=size(B, 2);
      Integer j=1;
      Boolean done=false;
      Real F[na + 2*nb, na + 2*nb];

    algorithm
      F := [A, B, zeros(na, nb); zeros(2*nb, na), zeros(2*nb, nb), [identity(nb);
        zeros(nb, nb)]];
      F := exp(F, T);
      phi := F[1:na, 1:na];
      gamma := F[1:na, na + 1:na + nb];
      gamma1 := F[1:na, na + nb + 1:na + 2*nb];

      annotation (Documentation(info="<html>
<blockquote><pre>
(phi,gamma,gamma1) = Matrices.<strong>integralExpT</strong>(A,B);
(phi,gamma,gamma1) = Matrices.<strong>integralExpT</strong>(A,B,T=1);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the exponential phi = e^(<strong>A</strong>T) of matrix <strong>A</strong>
and the integral gamma = integral(phi*dt)*B and the integral
integral((T-t)*exp(A*t)*dt)*B, where A is a square (n,n) matrix and
B, gamma, and gamma1 are (n,m) matrices.
</p>

<p>
The function calculates the matrices phi,gamma,gamma1 through the equation:
</p>
<blockquote><pre>
                                 [ A B 0 ]
[phi gamma gamma1] = [I 0 0]*exp([ 0 0 I ]*T)
                                 [ 0 0 0 ]
</pre></blockquote>

<p>
The matrices define the discretized first-order-hold equivalent of
a state-space system:
</p>
<blockquote><pre>
x(k+1) = phi*x(k) + gamma*u(k) + gamma1/T*(u(k+1) - u(k))
</pre></blockquote>
<p>
The first-order-hold sampling, also known as ramp-invariant method, gives
more smooth control signals as the ZOH equivalent. First-order-hold sampling
is, e.g., described in
</p>

<dl>
<dt>K. J. &Aring;str&ouml;m, B. Wittenmark:</dt>
<dd><strong>Computer Controlled Systems - Theory and Design</strong><br>
    Third Edition, p. 256</dd>
</dl>

</html>",   revisions="<html>
<p><strong>Release Notes:</strong></p>
<ul>
<li><em>July 31, 2002</em>
       by Nico Walther<br>
       Realized.
</li>
</ul>
</html>"));
    end integralExpT;

    function sort
      "Sort the rows or columns of a matrix in ascending or descending order"
      extends Modelica.Icons.Function;
      input Real M[:, :] "Matrix to be sorted";
      input Boolean sortRows=true "= true, if rows are sorted, otherwise columns";
      input Boolean ascending=true
        "= true, if ascending order, otherwise descending order";
      output Real sorted_M[size(M, 1), size(M, 2)]=M "Sorted matrix";
      output Integer indices[if sortRows then size(M, 1) else size(M, 2)]
        "sorted_M = if sortRows then M[indices,:] else M[:,indices]";

      /* shellsort algorithm; should be improved later */
  protected
      Integer gap;
      Integer i;
      Integer j;
      Real wM2[size(M, 2)];
      Integer wi;
      Integer nM1=size(M, 1);
      Boolean swap;
      Real sorted_MT[size(M, 2), size(M, 1)];

      encapsulated function greater "Compare whether vector v1 > v2"
        import Modelica;
        extends Modelica.Icons.Function;
        import Modelica.Utilities.Types.Compare;
        input Real v1[:];
        input Real v2[size(v1, 1)];
        output Boolean result;
    protected
        Integer n=size(v1, 1);
        Integer i=1;
      algorithm
        result := false;
        while i <= n loop
          if v1[i] > v2[i] then
            result := true;
            i := n;
          elseif v1[i] < v2[i] then
            i := n;
          end if;
          i := i + 1;
        end while;
      end greater;

      encapsulated function less "Compare whether vector v1 < v2"
        import Modelica;
        extends Modelica.Icons.Function;
        import Modelica.Utilities.Types.Compare;
        input Real v1[:];
        input Real v2[size(v1, 1)];
        output Boolean result;
    protected
        Integer n=size(v1, 1);
        Integer i=1;
      algorithm
        result := false;
        while i <= n loop
          if v1[i] < v2[i] then
            result := true;
            i := n;
          elseif v1[i] > v2[i] then
            i := n;
          end if;
          i := i + 1;
        end while;
      end less;
    algorithm
      if not sortRows then
        (sorted_MT,indices) := sort(transpose(M), ascending=ascending);
        sorted_M := transpose(sorted_MT);
      else
        indices := 1:size(M, 1);
        gap := div(nM1, 2);
        while gap > 0 loop
          i := gap;
          while i < nM1 loop
            j := i - gap;
            if j >= 0 then
              if ascending then
                swap := greater(sorted_M[j + 1, :], sorted_M[j + gap + 1, :]);
              else
                swap := less(sorted_M[j + 1, :], sorted_M[j + gap + 1, :]);
              end if;
            else
              swap := false;
            end if;

            while swap loop
              wM2 := sorted_M[j + 1, :];
              wi := indices[j + 1];
              sorted_M[j + 1, :] := sorted_M[j + gap + 1, :];
              sorted_M[j + gap + 1, :] := wM2;
              indices[j + 1] := indices[j + gap + 1];
              indices[j + gap + 1] := wi;
              j := j - gap;
              if j >= 0 then
                if ascending then
                  swap := greater(sorted_M[j + 1, :], sorted_M[j + gap + 1, :]);
                else
                  swap := less(sorted_M[j + 1, :], sorted_M[j + gap + 1, :]);
                end if;
              else
                swap := false;
              end if;
            end while;
            i := i + 1;
          end while;
          gap := div(gap, 2);
        end while;
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_M = Matrices.<strong>sort</strong>(M);
(sorted_M, indices) = Matrices.<strong>sort</strong>(M, sortRows=true, ascending=true);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>sort</strong>(..) sorts the rows of a Real matrix M
in ascending order and returns the result in sorted_M.
If the optional argument \"sortRows\" is <strong>false</strong>, the columns
of the matrix are sorted.
If the optional argument \"ascending\" is <strong>false</strong>, the rows or
columns are sorted in descending order. In the optional second
output argument, the indices of the sorted rows or columns with respect
to the original matrix are given, such that
</p>

<blockquote><pre>
sorted_M = <strong>if</strong> sortedRow <strong>then</strong> M[indices,:] <strong>else</strong> M[:,indices];
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
(M2, i2) := Matrices.sort([2, 1,  0;
                           2, 0, -1]);
     -> M2 = [2, 0, -1;
              2, 1, 0 ];
        i2 = {2,1};
</pre></blockquote>
</html>"));
    end sort;

    function flipLeftRight "Flip the columns of a matrix in left/right direction"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix to be flipped";
      output Real Aflip[size(A, 1), size(A, 2)] "Flipped matrix";
    algorithm
      Aflip := A[:, {i for i in size(A, 2):-1:1}];

      annotation (Inline=true, Documentation(info="<html>
 <h4>Syntax</h4>
<blockquote><pre>
A_flr = Matrices.<strong>flipLeftRight</strong>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>flipLeftRight</strong> computes from matrix <strong>A</strong> a matrix <strong>A_flr</strong> with flipped columns, i.e., <strong>A_flr</strong>[:,i]=<strong>A</strong>[:,n-i+1], i=1,..., n.
</p>

<h4>Example</h4>
<blockquote><pre>
A = [1, 2,  3;
     3, 4,  5;
    -1, 2, -3];

A_flr = flipLeftRight(A);

results in:

A_flr = [3, 2,  1;
         5, 4,  3;
        -3, 2, -1]
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">Matrices.flipUpDown</a>
</p>

</html>",   revisions="<html>
<ul>
<li><em>2010/05/31 </em>
       by Marcus Baur, DLR-RM</li>
</ul>
</html>"));
    end flipLeftRight;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.FunctionsPackage;

      pure function dgeev
        "Compute eigenvalues and (right) eigenvectors for real nonsymmetric matrix A"

        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        output Real eigenReal[size(A, 1)] "Real part of eigen values";
        output Real eigenImag[size(A, 1)] "Imaginary part of eigen values";
        output Real eigenVectors[size(A, 1), size(A, 1)] "Right eigen vectors";
        output Integer info;
    protected
        Real dummy[1,1];
        Integer n=size(A, 1);
        Integer lwork=12*n;
        Integer ldvl=1;
        Real Awork[size(A, 1), size(A, 1)]=A;
        Real work[12*size(A, 1)];

      external"FORTRAN 77" dgeev(
                "N",
                "V",
                n,
                Awork,
                n,
                eigenReal,
                eigenImag,
                dummy,
                ldvl,
                eigenVectors,
                n,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="This function is not a full interface to the LAPACK function DGEEV,
but calls it in such a way that only eigenvalues and right eigenvectors
are computed.

Lapack documentation
    Purpose
    =======

    DGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,3*N), and
            if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
            performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
"));
      end dgeev;

      pure function dgeev_eigenValues
        "Compute eigenvalues for real nonsymmetric matrix A"

        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        output Real EigenReal[size(A, 1)];
        output Real EigenImag[size(A, 1)];

        /*
      output Real Eigenvectors[size(A, 1), size(A, 1)]=zeros(size(A, 1), size(
          A, 1)); */
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer lwork=8*n;
        Real Awork[size(A, 1), size(A, 1)]=A;
        Real work[8*size(A, 1)];
        Real EigenvectorsL[size(A, 1), size(A, 1)]=zeros(size(A, 1), size(A, 1));

        /*
    external "FORTRAN 77" dgeev("N", "V", n, Awork, n,
        EigenReal, EigenImag, EigenvectorsL, n,
        Eigenvectors, n, work, lwork, info)
*/
      external"FORTRAN 77" dgeev(
                "N",
                "N",
                n,
                Awork,
                n,
                EigenReal,
                EigenImag,
                EigenvectorsL,
                n,
                EigenvectorsL,
                n,
                work,
                lwork,
                info) annotation (Library="lapack");

        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGEEV computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues and, optionally, the left and/or right eigenvectors.

    The right eigenvector v(j) of A satisfies
                     A * v(j) = lambda(j) * v(j)
    where lambda(j) is its eigenvalue.
    The left eigenvector u(j) of A satisfies
                  u(j)**H * A = lambda(j) * u(j)**H
    where u(j)**H denotes the conjugate transpose of u(j).

    The computed eigenvectors are normalized to have Euclidean norm
    equal to 1 and largest component real.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.

    JOBVR   (input) CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).

    LDVL    (input) INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).

    LDVR    (input) INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,3*N), and
            if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
            performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
"));
      end dgeev_eigenValues;

      pure function dgelsy
        "Compute the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real B[size(A, 1), :];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real X[max(size(A, 1), size(A, 2)), size(B, 2)]=cat(
                  1,
                  B,
                  zeros(max(nrow, ncol) - nrow, nrhs))
          "Solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nx=max(nrow, ncol);
        Integer nrhs=size(B, 2);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + nrhs);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + size(B, 2))];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                X,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy;

      pure function dgelsy_vec
        "Compute the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A, 1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(size(A, 1), size(A, 2))]=cat(
                  1,
                  b,
                  zeros(max(nrow, ncol) - nrow))
          "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nrhs=1;
        Integer nx=max(nrow, ncol);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + 1);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + 1)];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                x,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy_vec;

      pure function dgesv
        "Solve real system of linear equations A*X=B with a B matrix"
        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        input Real B[size(A, 1), :];
        output Real X[size(A, 1), size(B, 2)]=B;
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer nrhs=size(B, 2);
        Real Awork[size(A, 1), size(A, 1)]=A;
        Integer lda=max(1, size(A, 1));
        Integer ldb=max(1, size(B, 1));
        Integer ipiv[size(A, 1)];

      external"FORTRAN 77" dgesv(
                n,
                nrhs,
                Awork,
                lda,
                ipiv,
                X,
                ldb,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGESV computes the solution to a real system of linear equations
       A * X = B,
    where A is an N-by-N matrix and X and B are N-by-NRHS matrices.

    The LU decomposition with partial pivoting and row interchanges is
    used to factor A as
       A = P * L * U,
    where P is a permutation matrix, L is unit lower triangular, and U is
    upper triangular.  The factored form of A is then used to solve the
    system of equations A * X = B.

    Arguments
    =========

    N       (input) INTEGER
            The number of linear equations, i.e., the order of the
            matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N coefficient matrix A.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (output) INTEGER array, dimension (N)
            The pivot indices that define the permutation matrix P;
            row i of the matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the N-by-NRHS matrix of right hand side matrix B.
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
                  has been completed, but the factor U is exactly
                  singular, so the solution could not be computed.
"));
      end dgesv;

      pure function dgesv_vec
        "Solve real system of linear equations A*x=b with a b vector"
        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        input Real b[size(A, 1)];
        output Real x[size(A, 1)]=b;
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer nrhs=1;
        Real Awork[size(A, 1), size(A, 1)]=A;
        Integer lda=max(1, size(A, 1));
        Integer ldb=max(1, size(b, 1));
        Integer ipiv[size(A, 1)];

      external"FORTRAN 77" dgesv(
                n,
                nrhs,
                Awork,
                lda,
                ipiv,
                x,
                ldb,
                info) annotation (Library="lapack");
        annotation (Documentation(info="
Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgesv.
"));
      end dgesv_vec;

      pure function dgglse_vec
        "Solve a linear equality constrained least squares problem"
        extends Modelica.Icons.Function;
        input Real A[:, :] "Minimize |A*x - c|^2";
        input Real c[size(A, 1)];
        input Real B[:, size(A, 2)] "Subject to B*x=d";
        input Real d[size(B, 1)];
        output Real x[size(A, 2)] "Solution vector";
        output Integer info;
    protected
        Integer nrow_A=size(A, 1);
        Integer nrow_B=size(B, 1);
        Integer ncol_A=size(A, 2) "(min=nrow_B,max=nrow_A+nrow_B) required";
        Real Awork[size(A, 1), size(A, 2)]=A;
        Real Bwork[size(B, 1), size(A, 2)]=B;
        Real cwork[size(A, 1)]=c;
        Real dwork[size(B, 1)]=d;
        Integer lwork=ncol_A + nrow_B + max(nrow_A, max(ncol_A, nrow_B))*5;
        Real work[size(A, 2) + size(B, 1) + max(size(A, 1), max(size(A, 2), size(
          B, 1)))*5];

      external"FORTRAN 77" dgglse(
                nrow_A,
                ncol_A,
                nrow_B,
                Awork,
                nrow_A,
                Bwork,
                nrow_B,
                cwork,
                dwork,
                x,
                work,
                lwork,
                info) annotation (Library="lapack");

        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGGLSE solves the linear equality-constrained least squares (LSE)
    problem:

            minimize || c - A*x ||_2   subject to   B*x = d

    where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    M-vector, and d is a given P-vector. It is assumed that
    P <= N <= M+P, and

             rank(B) = P and  rank( (A) ) = N.
                                  ( (B) )

    These conditions ensure that the LSE problem has a unique solution,
    which is obtained using a generalized RQ factorization of the
    matrices (B, A) given by

       B = (0 R)*Q,   A = Z*T*Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrices A and B. N >= 0.

    P       (input) INTEGER
            The number of rows of the matrix B. 0 <= P <= N <= M+P.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix T.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, the upper triangle of the subarray B(1:P,N-P+1:N)
            contains the P-by-P upper triangular matrix R.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,P).

    C       (input/output) DOUBLE PRECISION array, dimension (M)
            On entry, C contains the right hand side vector for the
            least squares part of the LSE problem.
            On exit, the residual sum of squares for the solution
            is given by the sum of squares of elements N-P+1 to M of
            vector C.

    D       (input/output) DOUBLE PRECISION array, dimension (P)
            On entry, D contains the right hand side vector for the
            constrained equation.
            On exit, D is destroyed.

    X       (output) DOUBLE PRECISION array, dimension (N)
            On exit, X is the solution of the LSE problem.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,M+N+P).
            For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
            where NB is an upper bound for the optimal blocksizes for
            DGEQRF, SGERQF, DORMQR and SORMRQ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the upper triangular factor R associated with B in the
                  generalized RQ factorization of the pair (B, A) is
                  singular, so that rank(B) < P; the least squares
                  solution could not be computed.
            = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor
                  T associated with A in the generalized RQ factorization
                  of the pair (B, A) is singular, so that
                  rank( (A) ) < N; the least squares solution could not
                      ( (B) )
                  be computed.
"));
      end dgglse_vec;

      pure function dgesvd "Determine singular value decomposition"
        extends Modelica.Icons.Function;
        input Real A[:, :];
        output Real sigma[min(size(A, 1), size(A, 2))];
        output Real U[size(A, 1), size(A, 1)]=zeros(size(A, 1), size(A, 1));
        output Real VT[size(A, 2), size(A, 2)]=zeros(size(A, 2), size(A, 2));
        output Integer info;
    protected
        Integer m=size(A, 1);
        Integer n=size(A, 2);
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer lwork=5*size(A, 1) + 5*size(A, 2);
        Real work[5*size(A, 1) + 5*size(A, 2)];

      external"FORTRAN 77" dgesvd(
                "A",
                "A",
                m,
                n,
                Awork,
                m,
                sigma,
                U,
                m,
                VT,
                n,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGESVD computes the singular value decomposition (SVD) of a real
    M-by-N matrix A, optionally computing the left and/or right singular
    vectors. The SVD is written

         A = U * SIGMA * transpose(V)

    where SIGMA is an M-by-N matrix which is zero except for its
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
    are the singular values of A; they are real and non-negative, and
    are returned in descending order.  The first min(m,n) columns of
    U and V are the left and right singular vectors of A.

    Note that the routine returns V**T, not V.

    Arguments
    =========

    JOBU    (input) CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U are returned in array U:
            = 'S':  the first min(m,n) columns of U (the left singular
                    vectors) are returned in the array U;
            = 'O':  the first min(m,n) columns of U (the left singular
                    vectors) are overwritten on the array A;
            = 'N':  no columns of U (no left singular vectors) are
                    computed.

    JOBVT   (input) CHARACTER*1
            Specifies options for computing all or part of the matrix
            V**T:
            = 'A':  all N rows of V**T are returned in the array VT;
            = 'S':  the first min(m,n) rows of V**T (the right singular
                    vectors) are returned in the array VT;
            = 'O':  the first min(m,n) rows of V**T (the right singular
                    vectors) are overwritten on the array A;
            = 'N':  no rows of V**T (no right singular vectors) are
                    computed.

            JOBVT and JOBU cannot both be 'O'.

    M       (input) INTEGER
            The number of rows of the input matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the input matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBU = 'O',  A is overwritten with the first min(m,n)
                            columns of U (the left singular vectors,
                            stored columnwise);
            if JOBVT = 'O', A is overwritten with the first min(m,n)
                            rows of V**T (the right singular vectors,
                            stored rowwise);
            if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
                            are destroyed.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).

    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
            (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
            If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
            if JOBU = 'S', U contains the first min(m,n) columns of U
            (the left singular vectors, stored columnwise);
            if JOBU = 'N' or 'O', U is not referenced.

    LDU     (input) INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBU = 'S' or 'A', LDU >= M.

    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
            V**T;
            if JOBVT = 'S', VT contains the first min(m,n) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBVT = 'N' or 'O', VT is not referenced.

    LDVT    (input) INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
            superdiagonal elements of an upper bidiagonal matrix B
            whose diagonal is in S (not necessarily sorted). B
            satisfies A = U * B * VT, so it has the same singular values
            as A, and singular vectors related by U and VT.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            LWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
            For good performance, LWORK should generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit.
            < 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if DBDSQR did not converge, INFO specifies how many
                  superdiagonals of an intermediate bidiagonal form B
                  did not converge to zero. See the description of WORK
                  above for details.
"));
      end dgesvd;

      pure function dgetrf
        "Compute LU factorization of square or rectangular matrix A (A = P*L*U)"

        extends Modelica.Icons.Function;
        input Real A[:, :] "Square or rectangular matrix";
        output Real LU[size(A, 1), size(A, 2)]=A;
        output Integer pivots[min(size(A, 1), size(A, 2))] "Pivot vector";
        output Integer info "Information";
    protected
        Integer m=size(A, 1);
        Integer n=size(A, 2);
        Integer lda=max(1, size(A, 1));

      external"FORTRAN 77" dgetrf(
                m,
                n,
                LU,
                lda,
                pivots,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
"));
      end dgetrf;

      pure function dgetrs
        "Solve a system of linear equations with the LU decomposition from dgetrf"

        extends Modelica.Icons.Function;
        input Real LU[:, size(LU, 1)]
          "LU factorization of dgetrf of a square matrix";
        input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
        input Real B[size(LU, 1), :] "Right hand side matrix B";
        output Real X[size(B, 1), size(B, 2)]=B "Solution matrix X";
        output Integer info;
    protected
        Integer n=size(LU, 1);
        Integer nrhs=size(B, 2);
        Real work[size(LU, 1), size(LU, 1)]=LU;
        Integer lda=max(1, size(LU, 1));
        Integer ldb=max(1, size(B, 1));

      external"FORTRAN 77" dgetrs(
                "N",
                n,
                nrhs,
                work,
                lda,
                pivots,
                X,
                ldb,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRS solves a system of linear equations
       A * X = B  or  A' * X = B
    with a general N-by-N matrix A using the LU factorization computed
    by DGETRF.

    Arguments
    =========

    TRANS   (input) CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A'* X = B  (Transpose)
            = 'C':  A'* X = B  (Conjugate transpose = Transpose)

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.

    A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
"));
      end dgetrs;

      pure function dgetri
        "Compute the inverse of a matrix using the LU factorization from dgetrf"

        extends Modelica.Icons.Function;
        input Real LU[:, size(LU, 1)]
          "LU factorization of dgetrf of a square matrix";
        input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
        output Real inv[size(LU, 1), size(LU, 2)]=LU "Inverse of matrix P*L*U";
        output Integer info;

    protected
        Integer n=size(LU, 1);
        Integer lda=max(1, size(LU, 1));
        Integer lwork=max(1, min(10, size(LU, 1))*size(LU, 1))
          "Length of work array";
        Real work[max(1, min(10, size(LU, 1))*size(LU, 1))];

      external"FORTRAN 77" dgetri(
                n,
                inv,
                lda,
                pivots,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRI computes the inverse of a matrix using the LU factorization
    computed by DGETRF.

    This method inverts U and then computes inv(A) by solving the system
    inv(A)*L = inv(U) for inv(A).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
"));
      end dgetri;

      pure function dgeqp3 "Compute QR factorization with column pivoting of square or rectangular matrix A"

        extends Modelica.Icons.Function;
        input Real A[:, :] "Square or rectangular matrix";
        input Integer lwork=max(1, 3*size(A, 2) + 1) "Length of work array";
        output Real QR[size(A, 1), size(A, 2)]=A
          "QR factorization in packed format";
        output Real tau[min(size(A, 1), size(A, 2))]
          "The scalar factors of the elementary reflectors of Q";
        output Integer p[size(A, 2)]=zeros(size(A, 2)) "Pivot vector";
        output Integer info;
    protected
        Integer m=size(A, 1);
        Integer lda=max(1, size(A, 1));
        Integer ncol=size(A, 2) "Column dimension of A";
        Real work[lwork] "Work array";

      external"FORTRAN 77" dgeqp3(
                m,
                ncol,
                QR,
                lda,
                p,
                tau,
                work,
                lwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGEQP3 computes a QR factorization with column pivoting of a
    matrix A:  A*P = Q*R  using Level 3 BLAS.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA >= max(1,M).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= 3*N+1.
            For optimal performance LWORK >= 2*N+( N+1 )*NB, where NB
            is the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit.
            < 0: if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real/complex scalar, and v is a real/complex vector
    with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
    A(i+1:m,i), and tau in TAU(i).

    Based on contributions by
      G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
      X. Sun, Computer Science Dept., Duke University, USA
"));
      end dgeqp3;

      pure function dorgqr
        "Generate a Real orthogonal matrix Q which is defined as the product of elementary reflectors as returned from dgeqrf"

        extends Modelica.Icons.Function;
        input Real QR[:, :] "QR from dgeqrf";
        input Real tau[min(size(QR, 1), size(QR, 2))]
          "The scalar factors of the elementary reflectors of Q";
        output Real Q[size(QR, 1), size(QR, 2)]=QR "Orthogonal matrix Q";
        output Integer info;

    protected
        Integer m=size(QR, 1);
        Integer n=size(QR, 2);
        Integer k=size(tau, 1);
        Integer lda=max(1, size(Q, 1));
        Integer lwork=max(1, min(10, size(QR, 2))*size(QR, 2))
          "Length of work array";
        Real work[max(1, min(10, size(QR, 2))*size(QR, 2))];

      external"FORTRAN 77" dorgqr(
                m,
                n,
                k,
                Q,
                lda,
                tau,
                work,
                lwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DORGQR generates an M-by-N real matrix Q with orthonormal columns,
    which is defined as the first N columns of a product of K elementary
    reflectors of order M

          Q  =  H(1) H(2) . . . H(k)

    as returned by DGEQRF.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix Q. M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix Q. M >= N >= 0.

    K       (input) INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by DGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.

    LDA     (input) INTEGER
            The first dimension of the array A. LDA >= max(1,M).

    TAU     (input) DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument has an illegal value
"));
      end dorgqr;

      pure function dgees
        "Compute real Schur form T of real nonsymmetric matrix A, and, optionally, the matrix of Schur vectors Z as well as the eigenvalues"
        extends Modelica.Icons.Function;

        input Real A[:, size(A, 1)] "Square matrix";
        output Real T[size(A, 1), size(A, 2)]=A "Real Schur form with A = Z*T*Z'";
        output Real Z[size(A, 1), size(A, 1)]
          "Orthogonal matrix Z of Schur vectors";
        output Real eval_real[size(A, 1)] "Real part of the eigenvectors of A";
        output Real eval_imag[size(A, 1)]
          "Imaginary part of the eigenvectors of A";
        output Integer info;

    protected
        constant Integer dummyFunctionPointerNotUsed[1]={0};
        Integer n=size(A, 1) "Row dimension of A";
        Integer lda=max(1, n);
        Integer sdim=0;
        Integer lwork=max(1, 10*size(A, 1));
        Real work[lwork];
        Boolean bwork[size(A, 1)];

      external"FORTRAN 77" dgees(
                "V",
                "N",
                dummyFunctionPointerNotUsed,
                n,
                T,
                lda,
                sdim,
                eval_real,
                eval_imag,
                Z,
                lda,
                work,
                lwork,
                bwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGEES computes for an N-by-N real nonsymmetric matrix A, the
    eigenvalues, the real Schur form T, and, optionally, the matrix of
    Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).

    Optionally, it also orders the eigenvalues on the diagonal of the
    real Schur form so that selected eigenvalues are at the top left.
    The leading columns of Z then form an orthonormal basis for the
    invariant subspace corresponding to the selected eigenvalues.

    A matrix is in real Schur form if it is upper quasi-triangular with
    1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
    form
            [  a  b  ]
            [  c  a  ]

    where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).

    Arguments
    =========

    JOBVS   (input) CHARACTER*1
            = 'N': Schur vectors are not computed;
            = 'V': Schur vectors are computed.

    SORT    (input) CHARACTER*1
            Specifies whether or not to order the eigenvalues on the
            diagonal of the Schur form.
            = 'N': Eigenvalues are not ordered;
            = 'S': Eigenvalues are ordered (see SELECT).

    SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
            SELECT must be declared EXTERNAL in the calling subroutine.
            If SORT = 'S', SELECT is used to select eigenvalues to sort
            to the top left of the Schur form.
            If SORT = 'N', SELECT is not referenced.
            An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
            SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
            conjugate pair of eigenvalues is selected, then both complex
            eigenvalues are selected.
            Note that a selected complex eigenvalue may no longer
            satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case INFO is set to N+2 (see INFO below).

    N       (input) INTEGER
            The order of the matrix A. N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten by its real Schur form T.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    SDIM    (output) INTEGER
            If SORT = 'N', SDIM = 0.
            If SORT = 'S', SDIM = number of eigenvalues (after sorting)
                           for which SELECT is true. (Complex conjugate
                           pairs for which SELECT is true for either
                           eigenvalue count as 2.)

    WR      (output) DOUBLE PRECISION array, dimension (N)
    WI      (output) DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues in the same order
            that they appear on the diagonal of the output Schur form T.
            Complex conjugate pairs of eigenvalues will appear
            consecutively with the eigenvalue having the positive
            imaginary part first.

    VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
            If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
            vectors.
            If JOBVS = 'N', VS is not referenced.

    LDVS    (input) INTEGER
            The leading dimension of the array VS.  LDVS >= 1; if
            JOBVS = 'V', LDVS >= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) contains the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,3*N).
            For good performance, LWORK must generally be larger.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    BWORK   (workspace) LOGICAL array, dimension (N)
            Not referenced if SORT = 'N'.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: if INFO = -i, the i-th argument had an illegal value.
            > 0: if INFO = i, and i is
               <= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = 'V', VS contains the matrix which reduces A
                     to its partially converged Schur form.
               = N+1: the eigenvalues could not be reordered because some
                     eigenvalues were too close to separate (the problem
                     is very ill-conditioned);
               = N+2: after reordering, roundoff changed values of some
                     complex eigenvalues so that leading eigenvalues in
                     the Schur form no longer satisfy SELECT=.TRUE.  This
                     could also be caused by underflow due to scaling.
"));
      end dgees;

      pure function dgehrd
        "Reduce a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q' * A * Q = H"
        extends Modelica.Icons.Function;

        input Real A[:, size(A, 1)];
        input Integer ilo=1
          "Lowest index where the original matrix is not in upper triangular form";
        input Integer ihi=size(A, 1)
          "Highest index where the original matrix is not in upper triangular form";
        output Real Aout[size(A, 1), size(A, 2)]=A
          "Contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q";
        output Real tau[max(size(A, 1), 1) - 1]
          "Scalar factors of the elementary reflectors";
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer lda=max(1, n);
        Integer lwork=max(1, 3*n);
        Real work[max(1, 3*size(A, 1))];

      external"FORTRAN 77" dgehrd(
                n,
                ilo,
                ihi,
                Aout,
                lda,
                tau,
                work,
                lwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGEHRD reduces a real general matrix A to upper Hessenberg form H by
    an orthogonal similarity transformation:  Q' * A * Q = H .

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    ILO     (input) INTEGER
    IHI     (input) INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to DGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    TAU     (output) DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value.

    Further Details
    ===============

    The matrix Q is represented as a product of (ihi-ilo) elementary
    reflectors

       Q = H(ilo) H(ilo+1) . . . H(ihi-1).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
    exit in A(i+2:ihi,i), and tau in TAU(i).

    The contents of A are illustrated by the following example, with
    n = 7, ilo = 2 and ihi = 6:

    on entry,                        on exit,

    ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
    (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
    (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
    (                         a )    (                          a )

    where a denotes an element of the original matrix A, h denotes a
    modified element of the upper Hessenberg matrix H, and vi denotes an
    element of the vector defining H(i).
"));
      end dgehrd;

      pure function dgeqrf "Compute a QR factorization without pivoting"
        extends Modelica.Icons.Function;

        input Real A[:, :] "Square or rectangular matrix";
        output Real Aout[size(A, 1), size(A, 2)]=A
          "The upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors";
        output Real tau[min(size(A, 1), size(A, 2))]
          "Scalar factors of the elementary reflectors";
        output Integer info;
        output Real work[3*max(1, size(A, 2))];
    protected
        Integer m=size(A, 1);
        Integer n=size(A, 2);
        Integer lda=max(1, m);
        Integer lwork=3*max(1, n);

      external"FORTRAN 77" dgeqrf(
                m,
                n,
                Aout,
                lda,
                tau,
                work,
                lwork,
                info) annotation (Library={"lapack"});
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGEQRF computes a QR factorization of a real M-by-N matrix A:
    A = Q * R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(k), where k = min(m,n).

    Each H(i) has the form

       H(i) = I - tau * v * v'

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
    and tau in TAU(i).
"));
      end dgeqrf;
      annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;

    package Utilities
    "Utility functions that should not be directly utilized by the user"
      extends Modelica.Icons.UtilitiesPackage;

      function toUpperHessenberg
        "Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q' * A * Q = H"
        extends Modelica.Icons.Function;

        import Modelica.Math.Matrices;
        import Modelica.Math.Matrices.LAPACK;

        input Real A[:, size(A, 1)] "Square matrix A";
        input Integer ilo=1
          "Lowest index where the original matrix is not in upper triangular form";
        input Integer ihi=size(A, 1)
          "Highest index where the original matrix is not in upper triangular form";
        output Real H[size(A, 1), size(A, 2)] "Upper Hessenberg form";
        output Real V[size(A, 1), size(A, 2)]
          "V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors";

        output Real tau[max(0, size(A, 1) - 1)]
          "Scalar factors of the elementary reflectors";
        output Integer info "Information of successful function call";

    protected
        Integer n=size(A, 1);
        Real Aout[size(A, 1), size(A, 2)];
        Integer i;

      algorithm
        if n > 0 then
          if n == 1 then
            H := A;
            V := {{0.0}};
            tau := zeros(0);
            info := 0;
          else
            (Aout, tau, info) := LAPACK.dgehrd(A, ilo, ihi);
            H := zeros(size(H, 1), size(H, 2));
            H[1:2, 1:n] := Aout[1:2, 1:n];
            for i in 3:n loop
              H[i, (i - 1):n] := Aout[i, (i - 1):n];
            end for;
            V := zeros(size(V, 1), size(V, 2));
            for i in ilo:min(n - 2, ihi) loop
              V[i + 1, i] := 1.0;
              V[(i + 2):n, i] := Aout[(i + 2):n, i];
            end for;
            V[n, n - 1] := 1;
          end if;
        end if;
      annotation (Documentation(info="<html>
   <h4>Syntax</h4>
<blockquote><pre>
                H = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A);
(H, V, tau, info) = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A,ilo, ihi);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>toUpperHessenberg</strong> computes a upper Hessenberg form <strong>H</strong> of a matrix <strong>A</strong> by orthogonal similarity transformation:  <strong>Q</strong>' * <strong>A</strong> * <strong>Q</strong> = <strong>H</strong>.
The optional inputs <strong>ilo</strong> and <strong>ihi</strong> improve efficiency if the matrix is already partially converted to Hessenberg form; it is assumed
that matrix <strong>A</strong> is already upper Hessenberg for rows and columns <strong>1:(ilo-1)</strong> and <strong>(ihi+1):size(A, 1)</strong>.
The function calls <a href=\"modelica://Modelica.Math.Matrices.LAPACK.dgehrd\">LAPACK.dgehrd</a>.
See <a href=\"modelica://Modelica.Math.Matrices.LAPACK.dgehrd\">Matrices.LAPACK.dgehrd</a> for more information about the additional outputs V, tau, info and inputs ilo, ihi.
</p>

<h4>Example</h4>
<blockquote><pre>
A  = [1, 2, 3;
      6, 5, 4;
      1, 0, 0];

H = toUpperHessenberg(A);

results in:

H = [1.0,  -2.466,  2.630;
    -6.083, 5.514, -3.081;
     0.0,   0.919, -0.514]
</pre></blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.hessenberg\">Matrices.hessenberg</a>
</html>",   revisions="<html><ul>
<li><em>2010/04/30 </em>
       by Marcus Baur, DLR-RM</li>
</ul>
</html>"));
      end toUpperHessenberg;
      annotation (Documentation(info="<html>
<p>
This package contains utility functions that are utilized by higher level matrix functions.
These functions are usually not useful for an end-user.
</p>
</html>"));
    end Utilities;
    annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><strong>Basic Information</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><strong>Linear Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><strong>Matrix Factorizations</strong></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><strong>Matrix Properties</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><strong>Matrix Exponentials</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><strong>Matrix Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccati equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccati equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><strong>Matrix Manipulation</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</html>"),   Icon(graphics={
          Rectangle(
            extent={{-60,66},{-30,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,66},{58,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,-18},{-30,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,-18},{58,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Matrices;

  package Icons "Icons for Math"
    extends Modelica.Icons.IconsPackage;

    partial function AxisLeft
      "Basic icon for mathematical function with y-axis on left side"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              textColor={0,0,255})}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisLeft;

    partial function AxisCenter
      "Basic icon for mathematical function with y-axis in the center"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              textColor={0,0,255})}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisCenter;
  end Icons;

  function isEqual "Determine if two Real scalars are numerically identical"
    extends Modelica.Icons.Function;
    input Real s1 "First scalar";
    input Real s2 "Second scalar";
    input Real eps(min=0) = 0
      "The two scalars are identical if abs(s1-s2) <= eps";
    output Boolean result "= true, if scalars are identical";
  algorithm
    result := abs(s1 - s2) <= eps;
    annotation (Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Math.<strong>isEqual</strong>(s1, s2);
Math.<strong>isEqual</strong>(s1, s2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Math.isEqual(s1, s2)</code>\" returns <strong>true</strong>,
if the two Real scalars s1 and s2 are identical. Otherwise the function
returns <strong>false</strong>. The equality check is performed by
\"abs(s1-s2) &le; eps\", where \"eps\"
can be provided as third argument of the function. Default is \"eps = 0\".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real s1 = 2.0;
  Real s2 = 2.0;
  Real s3 = 2.000001;
  Boolean result;
<strong>algorithm</strong>
  result := Math.isEqual(s1,s2);     // = <strong>true</strong>
  result := Math.isEqual(s1,s3);     // = <strong>false</strong>
  result := Math.isEqual(s1,s3,0.1); // = <strong>true</strong>
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Vectors.isEqual\">Vectors.isEqual</a>,
<a href=\"modelica://Modelica.Math.Matrices.isEqual\">Matrices.isEqual</a>,
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">Strings.isEqual</a>
</p>
</html>"));
  end isEqual;

  function sin "Sine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=sin(u)";

  external "builtin" y = sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}),
          Text(
            extent={{12,84},{84,36}},
            textColor={192,192,192},
            textString="sin")}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"));
  end sin;

  function cos "Cosine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=cos(u)";

  external "builtin" y = cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}),
          Text(
            extent={{-36,82},{36,34}},
            textColor={192,192,192},
            textString="cos")}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"));
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends Modelica.Math.Icons.AxisCenter;
    input Modelica.Units.SI.Angle u "Independent variable";
    output Real y "Dependent variable y=tan(u)";

  external "builtin" y = tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}),
          Text(
            extent={{-90,72},{-18,24}},
            textColor={192,192,192},
            textString="tan")}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"));
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Modelica.Units.SI.Angle y "Dependent variable y=asin(u)";

  external "builtin" y = asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}),
          Text(
            extent={{-88,78},{-16,30}},
            textColor={192,192,192},
            textString="asin")}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"));
  end asin;

  function atan2 "Four quadrant inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u1 "First independent variable";
    input Real u2 "Second independent variable";
    output Modelica.Units.SI.Angle y "Dependent variable y=atan2(u1, u2)=atan(u1/u2)";

  external "builtin" y = atan2(u1, u2);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
                {69.9,-45.8},{80,-45.1}}),
          Line(points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
                -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
                62.1,33.5},{80,34.9}}),
          Line(points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
                65.8},{-1.82,77.2},{0,80}}),
          Text(
            extent={{-90,-46},{-18,-94}},
            textColor={192,192,192},
            textString="atan2")}),
      Documentation(info="<html>
<p>
This function returns y = atan2(u1,u2) such that tan(y) = u1/u2 and
y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
u1 is not zero. Usually u1, u2 is provided in such a form that
u1 = sin(y) and u2 = cos(y):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan2.png\">
</p>

</html>"));
  end atan2;

  function atan3
    "Four quadrant inverse tangent (select solution that is closest to given angle y0)"
    import Modelica.Constants.pi;
    extends Modelica.Math.Icons.AxisCenter;
    input Real u1 "First independent variable";
    input Real u2 "Second independent variable";
    input Modelica.Units.SI.Angle y0=0 "y shall be in the range: -pi < y-y0 <= pi";
    output Modelica.Units.SI.Angle y "Dependent variable y=atan3(u1, u2, y0)=atan(u1/u2)";

  protected
    constant Real pi2=2*pi;
    Real w;
  algorithm
    w := Math.atan2(u1, u2);
    if y0 == 0 then
      // For the default (y0 = 0), exactly the same result as with atan2(..) is returned
      y := w;
    else
      /* -pi < y - y0 <= pi
       -pi < w + 2*pi*N - y0 <= pi
       (-pi+y0-w)/(2*pi) < N <= (pi+y0-w)/(2*pi)
       -> N := integer( (pi+y0-w)/(2*pi) )
    */
      y := w + pi2*integer((pi+y0-w)/pi2);
    end if;
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
                {69.9,-45.8},{80,-45.1}}),
          Line(points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
                -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
                62.1,33.5},{80,34.9}}),
          Line(points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
                65.8},{-1.82,77.2},{0,80}}),
          Text(
            extent={{-90,-46},{-18,-94}},
            textColor={192,192,192},
            textString="atan3")}),
      Documentation(info="<html>
<p>
This function returns y = <strong>atan3</strong>(u1,u2,y0) such that
<strong>tan</strong>(y) = u1/u2 and
y is in the range: -pi &lt; y-y0 &le; pi.<br>
u2 may be zero, provided u1 is not zero. The difference to
Modelica.Math.atan2(..) is the optional third argument y0 that
allows to specify which of the infinite many solutions
shall be returned:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan3.png\">
</p>

<p>
Note, for the default case (y0=0), exactly the same result as with atan2(..)
is returned.
</p>
</html>"));
  end atan3;

  function asinh "Inverse of sinh (area hyperbolic sine)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Real y "Dependent variable y=asinh(u)";

  algorithm
    y := Modelica.Math.log(u + sqrt(u*u + 1));
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-56.7,-68.4},{-39.8,-56.8},{-26.9,-44.7},{-17.3,
                -32.4},{-9.25,-19},{9.25,19},{17.3,32.4},{26.9,44.7},{39.8,56.8},
                {56.7,68.4},{80,80}}),
          Text(
            extent={{-90,80},{-6,26}},
            textColor={192,192,192},
            textString="asinh")}),
      Documentation(info="<html>
<p>
The function returns the area hyperbolic sine of its
input argument u. This inverse of sinh(..) is unique
and there is no restriction on the input argument u of
asinh(u) (-&infin; &lt; u &lt; &infin;):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asinh.png\">
</p>
</html>"));
  end asinh;

  function exp "Exponential, base e"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u "Independent variable";
    output Real y "Dependent variable y=exp(u)";

  external "builtin" y = exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
          Text(
            extent={{-86,50},{-14,2}},
            textColor={192,192,192},
            textString="exp")}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"));
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u "Independent variable";
    output Real y "Dependent variable y=ln(u)";

  external "builtin" y = log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-6,-24},{66,-72}},
            textColor={192,192,192},
            textString="log")}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"));
  end log;

  function log10 "Base 10 logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u "Independent variable";
    output Real y "Dependent variable y=lg(u)";

  external "builtin" y = log10(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-79.8,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-30,-22},{60,-70}},
            textColor={192,192,192},
            textString="log10")}),
      Documentation(info="<html>
<p>
This function returns y = log10(u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log10.png\">
</p>
</html>"));
  end log10;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
            {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
              {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
              -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
              -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
              {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
              0,0,0}, smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<h4>Main Authors</h4>
<p><a href=\"http://www.robotic.dlr.de/Martin.Otter/\"><strong>Martin Otter</strong></a>
and <strong>Marcus Baur</strong><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a>
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 22, 2019</em>
       by Thomas Beutlich: Functions tempInterpol1/tempInterpol2 moved to ObsoleteModelica4</li>
<li><em>August 24, 2016</em>
       by Christian Kral: added wrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Function tempInterpol2 added.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"));
  end Math;

  package ComplexMath
  "Library of complex mathematical functions (e.g., sin, cos) and of functions operating on complex vectors and matrices"
    extends Modelica.Icons.Package;

    final constant Complex j = Complex(0,1) "Imaginary unit";

    function arg "Phase angle of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      input Modelica.Units.SI.Angle phi0=0
        "Phase angle phi shall be in the range: -pi < phi-phi0 < pi";
      output Modelica.Units.SI.Angle phi "= phase angle of c";
    algorithm
      phi := Modelica.Math.atan3(
          c.im,
          c.re,
          phi0);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Real argument of the Complex input, i.e., its angle.</p>
</html>"));
    end arg;

    function conj "Conjugate of complex number"
      extends Modelica.Icons.Function;
      input Complex c1 "Complex number";
      output Complex c2 "= c1.re - j*c1.im";
    algorithm
      c2 := Complex(c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Complex conjugate of the Complex input.</p>
</html>"));
    end conj;

    function real "Real part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.re";
    algorithm
      r := c.re;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the real part of the Complex input.</p>
</html>"));
    end real;

    function imag "Imaginary part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.im";
    algorithm
      r := c.im;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the imaginary part of the Complex input.</p>
</html>"));
    end imag;

    function fromPolar "Complex from polar representation"
      extends Modelica.Icons.Function;
      input Real len "abs of complex";
      input Modelica.Units.SI.Angle phi "arg of complex";
      output Complex c "= len*cos(phi) + j*len*sin(phi)";
    algorithm
      c := Complex(len*Modelica.Math.cos(phi), len*Modelica.Math.sin(phi));
      annotation(Inline=true, Documentation(info="<html>
<p>This function constructs a Complex number from its length (absolute) and angle (argument).</p>
</html>"));
    end fromPolar;
    annotation (Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong>
operating on complex numbers (such as sin(..)),
as well as functions operating on vectors of complex numbers.
</p>

</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=false), graphics={
          Line(points={{32,-86},{32,88}}, color={175,175,175}),
          Line(points={{-84,2},{88,2}}, color={175,175,175}),
          Line(
            points={{-50,75},{-5,30}}),
          Line(
            points={{-50,30},{-5,75}}),
          Line(
            points={{-50,-30},{-5,-75}}),
          Line(
            points={{-50,-75},{-5,-30}})}));
  end ComplexMath;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.UtilitiesPackage;

    package Files "Functions to work with files and directories"
      extends Modelica.Icons.FunctionsPackage;

    impure function copy "Generate a copy of a file or of a directory"
      extends Modelica.Icons.Function;
      input String oldName "Name of file or directory to be copied";
      input String newName "Name of copy of the file or of the directory";
      input Boolean replace=false
          "= true, if an existing file may be replaced by the required copy";
    //..............................................................
    protected
      impure function copyDirectory "Copy a directory"
         extends Modelica.Icons.Function;
         input String oldName
            "Old directory name without trailing '/'; existence is guaranteed";
         input String newName
            "New directory name without trailing '/'; directory was already created";
         input Boolean replace "= true, if an existing newName may be replaced";
      algorithm
         copyDirectoryContents(Modelica.Utilities.Internal.FileSystem.readDirectory(
                                           oldName, Modelica.Utilities.Internal.FileSystem.getNumberOfFiles(
                                                    oldName)), oldName, newName, replace);
      end copyDirectory;

      impure function copyDirectoryContents
        extends Modelica.Icons.Function;
        input String oldNames[:];
        input String oldName;
        input String newName;
        input Boolean replace;
      protected
         String oldName_i;
         String newName_i;
      algorithm
         for i in 1:size(oldNames,1) loop
            oldName_i := oldName + "/" + oldNames[i];
            newName_i := newName + "/" + oldNames[i];
            Files.copy(oldName_i, newName_i, replace);
         end for;
      end copyDirectoryContents;
    //..............................................................

      Integer lenOldName = Strings.length(oldName);
      Integer lenNewName = Strings.length(newName);
      String oldName2 = if Strings.substring(oldName,lenOldName,lenOldName) == "/" then
                           Strings.substring(oldName,1,lenOldName-1) else oldName;
      String newName2 = if Strings.substring(newName,lenNewName,lenNewName) == "/" then
                           Strings.substring(newName,1,lenNewName-1) else newName;
      Types.FileType oldFileType = Modelica.Utilities.Internal.FileSystem.stat(
                                                 oldName2);
      Types.FileType newFileType;
    algorithm
      if oldFileType == Types.FileType.NoFile then
         Streams.error("It is not possible to copy the file or directory\n" +
                       "\"" + oldName2 + "\" because it does not exist.");
      elseif oldFileType == Types.FileType.Directory then
         newFileType :=Modelica.Utilities.Internal.FileSystem.stat(
                                     newName2);
         if newFileType == Types.FileType.NoFile then
            createDirectory(newName2);
         elseif newFileType == Types.FileType.RegularFile or
                newFileType == Types.FileType.SpecialFile then
            if replace then
               Files.removeFile(newName2);
               Files.createDirectory(newName2);
            else
               Streams.error("Directory \"" + oldName2 + "\" should be copied to\n" +
                             "\"" + newName2 + "\" which is an existing file.\n" +
                             "Since argument replace=false, this is not allowed");
            end if;
         end if;
         copyDirectory(oldName2, newName2, replace);
      else // regular or special file
         if replace then
            Files.removeFile(newName2);
         else
            Files.assertNew(newName2, "File \"" + oldName2 + "\" should be copied or moved to\n" +
                                      "\"" + newName2 + "\" which is an existing file or directory.\n" +
                                      "Since argument replace=false, this is not allowed");
         end if;
         Modelica.Utilities.Internal.FileSystem.copyFile(
                           oldName2, newName2);
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>copy</strong>(oldName, newName);
Files.<strong>copy</strong>(oldName, newName, replace = true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>copy</strong>(..) copies a file or a directory
to a new location. Via the optional argument <strong>replace</strong>
it can be defined whether an already existing file may
be replaced by the required copy.
</p>
<p>
If oldName/newName are directories, then the newName
directory may exist. In such a case the content of oldName
is copied into directory newName. If replace = <strong>false</strong>
it is required that the existing files
in newName are different from the existing files in
oldName.
</p>
<h4>Example</h4>
<blockquote><pre>
copy(\"C:/test1/directory1\", \"C:/test2/directory2\");
   -> the content of directory1 is copied into directory2
      if \"C:/test2/directory2\" does not exist, it is newly
      created. If \"replace=true\", files in directory2
      may be overwritten by their copy
copy(\"test1.txt\", \"test2.txt\")
   -> make a copy of file \"test1.txt\" with the name \"test2.txt\"
      in the current directory
</pre></blockquote>
</html>"));
    end copy;

    impure function move "Move a file or a directory to another place"
      extends Modelica.Icons.Function;
      input String oldName "Name of file or directory to be moved";
      input String newName "New name of the moved file or directory";
      input Boolean replace=false
          "= true, if an existing file or directory may be replaced";
    algorithm
      // if both oldName and newName are in the current directory
      // use Internal.renameFile
      if Strings.find(oldName,"/") == 0 and Strings.find(newName,"/") == 0 then
         if replace then
            Files.remove(newName);
         end if;
         Internal.FileSystem.rename(oldName, newName);
      else
         Files.copy(oldName, newName, replace);
         Files.remove(oldName);
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>move</strong>(oldName, newName);
Files.<strong>move</strong>(oldName, newName, replace = true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>move</strong>(..) moves a file or a directory
to a new location. Via the optional argument <strong>replace</strong>
it can be defined whether an already existing file may
be replaced.
</p>
<p>
If oldName/newName are directories, then the newName
directory may exist. In such a case the content of oldName
is moved into directory newName. If replace = <strong>false</strong>
it is required that the existing files
in newName are different from the existing files in
oldName.
</p>
<h4>Example</h4>
<blockquote><pre>
move(\"C:/test1/directory1\", \"C:/test2/directory2\");
   -> the content of directory1 is moved into directory2.
      Afterwards directory1 is deleted.
      if \"C:/test2/directory2\" does not exist, it is newly
      created. If \"replace=true\", files in directory2
      may be overwritten
move(\"test1.txt\", \"test2.txt\")
  -> rename file \"test1.txt\" into \"test2.txt\"
     within the current directory
</pre></blockquote>
</html>"));
    end move;

    impure function remove "Remove file or directory (ignore call, if it does not exist)"
      extends Modelica.Icons.Function;
      input String name "Name of file or directory to be removed";
    //..............................................................
    protected
      impure function removeDirectory "Remove a directory, even if it is not empty"
         extends Modelica.Icons.Function;
         input String name;
      protected
         Integer lenName = Strings.length(name);
         // remove an optional trailing "/"
         String name2 = if Strings.substring(name,lenName,lenName) == "/" then
                           Strings.substring(name,lenName-1,lenName-1) else name;
      algorithm
         removeDirectoryContents(Modelica.Utilities.Internal.FileSystem.readDirectory(
                                            name2, Modelica.Utilities.Internal.FileSystem.getNumberOfFiles(
                                                    name2)), name2);
         Modelica.Utilities.Internal.FileSystem.rmdir(name2);
      end removeDirectory;

      impure function removeDirectoryContents
          extends Modelica.Icons.Function;
          input String fileNames[:];
          input String name2;
      algorithm
          for i in 1:size(fileNames,1) loop
             Files.remove(name2 + "/" + fileNames[i]);
          end for;
      end removeDirectoryContents;
    //..............................................................
      String fullName;
      Types.FileType fileType=Modelica.Utilities.Internal.FileSystem.stat(name);
    algorithm
      if fileType == Types.FileType.RegularFile or
         fileType == Types.FileType.SpecialFile then
         Modelica.Utilities.Internal.FileSystem.removeFile(name);
      elseif fileType == Types.FileType.Directory then
         fullName :=Files.fullPathName(name);
         removeDirectory(fullName);
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>remove</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Removes the file or directory \"name\". If \"name\" does not exist,
the function call is ignored. If \"name\" is a directory, first
the content of the directory is removed and afterwards
the directory itself.
</p>
<p>
This function is silent, i.e., it does not print a message.
</p>
</html>"));
    end remove;

    impure function removeFile "Remove file (ignore call, if it does not exist)"
      extends Modelica.Icons.Function;
      input String fileName "Name of file that should be removed";
    protected
      Types.FileType fileType = Modelica.Utilities.Internal.FileSystem.stat(
                                              fileName);
    algorithm
      if fileType == Types.FileType.RegularFile then
         Streams.close(fileName);
         Modelica.Utilities.Internal.FileSystem.removeFile(
                             fileName);
      elseif fileType == Types.FileType.Directory then
         Streams.error("File \"" + fileName + "\" should be removed.\n" +
                       "This is not possible, because it is a directory");
      elseif fileType == Types.FileType.SpecialFile then
         Streams.error("File \"" + fileName + "\" should be removed.\n" +
                       "This is not possible, because it is a special file (pipe, device, etc.)");
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>removeFile</strong>(fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Removes the file \"fileName\". If \"fileName\" does not exist,
the function call is ignored. If \"fileName\" exists but is
no regular file (e.g., directory, pipe, device, etc.) an
error is triggered.
</p>
<p>
This function is silent, i.e., it does not print a message.
</p>
</html>"));
    end removeFile;

    impure function createDirectory
        "Create directory (if directory already exists, ignore call)"
      extends Modelica.Icons.Function;
      input String directoryName
          "Name of directory to be created (if present, ignore call)";
    //..............................................................
    protected
      impure function existDirectory
          "Inquire whether directory exists; if present and not a directory, trigger an error"
         extends Modelica.Icons.Function;
         input String directoryName;
         output Boolean exists "= true, if directory exists";
      protected
         Types.FileType fileType = Modelica.Utilities.Internal.FileSystem.stat(
                                                 directoryName);
      algorithm
         if fileType == Types.FileType.RegularFile or
            fileType == Types.FileType.SpecialFile then
            Streams.error("Directory \"" + directoryName + "\" cannot be created\n" +
                          "because this is an existing file.");
         elseif fileType == Types.FileType.Directory then
            exists :=true;
         else
            exists :=false;
         end if;
      end existDirectory;

      function assertCorrectIndex
          "Print error, if index to last essential character in directory is wrong"
         extends Modelica.Icons.Function;
         input Integer index "Index must be > 0";
         input String directoryName "Directory name for error message";
      algorithm
         if index < 1 then
            Streams.error("It is not possible to create the directory\n" +
                          "\"" + directoryName + "\"\n" +
                          "because this directory name is not valid");
         end if;
      end assertCorrectIndex;

    //..............................................................
      String fullName;
      Integer index;
      Integer oldIndex;
      Integer lastIndex;
      Boolean found;
      Boolean finished;
      Integer nDirectories = 0 "Number of directories that need to be generated";
    algorithm
      // Ignore call, if directory exists
      if not existDirectory(directoryName) then
         fullName := Files.fullPathName(directoryName);

         // Remove a trailing "/"
            index :=Strings.length(fullName);
            if Strings.substring(fullName,index,index) == "/" then
               index :=index - 1;
               assertCorrectIndex(index,fullName);
            end if;
            lastIndex := index;
            fullName := Strings.substring(fullName,1,index);

         // Search upper directories until a directory is found that exists
         // ??? check the following while loop later, if also cases such as
         //  "c:/", "c:", "//name" are handled correctly ???
            found := false;
            while not found loop
               oldIndex := index;
               index := Strings.findLast(fullName,"/",startIndex=index);
               if index == 0 then
                  index := oldIndex;
                  found := true;
               else
                  index := index - 1;
                  assertCorrectIndex(index, fullName);
                  found := existDirectory(Strings.substring(fullName,1,index));
               end if;
            end while;
            index := oldIndex;

         // Create directories
            finished := false;
            while not finished loop
               Modelica.Utilities.Internal.FileSystem.mkdir(
                              Strings.substring(fullName,1,index));
               if index >= lastIndex then
                  finished := true;
               elseif index < lastIndex then
                  index := Strings.find(fullName, "/", startIndex=index+2);
                  if index == 0 then
                     index :=lastIndex;
                  end if;
               end if;
            end while;
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>createDirectory</strong>(directoryName);
</pre></blockquote>
<h4>Description</h4>
<p>
Creates directory \"directoryName\". If this directory already exists,
the function call is ignored. If several directories in \"directoryName\"
do not exist, all of them are created. For example, assume
that directory \"E:/test1\" exists and that directory
\"E:/test1/test2/test3\" shall be created. In this case
the directories \"test2\" in \"test1\" and \"test3\" in \"test2\"
are created.
</p>
<p>
This function is silent, i.e., it does not print a message.
In case of error (e.g., \"directoryName\" is an existing regular
file), an assert is triggered.
</p>
</html>"));
    end createDirectory;

    impure function exist "Inquire whether file or directory exists"
      extends Modelica.Icons.Function;
      input String name "Name of file or directory";
      output Boolean result "= true, if file or directory exists";
    algorithm
      result := Modelica.Utilities.Internal.FileSystem.stat(
                              name) > Types.FileType.NoFile;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Files.<strong>exist</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true, if \"name\" is an existing file or directory.
If this is not the case, the function returns false.
</p>
</html>"));
    end exist;

    impure function assertNew "Trigger an assert, if a file or directory exists"
      extends Modelica.Icons.Function;
      input String name "Name of file or directory";
      input String message="This is not allowed."
          "Message that should be printed after the default message in a new line";
    protected
      Types.FileType fileType = Modelica.Utilities.Internal.FileSystem.stat(
                                              name);
    algorithm
      if fileType == Types.FileType.RegularFile then
         Streams.error("File \"" + name + "\" already exists.\n" + message);
      elseif fileType == Types.FileType.Directory then
         Streams.error("Directory \"" + name + "\" already exists.\n" + message);
      elseif fileType == Types.FileType.SpecialFile then
         Streams.error("A special file (pipe, device, etc.) \"" + name + "\" already exists.\n" + message);
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>assertNew</strong>(name);
Files.<strong>assertNew</strong>(name, message=\"This is not allowed\");
</pre></blockquote>
<h4>Description</h4>
<p>
Triggers an assert, if \"name\" is an existing file or
directory. The error message has the following structure:
</p>
<blockquote><pre>
File \"&lt;name&gt;\" already exists.
&lt;message&gt;
</pre></blockquote>
</html>"));
    end assertNew;

    impure function fullPathName "Get full path name of file or directory name"
      extends Modelica.Icons.Function;
      input String name "Absolute or relative file or directory name";
      output String fullName "Full path of 'name'";
    external "C" fullName = ModelicaInternal_fullPathName(name) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fullName = Files.<strong>fullPathName</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the full path name of a file or directory \"name\".
</p>
</html>"));
    end fullPathName;

    function splitPathName
        "Split path name in directory, file name kernel, file name extension"
      extends Modelica.Icons.Function;
      input String pathName "Absolute or relative file or directory name";
      output String directory "Name of the directory including a trailing '/'";
      output String name "Name of the file without the extension";
      output String extension "Extension of the file name. Starts with '.'";

    protected
      Integer lenPath = Strings.length(pathName);
      Integer i = lenPath;
      Integer indexDot = 0;
      Integer indexSlash = 0;
      String c;
    algorithm
      while i >= 1 loop
        c :=Strings.substring(pathName, i, i);
        if c == "." then
           indexDot := i;
           i := 0;
        elseif c == "/" then
           indexSlash := i;
           i := 0;
        else
           i := i - 1;
        end if;
      end while;

      if indexSlash == lenPath then
         directory := pathName;
         name      := "";
         extension := "";
      elseif indexDot > 0 then
         indexSlash :=Strings.findLast(pathName, "/", startIndex=indexDot - 1);
         if indexSlash == 0 then
            directory :="";
            name :=Strings.substring(pathName, 1, indexDot - 1);
         else
            directory :=Strings.substring(pathName, 1, indexSlash);
            name :=Strings.substring(pathName, indexSlash + 1, indexDot - 1);
         end if;
         extension :=Strings.substring(pathName, indexDot, lenPath);
       else
         extension :="";
         if indexSlash > 0 then
           directory :=Strings.substring(pathName, 1, indexSlash);
           name :=Strings.substring(pathName, indexSlash + 1, lenPath);
         else
           directory :="";
           name :=pathName;
         end if;
       end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(directory, name, extension) = Files.<strong>splitPathName</strong>(pathName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>splitPathName</strong>(..) splits a path name into its parts.
</p>
<h4>Example</h4>
<blockquote><pre>
(directory, name, extension) = Files.splitPathName(\"C:/user/test/input.txt\")

-> directory = \"C:/user/test/\"
   name      = \"input\"
   extension = \".txt\"
</pre></blockquote>
</html>"));
    end splitPathName;

      function loadResource
        "Return the absolute path name of a URI or local file name"
         extends
        Modelica.Utilities.Internal.PartialModelicaServices.ExternalReferences.PartialLoadResource;
         extends ModelicaServices.ExternalReferences.loadResource;
        annotation (
          Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = Files.<strong>loadResource</strong>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Files.<strong>loadResource</strong>(uri)</code>\" returns the
<strong>absolute path name</strong> of the file that is either defined by an URI or by a local
path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific. However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
        // file1 is the absolute path name of the file
file2 = loadResource(\"C:\\\\data\\\\readParameters.txt\")
        file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
      end loadResource;
        annotation (
    Documentation(info="<html>
<p>
This package contains functions to work with files and directories.
As a general convention of this package, '/' is used as directory
separator both for input and output arguments of all functions.
For example:
</p>
<blockquote><pre>
exist(\"Modelica/Mechanics/Rotational.mo\");
</pre></blockquote>
<p>
The functions provide the mapping to the directory separator of the
underlying operating system. Note, that on Windows system the usage
of '\\' as directory separator would be inconvenient, because this
character is also the escape character in Modelica and C Strings.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.list\">list</a>(name)</td>
      <td> List content of file or of directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName, replace=false)</td>
      <td> Generate a copy of a file or of a directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName, replace=false)</td>
      <td> Move a file or a directory to another place.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.remove\">remove</a>(name)</td>
      <td> Remove file or directory (ignore call, if it does not exist).</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.removeFile\">removeFile</a>(name)</td>
      <td> Remove file (ignore call, if it does not exist)</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.createDirectory\">createDirectory</a>(name)</td>
      <td> Create directory (if directory already exists, ignore call).</td>
  </tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Files.exist\">exist</a>(name)</td>
      <td> Inquire whether file or directory exists.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.assertNew\">assertNew</a>(name,message)</td>
      <td> Trigger an assert, if a file or directory exists.</td>
  </tr>
  <tr><td>fullName = <a href=\"modelica://Modelica.Utilities.Files.fullPathName\">fullPathName</a>(name)</td>
      <td> Get full path name of file or directory name.</td>
  </tr>
  <tr><td>(directory, name, extension) = <a href=\"modelica://Modelica.Utilities.Files.splitPathName\">splitPathName</a>(name)</td>
      <td> Split path name in directory, file name kernel, file name extension.</td>
  </tr>
  <tr><td>fileName = <a href=\"modelica://Modelica.Utilities.Files.temporaryFileName\">temporaryFileName</a>()</td>
      <td> Return arbitrary name of a file that does not exist<br>
           and is in a directory where access rights allow to<br>
           write to this file (useful for temporary output of files).</td>
  </tr>
  <tr><td>fileReference = <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>(uri)</td>
      <td>Return the absolute path name of a URI or local file name.</td>
  </tr>
</table>
</html>"));
    end Files;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.FunctionsPackage;

      impure function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
          "File where to print (empty string is the terminal)"
                     annotation(Dialog(saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>print</strong>(string);
Streams.<strong>print</strong>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>print</strong>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <strong>Streams.close</strong>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
Streams.print(\"x = \" + String(x));
Streams.print(\"y = \" + String(y));
Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end print;

      impure function readFile
        "Read content of a file and return it in a vector of strings"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                     annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        output String stringVector[countLines(fileName)] "Content of file";
        external "C" ModelicaInternal_readFile(fileName,stringVector,size(stringVector,1)) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
stringVector = Streams.<strong>readFile</strong>(fileName)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readFile</strong>(..) opens the given file, reads the complete
content, closes the file and returns the content as a vector of strings. Lines are separated by LF or CR-LF; the returned strings do not contain the line separators.
Note, a fileName can be defined as URI by using the helper function
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.
</p>
</html>"));
      end readFile;

      impure function readLine "Read a line of text from a file and return it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
          "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<strong>readLine</strong>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readLine</strong>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      impure function countLines "Return the number of lines in a file"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                           annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for counting lines")));

        output Integer numberOfLines "Number of lines in file";
      external "C" numberOfLines = ModelicaInternal_countLines(fileName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
numberOfLines = Streams.<strong>countLines</strong>(fileName)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>countLines</strong>(..) opens the given file, reads the complete
content, closes the file and returns the number of lines. Lines are
separated by LF or CR-LF.
</p>
</html>"));
      end countLines;

      pure function error "Print error message and cancel all actions - in case of an unrecoverable error"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaUtilities.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>error</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
In case of an unrecoverable error (i.e., if the solver is unable to recover from the error),
print the string \"string\" as error message and cancel all actions.
This function is semantically equivalent with the built-in function <strong>assert</strong> if called with the (default) <strong>AssertionLevel.error</strong>.
Line breaks are characterized by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.'assert()'\">ModelicaReference.Operators.'assert()'</a>
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end error;

      impure function close "Close file"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be closed"
                     annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Close text file")));
        external "C" ModelicaStreams_closeFile(fileName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>close</strong>(fileName)
</pre></blockquote>
<h4>Description</h4>
<p>
Close file if it is open. Ignore call if
file is already closed or does not exist.
</p>
</html>"));
      end close;

      impure function writeRealMatrix "Write Real matrix to a MATLAB MAT file"
        extends Modelica.Icons.Function;
        input String fileName "File where external data is to be stored" annotation(Dialog(saveSelector(filter="MATLAB MAT files (*.mat)", caption="Save MATLAB MAT file")));
        input String matrixName "Name / identifier of the 2D Real array on the file";
        input Real matrix[:,:] "2D Real array";
        input Boolean append = false "Append values to file";
        input String format = "4" "MATLAB MAT file version: \"4\" -> v4, \"6\" -> v6, \"7\" -> v7"
          annotation(choices(choice="4" "MATLAB v4 MAT file",
                             choice="6" "MATLAB v6 MAT file",
                             choice="7" "MATLAB v7 MAT file"));
        output Boolean success "true if successful";
        external "C" success = ModelicaIO_writeRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), append, format)
        annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaIO.h\"", Library={"ModelicaIO", "ModelicaMatIO", "zlib"});
        annotation(Documentation(info="<html>

<h4>Syntax</h4>
<blockquote><pre>
success = Streams.<strong>writeRealMatrix</strong>(fileName, matrixName, matrix, append, format)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>writeRealMatrix</strong>(..) writes the given matrix to a new or an existing MATLAB MAT file
(in format v4, v6, v7, and if HDF is supported in the Modelica tool, also v7.3).
If <code>append = false</code> (= default), the file is newly created
(or an existing file is deleted and re-created).
If <code>append = true</code>, the matrix is included in an existing file or if the
file does not yet exists this flag is ignored. If the file exists and
<code>append = true</code>, argument format is ignored.
</p>

<p>
Parameter <strong>format</strong> defines the format in which the values are stored on file.
The following formats are supported:<br>&nbsp;
</p>

<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><td>format = </td><td>Type of format</td></tr>
<tr><td>\"4\"  </td><td>MATLAB MAT version v4</td></tr>
<tr><td>\"6\"  </td><td>MATLAB MAT version v6</td></tr>
<tr><td>\"7\"  </td><td>MATLAB MAT version v7</td></tr>
<tr><td>\"7.3\"</td><td>MATLAB MAT version v7.3<br>
                      (requires HDF support in the Modelica tool)</td></tr>
</table>

<p>
The function returns <code>success = true</code> if the matrix was successfully written
to file. Otherwise, an error message is printed and the function returns with
<code>success = false</code>.
</p>

<h4>Example</h4>
<p>
See <a href=\"modelica://Modelica.Utilities.Examples.WriteRealMatrixToFile\">Examples.WriteRealMatrixToFile</a>.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>,
<a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>
</p>
</html>"));
      end writeRealMatrix;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Streams</strong> contains functions to input and output strings
to a message window or on files, as well as reading matrices from file
and writing matrices to file. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<blockquote><p>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</p></blockquote>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td>stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td>(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td>Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td>lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td>Returns the number of lines in a file.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>(fileName, matrixName)</td>
      <td> Read dimensions of a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>(fileName, matrixName, nrow, ncol)</td>
      <td> Read a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>(fileName, matrixName, matrix, append, format)</td>
      <td> Write Real matrix to a MATLAB MAT file. </td></tr>
</table>
<p>
Use functions <strong>scanXXX</strong> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>(...).
Example:
</p>
<blockquote><pre>
<strong>if</strong> x &lt; 0 <strong>or</strong> x &gt; 1 <strong>then</strong>
   Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
<strong>end if</strong>;
</pre></blockquote>
</html>"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.FunctionsPackage;

      pure function length "Return length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>length</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      pure function substring "Return a substring defined by start and end index"
        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
          "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
          "String containing substring string[startIndex:endIndex]";
      external "C" result = ModelicaStrings_substring(string,startIndex,endIndex) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>substring</strong>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
string1 := \"This is line 111\";
string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      function repeat "Repeat a string n times"
        extends Modelica.Icons.Function;
        input Integer n(min=0) = 1 "Number of occurrences";
        input String string=" " "String that is repeated";
        output String repeatedString "String containing n concatenated strings";
      algorithm
        repeatedString :="";
        for i in 1:n loop
           repeatedString := repeatedString + string;
        end for;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>repeat</strong>(n);
string2 = Strings.<strong>repeat</strong>(n, string=\" \");
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns a string consisting of n blanks.
</p>
<p>
The second form returns a string consisting of n substrings
defined by the optional argument \"string\".
</p>
</html>"));
      end repeat;

      pure function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<strong>compare</strong>(string1, string2);
result = Strings.<strong>compare</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<blockquote><pre>
result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
       = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
       = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre></blockquote>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEqual</strong>(string1, string2);
Strings.<strong>isEqual</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function count "Count the number of non-overlapping occurrences of a string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for count";
        output Integer result "Number of occurrences of 'searchString' in 'string'";
    protected
        Integer lenSearchString = length(searchString);
        Integer i = startIndex;
      algorithm
        result := 0;
        while i <> 0 loop
           i := find(string, searchString, i, caseSensitive);
           if i > 0 then
              result := result + 1;
              i := i + lenSearchString;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>count</strong>(string, searchString)
Strings.<strong>count</strong>(string, searchString, startIndex=1,
                     caseSensitive=true)
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of non-overlapping occurrences of string \"searchString\"
in \"string\". The search is started at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false,
for the counting it does not matter whether a letter is upper
or lower case.
</p>
</html>"));
      end count;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
         output Integer index
          "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>find</strong>(string, searchString);
index = Strings.<strong>find</strong>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end find;

      function findLast "Find last occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=0)=0
          "Start search at index startIndex. If startIndex = 0, start at length(string)";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
        output Integer index
          "Index of the beginning of the last occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer iMax=lenString - lenSearchString + 1;
        Integer i;
      algorithm
        i := if startIndex == 0 or startIndex > iMax then iMax else startIndex;
        index := 0;
        while i >= 1 loop
           if isEqual(substring(string,i,i+lenSearchString-1),
                      searchString, caseSensitive) then
              index := i;
              i := 0;
           else
              i := i-1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>findLast</strong>(string, searchString);
index = Strings.<strong>findLast</strong>(string, searchString,
                         startIndex=length(string), caseSensitive=true,
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
when searching from the last character of \"string\"
backwards, and return the corresponding index.
Start search at index \"startIndex\" (default = 0;
if startIndex = 0, search starts at length(string)).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end findLast;

      function replace
        "Replace non-overlapping occurrences of a string from left to right"
        extends Modelica.Icons.Function;
        input String string "String to be modified";
        input String searchString
          "Replace non-overlapping occurrences of 'searchString' in 'string' with 'replaceString'";
        input String replaceString
          "String that replaces 'searchString' in 'string'";
        input Integer startIndex=1 "Start search at index startIndex";
        input Boolean replaceAll=true
          "= false, if only the first occurrence is replaced, otherwise all occurrences";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored when searching for searchString";
        output String result "Resultant string of replacement operation";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer i = startIndex;
        Integer i_found;
      algorithm
        result := if startIndex == 1 then "" else substring(string,1,startIndex-1);
        while i > 0 loop
           i_found := find(string, searchString, i, caseSensitive);
           if i_found > 0 then
              result := if i_found == 1 then
                           replaceString else
                           result + (if i_found-1<i then "" else substring(string, i, i_found-1)) + replaceString;
              i := i_found + lenSearchString;
              if i > lenString then
                 i := 0;
              elseif not replaceAll then
                 result := result + substring(string, i, lenString);
                 i := 0;
              end if;
           elseif lenString<i then
              i := 0;
           else
              result := result + substring(string, i, lenString);
              i := 0;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>replace</strong>(string, searchString, replaceString);
Strings.<strong>replace</strong>(string, searchString, replaceString,
                startIndex=1, replaceAll=true, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Search in \"string\" for \"searchString\" and replace the found
substring by \"replaceString\".
</p>
<ul>
<li> The search starts at the first character of \"string\",
     or at character position \"startIndex\",
     if this optional argument is provided.</li>
<li> If the optional argument \"replaceAll\" is <strong>true</strong> (default),
     all occurrences of \"searchString\" are replaced.
     If the argument is <strong>false</strong>, only the first occurrence
     is replaced.</li>
<li> The search for \"searchString\" distinguishes upper and lower
     case letters. If the optional argument \"caseSensitive\" is
     <strong>false</strong>,
     the search ignores whether letters are upper
     or lower case.</li>
</ul>
<p>
The function returns the \"string\" with the
performed replacements.
</p>
</html>"));
      end replace;

      pure function hashString "Create a hash value of a string"
        extends Modelica.Icons.Function;
        input String string "The string to create a hash from";
        output Integer hash "The hash value of string";
        external "C" hash = ModelicaStrings_hashString(string)
           annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
hash = Strings.<strong>hashString</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns an Integer hash value of the provided string
(the hash can be any Integer, including zero or a negative number).
</p>

<h4>Example</h4>
<blockquote><pre>
hashString(\"this is a test\")     // =  1827717433
hashString(\"Controller.noise1\")  // = -1025762750
</pre></blockquote>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=\"0\">
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\" alt=\"DLR logo\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end hashString;

      function scanToken "Scan for the next token and return it"
        extends Modelica.Icons.Function;
        input String string "String to be scanned";
        input Integer startIndex(min=1) = 1
          "Start scanning of string at character startIndex";
        input Boolean unsigned=false
          "= true, if Real and Integer tokens shall not start with a sign";
        output Types.TokenValue token "Scanned token";
        output Integer nextIndex
          "Index of character after the found token; = 0, if NoToken";
    protected
        Integer startTokenIndex;
      algorithm
        // Initialize token
        token.real :=0.0;
        token.integer :=0;
        token.boolean :=false;
        token.string :="";

        // skip white space and line comments
        startTokenIndex := Advanced.skipLineComments(string, startIndex);
        if startTokenIndex > length(string) then
          token.tokenType := Modelica.Utilities.Types.TokenType.NoToken;
          nextIndex := startTokenIndex;
        else
          // scan Integer number
            (nextIndex, token.integer) := Advanced.scanInteger(string, startTokenIndex, unsigned);
             token.tokenType := Types.TokenType.IntegerToken;

          // scan Real number
          if nextIndex == startTokenIndex then
            (nextIndex, token.real) :=Advanced.scanReal(string, startTokenIndex, unsigned);
             token.tokenType := Types.TokenType.RealToken;
          end if;

          // scan String
          if nextIndex == startTokenIndex then
             (nextIndex,token.string) := Advanced.scanString(string, startTokenIndex);
              token.tokenType:= Types.TokenType.StringToken;
          end if;

          // scan Identifier or Boolean
          if nextIndex == startTokenIndex then
             (nextIndex,token.string) := Advanced.scanIdentifier(string, startTokenIndex);
             if nextIndex > startTokenIndex then
                if token.string == "false" then
                   token.string := "";
                   token.boolean :=false;
                   token.tokenType := Types.TokenType.BooleanToken;
                elseif token.string == "true" then
                   token.string := "";
                   token.boolean := true;
                   token.tokenType := Types.TokenType.BooleanToken;
                else
                   token.tokenType := Types.TokenType.IdentifierToken;
                end if;
             end if;
          end if;

          // scan Delimiter
          if nextIndex == startTokenIndex then
             token.string :=substring(string, startTokenIndex, startTokenIndex);
             token.tokenType := Types.TokenType.DelimiterToken;
             nextIndex := startTokenIndex + 1;
          end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(token, nextIndex) = Strings.<strong>scanToken</strong>(string, startIndex, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>scanToken</strong> scans the string starting at index
\"startIndex\" and returns the next token, as well as the
index directly after the token. The returned token is a record
that holds the type of the token and the value of the token:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td>token.tokenType</td>
      <td>Type of the token, see below</td></tr>
  <tr><td>token.real</td>
      <td>Real value if tokenType == TokenType.RealToken</td></tr>
  <tr><td>token.integer</td>
      <td>Integer value if tokenType == TokenType.IntegerToken</td></tr>
  <tr><td>token.boolean</td>
      <td>Boolean value if tokenType == TokenType.BooleanToken</td></tr>
  <tr><td>token.string</td>
      <td>String value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken</td></tr>
</table>
<p>
Variable token.tokenType is an enumeration (emulated as a package
with constants) that can have the following values:
</p>
<blockquote><pre>
import T = Modelica.Utilities.Types.TokenType;
</pre></blockquote>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><td>T.RealToken</td>
      <td>Modelica Real literal (e.g., 1.23e-4)</td></tr>
  <tr><td>T.IntegerToken</td>
      <td>Modelica Integer literal (e.g., 123)</td></tr>
  <tr><td>T.BooleanToken</td>
      <td>Modelica Boolean literal (e.g., false)</td></tr>
  <tr><td>T.StringToken</td>
      <td>Modelica String literal (e.g., \"string 123\")</td></tr>
  <tr><td>T.IdentifierToken</td>
      <td>Modelica identifier (e.g., \"force_a\")</td></tr>
  <tr><td>T.DelimiterToken</td>
      <td>any character without white space that does not appear<br>
          as first character in the tokens above (e.g., \"&amp;\")</td></tr>
  <tr><td>T.NoToken</td>
      <td>White space, line comments and no other token<br>
          until the end of the string</td></tr>
</table>
<p>
Modelica line comments (\"// ... end-of-line/end-of-string\")
as well as white space is ignored.
If \"unsigned=true\", a Real or Integer literal
is not allowed to start with a \"+\" or \"-\" sign.
</p>
<h4>Example</h4>
<blockquote><pre>
import Modelica.Utilities.Strings;
import T = Modelica.Utilities.Types.TokenType;
(token, index) := Strings.scanToken(string);
<strong>if</strong> token.tokenType == T.RealToken <strong>then</strong>
   realValue := token.real;
<strong>elseif</strong> token.tokenType == T.IntegerToken <strong>then</strong>
   integerValue := token.integer;
<strong>elseif</strong> token.tokenType == T.BooleanToken <strong>then</strong>
   booleanValue := token.boolean;
<strong>elseif</strong> token.tokenType == T.Identifier <strong>then</strong>
   name := token.string;
<strong>else</strong>
   Strings.syntaxError(string,index,\"Expected Real, Integer, Boolean or identifier token\");
<strong>end if</strong>;
</pre></blockquote>
</html>"));
      end scanToken;

      function scanReal
        "Scan for the next Real number and trigger an assert if not present"
        extends Modelica.Icons.Function;
        input String string "String to be scanned";
        input Integer startIndex(min=1)=1
          "Start scanning of string at character startIndex";
        input Boolean unsigned=false
          "= true, if Real token shall not start with a sign";
        input String message=""
          "Message used in error message if scan is not successful";
        output Real number "Value of real number";
        output Integer nextIndex "Index of character after the found number";
      algorithm
        (nextIndex, number) :=Advanced.scanReal(string, startIndex, unsigned);
        if nextIndex == startIndex then
           nextIndex :=Advanced.skipWhiteSpace(string, startIndex);
           if unsigned then
              syntaxError(string, nextIndex, "Expected a Real number without a sign " + message);
           else
              syntaxError(string, nextIndex, "Expected a Real number " + message);
           end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
             number = Strings.<strong>scanReal</strong>(string);
(number, nextIndex) = Strings.<strong>scanReal</strong>(string, startIndex=1,
                                            unsigned=false, message=\"\");
</pre></blockquote>
<h4>Description</h4>
<p>
The first form, \"scanReal(string)\", scans \"string\" for a
Real number with leading white space and returns the value.
</p>
<p>
The second form, \"scanReal(string,startIndex,unsigned)\",
scans the string starting at index
\"startIndex\", checks whether the next token is a Real literal
and returns its value as a Real number, as well as the
index directly after the Real number.
If the optional argument \"unsigned\" is <strong>true</strong>,
the real number shall not have a leading \"+\" or \"-\" sign.
</p>
<p>
If the required Real number with leading white space
is not present in \"string\", an assert is triggered.
</p>
</html>"));
      end scanReal;

      function scanInteger
        "Scan for the next Integer number and trigger an assert if not present"
        extends Modelica.Icons.Function;
        input String string "String to be scanned";
        input Integer startIndex(min=1)=1
          "Start scanning of string at character startIndex";
        input Boolean unsigned=false
          "= true, if Integer token shall not start with a sign";
        input String message=""
          "Message used in error message if scan is not successful";
        output Integer number "Value of Integer number";
        output Integer nextIndex "Index of character after the found number";
      algorithm
        (nextIndex, number) :=Advanced.scanInteger(string, startIndex, unsigned);
        if nextIndex == startIndex then
           nextIndex :=Advanced.skipWhiteSpace(string, startIndex);
           if unsigned then
              syntaxError(string, nextIndex, "Expected an Integer number without a sign " + message);
           else
              syntaxError(string, nextIndex, "Expected an Integer number " + message);
           end if;
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
             number = Strings.<strong>scanInteger</strong>(string);
(number, nextIndex) = Strings.<strong>scanInteger</strong>(string, startIndex=1,
                                               unsigned=false, message=\"\");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>scanInteger</strong> scans the string starting at index
\"startIndex\", checks whether the next token is an Integer literal
and returns its value as an Integer number, as well as the
index directly after the Integer number. An assert is triggered,
if the scanned string does not contain an Integer literal with optional
leading white space.
</p>
</html>"));
      end scanInteger;

      function scanIdentifier
        "Scan for the next Identifier and trigger an assert if not present"
        extends Modelica.Icons.Function;
        input String string "String to be scanned";
        input Integer startIndex(min=1)=1
          "Start scanning of identifier at character startIndex";
        input String message=""
          "Message used in error message if scan is not successful";
        output String identifier "Value of Identifier";
        output Integer nextIndex "Index of character after the found identifier";
      algorithm
        (nextIndex, identifier) :=Advanced.scanIdentifier(string, startIndex);
        if nextIndex == startIndex then
           nextIndex :=Advanced.skipWhiteSpace(string, startIndex);
           syntaxError(string, nextIndex, "Expected an identifier " + message);
        end if;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
             identifier = Strings.<strong>scanIdentifier</strong>(string);
(identifier, nextIndex) = Strings.<strong>scanIdentifier</strong>(string, startIndex=1, message=\"\");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>scanIdentifier</strong> scans the string starting at index
\"startIndex\", checks whether the next token is an Identifier
and returns its value as a string, as well as the
index directly after the Identifier. An assert is triggered,
if the scanned string does not contain an Identifier with optional
leading white space.
</p>
</html>"));
      end scanIdentifier;

      function syntaxError
        "Print an error message, a string and the index at which scanning detected an error"
        extends Modelica.Icons.Function;
        input String string "String that has an error at position index";
        input Integer index "Index of string at which scanning detected an error";
        input String message="" "String printed at end of error message";

    protected
        Integer maxIndex = 40;
        Integer maxLenString = 60;
        Integer lenString = length(string);
        String errString;
        Integer index2 = if index < 1 then 1 else if index > lenString then lenString else index;
      algorithm
      // if "string" is too long, skip part of the string when printing it
         if index2 <= maxIndex then
           errString := string;
         else
           errString := "... " + substring(string, index2-maxIndex, lenString);
           index2 := maxIndex + 5; // To mark right position
         end if;

         if length(errString) > maxLenString then
            errString := substring(errString, 1, maxLenString) + " ...";
         end if;

      // Print error message
         Streams.error("Syntax error at character " + String(index) + " of\n" +
                       errString + "\n" +
                       repeat(index2-1, " ") + "*" + "\n" +
                       message);
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>syntaxError</strong>(string, index, message);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>syntaxError</strong> prints an error message in the
following form:
</p>
<blockquote><pre>
Syntax error at column &lt;index&gt; of
&lt;string&gt;
    ^       // shows character that is wrong
&lt;message&gt;
</pre></blockquote>
<p>
where the strings within &lt;..&gt; are the actual values of the
input arguments of the function.
</p>
<p>
If the given string is too long, only a relevant
part of the string is printed.
</p>
</html>"));
      end syntaxError;

      package Advanced "Advanced scanning functions"
        extends Modelica.Icons.FunctionsPackage;

        pure function scanReal "Scan a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <strong>scanReal</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<blockquote><pre>
real     ::= [sign] unsigned [fraction] [exponent]
sign     ::= '+' | '-'
unsigned ::= digit [unsigned]
fraction ::= '.' [unsigned]
exponent ::= ('e' | 'E') [sign] unsigned
digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre></blockquote>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanReal;

        pure function scanInteger "Scan signed integer number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Integer number "Value of Integer number";
          external "C" ModelicaStrings_scanInteger(string, startIndex, unsigned, nextIndex, number) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, integerNumber) = <strong>scanInteger</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a signed number
of type Integer. An Integer starts with an optional '+'
or '-', immediately
followed by a non-empty sequence of digits.
</p>
<p>
If successful, the function returns nextIndex = index of character
directly after the found Integer number, as well as the Integer value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
Note, a Real number, such as \"123.4\", is not treated
as an Integer number and scanInteger will return
nextIndex = startIndex in this case.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanInteger;

        pure function scanString "Scan string"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output String string2 "Value of String token";
          external "C" ModelicaStrings_scanString(string, startIndex, nextIndex, string2) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, string2) = <strong>scanString</strong>(string, startIndex=1);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a string
according to the Modelica grammar, i.e., a string
enclosed in double quotes.
</p>
<p>
If successful, the function returns nextIndex = index of character
directly after the found string, as well as the string value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is an empty string.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanString;

        pure function scanIdentifier "Scan simple identifiers"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output String identifier "Value of identifier token";
          external "C" ModelicaStrings_scanIdentifier(string, startIndex, nextIndex, identifier) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");

          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, identifier) = <strong>scanIdentifier</strong>(string, startIndex=1);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a Modelica
identifier, i.e., a sequence of characters starting with
a letter (\"a\"..\"z\" or \"A\"..\"Z\") followed by letters,
digits or underscores (\"_\").
</p>
<p>
If successful, the function returns nextIndex = index of character
directly after the found identifier, as well as the identifier
as string in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is an empty string.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanIdentifier;

        pure function skipWhiteSpace "Scan white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
          external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaStrings.h\"", Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipWhiteSpace</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\" and
skips white space. The function returns nextIndex = index of character
of the first non white space character.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipWhiteSpace;

        function skipLineComments "Scan comments and white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
      protected
          Integer lenString = length(string);
          Boolean scanning;
          Boolean lineComment;
        algorithm
          nextIndex := startIndex;
          scanning := true;
          while scanning loop
             nextIndex := Advanced.skipWhiteSpace(string, nextIndex);
             if nextIndex+1 <= lenString then
                if substring(string,nextIndex,nextIndex+1) == "//" then
                   // search end of line comment
                   nextIndex := nextIndex + 2;
                   if nextIndex <= lenString then
                      lineComment := true;
                      while lineComment loop
                         if substring(string,nextIndex,nextIndex) == "\n" then
                            lineComment := false;
                         end if;
                         nextIndex := nextIndex + 1;
                         if nextIndex > lenString then
                            lineComment := false;
                            scanning := false;
                         end if;
                      end while;
                   else
                      scanning := false;
                   end if;
                else
                   scanning := false;
                end if;
             else
                scanning := false;
             end if;
          end while;
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipLineComments</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a Modelica (C/C++)
line comment, i.e., a sequence of characters that
starts with \"//\" and ends with an end-of-line \"\\n\" or
with the end of the string. If end-of-line is reached,
the function continues to skip white space and
scanning of line comments until end-of-string is
reached, or another token is detected.
</p>
<p>
If successful, the function returns nextIndex = index of character
directly after the found line comment.
</p>
<p>
If not successful, on return nextIndex = startIndex.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipLineComments;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings.Advanced</strong> contains basic scanning
functions. These functions should be <strong>not called</strong> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<blockquote><pre>
(nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
(nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
(nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
(nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
 nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
 nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre></blockquote>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).</li>
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\".</li>
</ul>
</html>"));
      end Advanced;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings</strong> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <strong>default</strong> options.
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
  <tr><th><strong><em>Function</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td>len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td>Returns length of string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td>Returns a substring defined by start and end index</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td>Repeat a blank or a string n times.</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td>Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td>identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td>Determine whether two strings are identical</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td>Count the number of occurrences of a string</td></tr>
  <tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td>Find first occurrence of a string in another string</td></tr>
<tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td>Find last occurrence of a string in another string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td>Replace one or all occurrences of a string</td></tr>
  <tr><td>stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td>Sort vector of strings in alphabetic order</td></tr>
  <tr><td>hash = <a href=\"modelica://Modelica.Utilities.Strings.hashString\">hashString</a>(string)</td>
      <td>Create a hash value of a string</td></tr>
  <tr><td>(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td>Scan for a Real constant</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td>Scan for an Integer constant</td></tr>
  <tr><td>(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td>Scan for a Boolean constant</td></tr>
  <tr><td>(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td>Scan for a String constant</td></tr>
  <tr><td>(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td>Scan for an identifier</td></tr>
  <tr><td>(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td>Scan for delimiters</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td>Check that remaining part of string consists solely of<br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td> Print a \"syntax error message\" as well as a string and the<br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <strong>caseSensitive</strong> with default <strong>true</strong>.
If <strong>false</strong>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</html>"));
    end Strings;

    package System "Interaction with environment"
      extends Modelica.Icons.FunctionsPackage;

    impure function getWorkDirectory "Get full path name of work directory"
      extends Modelica.Icons.Function;
      output String directory "Full path name of work directory";
    // POSIX function "getcwd"
      external "C" directory = ModelicaInternal_getcwd(0) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>

</html>"));
    end getWorkDirectory;

    impure function setWorkDirectory "Set work directory"
      extends Modelica.Icons.Function;
      input String directory "New work directory";
    // POSIX function "chdir"
    external "C" ModelicaInternal_chdir(directory) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>

</html>"));
    end setWorkDirectory;

    impure function getEnvironmentVariable "Get content of environment variable"
      extends Modelica.Icons.Function;
      input String name "Name of environment variable";
      input Boolean convertToSlash =  false
          "True, if native directory separators in environment variable shall be changed to '/'";
      output String content
          "Content of environment variable (empty, if not existent)";
      output Boolean exist
          "= true, if environment variable exists; = false, if it does not exist";
      external "C" ModelicaInternal_getenv(name, convertToSlash, content, exist) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>

</html>"));
    end getEnvironmentVariable;

      impure function getTime "Retrieve the local time (in the local time zone)"
        extends Modelica.Icons.Function;
        output Integer ms "Millisecond";
        output Integer sec "Second";
        output Integer min "Minute";
        output Integer hour "Hour";
        output Integer day "Day";
        output Integer mon "Month";
        output Integer year "Year";
        external "C" ModelicaInternal_getTime(ms,sec,min,hour,day,mon,year)
          annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(ms, sec, min, hour, day, mon, year) = System.<strong>getTime</strong>();
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the local time at the time instant this function was called.
All returned values are of type Integer and have the following meaning:
</p>

<blockquote>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th>Argument</th>
    <th>Range</th>
    <th>Description</th></tr>

<tr><td>ms</td> <td>0 .. 999</td>
    <td>Milli-seconds after seconds</td></tr>

<tr><td>sec</td> <td>0 .. 59</td>
    <td>Seconds after minute</td></tr>

<tr><td>min</td> <td>0 .. 59</td>
    <td>Minutes after hour</td></tr>

<tr><td>hour</td> <td>0 .. 23</td>
    <td>Hours after midnight</td></tr>

<tr><td>day</td> <td>1 .. 31</td>
    <td>Day of month</td></tr>

<tr><td>mon</td> <td>1 .. 12</td>
    <td>Current month</td></tr>

<tr><td>year</td> <td>&ge; 2015</td>
    <td>Current year</td></tr>
</table>
</blockquote>

<h4>Example</h4>
<blockquote><pre>
(ms, sec, min, hour, mon, year) = getTime()   // = (281, 30, 13, 10, 15, 2, 2015)
                                              // Feb. 15, 2015 at 10:13 after 30.281 s
</pre></blockquote>
<h4>Note</h4>
<p>This function is impure!</p>
</html>",       revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=\"0\">
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\" alt=\"DLR logo\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end getTime;

    impure function command "Execute command in default shell"
      extends Modelica.Icons.Function;
      input String string "String to be passed to shell";
      output Integer result "Return value from command (depends on environment)";
      external "C" result = system(string) annotation(Include="#include <stdlib.h>", Library="ModelicaExternalC");
        annotation (Documentation(info="<html>

</html>"));
    end command;
        annotation (
    Documentation(info="<html>
<p>
This package contains functions to interact with the environment.
</p>
</html>"));
    end System;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.TypesPackage;

      type Compare = enumeration(
        Less   "String 1 is lexicographically less than string 2",
        Equal   "String 1 is identical to string 2",
        Greater   "String 1 is lexicographically greater than string 2")
        "Enumeration defining comparison of two strings";

      type FileType = enumeration(
        NoFile   "No file exists",
        RegularFile   "Regular file",
        Directory   "Directory",
        SpecialFile   "Special file (pipe, FIFO, device, etc.)")
        "Enumeration defining the type of a file";

      type TokenType = enumeration(
        RealToken,
        IntegerToken,
        BooleanToken,
        StringToken,
        IdentifierToken,
        DelimiterToken,
        NoToken)   "Enumeration defining the token type";

      record TokenValue "Value of token"
         extends Modelica.Icons.Record;
         TokenType tokenType "Type of token";
         Real real "Value if tokenType == TokenType.RealToken";
         Integer integer "Value if tokenType == TokenType.IntegerToken";
         Boolean boolean "Value if tokenType == TokenType.BooleanToken";
         String string
          "Value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken";
        annotation (Documentation(info="<html>

</html>"));
      end TokenValue;
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;

    package Internal
    "Internal components that a user should usually not directly utilize"
      extends Modelica.Icons.InternalPackage;
      import Modelica.Units.SI;

    partial package PartialModelicaServices
      "Interfaces of components requiring a tool specific implementation"
        extends Modelica.Icons.InternalPackage;

      package ExternalReferences "Functions to access external resources"
        extends Modelica.Icons.InternalPackage;

        partial function PartialLoadResource
            "Interface for tool specific function to return the absolute path name of a URI or local file name"
          extends Modelica.Icons.Function;
          input String uri "URI or local file name";
          output String fileReference "Absolute path name of file";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices. The interface is documented at
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Internal.FileSystem.loadResource</a>.
</p>

</html>"));
        end PartialLoadResource;
      end ExternalReferences;
        annotation (Documentation(info="<html>

<p>
This package contains interfaces of a set of functions and models used in the
Modelica Standard Library that requires a <strong>tool specific implementation</strong>.
There is an associated package called <strong>ModelicaServices</strong>. A tool vendor
should provide a proper implementation of this library for the corresponding
tool. The default implementation is \"do nothing\".
In the Modelica Standard Library, the models and functions of ModelicaServices
are used.
</p>
</html>"));
    end PartialModelicaServices;

    package FileSystem
      "Internal package with external functions as interface to the file system"
     extends Modelica.Icons.InternalPackage;

      impure function mkdir "Make directory (POSIX: 'mkdir')"
        extends Modelica.Icons.Function;
        input String directoryName "Make a new directory";
      external "C" ModelicaInternal_mkdir(directoryName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end mkdir;

      impure function rmdir "Remove empty directory (POSIX function 'rmdir')"
        extends Modelica.Icons.Function;
        input String directoryName "Empty directory to be removed";
      external "C" ModelicaInternal_rmdir(directoryName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end rmdir;

      impure function stat "Inquire file information (POSIX function 'stat')"
        extends Modelica.Icons.Function;
        input String name "Name of file, directory, pipe etc.";
        output Types.FileType fileType "Type of file";
      external "C" fileType = ModelicaInternal_stat(name) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end stat;

      impure function rename "Rename existing file or directory (C function 'rename')"
        extends Modelica.Icons.Function;
        input String oldName "Current name";
        input String newName "New name";
      external "C" ModelicaInternal_rename(oldName, newName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end rename;

      impure function removeFile "Remove existing file (C function 'remove')"
        extends Modelica.Icons.Function;
        input String fileName "File to be removed";
      external "C" ModelicaInternal_removeFile(fileName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end removeFile;

      impure function copyFile
          "Copy existing file (C functions 'fopen', 'fread', 'fwrite', 'fclose')"
        extends Modelica.Icons.Function;
        input String fromName "Name of file to be copied";
        input String toName "Name of copy of file";
      external "C" ModelicaInternal_copyFile(fromName, toName) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end copyFile;

      impure function readDirectory
          "Read names of a directory (POSIX functions opendir, readdir, closedir)"
        extends Modelica.Icons.Function;
        input String directory
            "Name of the directory from which information is desired";
        input Integer nNames
            "Number of names that are returned (inquire with getNumberOfFiles)";
        output String names[nNames]
            "All file and directory names in any order from the desired directory";
        external "C" ModelicaInternal_readDirectory(directory,nNames,names) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
      end readDirectory;

    impure function getNumberOfFiles
          "Get number of files and directories in a directory (POSIX functions opendir, readdir, closedir)"
      extends Modelica.Icons.Function;
      input String directory "Directory name";
      output Integer result
            "Number of files and directories present in 'directory'";
      external "C" result = ModelicaInternal_getNumberOfFiles(directory) annotation(IncludeDirectory="modelica://Modelica/Resources/C-Sources", Include="#include \"ModelicaInternal.h\"", Library="ModelicaExternalC");
    end getNumberOfFiles;
      annotation (
    Documentation(info="<html>
<p>
Package <strong>Internal.FileSystem</strong> is an internal package that contains
low level functions as interface to the file system.
These functions should not be called directly in a scripting
environment since more convenient functions are provided
in packages Files and Systems.
</p>
<p>
Note, the functions in this package are direct interfaces to
functions of POSIX and of the standard C library. Errors
occurring in these functions are treated by triggering
a Modelica assert. Therefore, the functions in this package
return only for a successful operation. Furthermore, the
representation of a string is hidden by this interface,
especially if the operating system supports Unicode characters.
</p>
</html>"));
    end FileSystem;
    end Internal;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <strong>functions</strong> that are
especially suited for <strong>scripting</strong>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    extends Modelica.Icons.Package;
    import Modelica.Units.SI;
    import Modelica.Units.NonSI;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=ModelicaServices.Machine.eps
      "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=ModelicaServices.Machine.small
      "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=ModelicaServices.Machine.inf
      "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Acceleration g_n=9.80665
      "Standard acceleration of gravity on earth";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source (based on the second source):
</p>
<dl>
<dt>Michael Stock, Richard Davis, Estefan&iacute;a de Mirand&eacute;s and Martin J T Milton:</dt>
<dd><strong>The revision of the SI-the result of three decades of progress in metrology</strong> in Metrologia, Volume 56, Number 2.
<a href= \"https://iopscience.iop.org/article/10.1088/1681-7575/ab0013/pdf\">https://iopscience.iop.org/article/10.1088/1681-7575/ab0013/pdf</a>, 2019.
</dd>
</dl>
<dl>
<dt>D B Newell, F Cabiati, J Fischer, K Fujii, S G Karshenboim, H S Margolis , E de Mirand&eacute;s, P J Mohr, F Nez, K Pachucki, T J Quinn, B N Taylor, M Wang, B M Wood and Z Zhang:</dt>
<dd><strong>The CODATA 2017 values of h, e, k, and NA for the revision of the SI</strong> in Metrologia, Volume 55, Number 1.
<a href= \"https://iopscience.iop.org/article/10.1088/1681-7575/aa950a/pdf\">https://iopscience.iop.org/article/10.1088/1681-7575/aa950a/pdf</a>, 2017.
</dd>
</dl>
<p>BIPM is Bureau International des Poids et Mesures (they publish the SI-standard).</p>
<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>Dec 4, 2019</em>
       by Thomas Beutlich:<br>
       Constant G updated according to 2018 CODATA value.</li>
<li><em>Mar 25, 2019</em>
       by Hans Olsson:<br>
       Constants updated according to 2017 CODATA values and new SI-standard.</li>
<li><em>Nov 4, 2015</em>
       by Thomas Beutlich:<br>
       Constants updated according to 2014 CODATA values.</li>
<li><em>Nov 8, 2004</em>
       by Christian Schweiger:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><em>Dec 9, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><em>Sep 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><em>Nov 15, 1997</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Polygon(
          origin={-9.2597,25.6673},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={-19.9923,-8.3993},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={23.753,-11.5422},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
          smooth=Smooth.Bezier)}));
  end Constants;

  package Icons "Library of icons"

    partial class Information "Icon for general information packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              lineColor={75,138,73},
              fillColor={75,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            Polygon(origin={-4.167,-15.0},
              fillColor={255,255,255},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,-50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier),
            Ellipse(origin={7.5,56.5},
              fillColor={255,255,255},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}),
                                Documentation(info="<html>
<p>This icon indicates classes containing only documentation, intended for general description of, e.g., concepts and features of a package.</p>
</html>"));
    end Information;
    extends Icons.Package;

    partial package ExamplesPackage
    "Icon for packages containing runnable examples"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(
              origin={8.0,14.0},
              lineColor={78,138,73},
              fillColor={78,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial model Example "Icon for runnable examples"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor = {75,138,73},
                    fillColor={255,255,255},
                    fillPattern = FillPattern.Solid,
                    extent = {{-100,-100},{100,100}}),
            Polygon(lineColor = {0,0,255},
                    fillColor = {75,138,73},
                    pattern = LinePattern.None,
                    fillPattern = FillPattern.Solid,
                    points = {{-36,60},{64,0},{-36,-60},{-36,60}})}), Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
    end Example;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              extent={{-30.0,-30.0},{30.0,30.0}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={20.0,0.0},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
            Polygon(fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={23.3333,0.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
            Rectangle(
              fillColor = {128,128,128},
              pattern = LinePattern.None,
              fillPattern = FillPattern.Solid,
              extent = {{-70,-4.5},{0,4.5}})}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package UtilitiesPackage "Icon for utility packages"
      extends Modelica.Icons.Package;
       annotation (Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}),
      Documentation(info="<html>
<p>This icon indicates a package containing utility classes.</p>
</html>"));
    end UtilitiesPackage;

    partial package TypesPackage
    "Icon for packages containing type definitions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-12.167,-23},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                  {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                  -30},{4.167,20},{12.167,65}},
              smooth=Smooth.Bezier), Polygon(
              origin={2.7403,1.6673},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
              smooth=Smooth.Bezier)}));
    end TypesPackage;

    partial package FunctionsPackage "Icon for packages containing functions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
              Text(
                textColor={128,128,128},
                extent={{-90,-90},{90,90}},
                textString="f")}));
    end FunctionsPackage;

    partial package IconsPackage "Icon for packages containing icons"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}));
    end IconsPackage;

    partial package InternalPackage
    "Icon for an internal package (indicating that the package should not be directly utilized by user)"
    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            lineColor={215,215,215},
            fillColor={255,255,255},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25),
          Rectangle(
            lineColor={215,215,215},
            extent={{-100,-100},{100,100}},
            radius=25),
          Ellipse(
            extent={{-80,80},{80,-80}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid),
          Ellipse(
            extent={{-55,55},{55,-55}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,14},{60,-14}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid,
            rotation=45)}),
      Documentation(info="<html>

<p>
This icon shall be used for a package that contains internal classes not to be
directly utilized by a user.
</p>
</html>"));
    end InternalPackage;

    partial package RecordsPackage "Icon for package containing records"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Rectangle(
              origin={0,-20},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-80,-60},{80,60}},
              radius=25.0),
            Line(
              points={{-80,0},{80,0}},
              color={64,64,64}),
            Line(
              origin={0,-40},
              points={{-80,0},{80,0}},
              color={64,64,64}),
            Line(
              origin={0,-5},
              points={{0,45},{0,-75}},
              color={64,64,64})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains records</p>
</html>"));
    end RecordsPackage;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Text(
              textColor={0,0,255},
              extent={{-150,105},{150,145}},
              textString="%name"),
            Ellipse(
              lineColor = {108,88,49},
              fillColor = {255,215,136},
              fillPattern = FillPattern.Solid,
              extent = {{-100,-100},{100,100}}),
            Text(
              textColor={108,88,49},
              extent={{-90.0,-90.0},{90.0,90.0}},
              textString="f")}),
    Documentation(info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Text(
              textColor={0,0,255},
              extent={{-150,60},{150,100}},
              textString="%name"),
            Rectangle(
              origin={0.0,-25.0},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-75.0},{100.0,75.0}},
              radius=25.0),
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-50.0},
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-25.0},
              points={{0.0,75.0},{0.0,-75.0}},
              color={64,64,64})}), Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    type TypeReal "Icon for Real types"
        extends Real;
        annotation(Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Text(
                textColor={255,255,255},
                extent={{-90.0,-50.0},{90.0,50.0}},
                textString="R")}),Documentation(info="<html>
<p>
This icon is designed for a <strong>Real</strong> type.
</p>
</html>"));
    end TypeReal;

    partial class ObsoleteModel
      "Icon for classes that are obsolete and will be removed in later versions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-102,102},{102,-102}},
              lineColor={255,0,0},
              pattern=LinePattern.Dash,
              lineThickness=0.5)}), Documentation(info="<html>
<p>
This partial class is intended to provide a <u>default icon
for an obsolete model</u> that will be removed from the
corresponding library in a future release.
</p>
</html>"));
    end ObsoleteModel;
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}), Documentation(info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer.</p>

<h4>Main Authors</h4>

<dl>
<dt><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dt>
    <dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd>
    <dd>Oberpfaffenhofen</dd>
    <dd>Postfach 1116</dd>
    <dd>D-82230 Wessling</dd>
    <dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
<dt>Christian Kral</dt>

    <dd>  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
</dd>
    <dd>1060 Vienna, Austria</dd>
    <dd>email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a></dd>
<dt>Johan Andreasson</dt>
    <dd><a href=\"https://www.modelon.com/\">Modelon AB</a></dd>
    <dd>Ideon Science Park</dd>
    <dd>22370 Lund, Sweden</dd>
    <dd>email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>"));
  end Icons;

  package Units "Library of type and unit definitions"
    extends Modelica.Icons.Package;

    package SI "Library of SI unit definitions"
      extends Modelica.Icons.Package;

      type Angle = Real (
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg");

      type Length = Real (final quantity="Length", final unit="m");

      type Position = Length;

      type Distance = Length (min=0);

      type Time = Real (final quantity="Time", final unit="s");

      type AngularVelocity = Real (
          final quantity="AngularVelocity",
          final unit="rad/s");

      type AngularAcceleration = Real (final quantity="AngularAcceleration", final unit="rad/s2");

      type Velocity = Real (final quantity="Velocity", final unit="m/s");

      type Acceleration = Real (final quantity="Acceleration", final unit="m/s2");

      type Frequency = Real (final quantity="Frequency", final unit="Hz");

      type DampingCoefficient = Real (final quantity="DampingCoefficient", final unit=
                 "s-1");

      type Damping = DampingCoefficient;

      type Mass = Real (
          quantity="Mass",
          final unit="kg",
          min=0);

      type MomentOfInertia = Real (final quantity="MomentOfInertia", final unit=
              "kg.m2");

      type Inertia = MomentOfInertia;

      type Force = Real (final quantity="Force", final unit="N");

      type Torque = Real (final quantity="Torque", final unit="N.m");

      type Power = Real (final quantity="Power", final unit="W");

      type ThermodynamicTemperature = Real (
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min = 0.0,
          start = 288.15,
          nominal = 300,
          displayUnit="degC")
        "Absolute temperature (use type TemperatureDifference for relative temperatures)" annotation(absoluteValue=true);

      type Temperature = ThermodynamicTemperature;

      type HeatFlowRate = Real (final quantity="Power", final unit="W");

      type ElectricCurrent = Real (final quantity="ElectricCurrent", final unit="A");

      type Current = ElectricCurrent;

      type ElectricPotential = Real (final quantity="ElectricPotential", final unit=
             "V");

      type Voltage = ElectricPotential;

      type Resistance = Real (
          final quantity="Resistance",
          final unit="Ohm");

      type PerUnit = Real(unit = "1");
      annotation (Icon(graphics={Text(
              extent={{-80,80},{80,-78}},
              textColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.None,
              fontName="serif",
              textString="SI",
              textStyle={TextStyle.Italic})}),
                                       Documentation(info="<html>
<p>This package provides predefined types based on the international standard
on units.
</p>
<p>
For an introduction to the conventions used in this package, have a look at:
<a href=\"modelica://Modelica.Units.UsersGuide.Conventions\">Conventions</a>.
</p>
</html>"));
    end SI;

    package NonSI "Type definitions of non SI and other units"
      extends Modelica.Icons.Package;

      type Angle_deg = Real (final quantity="Angle", final unit="deg")
        "Angle in degree";
      annotation (Documentation(info="<html>
<p>
This package provides predefined types, such as <strong>Angle_deg</strong> (angle in
degree), <strong>AngularVelocity_rpm</strong> (angular velocity in revolutions per
minute) or <strong>Temperature_degF</strong> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package <code>Modelica.Units.SI</code>. For more information on units, see also
the book of Francois Cardarelli <strong>Scientific Unit Conversion - A
Practical Guide to Metrication</strong> (Springer 1997).</p>
</html>"), Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={Ellipse(
              extent={{-10,10},{10,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid), Ellipse(
              extent={{-60,10},{-40,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid), Ellipse(
              extent={{40,10},{60,-10}},
              lineColor={128,128,128},
              fillColor={128,128,128},
              fillPattern=FillPattern.Solid)}));
    end NonSI;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      function to_deg "Convert from radian to degree"
        extends Modelica.Units.Icons.Conversion;
        input SI.Angle radian "Value in radian";
        output Modelica.Units.NonSI.Angle_deg degree "Value in degree";
      algorithm
        degree := (180.0/Modelica.Constants.pi)*radian;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{10,100},{-100,46}},
                textString="rad"), Text(
                extent={{100,-44},{-10,-100}},
                textString="deg")}));
      end to_deg;

      function from_deg "Convert from degree to radian"
        extends Modelica.Units.Icons.Conversion;
        input Modelica.Units.NonSI.Angle_deg degree "Value in degree";
        output SI.Angle radian "Value in radian";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                textString="rad")}));
      end from_deg;

      function from_Hz "Convert from Hz to rad/s"
        extends Modelica.Units.Icons.Conversion;
        input SI.Frequency f "Value in hertz";
        output SI.AngularVelocity w "Value in radian per second";

      algorithm
        w := 2*Modelica.Constants.pi*f;
        annotation (Inline=true,Icon(graphics={
                                      Text(
                extent={{2,100},{-100,52}},
                textString="Hz"), Text(
                extent={{100,-56},{12,-100}},
                textString="1/s")}));
      end from_Hz;

      function to_Hz "Convert from rad/s to Hz"
        extends Modelica.Units.Icons.Conversion;
        input SI.AngularVelocity w "Value in radian per second";
        output SI.Frequency f "Value in hertz";
      algorithm
        f := w/(2*Modelica.Constants.pi);
        annotation (Inline=true,Icon(graphics={
                                      Text(
                extent={{100,-52},{-2,-100}},
                textString="Hz"), Text(
                extent={{-12,100},{-100,56}},
                textString="1/s")}));
      end to_Hz;
      annotation (Documentation(info="<html>
<p>This package provides conversion functions from the non SI Units
defined in package <code>Modelica.Units.NonSI</code> to the
corresponding SI Units defined in package <code>Modelica.Units.SI</code> and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<blockquote><pre>
<strong>import</strong> Modelica.Units.SI;
<strong>import</strong> Modelica.Units.Conversions.{from_degC, from_deg, from_rpm};
   ...
<strong>parameter</strong> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to kelvin
<strong>parameter</strong> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
<strong>parameter</strong> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                   // to radian per seconds
</pre></blockquote>

</html>"),     Icon(graphics={
            Polygon(
              points={{80,0},{20,20},{20,-20},{80,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,0},{20,0}}, color={191,0,0})}));
    end Conversions;

    package Icons "Icons for Units"
      extends Modelica.Icons.IconsPackage;

      partial function Conversion "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                textColor={0,0,255})}));
      end Conversion;
    end Icons;
    annotation (Icon(graphics={
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-80,-40},{-80,-40},{-55,50},{-52.5,62.5},{-65,60},{-65,65},{-35,77.5},{-32.5,60},{-50,0},{-50,0},{-30,15},{-20,27.5},{-32.5,27.5},{-32.5,27.5},{-32.5,32.5},{-32.5,32.5},{2.5,32.5},{2.5,32.5},{2.5,27.5},{2.5,27.5},{-7.5,27.5},{-30,7.5},{-30,7.5},{-25,-25},{-17.5,-28.75},{-10,-25},{-5,-26.25},{-5,-32.5},{-16.25,-41.25},{-31.25,-43.75},{-40,-33.75},{-45,-5},{-45,-5},{-52.5,-10},{-52.5,-10},{-60,-40},{-60,-40}},
          smooth = Smooth.Bezier),
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{87.5,30},{62.5,30},{62.5,30},{55,33.75},{36.25,35},{16.25,25},{7.5,6.25},{11.25,-7.5},{22.5,-12.5},{22.5,-12.5},{6.25,-22.5},{6.25,-35},{16.25,-38.75},{16.25,-38.75},{21.25,-41.25},{21.25,-41.25},{45,-48.75},{47.5,-61.25},{32.5,-70},{12.5,-65},{7.5,-51.25},{21.25,-41.25},{21.25,-41.25},{16.25,-38.75},{16.25,-38.75},{6.25,-41.25},{-6.25,-50},{-3.75,-68.75},{30,-76.25},{65,-62.5},{63.75,-35},{27.5,-26.25},{22.5,-20},{27.5,-15},{27.5,-15},{30,-7.5},{30,-7.5},{27.5,-2.5},{28.75,11.25},{36.25,27.5},{47.5,30},{53.75,22.5},{51.25,8.75},{45,-6.25},{35,-11.25},{30,-7.5},{30,-7.5},{27.5,-15},{27.5,-15},{43.75,-16.25},{65,-6.25},{72.5,10},{70,20},{70,20},{80,20}},
          smooth = Smooth.Bezier)}), Documentation(info="<html>
<p>This package provides predefined types, such as <em>Mass</em>,
<em>Angle</em>, <em>Time</em>, based on the international standard
on units, e.g.,
</p>

<blockquote><pre>
<strong>type</strong> Angle = Real(<strong>final</strong> quantity = \"Angle\",
                  <strong>final</strong> unit     = \"rad\",
                  displayUnit   = \"deg\");
</pre></blockquote>

<p>
Some of the types are derived SI units that are utilized in package Modelica
(such as ComplexCurrent, which is a complex number where both the real and imaginary
part have the SI unit Ampere).
</p>

<p>
Furthermore, conversion functions from non SI-units to SI-units and vice versa
are provided in subpackage
<a href=\"modelica://Modelica.Units.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica Standard Library
with package Units, have a look at:
<a href=\"modelica://Modelica.Units.UsersGuide.HowToUseUnits\">How to use Units</a>.
</p>

<p>
Copyright &copy; 1998-2020, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br>Added molar units for energy and enthalpy.</li>
<li><em>Jan. 27, 2010</em> by Christian Kral:<br>Added complex units.</li>
<li><em>Dec. 14, 2005</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Add User&#39;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><em>October 21, 2002</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Christian Schweiger:<br>Added new package <strong>Conversions</strong>. Corrected typo <em>Wavelenght</em>.</li>
<li><em>June 6, 2000</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Introduced the following new types<br>type Temperature = ThermodynamicTemperature;<br>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><em>Oct. 27, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><em>Sept. 18, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><em>Aug 12, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><em>June 29, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><em>April 8, 1998</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br>Complete ISO 31 chapters realized.</li>
<li><em>Nov. 15, 1997</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Hubertus Tummescheit:<br>Some chapters realized.</li>
</ul>
</html>"));
  end Units;
annotation (
preferredView="info",
version="4.0.0",
versionDate="2020-06-04",
dateModified = "2020-06-04 11:00:00Z",
revisionId="6626538a2 2020-06-04 19:56:34 +0200",
uses(Complex(version="4.0.0"), ModelicaServices(version="4.0.0")),
conversion(
 from(version={"3.0", "3.0.1", "3.1", "3.2", "3.2.1", "3.2.2", "3.2.3"}, script="modelica://Modelica/Resources/Scripts/Conversion/ConvertModelica_from_3.2.3_to_4.0.0.mos")),
Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
  Polygon(
    origin={-6.9888,20.048},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    points={{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
    smooth=Smooth.Bezier),
  Ellipse(
    origin={40.8208,-37.7602},
    fillColor={161,0,4},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    extent={{-17.8562,-17.8563},{17.8563,17.8562}})}),
Documentation(info="<html>
<p>
<img src=\"modelica://Modelica/Resources/Images/Logos/Modelica_Libraries.svg\" width=\"250\">
</p>

<p>
The package <strong>Modelica&reg;</strong> is a <strong>standardized</strong> and <strong>free</strong> package
that is developed by the \"<strong>Modelica Association Project - Libraries</strong>\".</p>
<p>
Its development is coordinated with the Modelica&reg; language from the
Modelica Association, see <a href=\"https://www.Modelica.org\">https://www.Modelica.org</a>.
It is also called <strong>Modelica Standard Library</strong>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <strong>Examples</strong> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li><strong>1417</strong> component models and blocks,</li>
<li><strong>512</strong> example models, and</li>
<li><strong>1219</strong> functions</li>
</ul>
<p>
that are directly usable (= number of public, non-partial, non-internal and non-obsolete classes). It is fully compliant
to <a href=\"https://modelica.org/documents/ModelicaSpec34.pdf\">Modelica Specification version 3.4</a>
and it has been tested with Modelica tools from different vendors.
</p>

<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 1998-2020, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>.
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica;

package OpenIPSL "Open-Instance Power System Library"

  package Electrical

    record SystemBase "System Base Definition"
      parameter OpenIPSL.Types.ApparentPowerMega S_b=100 "System base";
      parameter Modelica.Units.SI.Frequency fn=50 "System Frequency";
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-120,-100},{120,100}},
            initialScale=0.1), graphics={Rectangle(extent={{-120,100},{120,-100}},
              lineColor={28,108,200}),Text(
              extent={{-100,40},{100,0}},
              lineColor={28,108,200},
              horizontalAlignment=TextAlignment.Left,
              textString="System Base: %S_b MVA"),Text(
              extent={{-100,-20},{100,-60}},
              lineColor={28,108,200},
              horizontalAlignment=TextAlignment.Left,
              textString="Frequency: %fn Hz"),Text(
              extent={{-100,100},{100,60}},
              lineColor={28,108,200},
              horizontalAlignment=TextAlignment.Center,
              textString="System Data")}),
        defaultComponentName="SysData",
        defaultAttributes="inner",
        missingInnerMessage="
No 'System Data' component is defined. A default component will be used, and generate a system base of 100 MVA, and a frequency of 50 Hz",
        Diagram(coordinateSystem(
            extent={{-120,-100},{120,100}},
            preserveAspectRatio=false,
            initialScale=0.1)),
        defaultComponentPrefixes="inner",
        Documentation);

    end SystemBase;

    package Buses

      model Bus "Bus model (2014/03/10)"
        extends OpenIPSL.Electrical.Essentials.pfComponent;
        OpenIPSL.Interfaces.PwPin p(vr(start=V_0*cos(angle_0*Modelica.Constants.pi/
                180)), vi(start=V_0*sin(angle_0*Modelica.Constants.pi/180)))
          annotation (Placement(
            visible=true,
            transformation(
              origin={0,0},
              extent={{-10.0,-10.0},{10.0,10.0}},
              rotation=0),
            iconTransformation(
              origin={0,0},
              extent={{-10,-10},{10,10}},
              rotation=0)));
        Real V(start=V_0) "Bus voltage magnitude (pu)";
        Modelica.Units.NonSI.Angle_deg angle(start=angle_0) "Bus voltage angle";
        parameter Boolean displayPF=true "Display voltage values:" annotation (Dialog(
            group="Visualisation",
            __Dymola_compact=true,
            __Dymola_descriptionLabel=true), choices(checkBox=true));
      equation
        V = sqrt(p.vr^2 + p.vi^2);
        angle = atan2(p.vi, p.vr)*180/Modelica.Constants.pi;
        p.ir = 0;
        p.ii = 0;
        annotation (Icon(graphics={Rectangle(
                visible=true,
                fillPattern=FillPattern.Solid,
                extent={{-10,-100},{10,100}}),Text(
                visible=true,
                origin={-0.02605,120.133},
                fillPattern=FillPattern.Solid,
                extent={{-100,-20},{100,20}},
                textString="%name"),Text(
                visible=displayPF,
                origin={0,-120},
                extent={{-60,-20},{60,20}},
                lineColor={170,0,0},
                textString=DynamicSelect("Vpu", String(V, significantDigits=3))),Text(
                visible=displayPF,
                origin={0,-160},
                extent={{-60,-20},{60,20}},
                lineColor={170,0,0},
                textString=DynamicSelect("Angle", String(angle, significantDigits=3)
                   + "°"))}), Documentation);
      end Bus;

      model InfiniteBus "PSAT Infinite Bus"
        extends OpenIPSL.Electrical.Essentials.pfComponent;
        Real P "Active Power absorbed by the Infinite bus (MW)";
        Real Q "Reactive Power absorbed by the Infinite bus (MVAr)";
        Interfaces.PwPin p
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        parameter Boolean displayPF=false "Display power flow results:" annotation (
            Dialog(
            group="Visualisation",
            __Dymola_compact=true,
            __Dymola_descriptionLabel=true), choices(checkBox=true));
      equation
        p.vr = V_0*cos(angle_0*Modelica.Constants.pi/180);
        p.vi = V_0*sin(angle_0*Modelica.Constants.pi/180);
        P = -(p.vr*p.ir + p.vi*p.ii)*S_b;
        Q = -(p.vr*p.ii - p.vi*p.ir)*S_b;
        annotation (
          Icon(coordinateSystem(
              extent={{-100,-100},{100,100}},
              preserveAspectRatio=false,
              initialScale=0.1,
              grid={2,2}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,0},
                fillColor={241,241,241},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{-80,100},{80,20}},
                lineColor={255,0,0},
                textString=DynamicSelect("0.0 MW",
                  OpenIPSL.NonElectrical.Functions.displayPower(P, " MW"))),Polygon(
                visible=displayPF,
                points=DynamicSelect({{-20,30},{-20,10},{20,20},{-20,30}}, if P >= 0
                   then {{-20,30},{-20,10},{20,20},{-20,30}} else {{20,30},{20,10},{-20,
                  20},{20,30}}),
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{-80,-20},{80,-100}},
                lineColor={0,255,0},
                textString=DynamicSelect("0.0 Mvar",
                  OpenIPSL.NonElectrical.Functions.displayPower(Q, " Mvar"))),Polygon(
                visible=displayPF,
                points=DynamicSelect({{-20,-30},{-20,-10},{20,-20},{-20,-30}}, if Q
                   >= 0 then {{-20,-30},{-20,-10},{20,-20},{-20,-30}} else {{20,-30},
                  {20,-10},{-20,-20},{20,-30}}),
                lineColor={0,255,0},
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),Text(
                extent={{-100,160},{100,120}},
                lineColor={0,0,255},
                textString="%name")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.1,
              grid={2,2})),
          Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\"><tr>
<td><p>Reference</p></td>
<td><p>None</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td><p>2015-12-14</p></td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Maxime Baudette, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
      end InfiniteBus;
    annotation (Documentation);
    end Buses;

    package Branches

      model PwLine "Model for a transmission Line based on the pi-equivalent circuit"
        outer OpenIPSL.Electrical.SystemBase SysData;
        import Modelica.ComplexMath.conj;
        import Modelica.ComplexMath.real;
        import Modelica.ComplexMath.imag;
        import Modelica.ComplexMath.j;
        OpenIPSL.Interfaces.PwPin p annotation (Placement(transformation(extent={{-100,
                  -10},{-80,10}}), iconTransformation(extent={{-100,-10},{-80,10}})));
        OpenIPSL.Interfaces.PwPin n annotation (Placement(transformation(extent={{80,
                  -10},{100,10}}), iconTransformation(extent={{80,-10},{100,10}})));
        parameter Modelica.Units.SI.PerUnit R "Resistance (pu)"
          annotation (Dialog(group="Line parameters"));
        parameter Modelica.Units.SI.PerUnit X "Reactance (pu)"
          annotation (Dialog(group="Line parameters"));
        parameter Modelica.Units.SI.PerUnit G "Shunt half conductance (pu)"
          annotation (Dialog(group="Line parameters"));
        parameter Modelica.Units.SI.PerUnit B "Shunt half susceptance (pu)"
          annotation (Dialog(group="Line parameters"));
        parameter OpenIPSL.Types.ApparentPowerMega S_b=SysData.S_b
          "System base power (MVA)"
          annotation (Dialog(group="Line parameters", enable=false));
        parameter Modelica.Units.SI.Time t1=Modelica.Constants.inf
          annotation (Dialog(group="Perturbation parameters"));
        parameter Modelica.Units.SI.Time t2=Modelica.Constants.inf
          annotation (Dialog(group="Perturbation parameters"));
        parameter Integer opening=1 annotation (Dialog(group=
                "Perturbation parameters"), choices(
            choice=1 "Line opening at both ends",
            choice=2 "Line opening at sending end",
            choice=3 "Line opening at receiving end"));
        parameter Boolean displayPF=false "Display power flow results:" annotation (
            Dialog(
            group="Visualisation",
            __Dymola_compact=true,
            __Dymola_descriptionLabel=true), choices(checkBox=true));
        OpenIPSL.Types.ActivePowerMega P12;
        OpenIPSL.Types.ActivePowerMega P21;
        OpenIPSL.Types.ReactivePowerMega Q12;
        OpenIPSL.Types.ReactivePowerMega Q21;
        Complex vs(re=p.vr, im=p.vi);
        Complex is(re=p.ir, im=p.ii);
        Complex vr(re=n.vr, im=n.vi);
        Complex ir(re=n.ir, im=n.ii);
    protected
        parameter Complex Y(re=G, im=B);
        parameter Complex Z(re=R, im=X);
      equation
        //Calculations for the power flow display
        P12 = real(vs*conj(is))*S_b;
        P21 = -real(vr*conj(ir))*S_b;
        Q12 = imag(vs*conj(is))*S_b;
        Q21 = -imag(vr*conj(ir))*S_b;
        //PI model with different line openings
        if time >= t1 and time < t2 then
          if opening == 1 then
            is = Complex(0);
            ir = Complex(0);
          elseif opening == 2 then
            is = Complex(0);
            ir = (vr - ir*Z)*Y;
          else
            ir = Complex(0);
            is = (vs - is*Z)*Y;
          end if;
        else
          vs - vr = Z*(is - vs*Y);
          vr - vs = Z*(ir - vr*Y);
        end if;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, initialScale=0.1),
              graphics={Rectangle(
                extent={{-80,40},{80,-40}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),Rectangle(
                extent={{-60,20},{60,-20}},
                lineColor={0,0,255},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{-200,160},{-20,40}},
                lineColor={255,0,0},
                textString=DynamicSelect("0.0 MW",
                  OpenIPSL.NonElectrical.Functions.displayPower(P12, " MW"))),Polygon(
                visible=displayPF,
                points=DynamicSelect({{-120,70},{-120,50},{-80,60},{-120,70}}, if P12
                   >= 0 then {{-120,70},{-120,50},{-80,60},{-120,70}} else {{-80,70},
                  {-80,50},{-120,60},{-80,70}}),
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{20,160},{200,40}},
                lineColor={255,0,0},
                textString=DynamicSelect("0.0 MW",
                  OpenIPSL.NonElectrical.Functions.displayPower(P21, " MW"))),Polygon(
                visible=displayPF,
                points=DynamicSelect({{80,70},{80,50},{120,60},{80,70}}, if P21 >= 0
                   then {{80,70},{80,50},{120,60},{80,70}} else {{120,70},{120,50},{
                  80,60},{120,70}}),
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{-200,-40},{-20,-160}},
                lineColor={0,255,0},
                textString=DynamicSelect("0.0 Mvar",
                  OpenIPSL.NonElectrical.Functions.displayPower(Q12, " Mvar"))),
                Polygon(
                visible=displayPF,
                points=DynamicSelect({{-120,-70},{-120,-50},{-80,-60},{-120,-70}},
                  if Q12 >= 0 then {{-120,-70},{-120,-50},{-80,-60},{-120,-70}} else
                  {{-80,-70},{-80,-50},{-120,-60},{-80,-70}}),
                lineColor={0,255,0},
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),Text(
                visible=displayPF,
                extent={{20,-40},{200,-160}},
                lineColor={0,255,0},
                textString=DynamicSelect("0.0 Mvar",
                  OpenIPSL.NonElectrical.Functions.displayPower(Q21, " Mvar"))),
                Polygon(
                visible=displayPF,
                points=DynamicSelect({{80,-70},{80,-50},{120,-60},{80,-70}}, if Q21
                   >= 0 then {{80,-70},{80,-50},{120,-60},{80,-70}} else {{120,-70},{
                  120,-50},{80,-60},{120,-70}}),
                lineColor={0,255,0},
                fillColor={0,255,0},
                fillPattern=FillPattern.Solid),Text(
                extent={{-60,20},{60,-20}},
                lineColor={255,255,0},
                textString="%name")}), Documentation);
      end PwLine;

      package PSAT

        model TwoWindingTransformer "Modeled as series reactances without iron losses"
          outer OpenIPSL.Electrical.SystemBase SysData;
          OpenIPSL.Interfaces.PwPin p
            annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
          OpenIPSL.Interfaces.PwPin n
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Real Sb=SysData.S_b "System base power (MVA)"
            annotation (Dialog(group="Power flow"));
          parameter Real Sn=100 "Power rating (MVA)"
            annotation (Dialog(group="Power flow"));
          parameter Real V_b=40 "Sending end bus voltage (kV)"
            annotation (Dialog(group="Power flow"));
          parameter Real Vn=40 "Voltage rating (kV)"
            annotation (Dialog(group="Power flow"));
          parameter Real fn=SysData.fn "Frequency rating (Hz)"
            annotation (Dialog(group="Power flow"));
          parameter Real kT=1 "Nominal tap ratio (kV1/kV2)"
            annotation (Dialog(group="Transformer parameters"));
          parameter Real x=0.001 "Reactance (pu machine base)"
            annotation (Dialog(group="Transformer parameters"));
          parameter Real r=0.1 "Resistance (pu machine base)"
            annotation (Dialog(group="Transformer parameters"));
      protected
          parameter Real Vb2new=V_b^2;
          parameter Real Vb2old=Vn*Vn;
          parameter Real xT=x*(Vb2old*Sb)/(Vb2new*Sn) "Reactance, p.u system base";
          parameter Real rT=r*(Vb2old*Sb)/(Vb2new*Sn) "Resistance, p.u system base";
        equation
          rT*p.ir - xT*p.ii = p.vr - n.vr;
          rT*p.ii + xT*p.ir = p.vi - n.vi;
          rT*n.ir - xT*n.ii = n.vr - p.vr;
          xT*n.ir + rT*n.ii = n.vi - p.vi;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(graphics={Ellipse(extent={{-46,30},{8,-30}}, lineColor={0,0,255}),
                  Ellipse(extent={{-10,30},{44,-30}}, lineColor={0,0,255}),Line(
                  points={{100,0},{44,0},{44,0}},
                  color={0,0,255},
                  smooth=Smooth.None),Line(
                  points={{-100,0},{-46,0}},
                  color={0,0,255},
                  smooth=Smooth.None),Text(
                  extent={{-38,20},{-4,-20}},
                  lineColor={28,108,200},
                  textString="1"),Text(
                  extent={{4,18},{32,-16}},
                  lineColor={28,108,200},
                  textString="2")}),
            Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\"><tr>
<td><p>Reference</p></td>
<td><p>PSAT Manual 2.1.8</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td><p>29/09/2015</p></td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>MAA Murad, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
        end TwoWindingTransformer;
      annotation (Documentation);
      end PSAT;
    annotation (Documentation);
    end Branches;

    package Machines

      package PSAT

        model Order6
          extends BaseClasses.baseMachine(vf(start=vf00), xq0=xq);
          parameter Real xd=1.9 "d-axis synchronous reactance (pu)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real xq=1.7 "q-axis synchronous reactance (pu)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real x1q=0.5 "q-axis transient reactance (pu)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real x2d=0.204 "d-axis sub-transient reactance (pu)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real x2q=0.3 "q-axis sub-transient reactance (pu)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real T1d0=8 "d-axis open circuit transient time constant (s)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real T1q0=0.8 "q-axis open circuit transient time constant (s)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real T2d0=0.04 "d-axis open circuit transient time constant (s)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real T2q0=0.02 "q-axis open circuit transient time constant (s)"
            annotation (Dialog(group="Machine parameters"));
          parameter Real Taa=2e-3 "d-axis aditional leakage time constant (s)"
            annotation (Dialog(group="Machine parameters"));

          Real e1q(start=e1q0) "q-axis transient voltage";
          Real e1d(start=e1d0) "d-axis transient voltage";
          Real e2q(start=e2q0) "q-axis sub-transient voltage";
          Real e2d(start=e2d0) "d-axis sub-transient voltage";
      protected
          parameter Real e2q0=vq0 + ra*iq0 + x2d*id0 "Initialitation";
          parameter Real e2d0=vd0 + ra*id0 - x2q*iq0 "Initialitation";
          parameter Real e1d0=(xq - x1q - T2q0*x2q*(xq - x1q)/(T1q0*x1q))*iq0;
          parameter Real K1=xd - x1d - T2d0*x2d*(xd - x1d)/(T1d0*x1d);
          parameter Real K2=x1d - x2d + T2d0*x2d*(xd - x1d)/(T1d0*x1d);
          parameter Real e1q0=e2q0 + K2*id0 - Taa/T1d0*((K1 + K2)*id0 + e2q0);
          parameter Real vf00=V_MBtoSB*(K1*id0 + e1q0)/(1 - Taa/T1d0)
            "Init. val. (pu, SB)";
        initial equation
          der(e1d) = 0;
          // der(e1d) = 0;
          der(e2d) = 0;
          // der(e2q) = 0;
        equation

          der(e1q) = ((-e1q) - (xd - x1d - T2d0/T1d0*x2d/x1d*(xd - x1d))*id + (1 - Taa/
            T1d0)*vf_MB)/T1d0;
          der(e1d) = ((-e1d) + (xq - x1q - T2q0/T1q0*x2q/x1q*(xq - x1q))*iq)/T1q0;
          der(e2d) = ((-e2d) + e1d + (x1q - x2q + T2q0/T1q0*x2q/x1q*(xq - x1q))*iq)/
            T2q0;
          der(e2q) = ((-e2q) + e1q - (x1d - x2d + T2d0/T1d0*x2d/x1d*(xd - x1d))*id +
            Taa/T1d0*vf_MB)/T2d0;
          e2q = vq + ra*iq + x2d*id;
          e2d = vd + ra*id - x2q*iq;
          vf0 = vf00;
          annotation (Icon(coordinateSystem(extent={{-100,-100},{100,100}},
                  initialScale=0.1), graphics={Rectangle(
                  visible=true,
                  fillColor={255,255,255},
                  extent={{-100.0,-100.0},{100.0,100.0}}),Text(
                  origin={0,60},
                  extent={{-60,-20},{60,20}},
                  lineColor={28,108,200},
                  textString="Order VI")}), Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td>Generator Order VI, PSAT Manual</td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>2015-10-02</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Le Qi, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
        end Order6;

        package BaseClasses

          partial model baseMachine
            extends OpenIPSL.Electrical.Essentials.pfComponent;
            import Modelica.Constants.pi;
            import      Modelica.Units.SI;
            import CM = Modelica.ComplexMath;
            import Complex;
            parameter OpenIPSL.Types.ApparentPowerMega Sn "Power rating (MVA)"
              annotation (Dialog(group="Machine parameters"));
            parameter OpenIPSL.Types.VoltageKilo Vn "Voltage rating (kV)"
              annotation (Dialog(group="Machine parameters"));
            parameter SI.PerUnit ra "Armature resistance (pu)"
              annotation (Dialog(group="Machine parameters"));
            parameter SI.PerUnit x1d "d-axis transient reactance (pu)"
              annotation (Dialog(group="Machine parameters"));
            parameter Real M "Mechanical starting time (2H), kWs/kVA"
              annotation (Dialog(group="Machine parameters"));
            parameter Real D "Damping coefficient"
              annotation (Dialog(group="Machine parameters"));

            OpenIPSL.Interfaces.PwPin p(
              vr(start=vr0),
              vi(start=vi0),
              ir(start=ir0),
              ii(start=ii0)) annotation (Placement(visible=true, transformation(
                  origin={100,0},
                  extent={{-10.0,-10.0},{10.0,10.0}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput delta(
              start=delta0,
              quantity="Angle",
              unit="rad",
              displayUnit="rad") "Rotor angle (rad)" annotation (Placement(visible=true,
                  transformation(
                  origin={110,60},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput w(start=1) "Rotor speed (pu)"
              annotation (Placement(visible=true, transformation(
                  origin={110,90},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput v(start=V_0)
              "Generator terminal voltage (pu)" annotation (Placement(visible=true,
                  transformation(
                  origin={110,30},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput P(start=p0) "Active power (pu)"
              annotation (Placement(visible=true, transformation(
                  origin={110,-30},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput Q(start=q0) "Reactive power (pu)"
              annotation (Placement(visible=true, transformation(
                  origin={110,-70},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealInput vf "Field voltage (pu)" annotation (
                Placement(visible=true, transformation(
                  origin={-120,50},
                  extent={{-20,-20},{20,20}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput vf0 "Initial field voltage (pu)"
              annotation (Placement(visible=true, transformation(
                  origin={-80,110},
                  extent={{-10,-10},{10,10}},
                  rotation=90)));
            Modelica.Blocks.Interfaces.RealOutput pm0(start=pm00)
              "Initial mechanical power (pu)" annotation (Placement(visible=true,
                  transformation(
                  origin={-80,-110},
                  extent={{-10,-10},{10,10}},
                  rotation=270)));
            Modelica.Blocks.Interfaces.RealInput pm(start=pm00) "Mechanical power (pu)"
              annotation (Placement(visible=true, transformation(
                  origin={-120,-50},
                  extent={{-20,-20},{20,20}},
                  rotation=0)));
            SI.Angle anglev(start=Modelica.Units.Conversions.from_deg(angle_0))
              " Bus voltage angle (rad)";
            Real vd(start=vd0) "d-axis voltage (pu)";
            Real vq(start=vq0) "q-axis voltage (pu)";
            Real id(start=id0) "d-axis currrent (pu)";
            Real iq(start=iq0) "q-axis current (pu)";
        protected
            SI.PerUnit pe(start=pm00) "electrical power transmitted through the air-gap";
            SI.PerUnit vf_MB=vf*V_b/Vn "field voltage on machine base";
            parameter SI.AngularVelocity w_b=2*pi*fn "Base frequency in rad/s";
            // Define multiplicative transforms to go from one pu-base to another:
            parameter Real S_SBtoMB=S_b/Sn "S(system base) -> S(machine base)";
            parameter Real I_MBtoSB=(Sn*V_b)/(S_b*Vn) "I(machine base) -> I(system base)";
            parameter Real V_MBtoSB=Vn/V_b "V(machine base) -> V(system base)";
            parameter Real Z_MBtoSB=(S_b*Vn^2)/(Sn*V_b^2)
              "Z(machine base) -> Z(system base)";

            // Initialize stator quantities (system base):
            parameter SI.PerUnit p0=P_0/S_b
              "Initial active power generation in pu (system base)";
            parameter SI.PerUnit q0=Q_0/S_b
              "Initial reactive power generation in pu (system base)";
            parameter Complex Vt0=CM.fromPolar(V_0, Modelica.Units.Conversions.from_deg(
                                                                            angle_0))
              "Init. val., conjugate";
            parameter Complex S0(re=p0, im=-q0) "Init. val., conjugate";
            parameter Complex I0=S0/(CM.conj(Vt0)) "Init. val., conjugate";
            parameter SI.PerUnit vr0=CM.real(Vt0) "Init. val.";
            parameter SI.PerUnit vi0=CM.imag(Vt0) "Init. val.";
            parameter SI.PerUnit ir0=-CM.real(I0) "Init. val.";
            parameter SI.PerUnit ii0=-CM.imag(I0) "Init. val.";

            // Initialize DQ-quantities (pu, machine base)
            parameter SI.PerUnit xq0 "used for setting the initial rotor angle";
            parameter SI.Angle delta0=CM.arg((Vt0 + ((ra + CM.j*xq0)*Z_MBtoSB*I0)))
              "Init. val. rotor angle";
            parameter Complex Vdq0=Vt0*CM.fromPolar(1/V_MBtoSB, (-delta0 + (pi/2)))
              "Init. val (pu, machine base)";
            parameter Complex Idq0=I0*CM.fromPolar(1/I_MBtoSB, (-delta0 + (pi/2)))
              "(pu, machine base)";
            parameter SI.PerUnit vd0=CM.real(Vdq0) "Init. val.";
            parameter SI.PerUnit vq0=CM.imag(Vdq0) "Init. val.";
            parameter SI.PerUnit id0=CM.real(Idq0) "Init. val.";
            parameter SI.PerUnit iq0=CM.imag(Idq0) "Init. val.";

            parameter SI.PerUnit pm00=((vq0 + ra*iq0)*iq0 + (vd0 + ra*id0)*id0)/S_SBtoMB
              "Init. val. (pu, system base)";
          initial equation
            w = 1;
            delta = delta0;
          equation
            v = sqrt(p.vr^2 + p.vi^2);
            anglev = atan2(p.vi, p.vr);
            der(delta) = w_b*(w - 1);
            if D > Modelica.Constants.eps then
              der(w) = (pm*S_SBtoMB - pe - D*(w - 1))/M;
            else
              der(w) = (pm*S_SBtoMB - pe)/M;
            end if;
            [p.ir; p.ii] = -[sin(delta), cos(delta); -cos(delta), sin(delta)]*[id; iq]*
              I_MBtoSB;
            [p.vr; p.vi] = [sin(delta), cos(delta); -cos(delta), sin(delta)]*[vd; vq]*
              V_MBtoSB;
            P = -p.vr*p.ir - p.vi*p.ii;
            Q = -p.vi*p.ir + p.vr*p.ii;
            pe = (vq + ra*iq)*iq + (vd + ra*id)*id "pu, machine base";
            pm0 = pm00 "pu, system base";
            annotation (
              Icon(coordinateSystem(extent={{-100,-100},{100,100}}, initialScale=0.1),
                  graphics={Rectangle(
                    fillColor={255,255,255},
                    extent={{-100,-100},{100,100}},
                    lineColor={28,108,200},
                    fillPattern=FillPattern.Solid),Text(
                    origin={-80,50},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="vf"),Text(
                    origin={-80,-50},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="pm"),Text(
                    origin={-80,90},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="vf0"),Text(
                    origin={-80,-90},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="pm0"),Text(
                    origin={85,60},
                    extent={{-15,-10},{15,10}},
                    lineColor={28,108,200},
                    textString="delta"),Text(
                    origin={90,90},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="w"),Text(
                    origin={90,30},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="v"),Ellipse(extent={{-40,40},{40,-40}}, lineColor={28,108,
                    200}),Line(
                    points={{-20,0},{-9,15},{9,-15},{20,0}},
                    color={28,108,200},
                    smooth=Smooth.Bezier),Text(
                    origin={0,-60},
                    extent={{-60,-20},{60,20}},
                    lineColor={28,108,200},
                    textString="%name"),Text(
                    origin={90,-31},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="P"),Text(
                    origin={90,-70},
                    extent={{-10,-10},{10,10}},
                    lineColor={28,108,200},
                    textString="Q")}),
              Documentation,
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                      100,100}})));
          end baseMachine;
        annotation (Documentation);
        end BaseClasses;
      annotation (Documentation);
      end PSAT;
    annotation (Documentation);
    end Machines;

    package Controls

      package PSAT

        package AVR

          model AVRtypeIII
            parameter Real vfmax=5;
            parameter Real vfmin=-5;
            parameter Real K0=20 "regulator gain";
            parameter Real T2=0.1 "regulator pole";
            parameter Real T1=0.45 "Regulator zero";
            parameter Real Te=0.1 "Field circuit time constant";
            parameter Real Tr=0.0015 "Measurement time constant";
            Real vm;
            Real vr;
            Real vf1;
            Modelica.Blocks.Nonlinear.Limiter limiter1(uMax=vfmax, uMin=vfmin)
              annotation (Placement(visible=true, transformation(
                  origin={5,0},
                  extent={{-10.0,-10.0},{10.0,10.0}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealInput v(start=1) annotation (Placement(
                visible=true,
                transformation(
                  origin={-119.972,50},
                  extent={{-20.0,-20.0},{20.0,20.0}},
                  rotation=0),
                iconTransformation(
                  origin={-110,60},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealOutput vf annotation (Placement(
                visible=true,
                transformation(
                  origin={130,0},
                  extent={{-10.0,-10.0},{10.0,10.0}},
                  rotation=0),
                iconTransformation(
                  origin={130,0},
                  extent={{-10,-10},{10,10}},
                  rotation=0)));
            Modelica.Blocks.Interfaces.RealInput vs annotation (Placement(transformation(
                    extent={{-140,-82},{-100,-42}}), iconTransformation(extent={{-120,-70},
                      {-100,-50}})));
            Modelica.Blocks.Interfaces.RealInput vf0(start=1) annotation (Placement(
                visible=true,
                transformation(
                  origin={0.028,120},
                  extent={{-20.0,-20.0},{20.0,20.0}},
                  rotation=-90),
                iconTransformation(
                  origin={0,110},
                  extent={{-10,-10},{10,10}},
                  rotation=-90)));
        protected
            parameter Real vref(fixed=false);
            parameter Real s0(fixed=false);
          initial equation
            vref = v;
            s0 = vs;
            vf1 = vf0;
            vm = v;
            vr = K0*(1 - T1/T2)*(vref + vs - vm);
          equation
            der(vm) = (v - vm)/Tr;
            der(vr) = (K0*(1 - T1/T2)*(vref + vs - vm) - vr)/T2;
            der(vf1) = ((vr + K0*(T1/T2)*(vref + vs - vm) + vf0)*(1 + s0*(v/vm - 1)) -
              vf1)/Te;
            limiter1.u = vf1;
            limiter1.y = vf;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-120,-120},{120,
                      120}}), graphics={Rectangle(
                    extent={{-120,120},{120,-120}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-104,72},{-72,50}},
                    lineColor={0,0,255},
                    textString="v"),Text(
                    extent={{-100,-48},{-68,-70}},
                    lineColor={0,0,255},
                    textString="vs"),Text(
                    extent={{88,10},{120,-12}},
                    lineColor={0,0,255},
                    textString="vf"),Text(
                    extent={{-34,36},{42,-24}},
                    lineColor={0,0,255},
                    textString="AVRTypeIII"),Text(
                    extent={{-16,100},{16,78}},
                    lineColor={0,0,255},
                    textString="vf0")}),
              Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td><p>AVR Type III, PSAT Manual 2.1.8</p></td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>September 2015</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Joan Russinol, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"),    Diagram(coordinateSystem(extent={{-120,-120},{120,120}})));
          end AVRtypeIII;
        annotation (Documentation);
        end AVR;

        package PSS

          model PSSTypeII "PSAT PSS TypeII"
            parameter Real vsmax "Max stabilizer output signal (pu)";
            parameter Real vsmin "Min stabilizer output signal (pu)";
            parameter Real Kw "Stabilizer gain (pu/pu)";
            parameter Real Tw "Wash-out time constant (s)";
            parameter Real T1 "First stabilizer time constant (s)";
            parameter Real T2 "Second stabilizer time constant (s)";
            parameter Real T3 "Third stabilizer time constant (s)";
            parameter Real T4 "Fourth stabilizer time constant (s)";
            Modelica.Blocks.Interfaces.RealInput vSI "PSS input signal "
              annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));
            Modelica.Blocks.Interfaces.RealOutput vs "PSS output signal"
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
            NonElectrical.Continuous.LeadLag imLeadLag(
              K=1,
              T1=T1,
              T2=T2,
              y_start=0)
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            NonElectrical.Continuous.LeadLag imLeadLag1(
              K=1,
              T1=T3,
              T2=T4,
              y_start=0) annotation (Placement(transformation(extent={{28,-10},{48,10}})));
            Modelica.Blocks.Nonlinear.Limiter limiter(uMax=vsmax, uMin=vsmin)
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            NonElectrical.Continuous.DerivativeLag derivativeLag(
              K=Kw*Tw,
              T=Tw,
              y_start=0,
              x_start=0)
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(vs, limiter.y)
              annotation (Line(points={{110,0},{96,0},{81,0}}, color={0,0,127}));
            connect(imLeadLag1.y, limiter.u)
              annotation (Line(points={{49,0},{53.5,0},{58,0}}, color={0,0,127}));
            connect(imLeadLag.y, imLeadLag1.u)
              annotation (Line(points={{11,0},{26,0}}, color={0,0,127}));
            connect(vSI, derivativeLag.u)
              annotation (Line(points={{-110,0},{-62,0},{-62,0}}, color={0,0,127}));
            connect(derivativeLag.y, imLeadLag.u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td>PSS Type II, PSAT manual</td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>2015-08-24</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Tin Rabuzin, SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>"));
          end PSSTypeII;
        annotation (Documentation(info="<html>
</html>"));
        end PSS;
      annotation (Documentation);
      end PSAT;
    annotation (Documentation);
    end Controls;

    package Loads

      package PSSE "Load models from PSSE components"

        model Load_ExtInput "PSS/E Load with variation"
          extends OpenIPSL.Electrical.Loads.PSSE.BaseClasses.baseLoad;
          parameter Real d_P "Active Load Variation (pu)";
          parameter Modelica.Units.SI.Time t1 "Time of Load Variation";
          parameter Modelica.Units.SI.Time d_t "Time duration of load variation";
      protected
          parameter Real PF=if q0 == 0 then 1 else p0/q0;
          parameter Real d_Q=(p0 + d_P)/PF - q0;
      public
          Modelica.Blocks.Interfaces.RealInput u annotation (Placement(transformation(
                  extent={{48,16},{88,56}}), iconTransformation(extent={{-100,36},{-62,
                    74}})));
        equation
          if time >= t1 and time <= t1 + d_t then
            kI*S_I.re*v + S_Y.re*v^2 + kP*(S_P.re + d_P) + u = p.vr*p.ir + p.vi*p.ii;
            kI*S_I.im*v + S_Y.im*v^2 + kP*(S_P.im + d_Q) = (-p.vr*p.ii) + p.vi*p.ir;
          else
            kI*S_I.re*v + S_Y.re*v^2 + kP*S_P.re + u = p.vr*p.ir + p.vi*p.ii;
            kI*S_I.im*v + S_Y.im*v^2 + kP*S_P.im = (-p.vr*p.ii) + p.vi*p.ir;
          end if;
          annotation (
            Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                initialScale=0.05)),
            Documentation(info="<html>
<table cellspacing=\"1\" cellpadding=\"1\" border=\"1\">
<tr>
<td><p>Reference</p></td>
<td>PSS/E Manual</td>
</tr>
<tr>
<td><p>Last update</p></td>
<td>Unknown</td>
</tr>
<tr>
<td><p>Author</p></td>
<td><p>Mengjia Zhang,SmarTS Lab, KTH Royal Institute of Technology</p></td>
</tr>
<tr>
<td><p>Contact</p></td>
<td><p><a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p></td>
</tr>
</table>
</html>",         revisions="<html>
<!--DISCLAIMER-->
<p>OpenIPSL:</p>
<p>Copyright 2016 SmarTS Lab (Sweden)</p>
<ul>
<li>SmarTS Lab, research group at KTH: <a href=\"https://www.kth.se/en\">https://www.kth.se/en</a></li>
</ul>
<p>The authors can be contacted by email: <a href=\"mailto:luigiv@kth.se\">luigiv@kth.se</a></p>

<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. </p>
<p>If a copy of the MPL was not distributed with this file, You can obtain one at <a href=\"http://mozilla.org/MPL/2.0/\"> http://mozilla.org/MPL/2.0</a>.</p>

<p></p>
<p>iPSL:</p>
<p>Copyright 2015-2016 RTE (France), SmarTS Lab (Sweden), AIA (Spain) and DTU (Denmark)</p>
<ul>
<li>RTE: <a href=\"http://www.rte-france.com\">http://www.rte-france.com</a></li>
<li>SmarTS Lab, research group at KTH: <a href=\"https://www.kth.se/en\">https://www.kth.se/en</a></li>
<li>AIA: <a href=\"http://www.aia.es/en/energy\"> http://www.aia.es/en/energy</a></li>
<li>DTU: <a href=\"http://www.dtu.dk/english\"> http://www.dtu.dk/english</a></li>
</ul>
<p>The authors can be contacted by email: <a href=\"mailto:info@itesla-ipsl.org\">info@itesla-ipsl.org</a></p>

<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. </p>
<p>If a copy of the MPL was not distributed with this file, You can obtain one at <a href=\"http://mozilla.org/MPL/2.0/\"> http://mozilla.org/MPL/2.0</a>.</p>
</html>
"),         Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                initialScale=0.05)));
        end Load_ExtInput;

        package BaseClasses

          partial model baseLoad
            import Modelica.Constants.pi;
            import Modelica.ComplexMath.j;
            extends OpenIPSL.Electrical.Essentials.pfComponent;
            parameter Complex S_p=P_0 + j*Q_0
              "Consumption of original constant power load (MVA)";
            parameter Complex S_i=0 + j*0
              "Consumption of original constant current load (MVA)";
            parameter Complex S_y=0 + j*0
              "Consumption of original constant shunt admittance load (MVA)";
            parameter Complex a=1 + j*0
              "Load transfer fraction for constant current load";
            parameter Complex b=0 + j*1
              "Load transfer fraction for constant shunt admittance load";
            parameter Real PQBRAK=0.7 "Constant power characteristic threshold";
            parameter Integer characteristic=1 annotation (choices(choice=1, choice=2));
            OpenIPSL.Interfaces.PwPin p(
              vr(start=vr0),
              vi(start=vi0),
              ir(start=ir0),
              ii(start=ii0))
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            Modelica.Units.SI.Angle angle(start=anglev_rad) "Bus voltage angle";
            Real v(start=V_0) "Bus voltage magnitude (pu)";
            Real P "Active power consumption (pu)";
            Real Q "Reactive power consumption (pu)";
        protected
            parameter Modelica.Units.SI.Angle anglev_rad=angle_0*pi/180;
            parameter Real p0=(S_i.re*V_0 + S_y.re*V_0^2 + S_p.re)/S_b "pu";
            parameter Real q0=(S_i.im*V_0 + S_y.im*V_0^2 + S_p.im)/S_b "pu";
            parameter Real vr0=V_0*cos(anglev_rad) "Initialitation";
            parameter Real vi0=V_0*sin(anglev_rad) "Initialitation";
            parameter Real ir0=(p0*vr0 + q0*vi0)/(vr0^2 + vi0^2) "Initialitation";
            parameter Real ii0=(p0*vi0 - q0*vr0)/(vr0^2 + vi0^2) "Initialitation";
            parameter Complex S_P=Complex((1 - a.re - b.re)*S_p.re, (1 - a.im - b.im)*S_p.im)
                /S_b "pu";
            parameter Complex S_I=(S_i + Complex(a.re*S_p.re/V_0, a.im*S_p.im/V_0))/S_b
              "pu";
            parameter Complex S_Y=(S_y + Complex(b.re*S_p.re/V_0^2, b.im*S_p.im/V_0^2))/
                S_b "pu";
            //Constant current load vary function when voltage is below 0.5
            parameter Real a2=1.502;
            parameter Real b2=1.769;
            //Constant Power load vary function when voltage is below 0.5
            parameter Real a0=0.4881;
            parameter Real a1=-0.4999;
            parameter Real b1=0.1389;
            parameter Real wp=3.964;
        protected
            Real kP(start=1);
            Real kI(start=1);
          equation
            P = p.vr*p.ir + p.vi*p.ii;
            Q = (-p.vr*p.ii) + p.vi*p.ir;
            angle = atan2(p.vi, p.vr);
            v = sqrt(p.vr^2 + p.vi^2);
            //Voltage dependancy characteristic
            if characteristic == 1 then
              if v < PQBRAK/2 and v > 0 then
                kP = 2*(v/PQBRAK)^2;
                kI = 1;
              elseif v > PQBRAK/2 and v < PQBRAK then
                kP = 1 - 2*((v - PQBRAK)/PQBRAK)^2;
                kI = 1;
              else
                kP = 1;
                kI = 1;
              end if;
            else
              if v < PQBRAK then
                kP = a0 + a1*cos(v*wp) + b1*sin(v*wp);
              else
                kP = 1;
              end if;
              if v < 0.5 then
                kI = a2*b2*v^(b2 - 1)*exp(-a2*v^b2);
              else
                kI = 1;
              end if;
            end if;
            annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}},
                  initialScale=0.1), graphics={Line(points={{-100,100},{100,100},{0,-100},
                    {-100,100}}, color={28,108,200}),Text(
                    extent={{-60,80},{60,40}},
                    lineColor={28,108,200},
                    textString="%P_0+j%Q_0"),Text(
                    extent={{-150,-110},{150,-150}},
                    lineColor={0,0,255},
                    textString="%name")}), Documentation);
          end baseLoad;
        annotation (Documentation);
        end BaseClasses;
      annotation (Documentation);
      end PSSE;
    annotation (Documentation);
    end Loads;

    package Events

      model PwFault "Transitory short-circuit on a node. Shunt impedance connected only during a specified interval of time.
              Developed by AIA. 2014/12/16"
        OpenIPSL.Interfaces.PwPin p annotation (Placement(transformation(extent={{-80,
                  -10},{-60,10}}), iconTransformation(extent={{-80,-10},{-60,10}})));
        parameter Real R "Resistance (pu)";
        parameter Real X "Reactance (pu)";
        parameter Real t1 "Start time of the fault (s)";
        parameter Real t2 "End time of the fault (s)";
        import Modelica.Constants.eps;
    protected
        parameter Boolean ground=abs(R) < eps and abs(X) < eps;
      equation
        if time < t1 then
          p.ii = 0;
          p.ir = 0;
        elseif time < t2 and ground then
          p.vr = 1E-10;
          // This is to avoid numerical problems
          p.vi = 0;
        elseif time < t2 then
          p.ii = (R*p.vi - X*p.vr)/(X*X + R*R);
          p.ir = (R*p.vr + X*p.vi)/(R*R + X*X);
        else
          p.ii = 0;
          p.ir = 0;
        end if;
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-60,-60},{60,60}},
              initialScale=0.1), graphics={Rectangle(extent={{-60,60},{60,-60}},
                lineColor={0,0,255}),Rectangle(
                extent={{-28,26},{12,6}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),Line(
                points={{12,16},{26,16},{26,-24}},
                color={0,0,255},
                smooth=Smooth.None),Line(
                points={{14,-24},{38,-24}},
                color={0,0,255},
                smooth=Smooth.None),Line(
                points={{16,-28},{36,-28}},
                color={0,0,255},
                smooth=Smooth.None),Line(
                points={{20,-32},{34,-32}},
                color={0,0,255},
                smooth=Smooth.None),Line(
                points={{22,-36},{30,-36}},
                color={0,0,255},
                smooth=Smooth.None),Rectangle(
                extent={{-38,18},{-28,14}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),Line(
                points={{-12,34},{-4,16},{-18,16},{-6,-6}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),Line(
                points={{-12,-4},{-6,-6},{-6,0}},
                color={255,0,0},
                smooth=Smooth.None),Text(
                extent={{-110,110},{110,70}},
                lineColor={0,0,255},
                textString="%name")}),
          Diagram(coordinateSystem(
              extent={{-60,-60},{60,60}},
              preserveAspectRatio=true,
              initialScale=0.1), graphics),
          Documentation);
      end PwFault;
    annotation (Documentation);
    end Events;

    package Essentials

      partial model pfComponent
        "Partial model containing all the Data for entering power flow data"
        outer OpenIPSL.Electrical.SystemBase SysData
          "Must add this line in all models";
        parameter OpenIPSL.Types.VoltageKilo V_b=400 "Base voltage of the bus"
          annotation (Dialog(group="Power flow data"));
        parameter Modelica.Units.SI.PerUnit V_0=1 "Voltage magnitude (pu)"
          annotation (Dialog(group="Power flow data"));
        parameter Modelica.Units.NonSI.Angle_deg angle_0=0 "Voltage angle"
          annotation (Dialog(group="Power flow data"));
        parameter OpenIPSL.Types.ActivePowerMega P_0=1 "Active power"
          annotation (Dialog(group="Power flow data"));
        parameter OpenIPSL.Types.ReactivePowerMega Q_0=0 "Reactive power"
          annotation (Dialog(group="Power flow data"));
        parameter OpenIPSL.Types.ApparentPowerMega S_b=SysData.S_b
          "System base power"
          annotation (Dialog(group="Power flow data", enable=false));
        parameter Modelica.Units.SI.Frequency fn=SysData.fn "System Frequeny"
          annotation (Dialog(group="Power flow data", enable=false));
        annotation (Documentation);
      end pfComponent;
    annotation (Documentation);
    end Essentials;
  annotation (Documentation);
  end Electrical;

  package NonElectrical

    package Continuous

      block DerivativeLag "Derivative lag transfer function blcok"
        extends Modelica.Blocks.Interfaces.SISO;
        parameter Real K "Gain";
        parameter Modelica.Units.SI.Time T "Time constan (s)";
        parameter Real y_start "Output start value"
          annotation (Dialog(group="Initialization"));
        parameter Real x_start=0 "Start value of state variable"
          annotation (Dialog(group="Initialization"));
        Modelica.Blocks.Sources.RealExpression par1(y=T)
          annotation (Placement(transformation(extent={{-80,54},{-60,74}})));
        Modelica.Blocks.Continuous.TransferFunction TF(
          initType=Modelica.Blocks.Types.Init.InitialOutput,
          x_start={x_start},
          b={K_dummy,0},
          y_start=y_start,
          a={T_dummy,1})
          annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
    protected
        parameter Modelica.Units.SI.Time T_dummy=if abs(T) < Modelica.Constants.eps
             then 1000 else T "Lead time constant";
        parameter Modelica.Units.SI.Time K_dummy=if abs(K) < Modelica.Constants.eps
             then 1 else K "Lead time constant";
      equation
        if abs(par1.y) < Modelica.Constants.eps then
          y = u;
        else
          y = TF.y;
        end if;
        connect(TF.u, u)
          annotation (Line(points={{-10,0},{-120,0}}, color={0,0,127}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}})),
          Documentation,
          Icon(graphics={Text(
                extent={{-60,82},{60,22}},
                lineColor={0,0,255},
                textString="Ks"),Line(
                points={{-62,0},{66,0}},
                color={0,0,255},
                smooth=Smooth.Bezier,
                thickness=0.5),Text(
                extent={{-60,-20},{60,-80}},
                lineColor={0,0,255},
                textString="1+sT")}));
      end DerivativeLag;

      block LeadLag "Lead-Lag filter"
        extends Modelica.Blocks.Interfaces.SISO;
        parameter Real K "Gain";
        parameter Modelica.Units.SI.Time T1 "Lead time constant";
        parameter Modelica.Units.SI.Time T2 "Lag time constant";
        parameter Real y_start "Output start value"
          annotation (Dialog(group="Initialization"));
        parameter Real x_start=0 "Start value of state variable"
          annotation (Dialog(group="Initialization"));
        Modelica.Blocks.Sources.RealExpression par1(y=T1)
          annotation (Placement(transformation(extent={{-80,54},{-60,74}})));
        Modelica.Blocks.Sources.RealExpression par2(y=T2)
          annotation (Placement(transformation(extent={{-80,34},{-60,54}})));
        Modelica.Blocks.Continuous.TransferFunction TF(
          b={K*T1,K},
          a={T2_dummy,1},
          y_start=y_start,
          initType=Modelica.Blocks.Types.Init.InitialOutput,
          x_start={x_start})
          annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
    protected
        parameter Modelica.Units.SI.Time T2_dummy=if abs(T1 - T2) < Modelica.Constants.eps
             then 1000 else T2 "Lead time constant";
      equation
        if abs(par1.y - par2.y) < Modelica.Constants.eps then
          y = K*u;
        else
          y = TF.y;
        end if;
        connect(TF.u, u)
          annotation (Line(points={{-10,0},{-120,0}}, color={0,0,127}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}})),
          Documentation,
          Icon(graphics={Text(
                extent={{-44,82},{76,22}},
                lineColor={0,0,255},
                textString="1+sT"),Line(
                points={{-46,0},{82,0}},
                color={0,0,255},
                smooth=Smooth.Bezier,
                thickness=0.5),Text(
                extent={{-44,-20},{76,-80}},
                lineColor={0,0,255},
                textString="1+sT"),Text(
                extent={{-100,28},{-40,-32}},
                lineColor={0,0,255},
                textString="K"),Text(
                extent={{62,44},{82,24}},
                lineColor={0,0,255},
                textString="1"),Text(
                extent={{64,-58},{84,-78}},
                lineColor={0,0,255},
                textString="2")}));
      end LeadLag;
    annotation (Documentation(info="<html>

All of the transfer functions found in this package are also available in the Modelica Standard Library (MSL). However, some of the models require the time constants of the functions in this package to be set to zero. This is not supported by MSL and, thus, this is supported by functions in this package.

</html>"));
    end Continuous;
  annotation (Documentation);
  end NonElectrical;

  package Interfaces "Package for interface models used in this library. "
  extends Modelica.Icons.InterfacesPackage;

    connector PwPin
      "Connector for electrical blocks treating voltage and current as complex variables"
      Real vr "Real part of the voltage";
      Real vi "Imaginary part of the voltage";
      flow Real ir "Real part of the current";
      flow Real ii "Imaginary part of the current";
      annotation (
        Icon(graphics={Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={Text(
              extent={{-100,160},{100,120}},
              lineColor={0,0,255},
              textString="%name"),Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,255},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid)}),
        Documentation);
    end PwPin;
  annotation (Documentation);
  end Interfaces;

  package Types "Collection of special types used in OpenIPSL"
  extends Modelica.Icons.TypesPackage;

    type ActivePowerMega = Real (final quantity="Power", final unit="MW")
      annotation (Documentation);

    type ApparentPowerMega = Real (final quantity="Power", final unit="MVA")
      annotation (Documentation);

    type ReactivePowerMega = Real (final quantity="Power", final unit="Mvar")
      annotation (Documentation);

    type VoltageKilo = Real (final quantity="ElectricPotential", final unit="kV")
      annotation (Documentation);
  annotation (Documentation);
  end Types;
annotation (
  uses(Modelica(version="4.0.0"), Complex(version="4.0.0")),
  version="1.5.0",
  conversion(noneFromVersion={"0.8","0.8.1","1.0.0"}),
  Documentation,
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
      graphics={Bitmap(extent={{-100,-100},{100,100}}, fileName=
            "modelica://OpenIPSL/Resources/Images/OpenIPSL_Logo.png")}));
end OpenIPSL;

package Luigi_eFMI_Test
  extends .DymolaEmbedded.EmbeddedConfiguration(model_configuration(model_name=
        "Luigi_eFMI_Test.PSSTypeII_Parameterized"),
      integrator_configuration(sample_period=0.001, solver_method=
          DymolaEmbedded.BuildUtilities.AlgorithmCode.Integrator.SolverMethod.Explicit_Euler),
  dymola_production_code_configuration(active=true, includes={
        "modelica://Luigi_eFMI_Test/Resources/"}));

  model PSSTypeII_Parameterized
    extends .OpenIPSL.Electrical.Controls.PSAT.PSS.PSSTypeII(
      vSI(start = vSI_start),
      Kw = 9.5,
      T1 = 0.154,
      T2 = 0.033,
      T3 = 1,
      T4 = 1,
      Tw = 1.41,
      vsmax = 0.2,
      vsmin = -0.2);
    extends .Modelica.Blocks.Icons.Block;

    parameter Real vSI_start = 1.0
      "Default start value for vSI, the PSS input signal.";
  end PSSTypeII_Parameterized;

  package OpenLoopTests
    extends .Modelica.Icons.ExamplesPackage;

    partial model BaseSetup
      extends .Modelica.Icons.Example;

      replaceable Modelica.Blocks.Interfaces.SignalSource stimulus
        annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
      final
      Modelica.Clocked.ClockSignals.Clocks.PeriodicRealClock clock(
        period=0.001,
        useSolver=true,
        solverMethod="ExplicitEuler")
        annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
      Modelica.Clocked.RealSignals.Sampler.SampleClocked vSI
        annotation (Placement(transformation(extent={{-46,-6},{-34,6}})));
      Modelica.Clocked.RealSignals.Sampler.Hold vs
        annotation (Placement(transformation(extent={{34,-6},{46,6}})));
      replaceable PSSTypeII_Parameterized controller
        annotation (Placement(transformation(extent={{-20,-20},{20,20}})));
    equation
      connect(clock.y, vSI.clock) annotation (Line(
          points={{-59,-50},{-40,-50},{-40,-7.2}},
          color={175,175,175},
          pattern=LinePattern.Dot,
          thickness=0.5));
      connect(stimulus.y, vSI.u)
        annotation (Line(points={{-59,0},{-47.2,0}}, color={0,0,127}));
      connect(vSI.y, controller.vSI)
        annotation (Line(points={{-33.4,0},{-22,0}}, color={0,0,127}));
      connect(controller.vs, vs.u)
        annotation (Line(points={{22,0},{32.8,0}}, color={0,0,127}));
    end BaseSetup;

    package Sine
      model Synchronous
        extends BaseSetup(
          redeclare .Modelica.Blocks.Sources.Sine stimulus(
            amplitude = 0.00001,
            f = 1));
      end Synchronous;

      model eFMI
        extends Synchronous(
          redeclare 'Luigi_eFMI_Test.eFMU_SiL_Support'.BinaryStub controller(
            __embedd_clock = false));
      end eFMI;

      model LegacyDymolaEmbeddedC
        extends Synchronous(
          redeclare 'Luigi_eFMI_Test.eFMU_Stub' controller);
      end LegacyDymolaEmbeddedC;
    end Sine;

    package Cosine

      model Synchronous
        extends BaseSetup(
          redeclare .Modelica.Blocks.Sources.Cosine stimulus(
            amplitude = 0.00001,
            f = 1));
      end Synchronous;

      model eFMI
        extends Synchronous(
          redeclare 'Luigi_eFMI_Test.eFMU_SiL_Support'.BinaryStub controller(
            __embedd_clock = false));
      end eFMI;

      model LegacyDymolaEmbeddedC
        extends Synchronous(
          redeclare 'Luigi_eFMI_Test.eFMU_Stub' controller);
      end LegacyDymolaEmbeddedC;
    end Cosine;
  end OpenLoopTests;

  package ClosedLoopTests
    extends .Modelica.Icons.ExamplesPackage;
    model Continuous
      extends .SMIBPS_IdControl.Analysis.Simulation.SMIB_AVR_PSS;
    end Continuous;

    model eFMI
      extends Continuous(
        G1(
          redeclare 'Luigi_eFMI_Test.eFMU_SiL_Support'.BinaryStub pss));
    end eFMI;
  end ClosedLoopTests;
  annotation (
    uses(
      Modelica(version="4.0.0"),
      OpenIPSL(version="1.5.0"),
      SMIBPS_IdControl(version="1")));
end Luigi_eFMI_Test;
