/*
	eFMI GALEC program generated by:
	  Dymola Version 2026x Refresh 1 Dev 3, 2026-01-23
	Generation date (xs:dateTime):
	  2026-01-14T21:37:20Z
*/
block 'PSSDesign.eFMU4CHIL.Grid4CHILTesting'
/* *******************************************************************************************************************************
	Block-interface entities:
******************************************************************************************************************************* */

	/* ********************************************************************************************************** Block inputs: */
	input Boolean fault;
	input Real vf;

	/* ********************************************************************************************************* Block outputs: */
	output Real Pgen;
	output Real Qgen;
	output Real v;
	output Real vf0OUT;
	output Real w;

	/* **************************************************************************************************** Tunable parameters: */
	parameter Real K0;

/* *******************************************************************************************************************************
	Block-local entities and functions:
******************************************************************************************************************************* */
protected
	/* B3.p: */
	Real 'B3.p.vi';
	Real 'B3.p.vr';

	/* G1: */
	constant Real 'G1.P_0';
	constant Real 'G1.Q_0';
	constant Real 'G1.V_b';
	constant Real 'G1.angle_0';
	constant Real 'G1.v_0';
	parameter Real 'G1.K0';
	parameter Real 'G1.S_b';

	/* G1.avr: */
	constant Real 'G1.avr.T1';
	constant Real 'G1.avr.T2';
	constant Real 'G1.avr.Te';
	constant Real 'G1.avr.Tr';
	constant Real 'G1.avr.vfmax';
	constant Real 'G1.avr.vfmin';
	parameter Real 'G1.avr.K0';
	parameter Real 'G1.avr.s0';
	parameter Real 'G1.avr.vref';
	Real 'derivative(G1.avr.vf1)';
	Real 'derivative(G1.avr.vm)';
	Real 'derivative(G1.avr.vr)';
	Real 'G1.avr.vf1';
	Real 'G1.avr.vm';
	Real 'G1.avr.vr';

	/* G1.avr.limiter1: */
	parameter Real 'G1.avr.limiter1.uMax';
	parameter Real 'G1.avr.limiter1.uMin';

	/* G1.machine: */
	constant Real 'G1.machine.M';
	constant Real 'G1.machine.Sn';
	constant Real 'G1.machine.T1d0';
	constant Real 'G1.machine.T1q0';
	constant Real 'G1.machine.T2d0';
	constant Real 'G1.machine.T2q0';
	constant Real 'G1.machine.Taa';
	constant Real 'G1.machine.Vn';
	constant Real 'G1.machine.ra';
	constant Real 'G1.machine.x1d';
	constant Real 'G1.machine.x1q';
	constant Real 'G1.machine.x2d';
	constant Real 'G1.machine.x2q';
	constant Real 'G1.machine.xd';
	constant Real 'G1.machine.xq';
	parameter Real 'G1.machine.I_MBtoSB';
	parameter Real 'G1.machine.K1';
	parameter Real 'G1.machine.K2';
	parameter Real 'G1.machine.P_0';
	parameter Real 'G1.machine.Q_0';
	parameter Real 'G1.machine.S_SBtoMB';
	parameter Real 'G1.machine.S_b';
	parameter Real 'G1.machine.V_MBtoSB';
	parameter Real 'G1.machine.V_b';
	parameter Real 'G1.machine.Z_MBtoSB';
	parameter Real 'G1.machine.angle_0';
	parameter Real 'G1.machine.delta0';
	parameter Real 'G1.machine.e1q0';
	parameter Real 'G1.machine.e2q0';
	parameter Real 'G1.machine.fn';
	parameter Real 'G1.machine.id0';
	parameter Real 'G1.machine.iq0';
	parameter Real 'G1.machine.p0';
	parameter Real 'G1.machine.pm00';
	parameter Real 'G1.machine.q0';
	parameter Real 'G1.machine.v_0';
	parameter Real 'G1.machine.vd0';
	parameter Real 'G1.machine.vf00';
	parameter Real 'G1.machine.vq0';
	parameter Real 'G1.machine.w_b';
	parameter Real 'G1.machine.xq0';
	Real 'derivative(G1.machine.delta)';
	Real 'derivative(G1.machine.e1d)';
	Real 'derivative(G1.machine.e1q)';
	Real 'derivative(G1.machine.e2d)';
	Real 'derivative(G1.machine.e2q)';
	Real 'derivative(G1.machine.w)';
	Real 'G1.machine.delta';
	Real 'G1.machine.e1d';
	Real 'G1.machine.e1q';
	Real 'G1.machine.e2d';
	Real 'G1.machine.e2q';
	Real 'G1.machine.id';
	Real 'G1.machine.iq';
	Real 'G1.machine.w';

	/* G1.machine.I0: */
	parameter Real 'G1.machine.I0.im';
	parameter Real 'G1.machine.I0.re';

	/* G1.machine.Idq0: */
	parameter Real 'G1.machine.Idq0.im';
	parameter Real 'G1.machine.Idq0.re';

	/* G1.machine.S0: */
	parameter Real 'G1.machine.S0.im';
	parameter Real 'G1.machine.S0.re';

	/* G1.machine.Vdq0: */
	parameter Real 'G1.machine.Vdq0.im';
	parameter Real 'G1.machine.Vdq0.re';

	/* G1.machine.Vt0: */
	parameter Real 'G1.machine.Vt0.im';
	parameter Real 'G1.machine.Vt0.re';

	/* G1.machine.auxCMval: */
	parameter Real 'G1.machine.auxCMval.im';
	parameter Real 'G1.machine.auxCMval.re';

	/* L1: */
	constant Real 'L1.B';
	constant Real 'L1.G';
	constant Real 'L1.R';
	constant Real 'L1.X';

	/* L1.Y: */
	parameter Real 'L1.Y.im';
	parameter Real 'L1.Y.re';

	/* L1.Z: */
	parameter Real 'L1.Z.im';
	parameter Real 'L1.Z.re';

	/* L2: */
	constant Real 'L2.B';
	constant Real 'L2.G';
	constant Real 'L2.R';
	constant Real 'L2.X';

	/* L2.Y: */
	parameter Real 'L2.Y.im';
	parameter Real 'L2.Y.re';

	/* L2.Z: */
	parameter Real 'L2.Z.im';
	parameter Real 'L2.Z.re';

	/* L2.p: */
	Real 'L2.p.ii';
	Real 'L2.p.ir';

	/* SysData: */
	constant Real 'SysData.S_b';
	constant Real 'SysData.fn';

	/* infiniteBus: */
	constant Real 'infiniteBus.angle_0';
	constant Real 'infiniteBus.v_0';

	/* transformer: */
	constant Real 'transformer.Sn';
	constant Real 'transformer.V_b';
	constant Real 'transformer.Vn';
	constant Real 'transformer.m';
	constant Real 'transformer.rT';
	constant Real 'transformer.xT';
	parameter Real 'transformer.S_b';
	parameter Real 'transformer.Zb';
	parameter Real 'transformer.Zn';
	parameter Real 'transformer.r';
	parameter Real 'transformer.x';

	/* transformer.n: */
	Real 'transformer.n.ii';
	Real 'transformer.n.ir';

	/* Internal sampling time: */
	constant Real 'discrete.stepSize';
	Boolean 'discrete.stepSize.active';

	/* ****************************************************************************************** User-defined local functions: */
	/*
		State initialization function: Called to (re)-initialize states and outputs
		  considering the current parametrization and inputs.
	*/
	method Reinitialize
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
		Boolean DymolaConvertInputToREAL0;
		Real DymolaConvertInputToReal0;

		/* B1.p: */
		Real 'B1.p.vi';
		Real 'B1.p.vr';

		/* G1.machine: */
		Real 'G1.machine.vd';
		Real 'G1.machine.vq';

		/* Internal work-buffers for solutions of linear systems of equations: */
		Real 'solution_buffer.for.x[6]'[ 6 ];

	algorithm
		/*
			Initialize variables without explicit start value or equation (implicit initializations):
		*/
		self.'derivative(G1.avr.vm)' := 0.0;
		self.'derivative(G1.avr.vr)' := 0.0;
		self.'derivative(G1.avr.vf1)' := 0.0;
		self.'derivative(G1.machine.e1q)' := 0.0;
		self.'derivative(G1.machine.e2q)' := 0.0;
		self.'derivative(G1.machine.w)' := 0.0;
		self.'derivative(G1.machine.delta)' := 0.0;
		self.Pgen := 0.0;
		self.Qgen := 0.0;
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.'G1.machine.e1q' := self.'G1.machine.e1q0';
		self.'G1.machine.e2q' := self.'G1.machine.e2q0';
		self.'G1.machine.w' := 1.0;
		self.w := 1.0;
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		self.'derivative(G1.machine.e1d)' := 0.0;
		self.'derivative(G1.machine.e2d)' := 0.0;
		self.'G1.machine.delta' := self.'G1.machine.delta0';
		DymolaConvertInputToReal0 := (if self.fault then 2.0 else 0.0);
		DymolaConvertInputToREAL0 := (DymolaConvertInputToReal0 > 1);
		/* Solve linear system of equations A*x = b: */
		'solution_buffer.for.x[6]' := solveLinearEquations(
			/* A matrix: */
			{
				/* Row 1: */
				{ (self.'transformer.r' / self.'transformer.m'), (-1.0 * ((self.'transformer.x' / self.'transformer.m'))), 0.0, 0.0, (((self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d') + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra'))) + (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T1q0') - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) + ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T2q0')) + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) + (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) - (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) },
				/* Row 2: */
				{ (self.'transformer.x' / self.'transformer.m'), (self.'transformer.r' / self.'transformer.m'), 0.0, 0.0, ((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra') - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) + (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) - (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))), (((self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T1q0')) + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T2q0')) + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q'))) + (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) },
				/* Row 3: */
				{ ((((((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))) * self.'transformer.x') + ((1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))) * self.'transformer.r')) + self.'L1.Z.re'), ((((((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))) * self.'transformer.r') - ((1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))) * self.'transformer.x')) - self.'L1.Z.im'), (-1.0 * self.'L1.Z.im'), self.'L1.Z.re', (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) * self.'G1.machine.x2d') + ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * self.'G1.machine.ra')) / self.'transformer.m'))), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) * self.'G1.machine.ra') / self.'transformer.m')) + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * self.'G1.machine.x2q') / self.'transformer.m')) },
				/* Row 4: */
				{ ((((1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))) * self.'transformer.x') + ((((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')) * self.'transformer.r')) + self.'L1.Z.im'), ((((1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))) * self.'transformer.r') - ((((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')) * self.'transformer.x')) + self.'L1.Z.re'), self.'L1.Z.re', self.'L1.Z.im', (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) * self.'G1.machine.x2d') + ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * self.'G1.machine.ra')) / self.'transformer.m'))), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) * self.'G1.machine.ra') / self.'transformer.m')) + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * self.'G1.machine.x2q') / self.'transformer.m')) },
				/* Row 5: */
				{ (((1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))) * self.'transformer.r') - (((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')) * self.'transformer.x')), (-1.0 * (((((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')) * self.'transformer.r') + ((1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))) * self.'transformer.x')))), self.'L2.Z.im', (-1.0 * (self.'L2.Z.re')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.x2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * self.'G1.machine.ra')) / self.'transformer.m'))), (((((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.ra') / self.'transformer.m')) + ((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * self.'G1.machine.x2q') / self.'transformer.m')) },
				/* Row 6: */
				{ (((1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))) * self.'transformer.x') + (((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')) * self.'transformer.r')), (((1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))) * self.'transformer.r') - (((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')) * self.'transformer.x')), (-1.0 * (self.'L2.Z.re')), (-1.0 * (self.'L2.Z.im')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.x2d') + ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * self.'G1.machine.ra')) / self.'transformer.m'))), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.ra') / self.'transformer.m')) + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * self.'G1.machine.x2q') / self.'transformer.m')) }
			},
			/* b vector: */
			{ (-1.0 * ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q'))), (-1.0 * ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q'))), (self.'B3.p.vr' - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vi' - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vr' - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vi' - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * self.'G1.machine.e2q') / self.'transformer.m')) });
		if signal in SOLVE_LINEAR_EQUATIONS_FAILED then
			/* Set states to default start-values and propagate error: */
			self.'transformer.n.ir' := 2.22044604925031308e-16;
			self.'transformer.n.ii' := 2.22044604925031308e-16;
			self.'L2.p.ii' := 2.22044604925031308e-16;
			self.'L2.p.ir' := 2.22044604925031308e-16;
			self.'G1.machine.id' := self.'G1.machine.id0';
			self.'G1.machine.iq' := self.'G1.machine.iq0';
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed states: */
			self.'transformer.n.ir' := 'solution_buffer.for.x[6]'[1];
			self.'transformer.n.ii' := 'solution_buffer.for.x[6]'[2];
			self.'L2.p.ii' := 'solution_buffer.for.x[6]'[3];
			self.'L2.p.ir' := 'solution_buffer.for.x[6]'[4];
			self.'G1.machine.id' := 'solution_buffer.for.x[6]'[5];
			self.'G1.machine.iq' := 'solution_buffer.for.x[6]'[6];
		end if;
		'G1.machine.vq' := (self.'G1.machine.e2q' - ((self.'G1.machine.ra' * self.'G1.machine.iq') + (self.'G1.machine.x2d' * self.'G1.machine.id')));
		self.'G1.machine.e1d' := (((((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq') * self.'G1.machine.T1q0') / self.'G1.machine.T1q0');
		self.'G1.machine.e2d' := (((self.'G1.machine.e1d' + (((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq')) * self.'G1.machine.T2q0') / self.'G1.machine.T2q0');
		'G1.machine.vd' := ((self.'G1.machine.e2d' - (self.'G1.machine.ra' * self.'G1.machine.id')) + (self.'G1.machine.x2q' * self.'G1.machine.iq'));
		'B1.p.vi' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vq') - (cos(self.'G1.machine.delta') * 'G1.machine.vd')));
		'B1.p.vr' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vd') + (cos(self.'G1.machine.delta') * 'G1.machine.vq')));
		self.v := sqrt((('B1.p.vr' ^ 2) + ('B1.p.vi' ^ 2)));
		self.'G1.avr.vref' := self.v;
		self.'G1.avr.s0' := self.vf;
		self.'G1.avr.vf1' := self.'G1.machine.vf00';
		self.'G1.avr.vm' := self.v;
		self.'G1.avr.vr' := ((self.'G1.avr.K0' * (1.0 - (self.'G1.avr.T1' / self.'G1.avr.T2'))) * ((self.'G1.avr.vref' + self.vf) - self.'G1.avr.vm'));
		/* Conduct delta(t) = 0 super-dense time initialization at next sampling:: */
		self.'discrete.stepSize.active' := false;
	end Reinitialize;

/* *******************************************************************************************************************************
	Block-interface functions:
******************************************************************************************************************************* */
public
	/*
		Recalibration function: Called whenever tunable parameters change during operation
		  to recompute the dependent parameters.
	*/
	method Recalibrate
	protected
	algorithm
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		self.'transformer.S_b' := self.'SysData.S_b';
		self.'transformer.Zn' := ((self.'transformer.Vn' ^ 2) / self.'transformer.Sn');
		self.'transformer.Zb' := ((self.'transformer.V_b' ^ 2) / self.'transformer.S_b');
		self.'transformer.r' := ((self.'transformer.rT' * self.'transformer.Zn') / self.'transformer.Zb');
		self.'transformer.x' := ((self.'transformer.xT' * self.'transformer.Zn') / self.'transformer.Zb');
		self.'L1.Y.re' := self.'L1.G';
		self.'L1.Y.im' := self.'L1.B';
		self.'L1.Z.re' := self.'L1.R';
		self.'L1.Z.im' := self.'L1.X';
		self.'L2.Y.re' := self.'L2.G';
		self.'L2.Y.im' := self.'L2.B';
		self.'L2.Z.re' := self.'L2.R';
		self.'L2.Z.im' := self.'L2.X';
		self.'G1.S_b' := self.'SysData.S_b';
		self.'G1.machine.S_b' := self.'SysData.S_b';
		self.'G1.machine.V_b' := self.'G1.V_b';
		self.'G1.machine.fn' := self.'SysData.fn';
		self.'G1.machine.P_0' := self.'G1.P_0';
		self.'G1.machine.Q_0' := self.'G1.Q_0';
		self.'G1.machine.v_0' := self.'G1.v_0';
		self.'G1.machine.angle_0' := self.'G1.angle_0';
		self.'G1.machine.w_b' := (6.28318530717958623 * self.'G1.machine.fn');
		self.'G1.machine.S_SBtoMB' := (self.'G1.machine.S_b' / self.'G1.machine.Sn');
		self.'G1.machine.I_MBtoSB' := ((self.'G1.machine.Sn' * self.'G1.machine.V_b') / (self.'G1.machine.S_b' * self.'G1.machine.Vn'));
		self.'G1.machine.V_MBtoSB' := (self.'G1.machine.Vn' / self.'G1.machine.V_b');
		self.'G1.machine.Z_MBtoSB' := ((self.'G1.machine.S_b' * (self.'G1.machine.Vn' ^ 2)) / (self.'G1.machine.Sn' * (self.'G1.machine.V_b' ^ 2)));
		self.'G1.machine.p0' := (self.'G1.machine.P_0' / self.'G1.machine.S_b');
		self.'G1.machine.q0' := (self.'G1.machine.Q_0' / self.'G1.machine.S_b');
		self.'G1.machine.Vt0.re' := (self.'G1.machine.v_0' * cos(self.'G1.machine.angle_0'));
		self.'G1.machine.Vt0.im' := (self.'G1.machine.v_0' * sin(self.'G1.machine.angle_0'));
		self.'G1.machine.S0.re' := self.'G1.machine.p0';
		self.'G1.machine.S0.im' := (-1.0 * (self.'G1.machine.q0'));
		self.'G1.machine.I0.re' := (((self.'G1.machine.S0.re' * self.'G1.machine.Vt0.re') - (self.'G1.machine.S0.im' * self.'G1.machine.Vt0.im')) / ((self.'G1.machine.Vt0.re' * self.'G1.machine.Vt0.re') + (self.'G1.machine.Vt0.im' * self.'G1.machine.Vt0.im')));
		self.'G1.machine.I0.im' := (((self.'G1.machine.S0.re' * self.'G1.machine.Vt0.im') + (self.'G1.machine.S0.im' * self.'G1.machine.Vt0.re')) / ((self.'G1.machine.Vt0.re' * self.'G1.machine.Vt0.re') + (self.'G1.machine.Vt0.im' * self.'G1.machine.Vt0.im')));
		self.'G1.machine.xq0' := self.'G1.machine.xq';
		self.'G1.machine.auxCMval.re' := (self.'G1.machine.Vt0.re' + (((self.'G1.machine.ra' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.re') - ((self.'G1.machine.xq0' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.im')));
		self.'G1.machine.auxCMval.im' := (self.'G1.machine.Vt0.im' + (((self.'G1.machine.ra' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.im') + ((self.'G1.machine.xq0' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.re')));
		self.'G1.machine.delta0' := atan2(self.'G1.machine.auxCMval.im', self.'G1.machine.auxCMval.re');
		self.'G1.machine.Vdq0.re' := (((self.'G1.machine.Vt0.re' * cos((1.57079632679489656 - self.'G1.machine.delta0'))) - (self.'G1.machine.Vt0.im' * sin((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.V_MBtoSB');
		self.'G1.machine.Vdq0.im' := (((self.'G1.machine.Vt0.re' * sin((1.57079632679489656 - self.'G1.machine.delta0'))) + (self.'G1.machine.Vt0.im' * cos((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.V_MBtoSB');
		self.'G1.machine.Idq0.re' := (((self.'G1.machine.I0.re' * cos((1.57079632679489656 - self.'G1.machine.delta0'))) - (self.'G1.machine.I0.im' * sin((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.I_MBtoSB');
		self.'G1.machine.Idq0.im' := (((self.'G1.machine.I0.re' * sin((1.57079632679489656 - self.'G1.machine.delta0'))) + (self.'G1.machine.I0.im' * cos((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.I_MBtoSB');
		self.'G1.machine.vd0' := self.'G1.machine.Vdq0.re';
		self.'G1.machine.vq0' := self.'G1.machine.Vdq0.im';
		self.'G1.machine.id0' := self.'G1.machine.Idq0.re';
		self.'G1.machine.iq0' := self.'G1.machine.Idq0.im';
		self.'G1.machine.pm00' := ((((self.'G1.machine.vq0' + (self.'G1.machine.ra' * self.'G1.machine.iq0')) * self.'G1.machine.iq0') + ((self.'G1.machine.vd0' + (self.'G1.machine.ra' * self.'G1.machine.id0')) * self.'G1.machine.id0')) / self.'G1.machine.S_SBtoMB');
		self.'G1.machine.e2q0' := ((self.'G1.machine.vq0' + (self.'G1.machine.ra' * self.'G1.machine.iq0')) + (self.'G1.machine.x2d' * self.'G1.machine.id0'));
		self.'G1.machine.K1' := ((self.'G1.machine.xd' - self.'G1.machine.x1d') - (((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / (self.'G1.machine.T1d0' * self.'G1.machine.x1d')));
		self.'G1.machine.K2' := ((self.'G1.machine.x1d' - self.'G1.machine.x2d') + (((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / (self.'G1.machine.T1d0' * self.'G1.machine.x1d')));
		self.'G1.machine.e1q0' := ((self.'G1.machine.e2q0' + (self.'G1.machine.K2' * self.'G1.machine.id0')) - ((self.'G1.machine.Taa' * (((self.'G1.machine.K1' + self.'G1.machine.K2') * self.'G1.machine.id0') + self.'G1.machine.e2q0')) / self.'G1.machine.T1d0'));
		self.'G1.machine.vf00' := ((self.'G1.machine.V_MBtoSB' * ((self.'G1.machine.K1' * self.'G1.machine.id0') + self.'G1.machine.e1q0')) / (1.0 - (self.'G1.machine.Taa' / self.'G1.machine.T1d0')));
		self.'G1.K0' := self.K0;
		self.'G1.avr.K0' := self.'G1.K0';
		self.'G1.avr.limiter1.uMax' := self.'G1.avr.vfmax';
		self.'G1.avr.limiter1.uMin' := self.'G1.avr.vfmin';
		self.'B3.p.vr' := (self.'infiniteBus.v_0' * cos(self.'infiniteBus.angle_0'));
		self.'B3.p.vi' := (self.'infiniteBus.v_0' * sin(self.'infiniteBus.angle_0'));
		self.vf0OUT := self.'G1.machine.vf00';
	end Recalibrate;

	/*
		Startup function: Called once at startup to default initialize all block-entities.
	*/
	method Startup
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
	algorithm
		/* ********************************************************************************************** Initialize constants: */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.'discrete.stepSize' := 1.00000000000000005e-4;
		self.'transformer.m' := 1.0;
		self.'G1.machine.x2q' := 2.5e-1;
		self.'G1.machine.ra' := 3.00000000000000006e-3;
		self.'G1.machine.x2d' := 2.3000000000000001e-1;
		self.'G1.avr.Tr' := 1.49999999999999994e-2;
		self.'G1.avr.T1' := 1.0;
		self.'G1.avr.T2' := 1.0;
		self.'G1.avr.Te' := 2.99999999999999989e-1;
		self.'G1.machine.Vn' := 4.0e+5;
		self.'G1.machine.Taa' := 2.00000000000000004e-3;
		self.'G1.machine.T1d0' := 8.0;
		self.'G1.machine.xd' := 1.81000000000000005;
		self.'G1.machine.x1d' := 2.99999999999999989e-1;
		self.'G1.machine.T2d0' := 2.99999999999999989e-2;
		self.'G1.machine.M' := 7.0;
		self.'G1.machine.xq' := 1.76000000000000001;
		self.'G1.machine.x1q' := 6.50000000000000022e-1;
		self.'G1.machine.T2q0' := 7.00000000000000067e-2;
		self.'G1.machine.T1q0' := 1.0;
		self.'SysData.S_b' := 1.0e+8;
		self.'infiniteBus.v_0' := 9.0081e-1;
		self.'infiniteBus.angle_0' := 0.0;
		self.'G1.avr.vfmin' := -6.40000000000000036;
		self.'G1.avr.vfmax' := 7.0;
		self.'G1.machine.Sn' := 2.22e+9;
		self.'G1.angle_0' := 4.94677176989159972e-1;
		self.'G1.v_0' := 1.0;
		self.'G1.Q_0' := 9.67924969906579971e+8;
		self.'G1.P_0' := 1.99799999999359989e+9;
		self.'SysData.fn' := 6.0e+1;
		self.'G1.V_b' := 4.0e+5;
		self.'L2.X' := 4.18918918918918942e-2;
		self.'L2.R' := 0.0;
		self.'L2.B' := 0.0;
		self.'L2.G' := 0.0;
		self.'L1.X' := 2.25225225225225215e-2;
		self.'L1.R' := 0.0;
		self.'L1.B' := 0.0;
		self.'L1.G' := 0.0;
		self.'transformer.xT' := 1.49999999999999994e-1;
		self.'transformer.rT' := 0.0;
		self.'transformer.V_b' := 4.0e+5;
		self.'transformer.Vn' := 4.0e+5;
		self.'transformer.Sn' := 2.22e+9;

		/* ******************************************************* Default initialize tuneable parameters (based on constants): */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.K0 := 3.0e+1;

		/* ****************************** Default initialize dependend parameters (based on constants and tuneable parameters): */
		() := Recalibrate();

		/* ***************************************************** Default initialize inputs (based on constants and parameters): */
		/*
			Initialize variables without explicit start value or equation (implicit initializations):
		*/
		self.fault := false;
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.vf := 0.0;

		/* ********************************* Default initialize states and outputs (based on constants, parameters and inputs): */
		() := Reinitialize();
	end Startup;

	/*
		Control-cycle function: Called at each sampling to update internal states and compute
		  block-outputs based on current inputs.
	*/
	method DoStep
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
		Boolean DymolaConvertInputToREAL0;
		Real DymolaConvertInputToReal0;

		/* B1.p: */
		Real 'B1.p.vi';
		Real 'B1.p.vr';

		/* B2.p: */
		Real 'B2.p.vi';
		Real 'B2.p.vr';

		/* G1: */
		Real 'G1.P';
		Real 'G1.Q';

		/* G1.machine: */
		Real 'G1.machine.pe';
		Real 'G1.machine.vd';
		Real 'G1.machine.vf';
		Real 'G1.machine.vf_MB';
		Real 'G1.machine.vq';

		/* L1.p: */
		Real 'L1.p.ii';
		Real 'L1.p.ir';

		/* pwFault4efmi.p: */
		Real 'pwFault4efmi.p.ii';
		Real 'pwFault4efmi.p.ir';

		/* transformer.p: */
		Real 'transformer.p.ii';
		Real 'transformer.p.ir';

		/* Internal work-buffers for solutions of linear systems of equations: */
		Real 'solution_buffer.for.x[6]'[ 6 ];

	algorithm
		if self.'discrete.stepSize.active' then
			/* *********************************************************************** Update-equations for inline integration: */
			self.'G1.avr.vm' := (self.'G1.avr.vm' + (self.'discrete.stepSize' * self.'derivative(G1.avr.vm)'));
			self.'G1.avr.vr' := (self.'G1.avr.vr' + (self.'discrete.stepSize' * self.'derivative(G1.avr.vr)'));
			self.'G1.avr.vf1' := (self.'G1.avr.vf1' + (self.'discrete.stepSize' * self.'derivative(G1.avr.vf1)'));
			self.'G1.machine.e1q' := (self.'G1.machine.e1q' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e1q)'));
			self.'G1.machine.e2q' := (self.'G1.machine.e2q' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e2q)'));
			self.'G1.machine.w' := (self.'G1.machine.w' + (self.'discrete.stepSize' * self.'derivative(G1.machine.w)'));
			self.'G1.machine.delta' := (self.'G1.machine.delta' + (self.'discrete.stepSize' * self.'derivative(G1.machine.delta)'));
			self.'G1.machine.e1d' := (self.'G1.machine.e1d' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e1d)'));
			self.'G1.machine.e2d' := (self.'G1.machine.e2d' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e2d)'));
		end if;

		/* ******************************************************************************************* Inline integration loop: */
		DymolaConvertInputToReal0 := (if self.fault then 2.0 else 0.0);
		DymolaConvertInputToREAL0 := (DymolaConvertInputToReal0 > 1);
		/* Solve linear system of equations A*x = b: */
		'solution_buffer.for.x[6]' := solveLinearEquations(
			/* A matrix: */
			{
				/* Row 1: */
				{ (-1.0 * (self.'transformer.x')), self.'transformer.r', 0.0, 0.0, (((((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) - ((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')), (((((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) },
				/* Row 2: */
				{ self.'transformer.r', self.'transformer.x', 0.0, 0.0, (((((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) + ((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')), (((((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) },
				/* Row 3: */
				{ (-1.0 * self.'L1.Z.im'), self.'L1.Z.re', self.'L1.Z.re', (-1.0 * self.'L1.Z.im'), (((((((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'transformer.m' * self.'transformer.r') * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) + ((self.'transformer.m' * self.'transformer.x') * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) + ((self.'transformer.m' * self.'transformer.x') * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im')))) - ((self.'transformer.m' * self.'transformer.r') * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) },
				/* Row 4: */
				{ self.'L1.Z.re', self.'L1.Z.im', self.'L1.Z.im', self.'L1.Z.re', (((((((self.'transformer.m' * self.'transformer.x') * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) },
				/* Row 5: */
				{ 0.0, 0.0, (-1.0 * (self.'L2.Z.re')), self.'L2.Z.im', (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) + ((self.'transformer.m' * self.'transformer.r') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))) + ((self.'transformer.m' * self.'transformer.r') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))) },
				/* Row 6: */
				{ 0.0, 0.0, (-1.0 * (self.'L2.Z.im')), (-1.0 * (self.'L2.Z.re')), (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) }
			},
			/* b vector: */
			{ (-1.0 * (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2d') + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q')))), ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2d') - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q')), (self.'B3.p.vr' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) - ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.im'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.re') - ((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vi' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.Z.re' * self.'L1.Y.im') + (self.'L1.Z.im' * self.'L1.Y.re')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then -2.22e+3 else 0.0) * self.'L1.Z.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.Z.re' * self.'L1.Y.re') - (self.'L1.Z.im' * self.'L1.Y.im')) + ((if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then 2.22e+3 else 0.0) * self.'L1.Z.im')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vr' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re'))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vi' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.Z.re' * self.'L2.Y.im') + (self.'L2.Z.im' * self.'L2.Y.re')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.Z.re' * self.'L2.Y.re') - (self.'L2.Z.im' * self.'L2.Y.im')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))) });
		if signal in SOLVE_LINEAR_EQUATIONS_FAILED then
			/* Propagate error but leave states as they are: */
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed states: */
			self.'transformer.n.ii' := 'solution_buffer.for.x[6]'[1];
			self.'transformer.n.ir' := 'solution_buffer.for.x[6]'[2];
			self.'L2.p.ir' := 'solution_buffer.for.x[6]'[3];
			self.'L2.p.ii' := 'solution_buffer.for.x[6]'[4];
			self.'G1.machine.iq' := 'solution_buffer.for.x[6]'[5];
			self.'G1.machine.id' := 'solution_buffer.for.x[6]'[6];
		end if;
		'transformer.p.ir' := (self.'G1.machine.I_MBtoSB' * ((sin(self.'G1.machine.delta') * self.'G1.machine.id') + (cos(self.'G1.machine.delta') * self.'G1.machine.iq')));
		'transformer.p.ii' := (self.'G1.machine.I_MBtoSB' * ((sin(self.'G1.machine.delta') * self.'G1.machine.iq') - (cos(self.'G1.machine.delta') * self.'G1.machine.id')));
		'G1.machine.vd' := ((self.'G1.machine.e2d' - (self.'G1.machine.ra' * self.'G1.machine.id')) + (self.'G1.machine.x2q' * self.'G1.machine.iq'));
		'G1.machine.vq' := (self.'G1.machine.e2q' - ((self.'G1.machine.ra' * self.'G1.machine.iq') + (self.'G1.machine.x2d' * self.'G1.machine.id')));
		'B1.p.vr' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vd') + (cos(self.'G1.machine.delta') * 'G1.machine.vq')));
		'B2.p.vr' := (((('B1.p.vr' / (self.'transformer.m' ^ 2)) - (self.'transformer.r' * 'transformer.p.ir')) + (self.'transformer.x' * 'transformer.p.ii')) * self.'transformer.m');
		'pwFault4efmi.p.ii' := (if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then (-2.22e+3 * 'B2.p.vr') else 0.0);
		'B1.p.vi' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vq') - (cos(self.'G1.machine.delta') * 'G1.machine.vd')));
		'B2.p.vi' := ((('B1.p.vi' / (self.'transformer.m' ^ 2)) - ((self.'transformer.r' * 'transformer.p.ii') + (self.'transformer.x' * 'transformer.p.ir'))) * self.'transformer.m');
		'pwFault4efmi.p.ir' := (if (DymolaConvertInputToREAL0 == false) then 0.0 elseif (DymolaConvertInputToREAL0 == true) then (2.22e+3 * 'B2.p.vi') else 0.0);
		'L1.p.ir' := (-1.0 * (((self.'L2.p.ir' + 'pwFault4efmi.p.ir') + self.'transformer.n.ir')));
		'L1.p.ii' := (-1.0 * (((self.'L2.p.ii' + 'pwFault4efmi.p.ii') + self.'transformer.n.ii')));
		self.v := sqrt((('B1.p.vr' ^ 2) + ('B1.p.vi' ^ 2)));
		self.'derivative(G1.avr.vm)' := ((self.v - self.'G1.avr.vm') / self.'G1.avr.Tr');
		self.'derivative(G1.avr.vr)' := ((((self.'G1.avr.K0' * (1.0 - (self.'G1.avr.T1' / self.'G1.avr.T2'))) * ((self.'G1.avr.vref' + self.vf) - self.'G1.avr.vm')) - self.'G1.avr.vr') / self.'G1.avr.T2');
		self.'derivative(G1.avr.vf1)' := (((((self.'G1.avr.vr' + (((self.'G1.avr.K0' * self.'G1.avr.T1') * ((self.'G1.avr.vref' + self.vf) - self.'G1.avr.vm')) / self.'G1.avr.T2')) + self.'G1.machine.vf00') * (1.0 + (self.'G1.avr.s0' * ((self.v / self.'G1.avr.vm') - 1.0)))) - self.'G1.avr.vf1') / self.'G1.avr.Te');
		'G1.machine.vf' := (if (self.'G1.avr.vf1' > self.'G1.avr.limiter1.uMax') then self.'G1.avr.limiter1.uMax' elseif (self.'G1.avr.vf1' < self.'G1.avr.limiter1.uMin') then self.'G1.avr.limiter1.uMin' else self.'G1.avr.vf1');
		'G1.machine.vf_MB' := (('G1.machine.vf' * self.'G1.machine.V_b') / self.'G1.machine.Vn');
		self.'derivative(G1.machine.e1q)' := ((((1.0 - (self.'G1.machine.Taa' / self.'G1.machine.T1d0')) * 'G1.machine.vf_MB') - (self.'G1.machine.e1q' + (((self.'G1.machine.xd' - self.'G1.machine.x1d') - ((((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / self.'G1.machine.T1d0') / self.'G1.machine.x1d')) * self.'G1.machine.id'))) / self.'G1.machine.T1d0');
		self.'derivative(G1.machine.e2q)' := ((((self.'G1.machine.e1q' - self.'G1.machine.e2q') - (((self.'G1.machine.x1d' - self.'G1.machine.x2d') + ((((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / self.'G1.machine.T1d0') / self.'G1.machine.x1d')) * self.'G1.machine.id')) + ((self.'G1.machine.Taa' * 'G1.machine.vf_MB') / self.'G1.machine.T1d0')) / self.'G1.machine.T2d0');
		'G1.machine.pe' := ((('G1.machine.vq' + (self.'G1.machine.ra' * self.'G1.machine.iq')) * self.'G1.machine.iq') + (('G1.machine.vd' + (self.'G1.machine.ra' * self.'G1.machine.id')) * self.'G1.machine.id'));
		self.'derivative(G1.machine.w)' := (((self.'G1.machine.pm00' * self.'G1.machine.S_SBtoMB') - 'G1.machine.pe') / self.'G1.machine.M');
		self.'derivative(G1.machine.delta)' := (self.'G1.machine.w_b' * (self.'G1.machine.w' - 1.0));
		self.'derivative(G1.machine.e1d)' := (((((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq') - self.'G1.machine.e1d') / self.'G1.machine.T1q0');
		self.'derivative(G1.machine.e2d)' := (((self.'G1.machine.e1d' - self.'G1.machine.e2d') + (((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq')) / self.'G1.machine.T2q0');

		/* ******************************************************************************** Inline integration post-processing: */
		self.w := self.'G1.machine.w';
		'G1.P' := ((('B1.p.vr' * 'transformer.p.ir') + ('B1.p.vi' * 'transformer.p.ii')) * self.'G1.S_b');
		self.Pgen := ('G1.P' / max(self.'SysData.S_b', 2.22507385850720138e-308));
		'G1.Q' := (-1.0 * (((('B1.p.vr' * 'transformer.p.ii') - ('B1.p.vi' * 'transformer.p.ir')) * self.'G1.S_b')));
		self.Qgen := ('G1.Q' / max(self.'SysData.S_b', 2.22507385850720138e-308));
		self.'discrete.stepSize.active' := true;
	end DoStep;
end 'PSSDesign.eFMU4CHIL.Grid4CHILTesting';
