/*
	eFMI GALEC program generated by:
	  Dymola Version 2025x Refresh 1, 2025-04-11
	Generation date (xs:dateTime):
	  2025-12-22T20:40:08Z
*/
block 'PSSDesign.eFMUs4RTHIL.GridForHILTesting'
/* *******************************************************************************************************************************
	Block-interface entities:
******************************************************************************************************************************* */

	/* ********************************************************************************************************** Block inputs: */
	input Boolean fault;
	input Real vf;

	/* ********************************************************************************************************* Block outputs: */
	output Real Pgen;
	output Real Qgen;
	output Real v;
	output Real vf0OUT;
	output Real w;

/* *******************************************************************************************************************************
	Block-local entities and functions:
******************************************************************************************************************************* */
protected
	/* B3: */
	constant Real 'B3.angle_0';
	constant Real 'B3.v_0';

	/* B3.p: */
	Real 'B3.p.vi';
	Real 'B3.p.vr';

	/* G1: */
	constant Real 'G1.P_0';
	constant Real 'G1.Q_0';
	constant Real 'G1.V_b';
	constant Real 'G1.angle_0';
	constant Real 'G1.v_0';

	/* G1.feedbackVf0: */
	Real 'G1.feedbackVf0.u2';

	/* G1.gainVf0: */
	constant Real 'G1.gainVf0.k';

	/* G1.machine: */
	constant Real 'G1.machine.M';
	constant Real 'G1.machine.Sn';
	constant Real 'G1.machine.T1d0';
	constant Real 'G1.machine.T1q0';
	constant Real 'G1.machine.T2d0';
	constant Real 'G1.machine.T2q0';
	constant Real 'G1.machine.Taa';
	constant Real 'G1.machine.Vn';
	constant Real 'G1.machine.ra';
	constant Real 'G1.machine.x1d';
	constant Real 'G1.machine.x1q';
	constant Real 'G1.machine.x2d';
	constant Real 'G1.machine.x2q';
	constant Real 'G1.machine.xd';
	constant Real 'G1.machine.xq';
	parameter Real 'G1.machine.I_MBtoSB';
	parameter Real 'G1.machine.K1';
	parameter Real 'G1.machine.K2';
	parameter Real 'G1.machine.S_SBtoMB';
	parameter Real 'G1.machine.V_MBtoSB';
	parameter Real 'G1.machine.Z_MBtoSB';
	parameter Real 'G1.machine.delta0';
	parameter Real 'G1.machine.e1d0';
	parameter Real 'G1.machine.e1q0';
	parameter Real 'G1.machine.e2d0';
	parameter Real 'G1.machine.e2q0';
	parameter Real 'G1.machine.id0';
	parameter Real 'G1.machine.iq0';
	parameter Real 'G1.machine.p0';
	parameter Real 'G1.machine.pm00';
	parameter Real 'G1.machine.q0';
	parameter Real 'G1.machine.vd0';
	parameter Real 'G1.machine.vf00';
	parameter Real 'G1.machine.vq0';
	parameter Real 'G1.machine.w_b';
	Real 'derivative(G1.machine.delta)';
	Real 'derivative(G1.machine.e1d)';
	Real 'derivative(G1.machine.e1q)';
	Real 'derivative(G1.machine.e2d)';
	Real 'derivative(G1.machine.e2q)';
	Real 'derivative(G1.machine.w)';
	Real 'G1.machine.delta';
	Real 'G1.machine.e1d';
	Real 'G1.machine.e1q';
	Real 'G1.machine.e2d';
	Real 'G1.machine.e2q';
	Real 'G1.machine.id';
	Real 'G1.machine.iq';
	Real 'G1.machine.w';

	/* G1.machine.I0: */
	parameter Real 'G1.machine.I0.im';
	parameter Real 'G1.machine.I0.re';

	/* G1.machine.Idq0: */
	parameter Real 'G1.machine.Idq0.im';
	parameter Real 'G1.machine.Idq0.re';

	/* G1.machine.S0: */
	parameter Real 'G1.machine.S0.im';

	/* G1.machine.Vdq0: */
	parameter Real 'G1.machine.Vdq0.im';
	parameter Real 'G1.machine.Vdq0.re';

	/* G1.machine.Vt0: */
	parameter Real 'G1.machine.Vt0.im';
	parameter Real 'G1.machine.Vt0.re';

	/* G1.machine.auxCMval: */
	parameter Real 'G1.machine.auxCMval.im';
	parameter Real 'G1.machine.auxCMval.re';

	/* L1: */
	constant Real 'L1.B';
	constant Real 'L1.G';
	constant Real 'L1.R';
	constant Real 'L1.X';

	/* L2: */
	constant Real 'L2.B';
	constant Real 'L2.G';
	constant Real 'L2.R';
	constant Real 'L2.X';

	/* L2.p: */
	Real 'L2.p.ii';
	Real 'L2.p.ir';

	/* SysData: */
	constant Real 'SysData.S_b';
	constant Real 'SysData.fn';

	/* transformer: */
	constant Real 'transformer.Sn';
	constant Real 'transformer.V_b';
	constant Real 'transformer.Vn';
	constant Real 'transformer.m';
	constant Real 'transformer.rT';
	constant Real 'transformer.xT';
	parameter Real 'transformer.Zb';
	parameter Real 'transformer.Zn';
	parameter Real 'transformer.r';
	parameter Real 'transformer.x';

	/* transformer.n: */
	Real 'transformer.n.ii';
	Real 'transformer.n.ir';

	/* Internal sampling time: */
	constant Real 'discrete.stepSize';
	/*
		State initialization function: Called to (re)-initialize states and outputs
		  considering the current parametrization and inputs.
	*/
	method Reinitialize
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
		Boolean DymolaConvertInputToREAL0;

		/* Internal work-buffers for solutions of linear systems of equations: */
		Real 'solution_buffer.for.x[6]'[ 6 ];

	algorithm
		/*
			Initialize variables without explicit start value or equation (implicit initializations):
		*/
		self.'derivative(G1.machine.e1q)' := 0.0;
		self.'derivative(G1.machine.e2q)' := 0.0;
		self.'derivative(G1.machine.w)' := 0.0;
		self.'derivative(G1.machine.delta)' := 0.0;
		self.Pgen := 0.0;
		self.Qgen := 0.0;
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.'G1.machine.e1q' := self.'G1.machine.e1q0';
		self.'G1.machine.e2q' := self.'G1.machine.e2q0';
		self.'G1.machine.w' := 1.0;
		self.'G1.machine.delta' := self.'G1.machine.delta0';
		self.'G1.machine.e1d' := self.'G1.machine.e1d0';
		self.'G1.machine.e2d' := self.'G1.machine.e2d0';
		DymolaConvertInputToREAL0 := false;
		self.'B3.p.vr' := (self.'B3.v_0' * cos(self.'B3.angle_0'));
		self.'B3.p.vi' := (self.'B3.v_0' * sin(self.'B3.angle_0'));
		self.w := 1.0;
		self.v := self.'G1.v_0';
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		self.'derivative(G1.machine.e1d)' := 0.0;
		self.'derivative(G1.machine.e2d)' := 0.0;
		/* Solve linear system of equations A*x = b: */
		'solution_buffer.for.x[6]' := solveLinearEquations(
			/* A matrix: */
			{
				/* Row 1: */
				{ (-1.0 * ((self.'transformer.x' / self.'transformer.m'))), (self.'transformer.r' / self.'transformer.m'), 0.0, 0.0, (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T1q0') + ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T2q0')) + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) - (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) + (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))), (((self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) - ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra') + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d'))) + (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) },
				/* Row 2: */
				{ (self.'transformer.r' / self.'transformer.m'), (self.'transformer.x' / self.'transformer.m'), 0.0, 0.0, (((self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - (((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T1q0') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'G1.machine.T2q0')) + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra'))) + (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))), ((((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra') - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) - (self.'transformer.r' * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (self.'transformer.x' * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) },
				/* Row 3: */
				{ ((((((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))) * self.'transformer.r') - ((1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))) * self.'transformer.x')) - self.'L1.X'), ((((1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))) * self.'transformer.r') + ((((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))) * self.'transformer.x')) + self.'L1.R'), self.'L1.R', (-1.0 * self.'L1.X'), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * self.'G1.machine.x2q') / self.'transformer.m')) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * self.'G1.machine.ra') / self.'transformer.m')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * self.'G1.machine.ra') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * self.'G1.machine.x2d')) / self.'transformer.m'))) },
				/* Row 4: */
				{ ((((1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))) * self.'transformer.r') - ((((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')) * self.'transformer.x')) + self.'L1.R'), ((((((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')) * self.'transformer.r') + ((1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))) * self.'transformer.x')) + self.'L1.X'), self.'L1.X', self.'L1.R', (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * self.'G1.machine.x2q') / self.'transformer.m')) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * self.'G1.machine.ra') / self.'transformer.m')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * self.'G1.machine.ra') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * self.'G1.machine.x2d')) / self.'transformer.m'))) },
				/* Row 5: */
				{ (-1.0 * ((((1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))) * self.'transformer.x') + (((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')) * self.'transformer.r')))), (((1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))) * self.'transformer.r') - (((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')) * self.'transformer.x')), (-1.0 * (self.'L2.R')), self.'L2.X', (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * self.'G1.machine.x2q') / self.'transformer.m')) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * self.'G1.machine.ra') / self.'transformer.m')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * self.'G1.machine.ra') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * self.'G1.machine.x2d')) / self.'transformer.m'))) },
				/* Row 6: */
				{ (((1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))) * self.'transformer.r') - (((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')) * self.'transformer.x')), ((((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')) * self.'transformer.r') + ((1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))) * self.'transformer.x')), (-1.0 * (self.'L2.X')), (-1.0 * (self.'L2.R')), (((((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.T1q0' * ((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T1q0') + ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.T2q0' * ((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')))) / self.'transformer.m') / self.'G1.machine.T2q0')) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * self.'G1.machine.x2q') / self.'transformer.m')) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * self.'G1.machine.ra') / self.'transformer.m')), (-1.0 * (((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * self.'G1.machine.ra') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * self.'G1.machine.x2d')) / self.'transformer.m'))) }
			},
			/* b vector: */
			{ (-1.0 * ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q'))), (-1.0 * ((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((1.0 / self.'transformer.m') / self.'transformer.m') - (1.0 / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q'))), (self.'B3.p.vr' - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vi' - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vr' - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * self.'G1.machine.e2q') / self.'transformer.m')), (self.'B3.p.vi' - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * self.'G1.machine.e2q') / self.'transformer.m')) });
		if signal in SOLVE_LINEAR_EQUATIONS_FAILED then
			/* Set states to default start-values and propagate error: */
			self.'transformer.n.ii' := 1.00000000000000008e-15;
			self.'transformer.n.ir' := 1.00000000000000008e-15;
			self.'L2.p.ir' := 1.00000000000000008e-15;
			self.'L2.p.ii' := 1.00000000000000008e-15;
			self.'G1.machine.iq' := self.'G1.machine.iq0';
			self.'G1.machine.id' := self.'G1.machine.id0';
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed states: */
			self.'transformer.n.ii' := 'solution_buffer.for.x[6]'[1];
			self.'transformer.n.ir' := 'solution_buffer.for.x[6]'[2];
			self.'L2.p.ir' := 'solution_buffer.for.x[6]'[3];
			self.'L2.p.ii' := 'solution_buffer.for.x[6]'[4];
			self.'G1.machine.iq' := 'solution_buffer.for.x[6]'[5];
			self.'G1.machine.id' := 'solution_buffer.for.x[6]'[6];
		end if;
	end Reinitialize;

/* *******************************************************************************************************************************
	Block-interface functions:
******************************************************************************************************************************* */
public
	/*
		Recalibration function: Called whenever tunable parameters change during operation
		  to recompute the dependent parameters.
	*/
	method Recalibrate
	protected
	algorithm
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		self.'transformer.Zn' := ((self.'transformer.Vn' ^ 2) / self.'transformer.Sn');
		self.'transformer.Zb' := ((self.'transformer.V_b' ^ 2) / self.'SysData.S_b');
		self.'transformer.r' := ((self.'transformer.rT' * self.'transformer.Zn') / self.'transformer.Zb');
		self.'transformer.x' := ((self.'transformer.xT' * self.'transformer.Zn') / self.'transformer.Zb');
		self.'G1.machine.w_b' := (6.28318530717958623 * self.'SysData.fn');
		self.'G1.machine.S_SBtoMB' := (self.'SysData.S_b' / self.'G1.machine.Sn');
		self.'G1.machine.I_MBtoSB' := ((self.'G1.machine.Sn' * self.'G1.V_b') / (self.'SysData.S_b' * self.'G1.machine.Vn'));
		self.'G1.machine.V_MBtoSB' := (self.'G1.machine.Vn' / self.'G1.V_b');
		self.'G1.machine.Z_MBtoSB' := ((self.'SysData.S_b' * (self.'G1.machine.Vn' ^ 2)) / (self.'G1.machine.Sn' * (self.'G1.V_b' ^ 2)));
		self.'G1.machine.p0' := (self.'G1.P_0' / self.'SysData.S_b');
		self.'G1.machine.q0' := (self.'G1.Q_0' / self.'SysData.S_b');
		self.'G1.machine.Vt0.re' := (self.'G1.v_0' * cos(self.'G1.angle_0'));
		self.'G1.machine.Vt0.im' := (self.'G1.v_0' * sin(self.'G1.angle_0'));
		self.'G1.machine.S0.im' := (-1.0 * (self.'G1.machine.q0'));
		self.'G1.machine.I0.re' := (((self.'G1.machine.p0' * self.'G1.machine.Vt0.re') - (self.'G1.machine.S0.im' * self.'G1.machine.Vt0.im')) / ((self.'G1.machine.Vt0.re' * self.'G1.machine.Vt0.re') + (self.'G1.machine.Vt0.im' * self.'G1.machine.Vt0.im')));
		self.'G1.machine.I0.im' := (((self.'G1.machine.p0' * self.'G1.machine.Vt0.im') + (self.'G1.machine.S0.im' * self.'G1.machine.Vt0.re')) / ((self.'G1.machine.Vt0.re' * self.'G1.machine.Vt0.re') + (self.'G1.machine.Vt0.im' * self.'G1.machine.Vt0.im')));
		self.'G1.machine.auxCMval.re' := (self.'G1.machine.Vt0.re' + (((self.'G1.machine.ra' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.re') - ((self.'G1.machine.xq' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.im')));
		self.'G1.machine.auxCMval.im' := (self.'G1.machine.Vt0.im' + (((self.'G1.machine.ra' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.im') + ((self.'G1.machine.xq' * self.'G1.machine.Z_MBtoSB') * self.'G1.machine.I0.re')));
		self.'G1.machine.delta0' := atan2(self.'G1.machine.auxCMval.im', self.'G1.machine.auxCMval.re');
		self.'G1.machine.Vdq0.re' := (((self.'G1.machine.Vt0.re' * cos((1.57079632679489656 - self.'G1.machine.delta0'))) - (self.'G1.machine.Vt0.im' * sin((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.V_MBtoSB');
		self.'G1.machine.Vdq0.im' := (((self.'G1.machine.Vt0.re' * sin((1.57079632679489656 - self.'G1.machine.delta0'))) + (self.'G1.machine.Vt0.im' * cos((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.V_MBtoSB');
		self.'G1.machine.Idq0.re' := (((self.'G1.machine.I0.re' * cos((1.57079632679489656 - self.'G1.machine.delta0'))) - (self.'G1.machine.I0.im' * sin((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.I_MBtoSB');
		self.'G1.machine.Idq0.im' := (((self.'G1.machine.I0.re' * sin((1.57079632679489656 - self.'G1.machine.delta0'))) + (self.'G1.machine.I0.im' * cos((1.57079632679489656 - self.'G1.machine.delta0')))) / self.'G1.machine.I_MBtoSB');
		self.'G1.machine.vd0' := self.'G1.machine.Vdq0.re';
		self.'G1.machine.vq0' := self.'G1.machine.Vdq0.im';
		self.'G1.machine.id0' := self.'G1.machine.Idq0.re';
		self.'G1.machine.iq0' := self.'G1.machine.Idq0.im';
		self.'G1.machine.pm00' := ((((self.'G1.machine.vq0' + (self.'G1.machine.ra' * self.'G1.machine.iq0')) * self.'G1.machine.iq0') + ((self.'G1.machine.vd0' + (self.'G1.machine.ra' * self.'G1.machine.id0')) * self.'G1.machine.id0')) / self.'G1.machine.S_SBtoMB');
		self.'G1.machine.e2q0' := ((self.'G1.machine.vq0' + (self.'G1.machine.ra' * self.'G1.machine.iq0')) + (self.'G1.machine.x2d' * self.'G1.machine.id0'));
		self.'G1.machine.e2d0' := ((self.'G1.machine.vd0' + (self.'G1.machine.ra' * self.'G1.machine.id0')) - (self.'G1.machine.x2q' * self.'G1.machine.iq0'));
		self.'G1.machine.e1d0' := (((self.'G1.machine.xq' - self.'G1.machine.x1q') - (((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / (self.'G1.machine.T1q0' * self.'G1.machine.x1q'))) * self.'G1.machine.iq0');
		self.'G1.machine.K1' := ((self.'G1.machine.xd' - self.'G1.machine.x1d') - (((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / (self.'G1.machine.T1d0' * self.'G1.machine.x1d')));
		self.'G1.machine.K2' := ((self.'G1.machine.x1d' - self.'G1.machine.x2d') + (((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / (self.'G1.machine.T1d0' * self.'G1.machine.x1d')));
		self.'G1.machine.e1q0' := ((self.'G1.machine.e2q0' + (self.'G1.machine.K2' * self.'G1.machine.id0')) - ((self.'G1.machine.Taa' * (((self.'G1.machine.K1' + self.'G1.machine.K2') * self.'G1.machine.id0') + self.'G1.machine.e2q0')) / self.'G1.machine.T1d0'));
		self.'G1.machine.vf00' := ((self.'G1.machine.V_MBtoSB' * ((self.'G1.machine.K1' * self.'G1.machine.id0') + self.'G1.machine.e1q0')) / (1.0 - (self.'G1.machine.Taa' / self.'G1.machine.T1d0')));
		self.'G1.feedbackVf0.u2' := (self.'G1.gainVf0.k' * self.'G1.machine.vf00');
		self.vf0OUT := self.'G1.machine.vf00';
	end Recalibrate;

	/*
		Startup function: Called once at startup to default initialize all block-entities.
	*/
	method Startup
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
	algorithm
		/* ********************************************************************************************** Initialize constants: */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.'discrete.stepSize' := 1.00000000000000002e-3;
		self.'G1.V_b' := 4.0e+5;
		self.'G1.machine.Vn' := 4.0e+5;
		self.'transformer.m' := 1.0;
		self.'G1.machine.x2q' := 2.5e-1;
		self.'G1.machine.ra' := 3.00000000000000006e-3;
		self.'G1.machine.x2d' := 2.3000000000000001e-1;
		self.'L1.X' := 2.25225225225225215e-2;
		self.'L1.R' := 0.0;
		self.'L1.G' := 0.0;
		self.'L1.B' := 0.0;
		self.'L2.R' := 0.0;
		self.'L2.X' := 4.18918918918918942e-2;
		self.'L2.B' := 0.0;
		self.'L2.G' := 0.0;
		self.'G1.machine.Taa' := 2.00000000000000004e-3;
		self.'G1.machine.T1d0' := 8.0;
		self.'G1.machine.xd' := 1.81000000000000005;
		self.'G1.machine.x1d' := 2.99999999999999989e-1;
		self.'G1.machine.T2d0' := 2.99999999999999989e-2;
		self.'G1.machine.M' := 7.0;
		self.'G1.machine.xq' := 1.76000000000000001;
		self.'G1.machine.x1q' := 6.50000000000000022e-1;
		self.'G1.machine.T2q0' := 7.00000000000000067e-2;
		self.'G1.machine.T1q0' := 1.0;
		self.'SysData.S_b' := 1.0e+8;
		self.'B3.v_0' := 1.0;
		self.'B3.angle_0' := 0.0;
		self.'G1.gainVf0.k' := -1.0;
		self.'G1.v_0' := 1.0;
		self.'G1.angle_0' := 4.94677176989159972e-1;
		self.'G1.Q_0' := 9.67924969906579971e+8;
		self.'G1.P_0' := 1.99799999999359989e+9;
		self.'G1.machine.Sn' := 2.22e+9;
		self.'SysData.fn' := 6.0e+1;
		self.'transformer.xT' := 1.49999999999999994e-1;
		self.'transformer.rT' := 0.0;
		self.'transformer.V_b' := 4.0e+5;
		self.'transformer.Vn' := 4.0e+5;
		self.'transformer.Sn' := 2.22e+9;

		/* ******************************************************* Default initialize tuneable parameters (based on constants): */

		/* ****************************** Default initialize dependend parameters (based on constants and tuneable parameters): */
		() := Recalibrate();

		/* ***************************************************** Default initialize inputs (based on constants and parameters): */
		/*
			Initialize variables without explicit start value or equation (implicit initializations):
		*/
		self.vf := 0.0;
		self.fault := false;

		/* ********************************* Default initialize states and outputs (based on constants, parameters and inputs): */
		() := Reinitialize();
	end Startup;

	/*
		Control-cycle function: Called at each sampling to update internal states and compute
		  block-outputs based on current inputs.
	*/
	method DoStep
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
		Boolean DymolaConvertInputToREAL0;
		Real DymolaConvertInputToReal0;

		/* B1.p: */
		Real 'B1.p.vi';
		Real 'B1.p.vr';

		/* B2.p: */
		Real 'B2.p.vi';
		Real 'B2.p.vr';

		/* G1: */
		Real 'G1.P';
		Real 'G1.Q';

		/* G1.machine: */
		Real 'G1.machine.pe';
		Real 'G1.machine.vd';
		Real 'G1.machine.vf';
		Real 'G1.machine.vf_MB';
		Real 'G1.machine.vq';

		/* L1.p: */
		Real 'L1.p.ii';
		Real 'L1.p.ir';

		/* pwFault4efmi.p: */
		Real 'pwFault4efmi.p.ii';
		Real 'pwFault4efmi.p.ir';

		/* transformer.p: */
		Real 'transformer.p.ii';
		Real 'transformer.p.ir';

		/* Internal work-buffers for solutions of linear systems of equations: */
		Real 'solution_buffer.for.x[6]'[ 6 ];

	algorithm
		/* *************************************************************************** Update-equations for inline integration: */
		self.'G1.machine.e1q' := (self.'G1.machine.e1q' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e1q)'));
		self.'G1.machine.e2q' := (self.'G1.machine.e2q' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e2q)'));
		self.'G1.machine.w' := (self.'G1.machine.w' + (self.'discrete.stepSize' * self.'derivative(G1.machine.w)'));
		self.'G1.machine.delta' := (self.'G1.machine.delta' + (self.'discrete.stepSize' * self.'derivative(G1.machine.delta)'));
		self.'G1.machine.e1d' := (self.'G1.machine.e1d' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e1d)'));
		self.'G1.machine.e2d' := (self.'G1.machine.e2d' + (self.'discrete.stepSize' * self.'derivative(G1.machine.e2d)'));

		/* ******************************************************************************************* Inline integration loop: */
		'G1.machine.vf' := (self.vf - self.'G1.feedbackVf0.u2');
		'G1.machine.vf_MB' := (('G1.machine.vf' * self.'G1.V_b') / self.'G1.machine.Vn');
		DymolaConvertInputToReal0 := (if self.fault then 2.0 else 0.0);
		DymolaConvertInputToREAL0 := (DymolaConvertInputToReal0 > 1.0);
		/* Solve linear system of equations A*x = b: */
		'solution_buffer.for.x[6]' := solveLinearEquations(
			/* A matrix: */
			{
				/* Row 1: */
				{ (-1.0 * (self.'transformer.x')), self.'transformer.r', 0.0, 0.0, (((((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) - ((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) + (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')), (((((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) },
				/* Row 2: */
				{ self.'transformer.r', self.'transformer.x', 0.0, 0.0, (((((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) + ((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) - (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2q')) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')), (((((self.'transformer.m' * self.'transformer.x') * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((self.'transformer.m' * self.'transformer.r') * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.ra')) - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.x2d')) },
				/* Row 3: */
				{ (-1.0 * self.'L1.X'), self.'L1.R', self.'L1.R', (-1.0 * self.'L1.X'), (((((((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'transformer.m' * self.'transformer.r') * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) + ((self.'transformer.m' * self.'transformer.x') * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) + ((self.'transformer.m' * self.'transformer.x') * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X')))) - ((self.'transformer.m' * self.'transformer.r') * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) },
				/* Row 4: */
				{ self.'L1.R', self.'L1.X', self.'L1.X', self.'L1.R', (((((((self.'transformer.m' * self.'transformer.x') * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) },
				/* Row 5: */
				{ 0.0, 0.0, (-1.0 * (self.'L2.R')), self.'L2.X', (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'transformer.m' * self.'transformer.r') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))) + ((self.'transformer.m' * self.'transformer.r') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) - (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))) },
				/* Row 6: */
				{ 0.0, 0.0, (-1.0 * (self.'L2.X')), (-1.0 * (self.'L2.R')), (((((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) - ((((self.'transformer.m' * self.'transformer.r') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.x2q') / (self.'transformer.m' ^ 2))) - (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))), (-1.0 * ((((((((self.'transformer.m' * self.'transformer.r') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) + ((self.'transformer.m' * self.'transformer.x') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * sin(self.'G1.machine.delta'))) + ((((self.'transformer.m' * self.'transformer.x') * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))) - ((self.'transformer.m' * self.'transformer.r') * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) * (self.'G1.machine.I_MBtoSB' * cos(self.'G1.machine.delta')))) + (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.ra') / (self.'transformer.m' ^ 2))) + (((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.x2d') / (self.'transformer.m' ^ 2))))) }
			},
			/* b vector: */
			{ (-1.0 * (((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2d') + (((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q')))), ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2d') - (((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * ((1.0 / self.'transformer.m') + ((-1.0 * self.'transformer.m') / (self.'transformer.m' ^ 2)))) * self.'G1.machine.e2q')), (self.'B3.p.vr' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) - ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.X'))))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.R') - ((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vi' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (((self.'L1.R' * self.'L1.B') + (self.'L1.X' * self.'L1.G')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then -2.22e+3 else 0.0) * self.'L1.R')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + (((self.'L1.R' * self.'L1.G') - (self.'L1.X' * self.'L1.B')) + ((if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then 2.22e+3 else 0.0) * self.'L1.X')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vr' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) + ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B'))))) - ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G'))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))), (self.'B3.p.vi' - ((((((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) - ((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.e2d') + ((((self.'G1.machine.V_MBtoSB' * cos(self.'G1.machine.delta')) * (self.'transformer.m' * ((self.'L2.R' * self.'L2.B') + (self.'L2.X' * self.'L2.G')))) + ((self.'G1.machine.V_MBtoSB' * sin(self.'G1.machine.delta')) * (self.'transformer.m' * (1.0 + ((self.'L2.R' * self.'L2.G') - (self.'L2.X' * self.'L2.B')))))) * self.'G1.machine.e2q')) / (self.'transformer.m' ^ 2))) });
		if signal in SOLVE_LINEAR_EQUATIONS_FAILED then
			/* Propagate error but leave states as they are: */
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed states: */
			self.'transformer.n.ii' := 'solution_buffer.for.x[6]'[1];
			self.'transformer.n.ir' := 'solution_buffer.for.x[6]'[2];
			self.'L2.p.ir' := 'solution_buffer.for.x[6]'[3];
			self.'L2.p.ii' := 'solution_buffer.for.x[6]'[4];
			self.'G1.machine.iq' := 'solution_buffer.for.x[6]'[5];
			self.'G1.machine.id' := 'solution_buffer.for.x[6]'[6];
		end if;
		'transformer.p.ir' := (self.'G1.machine.I_MBtoSB' * ((sin(self.'G1.machine.delta') * self.'G1.machine.id') + (cos(self.'G1.machine.delta') * self.'G1.machine.iq')));
		'transformer.p.ii' := (self.'G1.machine.I_MBtoSB' * ((sin(self.'G1.machine.delta') * self.'G1.machine.iq') - (cos(self.'G1.machine.delta') * self.'G1.machine.id')));
		'G1.machine.vd' := ((self.'G1.machine.e2d' - (self.'G1.machine.ra' * self.'G1.machine.id')) + (self.'G1.machine.x2q' * self.'G1.machine.iq'));
		'G1.machine.vq' := (self.'G1.machine.e2q' - ((self.'G1.machine.ra' * self.'G1.machine.iq') + (self.'G1.machine.x2d' * self.'G1.machine.id')));
		'B1.p.vr' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vd') + (cos(self.'G1.machine.delta') * 'G1.machine.vq')));
		'B2.p.vr' := (((('B1.p.vr' / (self.'transformer.m' ^ 2)) - (self.'transformer.r' * 'transformer.p.ir')) + (self.'transformer.x' * 'transformer.p.ii')) * self.'transformer.m');
		'pwFault4efmi.p.ii' := (if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then (-2.22e+3 * 'B2.p.vr') else 0.0);
		'B1.p.vi' := (self.'G1.machine.V_MBtoSB' * ((sin(self.'G1.machine.delta') * 'G1.machine.vq') - (cos(self.'G1.machine.delta') * 'G1.machine.vd')));
		'B2.p.vi' := ((('B1.p.vi' / (self.'transformer.m' ^ 2)) - ((self.'transformer.r' * 'transformer.p.ii') + (self.'transformer.x' * 'transformer.p.ir'))) * self.'transformer.m');
		'pwFault4efmi.p.ir' := (if (real(DymolaConvertInputToREAL0) == false) then 0.0 elseif (real(DymolaConvertInputToREAL0) == true) then (2.22e+3 * 'B2.p.vi') else 0.0);
		'L1.p.ir' := (-1.0 * (((self.'L2.p.ir' + 'pwFault4efmi.p.ir') + self.'transformer.n.ir')));
		'L1.p.ii' := (-1.0 * (((self.'L2.p.ii' + 'pwFault4efmi.p.ii') + self.'transformer.n.ii')));
		self.'derivative(G1.machine.e1q)' := ((((1.0 - (self.'G1.machine.Taa' / self.'G1.machine.T1d0')) * 'G1.machine.vf_MB') - (self.'G1.machine.e1q' + (((self.'G1.machine.xd' - self.'G1.machine.x1d') - ((((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / self.'G1.machine.T1d0') / self.'G1.machine.x1d')) * self.'G1.machine.id'))) / self.'G1.machine.T1d0');
		self.'derivative(G1.machine.e2q)' := ((((self.'G1.machine.e1q' - self.'G1.machine.e2q') - (((self.'G1.machine.x1d' - self.'G1.machine.x2d') + ((((self.'G1.machine.T2d0' * self.'G1.machine.x2d') * (self.'G1.machine.xd' - self.'G1.machine.x1d')) / self.'G1.machine.T1d0') / self.'G1.machine.x1d')) * self.'G1.machine.id')) + ((self.'G1.machine.Taa' * 'G1.machine.vf_MB') / self.'G1.machine.T1d0')) / self.'G1.machine.T2d0');
		'G1.machine.pe' := ((('G1.machine.vq' + (self.'G1.machine.ra' * self.'G1.machine.iq')) * self.'G1.machine.iq') + (('G1.machine.vd' + (self.'G1.machine.ra' * self.'G1.machine.id')) * self.'G1.machine.id'));
		self.'derivative(G1.machine.w)' := (((self.'G1.machine.pm00' * self.'G1.machine.S_SBtoMB') - 'G1.machine.pe') / self.'G1.machine.M');
		self.'derivative(G1.machine.delta)' := (self.'G1.machine.w_b' * (self.'G1.machine.w' - 1.0));
		self.'derivative(G1.machine.e1d)' := (((((self.'G1.machine.xq' - self.'G1.machine.x1q') - ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq') - self.'G1.machine.e1d') / self.'G1.machine.T1q0');
		self.'derivative(G1.machine.e2d)' := (((self.'G1.machine.e1d' - self.'G1.machine.e2d') + (((self.'G1.machine.x1q' - self.'G1.machine.x2q') + ((((self.'G1.machine.T2q0' * self.'G1.machine.x2q') * (self.'G1.machine.xq' - self.'G1.machine.x1q')) / self.'G1.machine.T1q0') / self.'G1.machine.x1q')) * self.'G1.machine.iq')) / self.'G1.machine.T2q0');

		/* ******************************************************************************** Inline integration post-processing: */
		self.w := self.'G1.machine.w';
		self.v := sqrt((('B1.p.vr' ^ 2) + ('B1.p.vi' ^ 2)));
		'G1.P' := ((('B1.p.vr' * 'transformer.p.ir') + ('B1.p.vi' * 'transformer.p.ii')) * self.'SysData.S_b');
		self.Pgen := ('G1.P' / max(self.'SysData.S_b', 9.9999999999999997e-61));
		'G1.Q' := (-1.0 * (((('B1.p.vr' * 'transformer.p.ii') - ('B1.p.vi' * 'transformer.p.ir')) * self.'SysData.S_b')));
		self.Qgen := ('G1.Q' / max(self.'SysData.S_b', 9.9999999999999997e-61));
	end DoStep;
end 'PSSDesign.eFMUs4RTHIL.GridForHILTesting';
