/*
	eFMI GALEC program generated by:
	  Dymola Version 2025x Refresh 1, 2025-04-11
	Generation date (xs:dateTime):
	  2025-12-22T20:19:31Z
*/
block 'efmiPSSusecase.Components.PSSTypeIImod4efmi'
/* *******************************************************************************************************************************
	Block-interface entities:
******************************************************************************************************************************* */

	/* ********************************************************************************************************** Block inputs: */
	input Real vSI;

	/* ********************************************************************************************************* Block outputs: */
	output Real vs;

	/* **************************************************************************************************** Tunable parameters: */
	parameter Real Kw;
	parameter Real T1;
	parameter Real T2;
	parameter Real T3;
	parameter Real T4;
	parameter Real Tw;
	parameter Real vSI_start;
	parameter Real vsmax;
	parameter Real vsmin;

/* *******************************************************************************************************************************
	Block-local entities and functions:
******************************************************************************************************************************* */
protected
	/* derivativeLag: */
	constant Real 'derivativeLag.x_start';
	constant Real 'derivativeLag.y_start';
	parameter Real 'derivativeLag.K';
	parameter Real 'derivativeLag.K_dummy';
	parameter Real 'derivativeLag.T_dummy';

	/* derivativeLag.TF: */
	parameter Real 'derivativeLag.TF.a'[ 1 ];
	parameter Real 'derivativeLag.TF.b'[ 1 ];
	parameter Real 'derivativeLag.TF.bb'[ 1 ];
	parameter Real 'derivativeLag.TF.d';
	parameter Real 'derivativeLag.TF.x_start'[ 1 ];
	Real 'derivative(derivativeLag.TF.x_scaled[1])';
	Real 'derivativeLag.TF.x_scaled[1]';

	/* imLeadLag: */
	constant Real 'imLeadLag.K';
	constant Real 'imLeadLag.x_start';
	constant Real 'imLeadLag.y_start';
	parameter Real 'imLeadLag.T2_dummy';

	/* imLeadLag.TF: */
	parameter Real 'imLeadLag.TF.a'[ 1 ];
	parameter Real 'imLeadLag.TF.b'[ 2 ];
	parameter Real 'imLeadLag.TF.bb'[ 2 ];
	parameter Real 'imLeadLag.TF.d';
	parameter Real 'imLeadLag.TF.x_start'[ 1 ];
	Real 'derivative(imLeadLag.TF.x_scaled[1])';
	Real 'imLeadLag.TF.x_scaled[1]';

	/* imLeadLag1: */
	constant Real 'imLeadLag1.K';
	constant Real 'imLeadLag1.x_start';
	constant Real 'imLeadLag1.y_start';
	parameter Real 'imLeadLag1.T2_dummy';

	/* imLeadLag1.TF: */
	parameter Real 'imLeadLag1.TF.a'[ 1 ];
	parameter Real 'imLeadLag1.TF.b'[ 2 ];
	parameter Real 'imLeadLag1.TF.bb'[ 2 ];
	parameter Real 'imLeadLag1.TF.d';
	parameter Real 'imLeadLag1.TF.x_start'[ 1 ];
	Real 'derivative(imLeadLag1.TF.x_scaled[1])';
	Real 'imLeadLag1.TF.x_scaled[1]';

	/* Internal sampling time: */
	constant Real 'discrete.stepSize';
	/*
		State initialization function: Called to (re)-initialize states and outputs
		  considering the current parametrization and inputs.
	*/
	method Reinitialize
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
		/* derivativeLag.TF: */
		Real 'derivativeLag.TF.y';

		/* imLeadLag: */
		Real 'imLeadLag.u';
		Real 'imLeadLag.y';

		/* imLeadLag.TF: */
		Real 'imLeadLag.TF.y';

		/* imLeadLag1: */
		Real 'imLeadLag1.y';

		/* imLeadLag1.TF: */
		Real 'imLeadLag1.TF.y';

		/* Internal work-buffers for solutions of linear systems of equations: */
		Real 'solution_buffer.for.x';

	algorithm
		/*
			Initialize variables without explicit start value or equation (implicit initializations):
		*/
		self.'derivative(derivativeLag.TF.x_scaled[1])' := 0.0;
		self.'derivative(imLeadLag.TF.x_scaled[1])' := 0.0;
		self.'derivative(imLeadLag1.TF.x_scaled[1])' := 0.0;
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		'derivativeLag.TF.y' := self.'derivativeLag.y_start';
		'solution_buffer.for.x' := (((self.'derivativeLag.TF.d' * self.vSI) - 'derivativeLag.TF.y') / self.'derivativeLag.TF.d');
		if isNaN('solution_buffer.for.x') or isInfinite('solution_buffer.for.x') then
			/* Set state to default start-value and signal error: */
			self.'derivativeLag.TF.x_scaled[1]' := self.'derivativeLag.TF.x_start'[1];
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed state: */
			self.'derivativeLag.TF.x_scaled[1]' := 'solution_buffer.for.x';
		end if;
		'imLeadLag.TF.y' := self.'imLeadLag.y_start';
		'imLeadLag.u' := (if (absolute(self.Tw) < 1.00000000000000008e-15) then self.vSI else 'derivativeLag.TF.y');
		'solution_buffer.for.x' := (((self.'imLeadLag.TF.d' * 'imLeadLag.u') - 'imLeadLag.TF.y') / (self.'imLeadLag.TF.d' - self.'imLeadLag.TF.bb'[2]));
		if isNaN('solution_buffer.for.x') or isInfinite('solution_buffer.for.x') then
			/* Set state to default start-value and signal error: */
			self.'imLeadLag.TF.x_scaled[1]' := self.'imLeadLag.TF.x_start'[1];
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed state: */
			self.'imLeadLag.TF.x_scaled[1]' := 'solution_buffer.for.x';
		end if;
		'imLeadLag1.TF.y' := self.'imLeadLag1.y_start';
		'imLeadLag.y' := (if (absolute((self.T1 - self.T2)) < 1.00000000000000008e-15) then (self.'imLeadLag.K' * 'imLeadLag.u') else 'imLeadLag.TF.y');
		'solution_buffer.for.x' := (((self.'imLeadLag1.TF.d' * 'imLeadLag.y') - 'imLeadLag1.TF.y') / (self.'imLeadLag1.TF.d' - self.'imLeadLag1.TF.bb'[2]));
		if isNaN('solution_buffer.for.x') or isInfinite('solution_buffer.for.x') then
			/* Set state to default start-value and signal error: */
			self.'imLeadLag1.TF.x_scaled[1]' := self.'imLeadLag1.TF.x_start'[1];
			signal SOLVE_LINEAR_EQUATIONS_FAILED;
		else
			/* Only if the system can be solved, assign computed state: */
			self.'imLeadLag1.TF.x_scaled[1]' := 'solution_buffer.for.x';
		end if;
		'imLeadLag1.y' := (if (absolute((self.T3 - self.T4)) < 1.00000000000000008e-15) then (self.'imLeadLag1.K' * 'imLeadLag.y') else 'imLeadLag1.TF.y');
		self.vs := (if ('imLeadLag1.y' > self.vsmax) then self.vsmax elseif ('imLeadLag1.y' < self.vsmin) then self.vsmin else 'imLeadLag1.y');
	end Reinitialize;

/* *******************************************************************************************************************************
	Block-interface functions:
******************************************************************************************************************************* */
public
	/*
		Recalibration function: Called whenever tunable parameters change during operation
		  to recompute the dependent parameters.
	*/
	method Recalibrate
		signals NAN;

	protected
	algorithm
		/*
			Initialize variables with start value equation (dependent initializations):
		*/
		self.'imLeadLag.TF.b'[1] := (self.'imLeadLag.K' * self.T1);
		self.'imLeadLag.TF.b'[2] := self.'imLeadLag.K';
		self.'imLeadLag.T2_dummy' := (if (absolute((self.T1 - self.T2)) < 1.00000000000000008e-15) then 1.0e+3 else self.T2);
		self.'imLeadLag.TF.a'[1] := self.'imLeadLag.T2_dummy';
		self.'imLeadLag.TF.x_start'[1] := self.'imLeadLag.x_start';
		self.'imLeadLag.TF.bb'[1] := self.'imLeadLag.TF.b'[1];
		self.'imLeadLag.TF.bb'[2] := self.'imLeadLag.TF.b'[2];
		self.'imLeadLag.TF.d' := (self.'imLeadLag.TF.bb'[1] / self.'imLeadLag.TF.a'[1]);
		self.'imLeadLag1.TF.b'[1] := (self.'imLeadLag1.K' * self.T3);
		self.'imLeadLag1.TF.b'[2] := self.'imLeadLag1.K';
		self.'imLeadLag1.T2_dummy' := (if (absolute((self.T3 - self.T4)) < 1.00000000000000008e-15) then 1.0e+3 else self.T4);
		self.'imLeadLag1.TF.a'[1] := self.'imLeadLag1.T2_dummy';
		self.'imLeadLag1.TF.x_start'[1] := self.'imLeadLag1.x_start';
		self.'imLeadLag1.TF.bb'[1] := self.'imLeadLag1.TF.b'[1];
		self.'imLeadLag1.TF.bb'[2] := self.'imLeadLag1.TF.b'[2];
		self.'imLeadLag1.TF.d' := (self.'imLeadLag1.TF.bb'[1] / self.'imLeadLag1.TF.a'[1]);
		self.'derivativeLag.K' := (self.Kw * self.Tw);
		self.'derivativeLag.K_dummy' := (if (absolute(self.'derivativeLag.K') < 1.00000000000000008e-15) then 1.0 else self.'derivativeLag.K');
		self.'derivativeLag.TF.b'[1] := self.'derivativeLag.K_dummy';
		self.'derivativeLag.T_dummy' := (if (absolute(self.Tw) < 1.00000000000000008e-15) then 1.0e+3 else self.Tw);
		self.'derivativeLag.TF.a'[1] := self.'derivativeLag.T_dummy';
		self.'derivativeLag.TF.x_start'[1] := self.'derivativeLag.x_start';
		self.'derivativeLag.TF.bb'[1] := self.'derivativeLag.TF.b'[1];
		self.'derivativeLag.TF.d' := (self.'derivativeLag.TF.bb'[1] / self.'derivativeLag.TF.a'[1]);
	end Recalibrate;

	/*
		Startup function: Called once at startup to default initialize all block-entities.
	*/
	method Startup
		signals NAN, SOLVE_LINEAR_EQUATIONS_FAILED;

	protected
	algorithm
		/* ********************************************************************************************** Initialize constants: */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.'discrete.stepSize' := 1.00000000000000002e-3;
		self.'imLeadLag.K' := 1.0;
		self.'imLeadLag1.K' := 1.0;
		self.'imLeadLag1.y_start' := 0.0;
		self.'imLeadLag.y_start' := 0.0;
		self.'derivativeLag.y_start' := 0.0;
		self.'derivativeLag.x_start' := 0.0;
		self.'imLeadLag1.x_start' := 0.0;
		self.'imLeadLag.x_start' := 0.0;

		/* ******************************************************* Default initialize tuneable parameters (based on constants): */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.Tw := 1.40999999999999992;
		self.T1 := 1.53999999999999998e-1;
		self.T2 := 3.30000000000000016e-2;
		self.T3 := 1.0;
		self.T4 := 1.0;
		self.vsmax := 2.00000000000000011e-1;
		self.vsmin := -2.00000000000000011e-1;
		self.Kw := 9.5;
		self.vSI_start := 1.0;

		/* ****************************** Default initialize dependend parameters (based on constants and tuneable parameters): */
		() := Recalibrate();

		/* ***************************************************** Default initialize inputs (based on constants and parameters): */
		/*
			Initialize variables with explicit start value (independent initializations):
		*/
		self.vSI := self.vSI_start;

		/* ********************************* Default initialize states and outputs (based on constants, parameters and inputs): */
		() := Reinitialize();
	end Startup;

	/*
		Control-cycle function: Called at each sampling to update internal states and compute
		  block-outputs based on current inputs.
	*/
	method DoStep
		signals NAN;

	protected
		/* derivativeLag.TF: */
		Real 'derivativeLag.TF.y';

		/* imLeadLag: */
		Real 'imLeadLag.u';
		Real 'imLeadLag.y';

		/* imLeadLag.TF: */
		Real 'imLeadLag.TF.y';

		/* imLeadLag1: */
		Real 'imLeadLag1.y';

		/* imLeadLag1.TF: */
		Real 'imLeadLag1.TF.y';

	algorithm
		/* *************************************************************************** Update-equations for inline integration: */
		self.'derivativeLag.TF.x_scaled[1]' := (self.'derivativeLag.TF.x_scaled[1]' + (self.'discrete.stepSize' * self.'derivative(derivativeLag.TF.x_scaled[1])'));
		self.'imLeadLag.TF.x_scaled[1]' := (self.'imLeadLag.TF.x_scaled[1]' + (self.'discrete.stepSize' * self.'derivative(imLeadLag.TF.x_scaled[1])'));
		self.'imLeadLag1.TF.x_scaled[1]' := (self.'imLeadLag1.TF.x_scaled[1]' + (self.'discrete.stepSize' * self.'derivative(imLeadLag1.TF.x_scaled[1])'));

		/* ******************************************************************************************* Inline integration loop: */
		self.'derivative(derivativeLag.TF.x_scaled[1])' := ((self.vSI - self.'derivativeLag.TF.x_scaled[1]') / self.'derivativeLag.TF.a'[1]);
		'derivativeLag.TF.y' := ((self.'derivativeLag.TF.d' * self.vSI) - (self.'derivativeLag.TF.d' * self.'derivativeLag.TF.x_scaled[1]'));
		'imLeadLag.u' := (if (absolute(self.Tw) < 1.00000000000000008e-15) then self.vSI else 'derivativeLag.TF.y');
		self.'derivative(imLeadLag.TF.x_scaled[1])' := (('imLeadLag.u' - self.'imLeadLag.TF.x_scaled[1]') / self.'imLeadLag.TF.a'[1]);
		'imLeadLag.TF.y' := (((self.'imLeadLag.TF.bb'[2] - self.'imLeadLag.TF.d') * self.'imLeadLag.TF.x_scaled[1]') + (self.'imLeadLag.TF.d' * 'imLeadLag.u'));
		'imLeadLag.y' := (if (absolute((self.T1 - self.T2)) < 1.00000000000000008e-15) then (self.'imLeadLag.K' * 'imLeadLag.u') else 'imLeadLag.TF.y');
		self.'derivative(imLeadLag1.TF.x_scaled[1])' := (('imLeadLag.y' - self.'imLeadLag1.TF.x_scaled[1]') / self.'imLeadLag1.TF.a'[1]);

		/* ******************************************************************************** Inline integration post-processing: */
		'imLeadLag1.TF.y' := (((self.'imLeadLag1.TF.bb'[2] - self.'imLeadLag1.TF.d') * self.'imLeadLag1.TF.x_scaled[1]') + (self.'imLeadLag1.TF.d' * 'imLeadLag.y'));
		'imLeadLag1.y' := (if (absolute((self.T3 - self.T4)) < 1.00000000000000008e-15) then (self.'imLeadLag1.K' * 'imLeadLag.y') else 'imLeadLag1.TF.y');
		self.vs := (if ('imLeadLag1.y' > self.vsmax) then self.vsmax elseif ('imLeadLag1.y' < self.vsmin) then self.vsmin else 'imLeadLag1.y');
	end DoStep;
end 'efmiPSSusecase.Components.PSSTypeIImod4efmi';
